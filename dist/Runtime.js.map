{"version":3,"names":[],"mappings":"","sources":["Runtime.js"],"sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.Runtime = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function (global){\n\"use strict\";\n\nrequire(\"core-js/shim\");\n\nrequire(\"regenerator-runtime/runtime\");\n\nrequire(\"core-js/fn/regexp/escape\");\n\nif (global._babelPolyfill) {\n  throw new Error(\"only one instance of babel-polyfill is allowed\");\n}\nglobal._babelPolyfill = true;\n\nvar DEFINE_PROPERTY = \"defineProperty\";\nfunction define(O, key, value) {\n  O[key] || Object[DEFINE_PROPERTY](O, key, {\n    writable: true,\n    configurable: true,\n    value: value\n  });\n}\n\ndefine(String.prototype, \"padLeft\", \"\".padStart);\ndefine(String.prototype, \"padRight\", \"\".padEnd);\n\n\"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill\".split(\",\").forEach(function (key) {\n  [][key] && define(Array, key, Function.call.bind([][key]));\n});\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"core-js/fn/regexp/escape\":21,\"core-js/shim\":417,\"regenerator-runtime/runtime\":419}],2:[function(require,module,exports){\nmodule.exports = { \"default\": require(\"core-js/library/fn/array/from\"), __esModule: true };\n},{\"core-js/library/fn/array/from\":22}],3:[function(require,module,exports){\nmodule.exports = { \"default\": require(\"core-js/library/fn/json/stringify\"), __esModule: true };\n},{\"core-js/library/fn/json/stringify\":23}],4:[function(require,module,exports){\nmodule.exports = { \"default\": require(\"core-js/library/fn/object/assign\"), __esModule: true };\n},{\"core-js/library/fn/object/assign\":24}],5:[function(require,module,exports){\nmodule.exports = { \"default\": require(\"core-js/library/fn/object/create\"), __esModule: true };\n},{\"core-js/library/fn/object/create\":25}],6:[function(require,module,exports){\nmodule.exports = { \"default\": require(\"core-js/library/fn/object/define-property\"), __esModule: true };\n},{\"core-js/library/fn/object/define-property\":26}],7:[function(require,module,exports){\nmodule.exports = { \"default\": require(\"core-js/library/fn/object/get-own-property-descriptor\"), __esModule: true };\n},{\"core-js/library/fn/object/get-own-property-descriptor\":27}],8:[function(require,module,exports){\nmodule.exports = { \"default\": require(\"core-js/library/fn/object/get-prototype-of\"), __esModule: true };\n},{\"core-js/library/fn/object/get-prototype-of\":28}],9:[function(require,module,exports){\nmodule.exports = { \"default\": require(\"core-js/library/fn/object/is-frozen\"), __esModule: true };\n},{\"core-js/library/fn/object/is-frozen\":29}],10:[function(require,module,exports){\nmodule.exports = { \"default\": require(\"core-js/library/fn/object/keys\"), __esModule: true };\n},{\"core-js/library/fn/object/keys\":30}],11:[function(require,module,exports){\nmodule.exports = { \"default\": require(\"core-js/library/fn/object/set-prototype-of\"), __esModule: true };\n},{\"core-js/library/fn/object/set-prototype-of\":31}],12:[function(require,module,exports){\nmodule.exports = { \"default\": require(\"core-js/library/fn/promise\"), __esModule: true };\n},{\"core-js/library/fn/promise\":32}],13:[function(require,module,exports){\nmodule.exports = { \"default\": require(\"core-js/library/fn/symbol\"), __esModule: true };\n},{\"core-js/library/fn/symbol\":33}],14:[function(require,module,exports){\nmodule.exports = { \"default\": require(\"core-js/library/fn/symbol/iterator\"), __esModule: true };\n},{\"core-js/library/fn/symbol/iterator\":34}],15:[function(require,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\n\nexports.default = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n},{}],16:[function(require,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\n\nvar _defineProperty = require(\"../core-js/object/define-property\");\n\nvar _defineProperty2 = _interopRequireDefault(_defineProperty);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      (0, _defineProperty2.default)(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n},{\"../core-js/object/define-property\":6}],17:[function(require,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\n\nvar _getPrototypeOf = require(\"../core-js/object/get-prototype-of\");\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _getOwnPropertyDescriptor = require(\"../core-js/object/get-own-property-descriptor\");\n\nvar _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = (0, _getOwnPropertyDescriptor2.default)(object, property);\n\n  if (desc === undefined) {\n    var parent = (0, _getPrototypeOf2.default)(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n},{\"../core-js/object/get-own-property-descriptor\":7,\"../core-js/object/get-prototype-of\":8}],18:[function(require,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\n\nvar _setPrototypeOf = require(\"../core-js/object/set-prototype-of\");\n\nvar _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);\n\nvar _create = require(\"../core-js/object/create\");\n\nvar _create2 = _interopRequireDefault(_create);\n\nvar _typeof2 = require(\"../helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(superClass)));\n  }\n\n  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;\n};\n},{\"../core-js/object/create\":5,\"../core-js/object/set-prototype-of\":11,\"../helpers/typeof\":20}],19:[function(require,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\n\nvar _typeof2 = require(\"../helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && ((typeof call === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(call)) === \"object\" || typeof call === \"function\") ? call : self;\n};\n},{\"../helpers/typeof\":20}],20:[function(require,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\n\nvar _iterator = require(\"../core-js/symbol/iterator\");\n\nvar _iterator2 = _interopRequireDefault(_iterator);\n\nvar _symbol = require(\"../core-js/symbol\");\n\nvar _symbol2 = _interopRequireDefault(_symbol);\n\nvar _typeof = typeof _symbol2.default === \"function\" && typeof _iterator2.default === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? \"symbol\" : typeof obj; };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = typeof _symbol2.default === \"function\" && _typeof(_iterator2.default) === \"symbol\" ? function (obj) {\n  return typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n} : function (obj) {\n  return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n};\n},{\"../core-js/symbol\":13,\"../core-js/symbol/iterator\":14}],21:[function(require,module,exports){\nrequire('../../modules/core.regexp.escape');\nmodule.exports = require('../../modules/_core').RegExp.escape;\n},{\"../../modules/_core\":145,\"../../modules/core.regexp.escape\":241}],22:[function(require,module,exports){\nrequire('../../modules/es6.string.iterator');\nrequire('../../modules/es6.array.from');\nmodule.exports = require('../../modules/_core').Array.from;\n},{\"../../modules/_core\":42,\"../../modules/es6.array.from\":108,\"../../modules/es6.string.iterator\":120}],23:[function(require,module,exports){\nvar core  = require('../../modules/_core')\n  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});\nmodule.exports = function stringify(it){ // eslint-disable-line no-unused-vars\n  return $JSON.stringify.apply($JSON, arguments);\n};\n},{\"../../modules/_core\":42}],24:[function(require,module,exports){\nrequire('../../modules/es6.object.assign');\nmodule.exports = require('../../modules/_core').Object.assign;\n},{\"../../modules/_core\":42,\"../../modules/es6.object.assign\":110}],25:[function(require,module,exports){\nrequire('../../modules/es6.object.create');\nvar $Object = require('../../modules/_core').Object;\nmodule.exports = function create(P, D){\n  return $Object.create(P, D);\n};\n},{\"../../modules/_core\":42,\"../../modules/es6.object.create\":111}],26:[function(require,module,exports){\nrequire('../../modules/es6.object.define-property');\nvar $Object = require('../../modules/_core').Object;\nmodule.exports = function defineProperty(it, key, desc){\n  return $Object.defineProperty(it, key, desc);\n};\n},{\"../../modules/_core\":42,\"../../modules/es6.object.define-property\":112}],27:[function(require,module,exports){\nrequire('../../modules/es6.object.get-own-property-descriptor');\nvar $Object = require('../../modules/_core').Object;\nmodule.exports = function getOwnPropertyDescriptor(it, key){\n  return $Object.getOwnPropertyDescriptor(it, key);\n};\n},{\"../../modules/_core\":42,\"../../modules/es6.object.get-own-property-descriptor\":113}],28:[function(require,module,exports){\nrequire('../../modules/es6.object.get-prototype-of');\nmodule.exports = require('../../modules/_core').Object.getPrototypeOf;\n},{\"../../modules/_core\":42,\"../../modules/es6.object.get-prototype-of\":114}],29:[function(require,module,exports){\nrequire('../../modules/es6.object.is-frozen');\nmodule.exports = require('../../modules/_core').Object.isFrozen;\n},{\"../../modules/_core\":42,\"../../modules/es6.object.is-frozen\":115}],30:[function(require,module,exports){\nrequire('../../modules/es6.object.keys');\nmodule.exports = require('../../modules/_core').Object.keys;\n},{\"../../modules/_core\":42,\"../../modules/es6.object.keys\":116}],31:[function(require,module,exports){\nrequire('../../modules/es6.object.set-prototype-of');\nmodule.exports = require('../../modules/_core').Object.setPrototypeOf;\n},{\"../../modules/_core\":42,\"../../modules/es6.object.set-prototype-of\":117}],32:[function(require,module,exports){\nrequire('../modules/es6.object.to-string');\nrequire('../modules/es6.string.iterator');\nrequire('../modules/web.dom.iterable');\nrequire('../modules/es6.promise');\nmodule.exports = require('../modules/_core').Promise;\n},{\"../modules/_core\":42,\"../modules/es6.object.to-string\":118,\"../modules/es6.promise\":119,\"../modules/es6.string.iterator\":120,\"../modules/web.dom.iterable\":124}],33:[function(require,module,exports){\nrequire('../../modules/es6.symbol');\nrequire('../../modules/es6.object.to-string');\nrequire('../../modules/es7.symbol.async-iterator');\nrequire('../../modules/es7.symbol.observable');\nmodule.exports = require('../../modules/_core').Symbol;\n},{\"../../modules/_core\":42,\"../../modules/es6.object.to-string\":118,\"../../modules/es6.symbol\":121,\"../../modules/es7.symbol.async-iterator\":122,\"../../modules/es7.symbol.observable\":123}],34:[function(require,module,exports){\nrequire('../../modules/es6.string.iterator');\nrequire('../../modules/web.dom.iterable');\nmodule.exports = require('../../modules/_wks-ext').f('iterator');\n},{\"../../modules/_wks-ext\":105,\"../../modules/es6.string.iterator\":120,\"../../modules/web.dom.iterable\":124}],35:[function(require,module,exports){\nmodule.exports = function(it){\n  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n  return it;\n};\n},{}],36:[function(require,module,exports){\nmodule.exports = function(){ /* empty */ };\n},{}],37:[function(require,module,exports){\nmodule.exports = function(it, Constructor, name, forbiddenField){\n  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){\n    throw TypeError(name + ': incorrect invocation!');\n  } return it;\n};\n},{}],38:[function(require,module,exports){\nvar isObject = require('./_is-object');\nmodule.exports = function(it){\n  if(!isObject(it))throw TypeError(it + ' is not an object!');\n  return it;\n};\n},{\"./_is-object\":62}],39:[function(require,module,exports){\n// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = require('./_to-iobject')\n  , toLength  = require('./_to-length')\n  , toIndex   = require('./_to-index');\nmodule.exports = function(IS_INCLUDES){\n  return function($this, el, fromIndex){\n    var O      = toIObject($this)\n      , length = toLength(O.length)\n      , index  = toIndex(fromIndex, length)\n      , value;\n    // Array#includes uses SameValueZero equality algorithm\n    if(IS_INCLUDES && el != el)while(length > index){\n      value = O[index++];\n      if(value != value)return true;\n    // Array#toIndex ignores holes, Array#includes - not\n    } else for(;length > index; index++)if(IS_INCLUDES || index in O){\n      if(O[index] === el)return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n},{\"./_to-index\":97,\"./_to-iobject\":99,\"./_to-length\":100}],40:[function(require,module,exports){\n// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = require('./_cof')\n  , TAG = require('./_wks')('toStringTag')\n  // ES3 wrong here\n  , ARG = cof(function(){ return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function(it, key){\n  try {\n    return it[key];\n  } catch(e){ /* empty */ }\n};\n\nmodule.exports = function(it){\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n},{\"./_cof\":41,\"./_wks\":106}],41:[function(require,module,exports){\nvar toString = {}.toString;\n\nmodule.exports = function(it){\n  return toString.call(it).slice(8, -1);\n};\n},{}],42:[function(require,module,exports){\nvar core = module.exports = {version: '2.4.0'};\nif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n},{}],43:[function(require,module,exports){\n'use strict';\nvar $defineProperty = require('./_object-dp')\n  , createDesc      = require('./_property-desc');\n\nmodule.exports = function(object, index, value){\n  if(index in object)$defineProperty.f(object, index, createDesc(0, value));\n  else object[index] = value;\n};\n},{\"./_object-dp\":75,\"./_property-desc\":86}],44:[function(require,module,exports){\n// optional / simple context binding\nvar aFunction = require('./_a-function');\nmodule.exports = function(fn, that, length){\n  aFunction(fn);\n  if(that === undefined)return fn;\n  switch(length){\n    case 1: return function(a){\n      return fn.call(that, a);\n    };\n    case 2: return function(a, b){\n      return fn.call(that, a, b);\n    };\n    case 3: return function(a, b, c){\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function(/* ...args */){\n    return fn.apply(that, arguments);\n  };\n};\n},{\"./_a-function\":35}],45:[function(require,module,exports){\n// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function(it){\n  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n},{}],46:[function(require,module,exports){\n// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('./_fails')(function(){\n  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n});\n},{\"./_fails\":51}],47:[function(require,module,exports){\nvar isObject = require('./_is-object')\n  , document = require('./_global').document\n  // in old IE typeof document.createElement is 'object'\n  , is = isObject(document) && isObject(document.createElement);\nmodule.exports = function(it){\n  return is ? document.createElement(it) : {};\n};\n},{\"./_global\":53,\"./_is-object\":62}],48:[function(require,module,exports){\n// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n},{}],49:[function(require,module,exports){\n// all enumerable object keys, includes symbols\nvar getKeys = require('./_object-keys')\n  , gOPS    = require('./_object-gops')\n  , pIE     = require('./_object-pie');\nmodule.exports = function(it){\n  var result     = getKeys(it)\n    , getSymbols = gOPS.f;\n  if(getSymbols){\n    var symbols = getSymbols(it)\n      , isEnum  = pIE.f\n      , i       = 0\n      , key;\n    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);\n  } return result;\n};\n},{\"./_object-gops\":80,\"./_object-keys\":83,\"./_object-pie\":84}],50:[function(require,module,exports){\nvar global    = require('./_global')\n  , core      = require('./_core')\n  , ctx       = require('./_ctx')\n  , hide      = require('./_hide')\n  , PROTOTYPE = 'prototype';\n\nvar $export = function(type, name, source){\n  var IS_FORCED = type & $export.F\n    , IS_GLOBAL = type & $export.G\n    , IS_STATIC = type & $export.S\n    , IS_PROTO  = type & $export.P\n    , IS_BIND   = type & $export.B\n    , IS_WRAP   = type & $export.W\n    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n    , expProto  = exports[PROTOTYPE]\n    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n    , key, own, out;\n  if(IS_GLOBAL)source = name;\n  for(key in source){\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    if(own && key in exports)continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function(C){\n      var F = function(a, b, c){\n        if(this instanceof C){\n          switch(arguments.length){\n            case 0: return new C;\n            case 1: return new C(a);\n            case 2: return new C(a, b);\n          } return new C(a, b, c);\n        } return C.apply(this, arguments);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n    if(IS_PROTO){\n      (exports.virtual || (exports.virtual = {}))[key] = out;\n      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);\n    }\n  }\n};\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library` \nmodule.exports = $export;\n},{\"./_core\":42,\"./_ctx\":44,\"./_global\":53,\"./_hide\":55}],51:[function(require,module,exports){\nmodule.exports = function(exec){\n  try {\n    return !!exec();\n  } catch(e){\n    return true;\n  }\n};\n},{}],52:[function(require,module,exports){\nvar ctx         = require('./_ctx')\n  , call        = require('./_iter-call')\n  , isArrayIter = require('./_is-array-iter')\n  , anObject    = require('./_an-object')\n  , toLength    = require('./_to-length')\n  , getIterFn   = require('./core.get-iterator-method')\n  , BREAK       = {}\n  , RETURN      = {};\nvar exports = module.exports = function(iterable, entries, fn, that, ITERATOR){\n  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)\n    , f      = ctx(fn, that, entries ? 2 : 1)\n    , index  = 0\n    , length, step, iterator, result;\n  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');\n  // fast case for arrays with default iterator\n  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){\n    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n    if(result === BREAK || result === RETURN)return result;\n  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){\n    result = call(iterator, f, step.value, entries);\n    if(result === BREAK || result === RETURN)return result;\n  }\n};\nexports.BREAK  = BREAK;\nexports.RETURN = RETURN;\n},{\"./_an-object\":38,\"./_ctx\":44,\"./_is-array-iter\":60,\"./_iter-call\":63,\"./_to-length\":100,\"./core.get-iterator-method\":107}],53:[function(require,module,exports){\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\nif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n},{}],54:[function(require,module,exports){\nvar hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function(it, key){\n  return hasOwnProperty.call(it, key);\n};\n},{}],55:[function(require,module,exports){\nvar dP         = require('./_object-dp')\n  , createDesc = require('./_property-desc');\nmodule.exports = require('./_descriptors') ? function(object, key, value){\n  return dP.f(object, key, createDesc(1, value));\n} : function(object, key, value){\n  object[key] = value;\n  return object;\n};\n},{\"./_descriptors\":46,\"./_object-dp\":75,\"./_property-desc\":86}],56:[function(require,module,exports){\nmodule.exports = require('./_global').document && document.documentElement;\n},{\"./_global\":53}],57:[function(require,module,exports){\nmodule.exports = !require('./_descriptors') && !require('./_fails')(function(){\n  return Object.defineProperty(require('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;\n});\n},{\"./_descriptors\":46,\"./_dom-create\":47,\"./_fails\":51}],58:[function(require,module,exports){\n// fast apply, http://jsperf.lnkit.com/fast-apply/5\nmodule.exports = function(fn, args, that){\n  var un = that === undefined;\n  switch(args.length){\n    case 0: return un ? fn()\n                      : fn.call(that);\n    case 1: return un ? fn(args[0])\n                      : fn.call(that, args[0]);\n    case 2: return un ? fn(args[0], args[1])\n                      : fn.call(that, args[0], args[1]);\n    case 3: return un ? fn(args[0], args[1], args[2])\n                      : fn.call(that, args[0], args[1], args[2]);\n    case 4: return un ? fn(args[0], args[1], args[2], args[3])\n                      : fn.call(that, args[0], args[1], args[2], args[3]);\n  } return              fn.apply(that, args);\n};\n},{}],59:[function(require,module,exports){\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = require('./_cof');\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n},{\"./_cof\":41}],60:[function(require,module,exports){\n// check on default Array iterator\nvar Iterators  = require('./_iterators')\n  , ITERATOR   = require('./_wks')('iterator')\n  , ArrayProto = Array.prototype;\n\nmodule.exports = function(it){\n  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n};\n},{\"./_iterators\":68,\"./_wks\":106}],61:[function(require,module,exports){\n// 7.2.2 IsArray(argument)\nvar cof = require('./_cof');\nmodule.exports = Array.isArray || function isArray(arg){\n  return cof(arg) == 'Array';\n};\n},{\"./_cof\":41}],62:[function(require,module,exports){\nmodule.exports = function(it){\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n},{}],63:[function(require,module,exports){\n// call something on iterator step with safe closing on error\nvar anObject = require('./_an-object');\nmodule.exports = function(iterator, fn, value, entries){\n  try {\n    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch(e){\n    var ret = iterator['return'];\n    if(ret !== undefined)anObject(ret.call(iterator));\n    throw e;\n  }\n};\n},{\"./_an-object\":38}],64:[function(require,module,exports){\n'use strict';\nvar create         = require('./_object-create')\n  , descriptor     = require('./_property-desc')\n  , setToStringTag = require('./_set-to-string-tag')\n  , IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nrequire('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function(){ return this; });\n\nmodule.exports = function(Constructor, NAME, next){\n  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n},{\"./_hide\":55,\"./_object-create\":74,\"./_property-desc\":86,\"./_set-to-string-tag\":91,\"./_wks\":106}],65:[function(require,module,exports){\n'use strict';\nvar LIBRARY        = require('./_library')\n  , $export        = require('./_export')\n  , redefine       = require('./_redefine')\n  , hide           = require('./_hide')\n  , has            = require('./_has')\n  , Iterators      = require('./_iterators')\n  , $iterCreate    = require('./_iter-create')\n  , setToStringTag = require('./_set-to-string-tag')\n  , getPrototypeOf = require('./_object-gpo')\n  , ITERATOR       = require('./_wks')('iterator')\n  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n  , FF_ITERATOR    = '@@iterator'\n  , KEYS           = 'keys'\n  , VALUES         = 'values';\n\nvar returnThis = function(){ return this; };\n\nmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function(kind){\n    if(!BUGGY && kind in proto)return proto[kind];\n    switch(kind){\n      case KEYS: return function keys(){ return new Constructor(this, kind); };\n      case VALUES: return function values(){ return new Constructor(this, kind); };\n    } return function entries(){ return new Constructor(this, kind); };\n  };\n  var TAG        = NAME + ' Iterator'\n    , DEF_VALUES = DEFAULT == VALUES\n    , VALUES_BUG = false\n    , proto      = Base.prototype\n    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n    , $default   = $native || getMethod(DEFAULT)\n    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined\n    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native\n    , methods, key, IteratorPrototype;\n  // Fix native\n  if($anyNative){\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));\n    if(IteratorPrototype !== Object.prototype){\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if(DEF_VALUES && $native && $native.name !== VALUES){\n    VALUES_BUG = true;\n    $default = function values(){ return $native.call(this); };\n  }\n  // Define iterator\n  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG]  = returnThis;\n  if(DEFAULT){\n    methods = {\n      values:  DEF_VALUES ? $default : getMethod(VALUES),\n      keys:    IS_SET     ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if(FORCED)for(key in methods){\n      if(!(key in proto))redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n},{\"./_export\":50,\"./_has\":54,\"./_hide\":55,\"./_iter-create\":64,\"./_iterators\":68,\"./_library\":70,\"./_object-gpo\":81,\"./_redefine\":88,\"./_set-to-string-tag\":91,\"./_wks\":106}],66:[function(require,module,exports){\nvar ITERATOR     = require('./_wks')('iterator')\n  , SAFE_CLOSING = false;\n\ntry {\n  var riter = [7][ITERATOR]();\n  riter['return'] = function(){ SAFE_CLOSING = true; };\n  Array.from(riter, function(){ throw 2; });\n} catch(e){ /* empty */ }\n\nmodule.exports = function(exec, skipClosing){\n  if(!skipClosing && !SAFE_CLOSING)return false;\n  var safe = false;\n  try {\n    var arr  = [7]\n      , iter = arr[ITERATOR]();\n    iter.next = function(){ return {done: safe = true}; };\n    arr[ITERATOR] = function(){ return iter; };\n    exec(arr);\n  } catch(e){ /* empty */ }\n  return safe;\n};\n},{\"./_wks\":106}],67:[function(require,module,exports){\nmodule.exports = function(done, value){\n  return {value: value, done: !!done};\n};\n},{}],68:[function(require,module,exports){\nmodule.exports = {};\n},{}],69:[function(require,module,exports){\nvar getKeys   = require('./_object-keys')\n  , toIObject = require('./_to-iobject');\nmodule.exports = function(object, el){\n  var O      = toIObject(object)\n    , keys   = getKeys(O)\n    , length = keys.length\n    , index  = 0\n    , key;\n  while(length > index)if(O[key = keys[index++]] === el)return key;\n};\n},{\"./_object-keys\":83,\"./_to-iobject\":99}],70:[function(require,module,exports){\nmodule.exports = true;\n},{}],71:[function(require,module,exports){\nvar META     = require('./_uid')('meta')\n  , isObject = require('./_is-object')\n  , has      = require('./_has')\n  , setDesc  = require('./_object-dp').f\n  , id       = 0;\nvar isExtensible = Object.isExtensible || function(){\n  return true;\n};\nvar FREEZE = !require('./_fails')(function(){\n  return isExtensible(Object.preventExtensions({}));\n});\nvar setMeta = function(it){\n  setDesc(it, META, {value: {\n    i: 'O' + ++id, // object ID\n    w: {}          // weak collections IDs\n  }});\n};\nvar fastKey = function(it, create){\n  // return primitive with prefix\n  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if(!has(it, META)){\n    // can't set metadata to uncaught frozen object\n    if(!isExtensible(it))return 'F';\n    // not necessary to add metadata\n    if(!create)return 'E';\n    // add missing metadata\n    setMeta(it);\n  // return object ID\n  } return it[META].i;\n};\nvar getWeak = function(it, create){\n  if(!has(it, META)){\n    // can't set metadata to uncaught frozen object\n    if(!isExtensible(it))return true;\n    // not necessary to add metadata\n    if(!create)return false;\n    // add missing metadata\n    setMeta(it);\n  // return hash weak collections IDs\n  } return it[META].w;\n};\n// add metadata on freeze-family methods calling\nvar onFreeze = function(it){\n  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);\n  return it;\n};\nvar meta = module.exports = {\n  KEY:      META,\n  NEED:     false,\n  fastKey:  fastKey,\n  getWeak:  getWeak,\n  onFreeze: onFreeze\n};\n},{\"./_fails\":51,\"./_has\":54,\"./_is-object\":62,\"./_object-dp\":75,\"./_uid\":103}],72:[function(require,module,exports){\nvar global    = require('./_global')\n  , macrotask = require('./_task').set\n  , Observer  = global.MutationObserver || global.WebKitMutationObserver\n  , process   = global.process\n  , Promise   = global.Promise\n  , isNode    = require('./_cof')(process) == 'process';\n\nmodule.exports = function(){\n  var head, last, notify;\n\n  var flush = function(){\n    var parent, fn;\n    if(isNode && (parent = process.domain))parent.exit();\n    while(head){\n      fn   = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch(e){\n        if(head)notify();\n        else last = undefined;\n        throw e;\n      }\n    } last = undefined;\n    if(parent)parent.enter();\n  };\n\n  // Node.js\n  if(isNode){\n    notify = function(){\n      process.nextTick(flush);\n    };\n  // browsers with MutationObserver\n  } else if(Observer){\n    var toggle = true\n      , node   = document.createTextNode('');\n    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new\n    notify = function(){\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if(Promise && Promise.resolve){\n    var promise = Promise.resolve();\n    notify = function(){\n      promise.then(flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessag\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    notify = function(){\n      // strange IE + webpack dev server bug - use .call(global)\n      macrotask.call(global, flush);\n    };\n  }\n\n  return function(fn){\n    var task = {fn: fn, next: undefined};\n    if(last)last.next = task;\n    if(!head){\n      head = task;\n      notify();\n    } last = task;\n  };\n};\n},{\"./_cof\":41,\"./_global\":53,\"./_task\":96}],73:[function(require,module,exports){\n'use strict';\n// 19.1.2.1 Object.assign(target, source, ...)\nvar getKeys  = require('./_object-keys')\n  , gOPS     = require('./_object-gops')\n  , pIE      = require('./_object-pie')\n  , toObject = require('./_to-object')\n  , IObject  = require('./_iobject')\n  , $assign  = Object.assign;\n\n// should work with symbols and should have deterministic property order (V8 bug)\nmodule.exports = !$assign || require('./_fails')(function(){\n  var A = {}\n    , B = {}\n    , S = Symbol()\n    , K = 'abcdefghijklmnopqrst';\n  A[S] = 7;\n  K.split('').forEach(function(k){ B[k] = k; });\n  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n}) ? function assign(target, source){ // eslint-disable-line no-unused-vars\n  var T     = toObject(target)\n    , aLen  = arguments.length\n    , index = 1\n    , getSymbols = gOPS.f\n    , isEnum     = pIE.f;\n  while(aLen > index){\n    var S      = IObject(arguments[index++])\n      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)\n      , length = keys.length\n      , j      = 0\n      , key;\n    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];\n  } return T;\n} : $assign;\n},{\"./_fails\":51,\"./_iobject\":59,\"./_object-gops\":80,\"./_object-keys\":83,\"./_object-pie\":84,\"./_to-object\":101}],74:[function(require,module,exports){\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject    = require('./_an-object')\n  , dPs         = require('./_object-dps')\n  , enumBugKeys = require('./_enum-bug-keys')\n  , IE_PROTO    = require('./_shared-key')('IE_PROTO')\n  , Empty       = function(){ /* empty */ }\n  , PROTOTYPE   = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function(){\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = require('./_dom-create')('iframe')\n    , i      = enumBugKeys.length\n    , lt     = '<'\n    , gt     = '>'\n    , iframeDocument;\n  iframe.style.display = 'none';\n  require('./_html').appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties){\n  var result;\n  if(O !== null){\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty;\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n\n},{\"./_an-object\":38,\"./_dom-create\":47,\"./_enum-bug-keys\":48,\"./_html\":56,\"./_object-dps\":76,\"./_shared-key\":92}],75:[function(require,module,exports){\nvar anObject       = require('./_an-object')\n  , IE8_DOM_DEFINE = require('./_ie8-dom-define')\n  , toPrimitive    = require('./_to-primitive')\n  , dP             = Object.defineProperty;\n\nexports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if(IE8_DOM_DEFINE)try {\n    return dP(O, P, Attributes);\n  } catch(e){ /* empty */ }\n  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n  if('value' in Attributes)O[P] = Attributes.value;\n  return O;\n};\n},{\"./_an-object\":38,\"./_descriptors\":46,\"./_ie8-dom-define\":57,\"./_to-primitive\":102}],76:[function(require,module,exports){\nvar dP       = require('./_object-dp')\n  , anObject = require('./_an-object')\n  , getKeys  = require('./_object-keys');\n\nmodule.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties){\n  anObject(O);\n  var keys   = getKeys(Properties)\n    , length = keys.length\n    , i = 0\n    , P;\n  while(length > i)dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n},{\"./_an-object\":38,\"./_descriptors\":46,\"./_object-dp\":75,\"./_object-keys\":83}],77:[function(require,module,exports){\nvar pIE            = require('./_object-pie')\n  , createDesc     = require('./_property-desc')\n  , toIObject      = require('./_to-iobject')\n  , toPrimitive    = require('./_to-primitive')\n  , has            = require('./_has')\n  , IE8_DOM_DEFINE = require('./_ie8-dom-define')\n  , gOPD           = Object.getOwnPropertyDescriptor;\n\nexports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P){\n  O = toIObject(O);\n  P = toPrimitive(P, true);\n  if(IE8_DOM_DEFINE)try {\n    return gOPD(O, P);\n  } catch(e){ /* empty */ }\n  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);\n};\n},{\"./_descriptors\":46,\"./_has\":54,\"./_ie8-dom-define\":57,\"./_object-pie\":84,\"./_property-desc\":86,\"./_to-iobject\":99,\"./_to-primitive\":102}],78:[function(require,module,exports){\n// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nvar toIObject = require('./_to-iobject')\n  , gOPN      = require('./_object-gopn').f\n  , toString  = {}.toString;\n\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function(it){\n  try {\n    return gOPN(it);\n  } catch(e){\n    return windowNames.slice();\n  }\n};\n\nmodule.exports.f = function getOwnPropertyNames(it){\n  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\n};\n\n},{\"./_object-gopn\":79,\"./_to-iobject\":99}],79:[function(require,module,exports){\n// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\nvar $keys      = require('./_object-keys-internal')\n  , hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');\n\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){\n  return $keys(O, hiddenKeys);\n};\n},{\"./_enum-bug-keys\":48,\"./_object-keys-internal\":82}],80:[function(require,module,exports){\nexports.f = Object.getOwnPropertySymbols;\n},{}],81:[function(require,module,exports){\n// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has         = require('./_has')\n  , toObject    = require('./_to-object')\n  , IE_PROTO    = require('./_shared-key')('IE_PROTO')\n  , ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function(O){\n  O = toObject(O);\n  if(has(O, IE_PROTO))return O[IE_PROTO];\n  if(typeof O.constructor == 'function' && O instanceof O.constructor){\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n},{\"./_has\":54,\"./_shared-key\":92,\"./_to-object\":101}],82:[function(require,module,exports){\nvar has          = require('./_has')\n  , toIObject    = require('./_to-iobject')\n  , arrayIndexOf = require('./_array-includes')(false)\n  , IE_PROTO     = require('./_shared-key')('IE_PROTO');\n\nmodule.exports = function(object, names){\n  var O      = toIObject(object)\n    , i      = 0\n    , result = []\n    , key;\n  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while(names.length > i)if(has(O, key = names[i++])){\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n},{\"./_array-includes\":39,\"./_has\":54,\"./_shared-key\":92,\"./_to-iobject\":99}],83:[function(require,module,exports){\n// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys       = require('./_object-keys-internal')\n  , enumBugKeys = require('./_enum-bug-keys');\n\nmodule.exports = Object.keys || function keys(O){\n  return $keys(O, enumBugKeys);\n};\n},{\"./_enum-bug-keys\":48,\"./_object-keys-internal\":82}],84:[function(require,module,exports){\nexports.f = {}.propertyIsEnumerable;\n},{}],85:[function(require,module,exports){\n// most Object methods by ES6 should accept primitives\nvar $export = require('./_export')\n  , core    = require('./_core')\n  , fails   = require('./_fails');\nmodule.exports = function(KEY, exec){\n  var fn  = (core.Object || {})[KEY] || Object[KEY]\n    , exp = {};\n  exp[KEY] = exec(fn);\n  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);\n};\n},{\"./_core\":42,\"./_export\":50,\"./_fails\":51}],86:[function(require,module,exports){\nmodule.exports = function(bitmap, value){\n  return {\n    enumerable  : !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable    : !(bitmap & 4),\n    value       : value\n  };\n};\n},{}],87:[function(require,module,exports){\nvar hide = require('./_hide');\nmodule.exports = function(target, src, safe){\n  for(var key in src){\n    if(safe && target[key])target[key] = src[key];\n    else hide(target, key, src[key]);\n  } return target;\n};\n},{\"./_hide\":55}],88:[function(require,module,exports){\nmodule.exports = require('./_hide');\n},{\"./_hide\":55}],89:[function(require,module,exports){\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n/* eslint-disable no-proto */\nvar isObject = require('./_is-object')\n  , anObject = require('./_an-object');\nvar check = function(O, proto){\n  anObject(O);\n  if(!isObject(proto) && proto !== null)throw TypeError(proto + \": can't set as prototype!\");\n};\nmodule.exports = {\n  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\n    function(test, buggy, set){\n      try {\n        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);\n        set(test, []);\n        buggy = !(test instanceof Array);\n      } catch(e){ buggy = true; }\n      return function setPrototypeOf(O, proto){\n        check(O, proto);\n        if(buggy)O.__proto__ = proto;\n        else set(O, proto);\n        return O;\n      };\n    }({}, false) : undefined),\n  check: check\n};\n},{\"./_an-object\":38,\"./_ctx\":44,\"./_is-object\":62,\"./_object-gopd\":77}],90:[function(require,module,exports){\n'use strict';\nvar global      = require('./_global')\n  , core        = require('./_core')\n  , dP          = require('./_object-dp')\n  , DESCRIPTORS = require('./_descriptors')\n  , SPECIES     = require('./_wks')('species');\n\nmodule.exports = function(KEY){\n  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];\n  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {\n    configurable: true,\n    get: function(){ return this; }\n  });\n};\n},{\"./_core\":42,\"./_descriptors\":46,\"./_global\":53,\"./_object-dp\":75,\"./_wks\":106}],91:[function(require,module,exports){\nvar def = require('./_object-dp').f\n  , has = require('./_has')\n  , TAG = require('./_wks')('toStringTag');\n\nmodule.exports = function(it, tag, stat){\n  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n};\n},{\"./_has\":54,\"./_object-dp\":75,\"./_wks\":106}],92:[function(require,module,exports){\nvar shared = require('./_shared')('keys')\n  , uid    = require('./_uid');\nmodule.exports = function(key){\n  return shared[key] || (shared[key] = uid(key));\n};\n},{\"./_shared\":93,\"./_uid\":103}],93:[function(require,module,exports){\nvar global = require('./_global')\n  , SHARED = '__core-js_shared__'\n  , store  = global[SHARED] || (global[SHARED] = {});\nmodule.exports = function(key){\n  return store[key] || (store[key] = {});\n};\n},{\"./_global\":53}],94:[function(require,module,exports){\n// 7.3.20 SpeciesConstructor(O, defaultConstructor)\nvar anObject  = require('./_an-object')\n  , aFunction = require('./_a-function')\n  , SPECIES   = require('./_wks')('species');\nmodule.exports = function(O, D){\n  var C = anObject(O).constructor, S;\n  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);\n};\n},{\"./_a-function\":35,\"./_an-object\":38,\"./_wks\":106}],95:[function(require,module,exports){\nvar toInteger = require('./_to-integer')\n  , defined   = require('./_defined');\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function(TO_STRING){\n  return function(that, pos){\n    var s = String(defined(that))\n      , i = toInteger(pos)\n      , l = s.length\n      , a, b;\n    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n},{\"./_defined\":45,\"./_to-integer\":98}],96:[function(require,module,exports){\nvar ctx                = require('./_ctx')\n  , invoke             = require('./_invoke')\n  , html               = require('./_html')\n  , cel                = require('./_dom-create')\n  , global             = require('./_global')\n  , process            = global.process\n  , setTask            = global.setImmediate\n  , clearTask          = global.clearImmediate\n  , MessageChannel     = global.MessageChannel\n  , counter            = 0\n  , queue              = {}\n  , ONREADYSTATECHANGE = 'onreadystatechange'\n  , defer, channel, port;\nvar run = function(){\n  var id = +this;\n  if(queue.hasOwnProperty(id)){\n    var fn = queue[id];\n    delete queue[id];\n    fn();\n  }\n};\nvar listener = function(event){\n  run.call(event.data);\n};\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif(!setTask || !clearTask){\n  setTask = function setImmediate(fn){\n    var args = [], i = 1;\n    while(arguments.length > i)args.push(arguments[i++]);\n    queue[++counter] = function(){\n      invoke(typeof fn == 'function' ? fn : Function(fn), args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clearTask = function clearImmediate(id){\n    delete queue[id];\n  };\n  // Node.js 0.8-\n  if(require('./_cof')(process) == 'process'){\n    defer = function(id){\n      process.nextTick(ctx(run, id, 1));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  } else if(MessageChannel){\n    channel = new MessageChannel;\n    port    = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = ctx(port.postMessage, port, 1);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){\n    defer = function(id){\n      global.postMessage(id + '', '*');\n    };\n    global.addEventListener('message', listener, false);\n  // IE8-\n  } else if(ONREADYSTATECHANGE in cel('script')){\n    defer = function(id){\n      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){\n        html.removeChild(this);\n        run.call(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function(id){\n      setTimeout(ctx(run, id, 1), 0);\n    };\n  }\n}\nmodule.exports = {\n  set:   setTask,\n  clear: clearTask\n};\n},{\"./_cof\":41,\"./_ctx\":44,\"./_dom-create\":47,\"./_global\":53,\"./_html\":56,\"./_invoke\":58}],97:[function(require,module,exports){\nvar toInteger = require('./_to-integer')\n  , max       = Math.max\n  , min       = Math.min;\nmodule.exports = function(index, length){\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n},{\"./_to-integer\":98}],98:[function(require,module,exports){\n// 7.1.4 ToInteger\nvar ceil  = Math.ceil\n  , floor = Math.floor;\nmodule.exports = function(it){\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n},{}],99:[function(require,module,exports){\n// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = require('./_iobject')\n  , defined = require('./_defined');\nmodule.exports = function(it){\n  return IObject(defined(it));\n};\n},{\"./_defined\":45,\"./_iobject\":59}],100:[function(require,module,exports){\n// 7.1.15 ToLength\nvar toInteger = require('./_to-integer')\n  , min       = Math.min;\nmodule.exports = function(it){\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n},{\"./_to-integer\":98}],101:[function(require,module,exports){\n// 7.1.13 ToObject(argument)\nvar defined = require('./_defined');\nmodule.exports = function(it){\n  return Object(defined(it));\n};\n},{\"./_defined\":45}],102:[function(require,module,exports){\n// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = require('./_is-object');\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function(it, S){\n  if(!isObject(it))return it;\n  var fn, val;\n  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n},{\"./_is-object\":62}],103:[function(require,module,exports){\nvar id = 0\n  , px = Math.random();\nmodule.exports = function(key){\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n},{}],104:[function(require,module,exports){\nvar global         = require('./_global')\n  , core           = require('./_core')\n  , LIBRARY        = require('./_library')\n  , wksExt         = require('./_wks-ext')\n  , defineProperty = require('./_object-dp').f;\nmodule.exports = function(name){\n  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\n  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});\n};\n},{\"./_core\":42,\"./_global\":53,\"./_library\":70,\"./_object-dp\":75,\"./_wks-ext\":105}],105:[function(require,module,exports){\nexports.f = require('./_wks');\n},{\"./_wks\":106}],106:[function(require,module,exports){\nvar store      = require('./_shared')('wks')\n  , uid        = require('./_uid')\n  , Symbol     = require('./_global').Symbol\n  , USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function(name){\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n},{\"./_global\":53,\"./_shared\":93,\"./_uid\":103}],107:[function(require,module,exports){\nvar classof   = require('./_classof')\n  , ITERATOR  = require('./_wks')('iterator')\n  , Iterators = require('./_iterators');\nmodule.exports = require('./_core').getIteratorMethod = function(it){\n  if(it != undefined)return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n},{\"./_classof\":40,\"./_core\":42,\"./_iterators\":68,\"./_wks\":106}],108:[function(require,module,exports){\n'use strict';\nvar ctx            = require('./_ctx')\n  , $export        = require('./_export')\n  , toObject       = require('./_to-object')\n  , call           = require('./_iter-call')\n  , isArrayIter    = require('./_is-array-iter')\n  , toLength       = require('./_to-length')\n  , createProperty = require('./_create-property')\n  , getIterFn      = require('./core.get-iterator-method');\n\n$export($export.S + $export.F * !require('./_iter-detect')(function(iter){ Array.from(iter); }), 'Array', {\n  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\n  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){\n    var O       = toObject(arrayLike)\n      , C       = typeof this == 'function' ? this : Array\n      , aLen    = arguments.length\n      , mapfn   = aLen > 1 ? arguments[1] : undefined\n      , mapping = mapfn !== undefined\n      , index   = 0\n      , iterFn  = getIterFn(O)\n      , length, result, step, iterator;\n    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);\n    // if object isn't iterable or it's array with default iterator - use simple case\n    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){\n      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){\n        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);\n      }\n    } else {\n      length = toLength(O.length);\n      for(result = new C(length); length > index; index++){\n        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\n      }\n    }\n    result.length = index;\n    return result;\n  }\n});\n\n},{\"./_create-property\":43,\"./_ctx\":44,\"./_export\":50,\"./_is-array-iter\":60,\"./_iter-call\":63,\"./_iter-detect\":66,\"./_to-length\":100,\"./_to-object\":101,\"./core.get-iterator-method\":107}],109:[function(require,module,exports){\n'use strict';\nvar addToUnscopables = require('./_add-to-unscopables')\n  , step             = require('./_iter-step')\n  , Iterators        = require('./_iterators')\n  , toIObject        = require('./_to-iobject');\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = require('./_iter-define')(Array, 'Array', function(iterated, kind){\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , kind  = this._k\n    , index = this._i++;\n  if(!O || index >= O.length){\n    this._t = undefined;\n    return step(1);\n  }\n  if(kind == 'keys'  )return step(0, index);\n  if(kind == 'values')return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n},{\"./_add-to-unscopables\":36,\"./_iter-define\":65,\"./_iter-step\":67,\"./_iterators\":68,\"./_to-iobject\":99}],110:[function(require,module,exports){\n// 19.1.3.1 Object.assign(target, source)\nvar $export = require('./_export');\n\n$export($export.S + $export.F, 'Object', {assign: require('./_object-assign')});\n},{\"./_export\":50,\"./_object-assign\":73}],111:[function(require,module,exports){\nvar $export = require('./_export')\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n$export($export.S, 'Object', {create: require('./_object-create')});\n},{\"./_export\":50,\"./_object-create\":74}],112:[function(require,module,exports){\nvar $export = require('./_export');\n// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)\n$export($export.S + $export.F * !require('./_descriptors'), 'Object', {defineProperty: require('./_object-dp').f});\n},{\"./_descriptors\":46,\"./_export\":50,\"./_object-dp\":75}],113:[function(require,module,exports){\n// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\nvar toIObject                 = require('./_to-iobject')\n  , $getOwnPropertyDescriptor = require('./_object-gopd').f;\n\nrequire('./_object-sap')('getOwnPropertyDescriptor', function(){\n  return function getOwnPropertyDescriptor(it, key){\n    return $getOwnPropertyDescriptor(toIObject(it), key);\n  };\n});\n},{\"./_object-gopd\":77,\"./_object-sap\":85,\"./_to-iobject\":99}],114:[function(require,module,exports){\n// 19.1.2.9 Object.getPrototypeOf(O)\nvar toObject        = require('./_to-object')\n  , $getPrototypeOf = require('./_object-gpo');\n\nrequire('./_object-sap')('getPrototypeOf', function(){\n  return function getPrototypeOf(it){\n    return $getPrototypeOf(toObject(it));\n  };\n});\n},{\"./_object-gpo\":81,\"./_object-sap\":85,\"./_to-object\":101}],115:[function(require,module,exports){\n// 19.1.2.12 Object.isFrozen(O)\nvar isObject = require('./_is-object');\n\nrequire('./_object-sap')('isFrozen', function($isFrozen){\n  return function isFrozen(it){\n    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;\n  };\n});\n},{\"./_is-object\":62,\"./_object-sap\":85}],116:[function(require,module,exports){\n// 19.1.2.14 Object.keys(O)\nvar toObject = require('./_to-object')\n  , $keys    = require('./_object-keys');\n\nrequire('./_object-sap')('keys', function(){\n  return function keys(it){\n    return $keys(toObject(it));\n  };\n});\n},{\"./_object-keys\":83,\"./_object-sap\":85,\"./_to-object\":101}],117:[function(require,module,exports){\n// 19.1.3.19 Object.setPrototypeOf(O, proto)\nvar $export = require('./_export');\n$export($export.S, 'Object', {setPrototypeOf: require('./_set-proto').set});\n},{\"./_export\":50,\"./_set-proto\":89}],118:[function(require,module,exports){\n\n},{}],119:[function(require,module,exports){\n'use strict';\nvar LIBRARY            = require('./_library')\n  , global             = require('./_global')\n  , ctx                = require('./_ctx')\n  , classof            = require('./_classof')\n  , $export            = require('./_export')\n  , isObject           = require('./_is-object')\n  , aFunction          = require('./_a-function')\n  , anInstance         = require('./_an-instance')\n  , forOf              = require('./_for-of')\n  , speciesConstructor = require('./_species-constructor')\n  , task               = require('./_task').set\n  , microtask          = require('./_microtask')()\n  , PROMISE            = 'Promise'\n  , TypeError          = global.TypeError\n  , process            = global.process\n  , $Promise           = global[PROMISE]\n  , process            = global.process\n  , isNode             = classof(process) == 'process'\n  , empty              = function(){ /* empty */ }\n  , Internal, GenericPromiseCapability, Wrapper;\n\nvar USE_NATIVE = !!function(){\n  try {\n    // correct subclassing with @@species support\n    var promise     = $Promise.resolve(1)\n      , FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function(exec){ exec(empty, empty); };\n    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;\n  } catch(e){ /* empty */ }\n}();\n\n// helpers\nvar sameConstructor = function(a, b){\n  // with library wrapper special case\n  return a === b || a === $Promise && b === Wrapper;\n};\nvar isThenable = function(it){\n  var then;\n  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n};\nvar newPromiseCapability = function(C){\n  return sameConstructor($Promise, C)\n    ? new PromiseCapability(C)\n    : new GenericPromiseCapability(C);\n};\nvar PromiseCapability = GenericPromiseCapability = function(C){\n  var resolve, reject;\n  this.promise = new C(function($$resolve, $$reject){\n    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject  = $$reject;\n  });\n  this.resolve = aFunction(resolve);\n  this.reject  = aFunction(reject);\n};\nvar perform = function(exec){\n  try {\n    exec();\n  } catch(e){\n    return {error: e};\n  }\n};\nvar notify = function(promise, isReject){\n  if(promise._n)return;\n  promise._n = true;\n  var chain = promise._c;\n  microtask(function(){\n    var value = promise._v\n      , ok    = promise._s == 1\n      , i     = 0;\n    var run = function(reaction){\n      var handler = ok ? reaction.ok : reaction.fail\n        , resolve = reaction.resolve\n        , reject  = reaction.reject\n        , domain  = reaction.domain\n        , result, then;\n      try {\n        if(handler){\n          if(!ok){\n            if(promise._h == 2)onHandleUnhandled(promise);\n            promise._h = 1;\n          }\n          if(handler === true)result = value;\n          else {\n            if(domain)domain.enter();\n            result = handler(value);\n            if(domain)domain.exit();\n          }\n          if(result === reaction.promise){\n            reject(TypeError('Promise-chain cycle'));\n          } else if(then = isThenable(result)){\n            then.call(result, resolve, reject);\n          } else resolve(result);\n        } else reject(value);\n      } catch(e){\n        reject(e);\n      }\n    };\n    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach\n    promise._c = [];\n    promise._n = false;\n    if(isReject && !promise._h)onUnhandled(promise);\n  });\n};\nvar onUnhandled = function(promise){\n  task.call(global, function(){\n    var value = promise._v\n      , abrupt, handler, console;\n    if(isUnhandled(promise)){\n      abrupt = perform(function(){\n        if(isNode){\n          process.emit('unhandledRejection', value, promise);\n        } else if(handler = global.onunhandledrejection){\n          handler({promise: promise, reason: value});\n        } else if((console = global.console) && console.error){\n          console.error('Unhandled promise rejection', value);\n        }\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      promise._h = isNode || isUnhandled(promise) ? 2 : 1;\n    } promise._a = undefined;\n    if(abrupt)throw abrupt.error;\n  });\n};\nvar isUnhandled = function(promise){\n  if(promise._h == 1)return false;\n  var chain = promise._a || promise._c\n    , i     = 0\n    , reaction;\n  while(chain.length > i){\n    reaction = chain[i++];\n    if(reaction.fail || !isUnhandled(reaction.promise))return false;\n  } return true;\n};\nvar onHandleUnhandled = function(promise){\n  task.call(global, function(){\n    var handler;\n    if(isNode){\n      process.emit('rejectionHandled', promise);\n    } else if(handler = global.onrejectionhandled){\n      handler({promise: promise, reason: promise._v});\n    }\n  });\n};\nvar $reject = function(value){\n  var promise = this;\n  if(promise._d)return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  promise._v = value;\n  promise._s = 2;\n  if(!promise._a)promise._a = promise._c.slice();\n  notify(promise, true);\n};\nvar $resolve = function(value){\n  var promise = this\n    , then;\n  if(promise._d)return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  try {\n    if(promise === value)throw TypeError(\"Promise can't be resolved itself\");\n    if(then = isThenable(value)){\n      microtask(function(){\n        var wrapper = {_w: promise, _d: false}; // wrap\n        try {\n          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));\n        } catch(e){\n          $reject.call(wrapper, e);\n        }\n      });\n    } else {\n      promise._v = value;\n      promise._s = 1;\n      notify(promise, false);\n    }\n  } catch(e){\n    $reject.call({_w: promise, _d: false}, e); // wrap\n  }\n};\n\n// constructor polyfill\nif(!USE_NATIVE){\n  // 25.4.3.1 Promise(executor)\n  $Promise = function Promise(executor){\n    anInstance(this, $Promise, PROMISE, '_h');\n    aFunction(executor);\n    Internal.call(this);\n    try {\n      executor(ctx($resolve, this, 1), ctx($reject, this, 1));\n    } catch(err){\n      $reject.call(this, err);\n    }\n  };\n  Internal = function Promise(executor){\n    this._c = [];             // <- awaiting reactions\n    this._a = undefined;      // <- checked in isUnhandled reactions\n    this._s = 0;              // <- state\n    this._d = false;          // <- done\n    this._v = undefined;      // <- value\n    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled\n    this._n = false;          // <- notify\n  };\n  Internal.prototype = require('./_redefine-all')($Promise.prototype, {\n    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\n    then: function then(onFulfilled, onRejected){\n      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));\n      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;\n      reaction.fail   = typeof onRejected == 'function' && onRejected;\n      reaction.domain = isNode ? process.domain : undefined;\n      this._c.push(reaction);\n      if(this._a)this._a.push(reaction);\n      if(this._s)notify(this, false);\n      return reaction.promise;\n    },\n    // 25.4.5.1 Promise.prototype.catch(onRejected)\n    'catch': function(onRejected){\n      return this.then(undefined, onRejected);\n    }\n  });\n  PromiseCapability = function(){\n    var promise  = new Internal;\n    this.promise = promise;\n    this.resolve = ctx($resolve, promise, 1);\n    this.reject  = ctx($reject, promise, 1);\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});\nrequire('./_set-to-string-tag')($Promise, PROMISE);\nrequire('./_set-species')(PROMISE);\nWrapper = require('./_core')[PROMISE];\n\n// statics\n$export($export.S + $export.F * !USE_NATIVE, PROMISE, {\n  // 25.4.4.5 Promise.reject(r)\n  reject: function reject(r){\n    var capability = newPromiseCapability(this)\n      , $$reject   = capability.reject;\n    $$reject(r);\n    return capability.promise;\n  }\n});\n$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {\n  // 25.4.4.6 Promise.resolve(x)\n  resolve: function resolve(x){\n    // instanceof instead of internal slot check because we should fix it without replacement native Promise core\n    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;\n    var capability = newPromiseCapability(this)\n      , $$resolve  = capability.resolve;\n    $$resolve(x);\n    return capability.promise;\n  }\n});\n$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function(iter){\n  $Promise.all(iter)['catch'](empty);\n})), PROMISE, {\n  // 25.4.4.1 Promise.all(iterable)\n  all: function all(iterable){\n    var C          = this\n      , capability = newPromiseCapability(C)\n      , resolve    = capability.resolve\n      , reject     = capability.reject;\n    var abrupt = perform(function(){\n      var values    = []\n        , index     = 0\n        , remaining = 1;\n      forOf(iterable, false, function(promise){\n        var $index        = index++\n          , alreadyCalled = false;\n        values.push(undefined);\n        remaining++;\n        C.resolve(promise).then(function(value){\n          if(alreadyCalled)return;\n          alreadyCalled  = true;\n          values[$index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if(abrupt)reject(abrupt.error);\n    return capability.promise;\n  },\n  // 25.4.4.4 Promise.race(iterable)\n  race: function race(iterable){\n    var C          = this\n      , capability = newPromiseCapability(C)\n      , reject     = capability.reject;\n    var abrupt = perform(function(){\n      forOf(iterable, false, function(promise){\n        C.resolve(promise).then(capability.resolve, reject);\n      });\n    });\n    if(abrupt)reject(abrupt.error);\n    return capability.promise;\n  }\n});\n},{\"./_a-function\":35,\"./_an-instance\":37,\"./_classof\":40,\"./_core\":42,\"./_ctx\":44,\"./_export\":50,\"./_for-of\":52,\"./_global\":53,\"./_is-object\":62,\"./_iter-detect\":66,\"./_library\":70,\"./_microtask\":72,\"./_redefine-all\":87,\"./_set-species\":90,\"./_set-to-string-tag\":91,\"./_species-constructor\":94,\"./_task\":96,\"./_wks\":106}],120:[function(require,module,exports){\n'use strict';\nvar $at  = require('./_string-at')(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\nrequire('./_iter-define')(String, 'String', function(iterated){\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , index = this._i\n    , point;\n  if(index >= O.length)return {value: undefined, done: true};\n  point = $at(O, index);\n  this._i += point.length;\n  return {value: point, done: false};\n});\n},{\"./_iter-define\":65,\"./_string-at\":95}],121:[function(require,module,exports){\n'use strict';\n// ECMAScript 6 symbols shim\nvar global         = require('./_global')\n  , has            = require('./_has')\n  , DESCRIPTORS    = require('./_descriptors')\n  , $export        = require('./_export')\n  , redefine       = require('./_redefine')\n  , META           = require('./_meta').KEY\n  , $fails         = require('./_fails')\n  , shared         = require('./_shared')\n  , setToStringTag = require('./_set-to-string-tag')\n  , uid            = require('./_uid')\n  , wks            = require('./_wks')\n  , wksExt         = require('./_wks-ext')\n  , wksDefine      = require('./_wks-define')\n  , keyOf          = require('./_keyof')\n  , enumKeys       = require('./_enum-keys')\n  , isArray        = require('./_is-array')\n  , anObject       = require('./_an-object')\n  , toIObject      = require('./_to-iobject')\n  , toPrimitive    = require('./_to-primitive')\n  , createDesc     = require('./_property-desc')\n  , _create        = require('./_object-create')\n  , gOPNExt        = require('./_object-gopn-ext')\n  , $GOPD          = require('./_object-gopd')\n  , $DP            = require('./_object-dp')\n  , $keys          = require('./_object-keys')\n  , gOPD           = $GOPD.f\n  , dP             = $DP.f\n  , gOPN           = gOPNExt.f\n  , $Symbol        = global.Symbol\n  , $JSON          = global.JSON\n  , _stringify     = $JSON && $JSON.stringify\n  , PROTOTYPE      = 'prototype'\n  , HIDDEN         = wks('_hidden')\n  , TO_PRIMITIVE   = wks('toPrimitive')\n  , isEnum         = {}.propertyIsEnumerable\n  , SymbolRegistry = shared('symbol-registry')\n  , AllSymbols     = shared('symbols')\n  , OPSymbols      = shared('op-symbols')\n  , ObjectProto    = Object[PROTOTYPE]\n  , USE_NATIVE     = typeof $Symbol == 'function'\n  , QObject        = global.QObject;\n// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\nvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar setSymbolDesc = DESCRIPTORS && $fails(function(){\n  return _create(dP({}, 'a', {\n    get: function(){ return dP(this, 'a', {value: 7}).a; }\n  })).a != 7;\n}) ? function(it, key, D){\n  var protoDesc = gOPD(ObjectProto, key);\n  if(protoDesc)delete ObjectProto[key];\n  dP(it, key, D);\n  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);\n} : dP;\n\nvar wrap = function(tag){\n  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n  sym._k = tag;\n  return sym;\n};\n\nvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){\n  return typeof it == 'symbol';\n} : function(it){\n  return it instanceof $Symbol;\n};\n\nvar $defineProperty = function defineProperty(it, key, D){\n  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);\n  anObject(it);\n  key = toPrimitive(key, true);\n  anObject(D);\n  if(has(AllSymbols, key)){\n    if(!D.enumerable){\n      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));\n      it[HIDDEN][key] = true;\n    } else {\n      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;\n      D = _create(D, {enumerable: createDesc(0, false)});\n    } return setSymbolDesc(it, key, D);\n  } return dP(it, key, D);\n};\nvar $defineProperties = function defineProperties(it, P){\n  anObject(it);\n  var keys = enumKeys(P = toIObject(P))\n    , i    = 0\n    , l = keys.length\n    , key;\n  while(l > i)$defineProperty(it, key = keys[i++], P[key]);\n  return it;\n};\nvar $create = function create(it, P){\n  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n};\nvar $propertyIsEnumerable = function propertyIsEnumerable(key){\n  var E = isEnum.call(this, key = toPrimitive(key, true));\n  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;\n  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n};\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){\n  it  = toIObject(it);\n  key = toPrimitive(key, true);\n  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;\n  var D = gOPD(it, key);\n  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;\n  return D;\n};\nvar $getOwnPropertyNames = function getOwnPropertyNames(it){\n  var names  = gOPN(toIObject(it))\n    , result = []\n    , i      = 0\n    , key;\n  while(names.length > i){\n    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);\n  } return result;\n};\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(it){\n  var IS_OP  = it === ObjectProto\n    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))\n    , result = []\n    , i      = 0\n    , key;\n  while(names.length > i){\n    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);\n  } return result;\n};\n\n// 19.4.1.1 Symbol([description])\nif(!USE_NATIVE){\n  $Symbol = function Symbol(){\n    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');\n    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n    var $set = function(value){\n      if(this === ObjectProto)$set.call(OPSymbols, value);\n      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;\n      setSymbolDesc(this, tag, createDesc(1, value));\n    };\n    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});\n    return wrap(tag);\n  };\n  redefine($Symbol[PROTOTYPE], 'toString', function toString(){\n    return this._k;\n  });\n\n  $GOPD.f = $getOwnPropertyDescriptor;\n  $DP.f   = $defineProperty;\n  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;\n  require('./_object-pie').f  = $propertyIsEnumerable;\n  require('./_object-gops').f = $getOwnPropertySymbols;\n\n  if(DESCRIPTORS && !require('./_library')){\n    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n  }\n\n  wksExt.f = function(name){\n    return wrap(wks(name));\n  }\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});\n\nfor(var symbols = (\n  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);\n\nfor(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);\n\n$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\n  // 19.4.2.1 Symbol.for(key)\n  'for': function(key){\n    return has(SymbolRegistry, key += '')\n      ? SymbolRegistry[key]\n      : SymbolRegistry[key] = $Symbol(key);\n  },\n  // 19.4.2.5 Symbol.keyFor(sym)\n  keyFor: function keyFor(key){\n    if(isSymbol(key))return keyOf(SymbolRegistry, key);\n    throw TypeError(key + ' is not a symbol!');\n  },\n  useSetter: function(){ setter = true; },\n  useSimple: function(){ setter = false; }\n});\n\n$export($export.S + $export.F * !USE_NATIVE, 'Object', {\n  // 19.1.2.2 Object.create(O [, Properties])\n  create: $create,\n  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n  defineProperty: $defineProperty,\n  // 19.1.2.3 Object.defineProperties(O, Properties)\n  defineProperties: $defineProperties,\n  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n  // 19.1.2.7 Object.getOwnPropertyNames(O)\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n  getOwnPropertySymbols: $getOwnPropertySymbols\n});\n\n// 24.3.2 JSON.stringify(value [, replacer [, space]])\n$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){\n  var S = $Symbol();\n  // MS Edge converts symbol values to JSON as {}\n  // WebKit converts symbol values to JSON as null\n  // V8 throws on boxed symbols\n  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';\n})), 'JSON', {\n  stringify: function stringify(it){\n    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined\n    var args = [it]\n      , i    = 1\n      , replacer, $replacer;\n    while(arguments.length > i)args.push(arguments[i++]);\n    replacer = args[1];\n    if(typeof replacer == 'function')$replacer = replacer;\n    if($replacer || !isArray(replacer))replacer = function(key, value){\n      if($replacer)value = $replacer.call(this, key, value);\n      if(!isSymbol(value))return value;\n    };\n    args[1] = replacer;\n    return _stringify.apply($JSON, args);\n  }\n});\n\n// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n// 19.4.3.5 Symbol.prototype[@@toStringTag]\nsetToStringTag($Symbol, 'Symbol');\n// 20.2.1.9 Math[@@toStringTag]\nsetToStringTag(Math, 'Math', true);\n// 24.3.3 JSON[@@toStringTag]\nsetToStringTag(global.JSON, 'JSON', true);\n},{\"./_an-object\":38,\"./_descriptors\":46,\"./_enum-keys\":49,\"./_export\":50,\"./_fails\":51,\"./_global\":53,\"./_has\":54,\"./_hide\":55,\"./_is-array\":61,\"./_keyof\":69,\"./_library\":70,\"./_meta\":71,\"./_object-create\":74,\"./_object-dp\":75,\"./_object-gopd\":77,\"./_object-gopn\":79,\"./_object-gopn-ext\":78,\"./_object-gops\":80,\"./_object-keys\":83,\"./_object-pie\":84,\"./_property-desc\":86,\"./_redefine\":88,\"./_set-to-string-tag\":91,\"./_shared\":93,\"./_to-iobject\":99,\"./_to-primitive\":102,\"./_uid\":103,\"./_wks\":106,\"./_wks-define\":104,\"./_wks-ext\":105}],122:[function(require,module,exports){\nrequire('./_wks-define')('asyncIterator');\n},{\"./_wks-define\":104}],123:[function(require,module,exports){\nrequire('./_wks-define')('observable');\n},{\"./_wks-define\":104}],124:[function(require,module,exports){\nrequire('./es6.array.iterator');\nvar global        = require('./_global')\n  , hide          = require('./_hide')\n  , Iterators     = require('./_iterators')\n  , TO_STRING_TAG = require('./_wks')('toStringTag');\n\nfor(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){\n  var NAME       = collections[i]\n    , Collection = global[NAME]\n    , proto      = Collection && Collection.prototype;\n  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);\n  Iterators[NAME] = Iterators.Array;\n}\n},{\"./_global\":53,\"./_hide\":55,\"./_iterators\":68,\"./_wks\":106,\"./es6.array.iterator\":109}],125:[function(require,module,exports){\narguments[4][35][0].apply(exports,arguments)\n},{\"dup\":35}],126:[function(require,module,exports){\nvar cof = require('./_cof');\nmodule.exports = function(it, msg){\n  if(typeof it != 'number' && cof(it) != 'Number')throw TypeError(msg);\n  return +it;\n};\n},{\"./_cof\":140}],127:[function(require,module,exports){\n// 22.1.3.31 Array.prototype[@@unscopables]\nvar UNSCOPABLES = require('./_wks')('unscopables')\n  , ArrayProto  = Array.prototype;\nif(ArrayProto[UNSCOPABLES] == undefined)require('./_hide')(ArrayProto, UNSCOPABLES, {});\nmodule.exports = function(key){\n  ArrayProto[UNSCOPABLES][key] = true;\n};\n},{\"./_hide\":162,\"./_wks\":239}],128:[function(require,module,exports){\narguments[4][37][0].apply(exports,arguments)\n},{\"dup\":37}],129:[function(require,module,exports){\narguments[4][38][0].apply(exports,arguments)\n},{\"./_is-object\":171,\"dup\":38}],130:[function(require,module,exports){\n// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)\n'use strict';\nvar toObject = require('./_to-object')\n  , toIndex  = require('./_to-index')\n  , toLength = require('./_to-length');\n\nmodule.exports = [].copyWithin || function copyWithin(target/*= 0*/, start/*= 0, end = @length*/){\n  var O     = toObject(this)\n    , len   = toLength(O.length)\n    , to    = toIndex(target, len)\n    , from  = toIndex(start, len)\n    , end   = arguments.length > 2 ? arguments[2] : undefined\n    , count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to)\n    , inc   = 1;\n  if(from < to && to < from + count){\n    inc  = -1;\n    from += count - 1;\n    to   += count - 1;\n  }\n  while(count-- > 0){\n    if(from in O)O[to] = O[from];\n    else delete O[to];\n    to   += inc;\n    from += inc;\n  } return O;\n};\n},{\"./_to-index\":227,\"./_to-length\":230,\"./_to-object\":231}],131:[function(require,module,exports){\n// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)\n'use strict';\nvar toObject = require('./_to-object')\n  , toIndex  = require('./_to-index')\n  , toLength = require('./_to-length');\nmodule.exports = function fill(value /*, start = 0, end = @length */){\n  var O      = toObject(this)\n    , length = toLength(O.length)\n    , aLen   = arguments.length\n    , index  = toIndex(aLen > 1 ? arguments[1] : undefined, length)\n    , end    = aLen > 2 ? arguments[2] : undefined\n    , endPos = end === undefined ? length : toIndex(end, length);\n  while(endPos > index)O[index++] = value;\n  return O;\n};\n},{\"./_to-index\":227,\"./_to-length\":230,\"./_to-object\":231}],132:[function(require,module,exports){\nvar forOf = require('./_for-of');\n\nmodule.exports = function(iter, ITERATOR){\n  var result = [];\n  forOf(iter, false, result.push, result, ITERATOR);\n  return result;\n};\n\n},{\"./_for-of\":159}],133:[function(require,module,exports){\narguments[4][39][0].apply(exports,arguments)\n},{\"./_to-index\":227,\"./_to-iobject\":229,\"./_to-length\":230,\"dup\":39}],134:[function(require,module,exports){\n// 0 -> Array#forEach\n// 1 -> Array#map\n// 2 -> Array#filter\n// 3 -> Array#some\n// 4 -> Array#every\n// 5 -> Array#find\n// 6 -> Array#findIndex\nvar ctx      = require('./_ctx')\n  , IObject  = require('./_iobject')\n  , toObject = require('./_to-object')\n  , toLength = require('./_to-length')\n  , asc      = require('./_array-species-create');\nmodule.exports = function(TYPE, $create){\n  var IS_MAP        = TYPE == 1\n    , IS_FILTER     = TYPE == 2\n    , IS_SOME       = TYPE == 3\n    , IS_EVERY      = TYPE == 4\n    , IS_FIND_INDEX = TYPE == 6\n    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX\n    , create        = $create || asc;\n  return function($this, callbackfn, that){\n    var O      = toObject($this)\n      , self   = IObject(O)\n      , f      = ctx(callbackfn, that, 3)\n      , length = toLength(self.length)\n      , index  = 0\n      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined\n      , val, res;\n    for(;length > index; index++)if(NO_HOLES || index in self){\n      val = self[index];\n      res = f(val, index, O);\n      if(TYPE){\n        if(IS_MAP)result[index] = res;            // map\n        else if(res)switch(TYPE){\n          case 3: return true;                    // some\n          case 5: return val;                     // find\n          case 6: return index;                   // findIndex\n          case 2: result.push(val);               // filter\n        } else if(IS_EVERY)return false;          // every\n      }\n    }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;\n  };\n};\n},{\"./_array-species-create\":137,\"./_ctx\":147,\"./_iobject\":167,\"./_to-length\":230,\"./_to-object\":231}],135:[function(require,module,exports){\nvar aFunction = require('./_a-function')\n  , toObject  = require('./_to-object')\n  , IObject   = require('./_iobject')\n  , toLength  = require('./_to-length');\n\nmodule.exports = function(that, callbackfn, aLen, memo, isRight){\n  aFunction(callbackfn);\n  var O      = toObject(that)\n    , self   = IObject(O)\n    , length = toLength(O.length)\n    , index  = isRight ? length - 1 : 0\n    , i      = isRight ? -1 : 1;\n  if(aLen < 2)for(;;){\n    if(index in self){\n      memo = self[index];\n      index += i;\n      break;\n    }\n    index += i;\n    if(isRight ? index < 0 : length <= index){\n      throw TypeError('Reduce of empty array with no initial value');\n    }\n  }\n  for(;isRight ? index >= 0 : length > index; index += i)if(index in self){\n    memo = callbackfn(memo, self[index], index, O);\n  }\n  return memo;\n};\n},{\"./_a-function\":125,\"./_iobject\":167,\"./_to-length\":230,\"./_to-object\":231}],136:[function(require,module,exports){\nvar isObject = require('./_is-object')\n  , isArray  = require('./_is-array')\n  , SPECIES  = require('./_wks')('species');\n\nmodule.exports = function(original){\n  var C;\n  if(isArray(original)){\n    C = original.constructor;\n    // cross-realm fallback\n    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;\n    if(isObject(C)){\n      C = C[SPECIES];\n      if(C === null)C = undefined;\n    }\n  } return C === undefined ? Array : C;\n};\n},{\"./_is-array\":169,\"./_is-object\":171,\"./_wks\":239}],137:[function(require,module,exports){\n// 9.4.2.3 ArraySpeciesCreate(originalArray, length)\nvar speciesConstructor = require('./_array-species-constructor');\n\nmodule.exports = function(original, length){\n  return new (speciesConstructor(original))(length);\n};\n},{\"./_array-species-constructor\":136}],138:[function(require,module,exports){\n'use strict';\nvar aFunction  = require('./_a-function')\n  , isObject   = require('./_is-object')\n  , invoke     = require('./_invoke')\n  , arraySlice = [].slice\n  , factories  = {};\n\nvar construct = function(F, len, args){\n  if(!(len in factories)){\n    for(var n = [], i = 0; i < len; i++)n[i] = 'a[' + i + ']';\n    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');\n  } return factories[len](F, args);\n};\n\nmodule.exports = Function.bind || function bind(that /*, args... */){\n  var fn       = aFunction(this)\n    , partArgs = arraySlice.call(arguments, 1);\n  var bound = function(/* args... */){\n    var args = partArgs.concat(arraySlice.call(arguments));\n    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);\n  };\n  if(isObject(fn.prototype))bound.prototype = fn.prototype;\n  return bound;\n};\n},{\"./_a-function\":125,\"./_invoke\":166,\"./_is-object\":171}],139:[function(require,module,exports){\narguments[4][40][0].apply(exports,arguments)\n},{\"./_cof\":140,\"./_wks\":239,\"dup\":40}],140:[function(require,module,exports){\narguments[4][41][0].apply(exports,arguments)\n},{\"dup\":41}],141:[function(require,module,exports){\n'use strict';\nvar dP          = require('./_object-dp').f\n  , create      = require('./_object-create')\n  , redefineAll = require('./_redefine-all')\n  , ctx         = require('./_ctx')\n  , anInstance  = require('./_an-instance')\n  , defined     = require('./_defined')\n  , forOf       = require('./_for-of')\n  , $iterDefine = require('./_iter-define')\n  , step        = require('./_iter-step')\n  , setSpecies  = require('./_set-species')\n  , DESCRIPTORS = require('./_descriptors')\n  , fastKey     = require('./_meta').fastKey\n  , SIZE        = DESCRIPTORS ? '_s' : 'size';\n\nvar getEntry = function(that, key){\n  // fast case\n  var index = fastKey(key), entry;\n  if(index !== 'F')return that._i[index];\n  // frozen object case\n  for(entry = that._f; entry; entry = entry.n){\n    if(entry.k == key)return entry;\n  }\n};\n\nmodule.exports = {\n  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){\n    var C = wrapper(function(that, iterable){\n      anInstance(that, C, NAME, '_i');\n      that._i = create(null); // index\n      that._f = undefined;    // first entry\n      that._l = undefined;    // last entry\n      that[SIZE] = 0;         // size\n      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);\n    });\n    redefineAll(C.prototype, {\n      // 23.1.3.1 Map.prototype.clear()\n      // 23.2.3.2 Set.prototype.clear()\n      clear: function clear(){\n        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){\n          entry.r = true;\n          if(entry.p)entry.p = entry.p.n = undefined;\n          delete data[entry.i];\n        }\n        that._f = that._l = undefined;\n        that[SIZE] = 0;\n      },\n      // 23.1.3.3 Map.prototype.delete(key)\n      // 23.2.3.4 Set.prototype.delete(value)\n      'delete': function(key){\n        var that  = this\n          , entry = getEntry(that, key);\n        if(entry){\n          var next = entry.n\n            , prev = entry.p;\n          delete that._i[entry.i];\n          entry.r = true;\n          if(prev)prev.n = next;\n          if(next)next.p = prev;\n          if(that._f == entry)that._f = next;\n          if(that._l == entry)that._l = prev;\n          that[SIZE]--;\n        } return !!entry;\n      },\n      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)\n      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)\n      forEach: function forEach(callbackfn /*, that = undefined */){\n        anInstance(this, C, 'forEach');\n        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)\n          , entry;\n        while(entry = entry ? entry.n : this._f){\n          f(entry.v, entry.k, this);\n          // revert to the last existing entry\n          while(entry && entry.r)entry = entry.p;\n        }\n      },\n      // 23.1.3.7 Map.prototype.has(key)\n      // 23.2.3.7 Set.prototype.has(value)\n      has: function has(key){\n        return !!getEntry(this, key);\n      }\n    });\n    if(DESCRIPTORS)dP(C.prototype, 'size', {\n      get: function(){\n        return defined(this[SIZE]);\n      }\n    });\n    return C;\n  },\n  def: function(that, key, value){\n    var entry = getEntry(that, key)\n      , prev, index;\n    // change existing entry\n    if(entry){\n      entry.v = value;\n    // create new entry\n    } else {\n      that._l = entry = {\n        i: index = fastKey(key, true), // <- index\n        k: key,                        // <- key\n        v: value,                      // <- value\n        p: prev = that._l,             // <- previous entry\n        n: undefined,                  // <- next entry\n        r: false                       // <- removed\n      };\n      if(!that._f)that._f = entry;\n      if(prev)prev.n = entry;\n      that[SIZE]++;\n      // add to index\n      if(index !== 'F')that._i[index] = entry;\n    } return that;\n  },\n  getEntry: getEntry,\n  setStrong: function(C, NAME, IS_MAP){\n    // add .keys, .values, .entries, [@@iterator]\n    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11\n    $iterDefine(C, NAME, function(iterated, kind){\n      this._t = iterated;  // target\n      this._k = kind;      // kind\n      this._l = undefined; // previous\n    }, function(){\n      var that  = this\n        , kind  = that._k\n        , entry = that._l;\n      // revert to the last existing entry\n      while(entry && entry.r)entry = entry.p;\n      // get next entry\n      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){\n        // or finish the iteration\n        that._t = undefined;\n        return step(1);\n      }\n      // return step by kind\n      if(kind == 'keys'  )return step(0, entry.k);\n      if(kind == 'values')return step(0, entry.v);\n      return step(0, [entry.k, entry.v]);\n    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);\n\n    // add [@@species], 23.1.2.2, 23.2.2.2\n    setSpecies(NAME);\n  }\n};\n},{\"./_an-instance\":128,\"./_ctx\":147,\"./_defined\":149,\"./_descriptors\":150,\"./_for-of\":159,\"./_iter-define\":175,\"./_iter-step\":177,\"./_meta\":184,\"./_object-create\":188,\"./_object-dp\":189,\"./_redefine-all\":208,\"./_set-species\":213}],142:[function(require,module,exports){\n// https://github.com/DavidBruant/Map-Set.prototype.toJSON\nvar classof = require('./_classof')\n  , from    = require('./_array-from-iterable');\nmodule.exports = function(NAME){\n  return function toJSON(){\n    if(classof(this) != NAME)throw TypeError(NAME + \"#toJSON isn't generic\");\n    return from(this);\n  };\n};\n},{\"./_array-from-iterable\":132,\"./_classof\":139}],143:[function(require,module,exports){\n'use strict';\nvar redefineAll       = require('./_redefine-all')\n  , getWeak           = require('./_meta').getWeak\n  , anObject          = require('./_an-object')\n  , isObject          = require('./_is-object')\n  , anInstance        = require('./_an-instance')\n  , forOf             = require('./_for-of')\n  , createArrayMethod = require('./_array-methods')\n  , $has              = require('./_has')\n  , arrayFind         = createArrayMethod(5)\n  , arrayFindIndex    = createArrayMethod(6)\n  , id                = 0;\n\n// fallback for uncaught frozen keys\nvar uncaughtFrozenStore = function(that){\n  return that._l || (that._l = new UncaughtFrozenStore);\n};\nvar UncaughtFrozenStore = function(){\n  this.a = [];\n};\nvar findUncaughtFrozen = function(store, key){\n  return arrayFind(store.a, function(it){\n    return it[0] === key;\n  });\n};\nUncaughtFrozenStore.prototype = {\n  get: function(key){\n    var entry = findUncaughtFrozen(this, key);\n    if(entry)return entry[1];\n  },\n  has: function(key){\n    return !!findUncaughtFrozen(this, key);\n  },\n  set: function(key, value){\n    var entry = findUncaughtFrozen(this, key);\n    if(entry)entry[1] = value;\n    else this.a.push([key, value]);\n  },\n  'delete': function(key){\n    var index = arrayFindIndex(this.a, function(it){\n      return it[0] === key;\n    });\n    if(~index)this.a.splice(index, 1);\n    return !!~index;\n  }\n};\n\nmodule.exports = {\n  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){\n    var C = wrapper(function(that, iterable){\n      anInstance(that, C, NAME, '_i');\n      that._i = id++;      // collection id\n      that._l = undefined; // leak store for uncaught frozen objects\n      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);\n    });\n    redefineAll(C.prototype, {\n      // 23.3.3.2 WeakMap.prototype.delete(key)\n      // 23.4.3.3 WeakSet.prototype.delete(value)\n      'delete': function(key){\n        if(!isObject(key))return false;\n        var data = getWeak(key);\n        if(data === true)return uncaughtFrozenStore(this)['delete'](key);\n        return data && $has(data, this._i) && delete data[this._i];\n      },\n      // 23.3.3.4 WeakMap.prototype.has(key)\n      // 23.4.3.4 WeakSet.prototype.has(value)\n      has: function has(key){\n        if(!isObject(key))return false;\n        var data = getWeak(key);\n        if(data === true)return uncaughtFrozenStore(this).has(key);\n        return data && $has(data, this._i);\n      }\n    });\n    return C;\n  },\n  def: function(that, key, value){\n    var data = getWeak(anObject(key), true);\n    if(data === true)uncaughtFrozenStore(that).set(key, value);\n    else data[that._i] = value;\n    return that;\n  },\n  ufstore: uncaughtFrozenStore\n};\n},{\"./_an-instance\":128,\"./_an-object\":129,\"./_array-methods\":134,\"./_for-of\":159,\"./_has\":161,\"./_is-object\":171,\"./_meta\":184,\"./_redefine-all\":208}],144:[function(require,module,exports){\n'use strict';\nvar global            = require('./_global')\n  , $export           = require('./_export')\n  , redefine          = require('./_redefine')\n  , redefineAll       = require('./_redefine-all')\n  , meta              = require('./_meta')\n  , forOf             = require('./_for-of')\n  , anInstance        = require('./_an-instance')\n  , isObject          = require('./_is-object')\n  , fails             = require('./_fails')\n  , $iterDetect       = require('./_iter-detect')\n  , setToStringTag    = require('./_set-to-string-tag')\n  , inheritIfRequired = require('./_inherit-if-required');\n\nmodule.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){\n  var Base  = global[NAME]\n    , C     = Base\n    , ADDER = IS_MAP ? 'set' : 'add'\n    , proto = C && C.prototype\n    , O     = {};\n  var fixMethod = function(KEY){\n    var fn = proto[KEY];\n    redefine(proto, KEY,\n      KEY == 'delete' ? function(a){\n        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);\n      } : KEY == 'has' ? function has(a){\n        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);\n      } : KEY == 'get' ? function get(a){\n        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);\n      } : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }\n        : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }\n    );\n  };\n  if(typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){\n    new C().entries().next();\n  }))){\n    // create collection constructor\n    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);\n    redefineAll(C.prototype, methods);\n    meta.NEED = true;\n  } else {\n    var instance             = new C\n      // early implementations not supports chaining\n      , HASNT_CHAINING       = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance\n      // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false\n      , THROWS_ON_PRIMITIVES = fails(function(){ instance.has(1); })\n      // most early implementations doesn't supports iterables, most modern - not close it correctly\n      , ACCEPT_ITERABLES     = $iterDetect(function(iter){ new C(iter); }) // eslint-disable-line no-new\n      // for early implementations -0 and +0 not the same\n      , BUGGY_ZERO = !IS_WEAK && fails(function(){\n        // V8 ~ Chromium 42- fails only with 5+ elements\n        var $instance = new C()\n          , index     = 5;\n        while(index--)$instance[ADDER](index, index);\n        return !$instance.has(-0);\n      });\n    if(!ACCEPT_ITERABLES){ \n      C = wrapper(function(target, iterable){\n        anInstance(target, C, NAME);\n        var that = inheritIfRequired(new Base, target, C);\n        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);\n        return that;\n      });\n      C.prototype = proto;\n      proto.constructor = C;\n    }\n    if(THROWS_ON_PRIMITIVES || BUGGY_ZERO){\n      fixMethod('delete');\n      fixMethod('has');\n      IS_MAP && fixMethod('get');\n    }\n    if(BUGGY_ZERO || HASNT_CHAINING)fixMethod(ADDER);\n    // weak collections should not contains .clear method\n    if(IS_WEAK && proto.clear)delete proto.clear;\n  }\n\n  setToStringTag(C, NAME);\n\n  O[NAME] = C;\n  $export($export.G + $export.W + $export.F * (C != Base), O);\n\n  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);\n\n  return C;\n};\n},{\"./_an-instance\":128,\"./_export\":154,\"./_fails\":156,\"./_for-of\":159,\"./_global\":160,\"./_inherit-if-required\":165,\"./_is-object\":171,\"./_iter-detect\":176,\"./_meta\":184,\"./_redefine\":209,\"./_redefine-all\":208,\"./_set-to-string-tag\":214}],145:[function(require,module,exports){\narguments[4][42][0].apply(exports,arguments)\n},{\"dup\":42}],146:[function(require,module,exports){\narguments[4][43][0].apply(exports,arguments)\n},{\"./_object-dp\":189,\"./_property-desc\":207,\"dup\":43}],147:[function(require,module,exports){\narguments[4][44][0].apply(exports,arguments)\n},{\"./_a-function\":125,\"dup\":44}],148:[function(require,module,exports){\n'use strict';\nvar anObject    = require('./_an-object')\n  , toPrimitive = require('./_to-primitive')\n  , NUMBER      = 'number';\n\nmodule.exports = function(hint){\n  if(hint !== 'string' && hint !== NUMBER && hint !== 'default')throw TypeError('Incorrect hint');\n  return toPrimitive(anObject(this), hint != NUMBER);\n};\n},{\"./_an-object\":129,\"./_to-primitive\":232}],149:[function(require,module,exports){\narguments[4][45][0].apply(exports,arguments)\n},{\"dup\":45}],150:[function(require,module,exports){\narguments[4][46][0].apply(exports,arguments)\n},{\"./_fails\":156,\"dup\":46}],151:[function(require,module,exports){\narguments[4][47][0].apply(exports,arguments)\n},{\"./_global\":160,\"./_is-object\":171,\"dup\":47}],152:[function(require,module,exports){\narguments[4][48][0].apply(exports,arguments)\n},{\"dup\":48}],153:[function(require,module,exports){\narguments[4][49][0].apply(exports,arguments)\n},{\"./_object-gops\":195,\"./_object-keys\":198,\"./_object-pie\":199,\"dup\":49}],154:[function(require,module,exports){\nvar global    = require('./_global')\n  , core      = require('./_core')\n  , hide      = require('./_hide')\n  , redefine  = require('./_redefine')\n  , ctx       = require('./_ctx')\n  , PROTOTYPE = 'prototype';\n\nvar $export = function(type, name, source){\n  var IS_FORCED = type & $export.F\n    , IS_GLOBAL = type & $export.G\n    , IS_STATIC = type & $export.S\n    , IS_PROTO  = type & $export.P\n    , IS_BIND   = type & $export.B\n    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]\n    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})\n    , key, own, out, exp;\n  if(IS_GLOBAL)source = name;\n  for(key in source){\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    // export native or passed\n    out = (own ? target : source)[key];\n    // bind timers to global for call from export context\n    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // extend global\n    if(target)redefine(target, key, out, type & $export.U);\n    // export\n    if(exports[key] != out)hide(exports, key, exp);\n    if(IS_PROTO && expProto[key] != out)expProto[key] = out;\n  }\n};\nglobal.core = core;\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library` \nmodule.exports = $export;\n},{\"./_core\":145,\"./_ctx\":147,\"./_global\":160,\"./_hide\":162,\"./_redefine\":209}],155:[function(require,module,exports){\nvar MATCH = require('./_wks')('match');\nmodule.exports = function(KEY){\n  var re = /./;\n  try {\n    '/./'[KEY](re);\n  } catch(e){\n    try {\n      re[MATCH] = false;\n      return !'/./'[KEY](re);\n    } catch(f){ /* empty */ }\n  } return true;\n};\n},{\"./_wks\":239}],156:[function(require,module,exports){\narguments[4][51][0].apply(exports,arguments)\n},{\"dup\":51}],157:[function(require,module,exports){\n'use strict';\nvar hide     = require('./_hide')\n  , redefine = require('./_redefine')\n  , fails    = require('./_fails')\n  , defined  = require('./_defined')\n  , wks      = require('./_wks');\n\nmodule.exports = function(KEY, length, exec){\n  var SYMBOL   = wks(KEY)\n    , fns      = exec(defined, SYMBOL, ''[KEY])\n    , strfn    = fns[0]\n    , rxfn     = fns[1];\n  if(fails(function(){\n    var O = {};\n    O[SYMBOL] = function(){ return 7; };\n    return ''[KEY](O) != 7;\n  })){\n    redefine(String.prototype, KEY, strfn);\n    hide(RegExp.prototype, SYMBOL, length == 2\n      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)\n      // 21.2.5.11 RegExp.prototype[@@split](string, limit)\n      ? function(string, arg){ return rxfn.call(string, this, arg); }\n      // 21.2.5.6 RegExp.prototype[@@match](string)\n      // 21.2.5.9 RegExp.prototype[@@search](string)\n      : function(string){ return rxfn.call(string, this); }\n    );\n  }\n};\n},{\"./_defined\":149,\"./_fails\":156,\"./_hide\":162,\"./_redefine\":209,\"./_wks\":239}],158:[function(require,module,exports){\n'use strict';\n// 21.2.5.3 get RegExp.prototype.flags\nvar anObject = require('./_an-object');\nmodule.exports = function(){\n  var that   = anObject(this)\n    , result = '';\n  if(that.global)     result += 'g';\n  if(that.ignoreCase) result += 'i';\n  if(that.multiline)  result += 'm';\n  if(that.unicode)    result += 'u';\n  if(that.sticky)     result += 'y';\n  return result;\n};\n},{\"./_an-object\":129}],159:[function(require,module,exports){\narguments[4][52][0].apply(exports,arguments)\n},{\"./_an-object\":129,\"./_ctx\":147,\"./_is-array-iter\":168,\"./_iter-call\":173,\"./_to-length\":230,\"./core.get-iterator-method\":240,\"dup\":52}],160:[function(require,module,exports){\narguments[4][53][0].apply(exports,arguments)\n},{\"dup\":53}],161:[function(require,module,exports){\narguments[4][54][0].apply(exports,arguments)\n},{\"dup\":54}],162:[function(require,module,exports){\narguments[4][55][0].apply(exports,arguments)\n},{\"./_descriptors\":150,\"./_object-dp\":189,\"./_property-desc\":207,\"dup\":55}],163:[function(require,module,exports){\narguments[4][56][0].apply(exports,arguments)\n},{\"./_global\":160,\"dup\":56}],164:[function(require,module,exports){\narguments[4][57][0].apply(exports,arguments)\n},{\"./_descriptors\":150,\"./_dom-create\":151,\"./_fails\":156,\"dup\":57}],165:[function(require,module,exports){\nvar isObject       = require('./_is-object')\n  , setPrototypeOf = require('./_set-proto').set;\nmodule.exports = function(that, target, C){\n  var P, S = target.constructor;\n  if(S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf){\n    setPrototypeOf(that, P);\n  } return that;\n};\n},{\"./_is-object\":171,\"./_set-proto\":212}],166:[function(require,module,exports){\narguments[4][58][0].apply(exports,arguments)\n},{\"dup\":58}],167:[function(require,module,exports){\narguments[4][59][0].apply(exports,arguments)\n},{\"./_cof\":140,\"dup\":59}],168:[function(require,module,exports){\narguments[4][60][0].apply(exports,arguments)\n},{\"./_iterators\":178,\"./_wks\":239,\"dup\":60}],169:[function(require,module,exports){\narguments[4][61][0].apply(exports,arguments)\n},{\"./_cof\":140,\"dup\":61}],170:[function(require,module,exports){\n// 20.1.2.3 Number.isInteger(number)\nvar isObject = require('./_is-object')\n  , floor    = Math.floor;\nmodule.exports = function isInteger(it){\n  return !isObject(it) && isFinite(it) && floor(it) === it;\n};\n},{\"./_is-object\":171}],171:[function(require,module,exports){\narguments[4][62][0].apply(exports,arguments)\n},{\"dup\":62}],172:[function(require,module,exports){\n// 7.2.8 IsRegExp(argument)\nvar isObject = require('./_is-object')\n  , cof      = require('./_cof')\n  , MATCH    = require('./_wks')('match');\nmodule.exports = function(it){\n  var isRegExp;\n  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');\n};\n},{\"./_cof\":140,\"./_is-object\":171,\"./_wks\":239}],173:[function(require,module,exports){\narguments[4][63][0].apply(exports,arguments)\n},{\"./_an-object\":129,\"dup\":63}],174:[function(require,module,exports){\narguments[4][64][0].apply(exports,arguments)\n},{\"./_hide\":162,\"./_object-create\":188,\"./_property-desc\":207,\"./_set-to-string-tag\":214,\"./_wks\":239,\"dup\":64}],175:[function(require,module,exports){\narguments[4][65][0].apply(exports,arguments)\n},{\"./_export\":154,\"./_has\":161,\"./_hide\":162,\"./_iter-create\":174,\"./_iterators\":178,\"./_library\":180,\"./_object-gpo\":196,\"./_redefine\":209,\"./_set-to-string-tag\":214,\"./_wks\":239,\"dup\":65}],176:[function(require,module,exports){\narguments[4][66][0].apply(exports,arguments)\n},{\"./_wks\":239,\"dup\":66}],177:[function(require,module,exports){\narguments[4][67][0].apply(exports,arguments)\n},{\"dup\":67}],178:[function(require,module,exports){\narguments[4][68][0].apply(exports,arguments)\n},{\"dup\":68}],179:[function(require,module,exports){\narguments[4][69][0].apply(exports,arguments)\n},{\"./_object-keys\":198,\"./_to-iobject\":229,\"dup\":69}],180:[function(require,module,exports){\nmodule.exports = false;\n},{}],181:[function(require,module,exports){\n// 20.2.2.14 Math.expm1(x)\nvar $expm1 = Math.expm1;\nmodule.exports = (!$expm1\n  // Old FF bug\n  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168\n  // Tor Browser bug\n  || $expm1(-2e-17) != -2e-17\n) ? function expm1(x){\n  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;\n} : $expm1;\n},{}],182:[function(require,module,exports){\n// 20.2.2.20 Math.log1p(x)\nmodule.exports = Math.log1p || function log1p(x){\n  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);\n};\n},{}],183:[function(require,module,exports){\n// 20.2.2.28 Math.sign(x)\nmodule.exports = Math.sign || function sign(x){\n  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;\n};\n},{}],184:[function(require,module,exports){\narguments[4][71][0].apply(exports,arguments)\n},{\"./_fails\":156,\"./_has\":161,\"./_is-object\":171,\"./_object-dp\":189,\"./_uid\":236,\"dup\":71}],185:[function(require,module,exports){\nvar Map     = require('./es6.map')\n  , $export = require('./_export')\n  , shared  = require('./_shared')('metadata')\n  , store   = shared.store || (shared.store = new (require('./es6.weak-map')));\n\nvar getOrCreateMetadataMap = function(target, targetKey, create){\n  var targetMetadata = store.get(target);\n  if(!targetMetadata){\n    if(!create)return undefined;\n    store.set(target, targetMetadata = new Map);\n  }\n  var keyMetadata = targetMetadata.get(targetKey);\n  if(!keyMetadata){\n    if(!create)return undefined;\n    targetMetadata.set(targetKey, keyMetadata = new Map);\n  } return keyMetadata;\n};\nvar ordinaryHasOwnMetadata = function(MetadataKey, O, P){\n  var metadataMap = getOrCreateMetadataMap(O, P, false);\n  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);\n};\nvar ordinaryGetOwnMetadata = function(MetadataKey, O, P){\n  var metadataMap = getOrCreateMetadataMap(O, P, false);\n  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);\n};\nvar ordinaryDefineOwnMetadata = function(MetadataKey, MetadataValue, O, P){\n  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);\n};\nvar ordinaryOwnMetadataKeys = function(target, targetKey){\n  var metadataMap = getOrCreateMetadataMap(target, targetKey, false)\n    , keys        = [];\n  if(metadataMap)metadataMap.forEach(function(_, key){ keys.push(key); });\n  return keys;\n};\nvar toMetaKey = function(it){\n  return it === undefined || typeof it == 'symbol' ? it : String(it);\n};\nvar exp = function(O){\n  $export($export.S, 'Reflect', O);\n};\n\nmodule.exports = {\n  store: store,\n  map: getOrCreateMetadataMap,\n  has: ordinaryHasOwnMetadata,\n  get: ordinaryGetOwnMetadata,\n  set: ordinaryDefineOwnMetadata,\n  keys: ordinaryOwnMetadataKeys,\n  key: toMetaKey,\n  exp: exp\n};\n},{\"./_export\":154,\"./_shared\":216,\"./es6.map\":271,\"./es6.weak-map\":377}],186:[function(require,module,exports){\narguments[4][72][0].apply(exports,arguments)\n},{\"./_cof\":140,\"./_global\":160,\"./_task\":226,\"dup\":72}],187:[function(require,module,exports){\narguments[4][73][0].apply(exports,arguments)\n},{\"./_fails\":156,\"./_iobject\":167,\"./_object-gops\":195,\"./_object-keys\":198,\"./_object-pie\":199,\"./_to-object\":231,\"dup\":73}],188:[function(require,module,exports){\narguments[4][74][0].apply(exports,arguments)\n},{\"./_an-object\":129,\"./_dom-create\":151,\"./_enum-bug-keys\":152,\"./_html\":163,\"./_object-dps\":190,\"./_shared-key\":215,\"dup\":74}],189:[function(require,module,exports){\narguments[4][75][0].apply(exports,arguments)\n},{\"./_an-object\":129,\"./_descriptors\":150,\"./_ie8-dom-define\":164,\"./_to-primitive\":232,\"dup\":75}],190:[function(require,module,exports){\narguments[4][76][0].apply(exports,arguments)\n},{\"./_an-object\":129,\"./_descriptors\":150,\"./_object-dp\":189,\"./_object-keys\":198,\"dup\":76}],191:[function(require,module,exports){\n// Forced replacement prototype accessors methods\nmodule.exports = require('./_library')|| !require('./_fails')(function(){\n  var K = Math.random();\n  // In FF throws only define methods\n  __defineSetter__.call(null, K, function(){ /* empty */});\n  delete require('./_global')[K];\n});\n},{\"./_fails\":156,\"./_global\":160,\"./_library\":180}],192:[function(require,module,exports){\narguments[4][77][0].apply(exports,arguments)\n},{\"./_descriptors\":150,\"./_has\":161,\"./_ie8-dom-define\":164,\"./_object-pie\":199,\"./_property-desc\":207,\"./_to-iobject\":229,\"./_to-primitive\":232,\"dup\":77}],193:[function(require,module,exports){\narguments[4][78][0].apply(exports,arguments)\n},{\"./_object-gopn\":194,\"./_to-iobject\":229,\"dup\":78}],194:[function(require,module,exports){\narguments[4][79][0].apply(exports,arguments)\n},{\"./_enum-bug-keys\":152,\"./_object-keys-internal\":197,\"dup\":79}],195:[function(require,module,exports){\narguments[4][80][0].apply(exports,arguments)\n},{\"dup\":80}],196:[function(require,module,exports){\narguments[4][81][0].apply(exports,arguments)\n},{\"./_has\":161,\"./_shared-key\":215,\"./_to-object\":231,\"dup\":81}],197:[function(require,module,exports){\narguments[4][82][0].apply(exports,arguments)\n},{\"./_array-includes\":133,\"./_has\":161,\"./_shared-key\":215,\"./_to-iobject\":229,\"dup\":82}],198:[function(require,module,exports){\narguments[4][83][0].apply(exports,arguments)\n},{\"./_enum-bug-keys\":152,\"./_object-keys-internal\":197,\"dup\":83}],199:[function(require,module,exports){\narguments[4][84][0].apply(exports,arguments)\n},{\"dup\":84}],200:[function(require,module,exports){\narguments[4][85][0].apply(exports,arguments)\n},{\"./_core\":145,\"./_export\":154,\"./_fails\":156,\"dup\":85}],201:[function(require,module,exports){\nvar getKeys   = require('./_object-keys')\n  , toIObject = require('./_to-iobject')\n  , isEnum    = require('./_object-pie').f;\nmodule.exports = function(isEntries){\n  return function(it){\n    var O      = toIObject(it)\n      , keys   = getKeys(O)\n      , length = keys.length\n      , i      = 0\n      , result = []\n      , key;\n    while(length > i)if(isEnum.call(O, key = keys[i++])){\n      result.push(isEntries ? [key, O[key]] : O[key]);\n    } return result;\n  };\n};\n},{\"./_object-keys\":198,\"./_object-pie\":199,\"./_to-iobject\":229}],202:[function(require,module,exports){\n// all object keys, includes non-enumerable and symbols\nvar gOPN     = require('./_object-gopn')\n  , gOPS     = require('./_object-gops')\n  , anObject = require('./_an-object')\n  , Reflect  = require('./_global').Reflect;\nmodule.exports = Reflect && Reflect.ownKeys || function ownKeys(it){\n  var keys       = gOPN.f(anObject(it))\n    , getSymbols = gOPS.f;\n  return getSymbols ? keys.concat(getSymbols(it)) : keys;\n};\n},{\"./_an-object\":129,\"./_global\":160,\"./_object-gopn\":194,\"./_object-gops\":195}],203:[function(require,module,exports){\nvar $parseFloat = require('./_global').parseFloat\n  , $trim       = require('./_string-trim').trim;\n\nmodule.exports = 1 / $parseFloat(require('./_string-ws') + '-0') !== -Infinity ? function parseFloat(str){\n  var string = $trim(String(str), 3)\n    , result = $parseFloat(string);\n  return result === 0 && string.charAt(0) == '-' ? -0 : result;\n} : $parseFloat;\n},{\"./_global\":160,\"./_string-trim\":224,\"./_string-ws\":225}],204:[function(require,module,exports){\nvar $parseInt = require('./_global').parseInt\n  , $trim     = require('./_string-trim').trim\n  , ws        = require('./_string-ws')\n  , hex       = /^[\\-+]?0[xX]/;\n\nmodule.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix){\n  var string = $trim(String(str), 3);\n  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));\n} : $parseInt;\n},{\"./_global\":160,\"./_string-trim\":224,\"./_string-ws\":225}],205:[function(require,module,exports){\n'use strict';\nvar path      = require('./_path')\n  , invoke    = require('./_invoke')\n  , aFunction = require('./_a-function');\nmodule.exports = function(/* ...pargs */){\n  var fn     = aFunction(this)\n    , length = arguments.length\n    , pargs  = Array(length)\n    , i      = 0\n    , _      = path._\n    , holder = false;\n  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;\n  return function(/* ...args */){\n    var that = this\n      , aLen = arguments.length\n      , j = 0, k = 0, args;\n    if(!holder && !aLen)return invoke(fn, pargs, that);\n    args = pargs.slice();\n    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = arguments[k++];\n    while(aLen > k)args.push(arguments[k++]);\n    return invoke(fn, args, that);\n  };\n};\n},{\"./_a-function\":125,\"./_invoke\":166,\"./_path\":206}],206:[function(require,module,exports){\nmodule.exports = require('./_global');\n},{\"./_global\":160}],207:[function(require,module,exports){\narguments[4][86][0].apply(exports,arguments)\n},{\"dup\":86}],208:[function(require,module,exports){\nvar redefine = require('./_redefine');\nmodule.exports = function(target, src, safe){\n  for(var key in src)redefine(target, key, src[key], safe);\n  return target;\n};\n},{\"./_redefine\":209}],209:[function(require,module,exports){\nvar global    = require('./_global')\n  , hide      = require('./_hide')\n  , has       = require('./_has')\n  , SRC       = require('./_uid')('src')\n  , TO_STRING = 'toString'\n  , $toString = Function[TO_STRING]\n  , TPL       = ('' + $toString).split(TO_STRING);\n\nrequire('./_core').inspectSource = function(it){\n  return $toString.call(it);\n};\n\n(module.exports = function(O, key, val, safe){\n  var isFunction = typeof val == 'function';\n  if(isFunction)has(val, 'name') || hide(val, 'name', key);\n  if(O[key] === val)return;\n  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));\n  if(O === global){\n    O[key] = val;\n  } else {\n    if(!safe){\n      delete O[key];\n      hide(O, key, val);\n    } else {\n      if(O[key])O[key] = val;\n      else hide(O, key, val);\n    }\n  }\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, TO_STRING, function toString(){\n  return typeof this == 'function' && this[SRC] || $toString.call(this);\n});\n},{\"./_core\":145,\"./_global\":160,\"./_has\":161,\"./_hide\":162,\"./_uid\":236}],210:[function(require,module,exports){\nmodule.exports = function(regExp, replace){\n  var replacer = replace === Object(replace) ? function(part){\n    return replace[part];\n  } : replace;\n  return function(it){\n    return String(it).replace(regExp, replacer);\n  };\n};\n},{}],211:[function(require,module,exports){\n// 7.2.9 SameValue(x, y)\nmodule.exports = Object.is || function is(x, y){\n  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;\n};\n},{}],212:[function(require,module,exports){\narguments[4][89][0].apply(exports,arguments)\n},{\"./_an-object\":129,\"./_ctx\":147,\"./_is-object\":171,\"./_object-gopd\":192,\"dup\":89}],213:[function(require,module,exports){\n'use strict';\nvar global      = require('./_global')\n  , dP          = require('./_object-dp')\n  , DESCRIPTORS = require('./_descriptors')\n  , SPECIES     = require('./_wks')('species');\n\nmodule.exports = function(KEY){\n  var C = global[KEY];\n  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {\n    configurable: true,\n    get: function(){ return this; }\n  });\n};\n},{\"./_descriptors\":150,\"./_global\":160,\"./_object-dp\":189,\"./_wks\":239}],214:[function(require,module,exports){\narguments[4][91][0].apply(exports,arguments)\n},{\"./_has\":161,\"./_object-dp\":189,\"./_wks\":239,\"dup\":91}],215:[function(require,module,exports){\narguments[4][92][0].apply(exports,arguments)\n},{\"./_shared\":216,\"./_uid\":236,\"dup\":92}],216:[function(require,module,exports){\narguments[4][93][0].apply(exports,arguments)\n},{\"./_global\":160,\"dup\":93}],217:[function(require,module,exports){\narguments[4][94][0].apply(exports,arguments)\n},{\"./_a-function\":125,\"./_an-object\":129,\"./_wks\":239,\"dup\":94}],218:[function(require,module,exports){\nvar fails = require('./_fails');\n\nmodule.exports = function(method, arg){\n  return !!method && fails(function(){\n    arg ? method.call(null, function(){}, 1) : method.call(null);\n  });\n};\n},{\"./_fails\":156}],219:[function(require,module,exports){\narguments[4][95][0].apply(exports,arguments)\n},{\"./_defined\":149,\"./_to-integer\":228,\"dup\":95}],220:[function(require,module,exports){\n// helper for String#{startsWith, endsWith, includes}\nvar isRegExp = require('./_is-regexp')\n  , defined  = require('./_defined');\n\nmodule.exports = function(that, searchString, NAME){\n  if(isRegExp(searchString))throw TypeError('String#' + NAME + \" doesn't accept regex!\");\n  return String(defined(that));\n};\n},{\"./_defined\":149,\"./_is-regexp\":172}],221:[function(require,module,exports){\nvar $export = require('./_export')\n  , fails   = require('./_fails')\n  , defined = require('./_defined')\n  , quot    = /\"/g;\n// B.2.3.2.1 CreateHTML(string, tag, attribute, value)\nvar createHTML = function(string, tag, attribute, value) {\n  var S  = String(defined(string))\n    , p1 = '<' + tag;\n  if(attribute !== '')p1 += ' ' + attribute + '=\"' + String(value).replace(quot, '&quot;') + '\"';\n  return p1 + '>' + S + '</' + tag + '>';\n};\nmodule.exports = function(NAME, exec){\n  var O = {};\n  O[NAME] = exec(createHTML);\n  $export($export.P + $export.F * fails(function(){\n    var test = ''[NAME]('\"');\n    return test !== test.toLowerCase() || test.split('\"').length > 3;\n  }), 'String', O);\n};\n},{\"./_defined\":149,\"./_export\":154,\"./_fails\":156}],222:[function(require,module,exports){\n// https://github.com/tc39/proposal-string-pad-start-end\nvar toLength = require('./_to-length')\n  , repeat   = require('./_string-repeat')\n  , defined  = require('./_defined');\n\nmodule.exports = function(that, maxLength, fillString, left){\n  var S            = String(defined(that))\n    , stringLength = S.length\n    , fillStr      = fillString === undefined ? ' ' : String(fillString)\n    , intMaxLength = toLength(maxLength);\n  if(intMaxLength <= stringLength || fillStr == '')return S;\n  var fillLen = intMaxLength - stringLength\n    , stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));\n  if(stringFiller.length > fillLen)stringFiller = stringFiller.slice(0, fillLen);\n  return left ? stringFiller + S : S + stringFiller;\n};\n\n},{\"./_defined\":149,\"./_string-repeat\":223,\"./_to-length\":230}],223:[function(require,module,exports){\n'use strict';\nvar toInteger = require('./_to-integer')\n  , defined   = require('./_defined');\n\nmodule.exports = function repeat(count){\n  var str = String(defined(this))\n    , res = ''\n    , n   = toInteger(count);\n  if(n < 0 || n == Infinity)throw RangeError(\"Count can't be negative\");\n  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;\n  return res;\n};\n},{\"./_defined\":149,\"./_to-integer\":228}],224:[function(require,module,exports){\nvar $export = require('./_export')\n  , defined = require('./_defined')\n  , fails   = require('./_fails')\n  , spaces  = require('./_string-ws')\n  , space   = '[' + spaces + ']'\n  , non     = '\\u200b\\u0085'\n  , ltrim   = RegExp('^' + space + space + '*')\n  , rtrim   = RegExp(space + space + '*$');\n\nvar exporter = function(KEY, exec, ALIAS){\n  var exp   = {};\n  var FORCE = fails(function(){\n    return !!spaces[KEY]() || non[KEY]() != non;\n  });\n  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];\n  if(ALIAS)exp[ALIAS] = fn;\n  $export($export.P + $export.F * FORCE, 'String', exp);\n};\n\n// 1 -> String#trimLeft\n// 2 -> String#trimRight\n// 3 -> String#trim\nvar trim = exporter.trim = function(string, TYPE){\n  string = String(defined(string));\n  if(TYPE & 1)string = string.replace(ltrim, '');\n  if(TYPE & 2)string = string.replace(rtrim, '');\n  return string;\n};\n\nmodule.exports = exporter;\n},{\"./_defined\":149,\"./_export\":154,\"./_fails\":156,\"./_string-ws\":225}],225:[function(require,module,exports){\nmodule.exports = '\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003' +\n  '\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n},{}],226:[function(require,module,exports){\narguments[4][96][0].apply(exports,arguments)\n},{\"./_cof\":140,\"./_ctx\":147,\"./_dom-create\":151,\"./_global\":160,\"./_html\":163,\"./_invoke\":166,\"dup\":96}],227:[function(require,module,exports){\narguments[4][97][0].apply(exports,arguments)\n},{\"./_to-integer\":228,\"dup\":97}],228:[function(require,module,exports){\narguments[4][98][0].apply(exports,arguments)\n},{\"dup\":98}],229:[function(require,module,exports){\narguments[4][99][0].apply(exports,arguments)\n},{\"./_defined\":149,\"./_iobject\":167,\"dup\":99}],230:[function(require,module,exports){\narguments[4][100][0].apply(exports,arguments)\n},{\"./_to-integer\":228,\"dup\":100}],231:[function(require,module,exports){\narguments[4][101][0].apply(exports,arguments)\n},{\"./_defined\":149,\"dup\":101}],232:[function(require,module,exports){\narguments[4][102][0].apply(exports,arguments)\n},{\"./_is-object\":171,\"dup\":102}],233:[function(require,module,exports){\n'use strict';\nif(require('./_descriptors')){\n  var LIBRARY             = require('./_library')\n    , global              = require('./_global')\n    , fails               = require('./_fails')\n    , $export             = require('./_export')\n    , $typed              = require('./_typed')\n    , $buffer             = require('./_typed-buffer')\n    , ctx                 = require('./_ctx')\n    , anInstance          = require('./_an-instance')\n    , propertyDesc        = require('./_property-desc')\n    , hide                = require('./_hide')\n    , redefineAll         = require('./_redefine-all')\n    , toInteger           = require('./_to-integer')\n    , toLength            = require('./_to-length')\n    , toIndex             = require('./_to-index')\n    , toPrimitive         = require('./_to-primitive')\n    , has                 = require('./_has')\n    , same                = require('./_same-value')\n    , classof             = require('./_classof')\n    , isObject            = require('./_is-object')\n    , toObject            = require('./_to-object')\n    , isArrayIter         = require('./_is-array-iter')\n    , create              = require('./_object-create')\n    , getPrototypeOf      = require('./_object-gpo')\n    , gOPN                = require('./_object-gopn').f\n    , getIterFn           = require('./core.get-iterator-method')\n    , uid                 = require('./_uid')\n    , wks                 = require('./_wks')\n    , createArrayMethod   = require('./_array-methods')\n    , createArrayIncludes = require('./_array-includes')\n    , speciesConstructor  = require('./_species-constructor')\n    , ArrayIterators      = require('./es6.array.iterator')\n    , Iterators           = require('./_iterators')\n    , $iterDetect         = require('./_iter-detect')\n    , setSpecies          = require('./_set-species')\n    , arrayFill           = require('./_array-fill')\n    , arrayCopyWithin     = require('./_array-copy-within')\n    , $DP                 = require('./_object-dp')\n    , $GOPD               = require('./_object-gopd')\n    , dP                  = $DP.f\n    , gOPD                = $GOPD.f\n    , RangeError          = global.RangeError\n    , TypeError           = global.TypeError\n    , Uint8Array          = global.Uint8Array\n    , ARRAY_BUFFER        = 'ArrayBuffer'\n    , SHARED_BUFFER       = 'Shared' + ARRAY_BUFFER\n    , BYTES_PER_ELEMENT   = 'BYTES_PER_ELEMENT'\n    , PROTOTYPE           = 'prototype'\n    , ArrayProto          = Array[PROTOTYPE]\n    , $ArrayBuffer        = $buffer.ArrayBuffer\n    , $DataView           = $buffer.DataView\n    , arrayForEach        = createArrayMethod(0)\n    , arrayFilter         = createArrayMethod(2)\n    , arraySome           = createArrayMethod(3)\n    , arrayEvery          = createArrayMethod(4)\n    , arrayFind           = createArrayMethod(5)\n    , arrayFindIndex      = createArrayMethod(6)\n    , arrayIncludes       = createArrayIncludes(true)\n    , arrayIndexOf        = createArrayIncludes(false)\n    , arrayValues         = ArrayIterators.values\n    , arrayKeys           = ArrayIterators.keys\n    , arrayEntries        = ArrayIterators.entries\n    , arrayLastIndexOf    = ArrayProto.lastIndexOf\n    , arrayReduce         = ArrayProto.reduce\n    , arrayReduceRight    = ArrayProto.reduceRight\n    , arrayJoin           = ArrayProto.join\n    , arraySort           = ArrayProto.sort\n    , arraySlice          = ArrayProto.slice\n    , arrayToString       = ArrayProto.toString\n    , arrayToLocaleString = ArrayProto.toLocaleString\n    , ITERATOR            = wks('iterator')\n    , TAG                 = wks('toStringTag')\n    , TYPED_CONSTRUCTOR   = uid('typed_constructor')\n    , DEF_CONSTRUCTOR     = uid('def_constructor')\n    , ALL_CONSTRUCTORS    = $typed.CONSTR\n    , TYPED_ARRAY         = $typed.TYPED\n    , VIEW                = $typed.VIEW\n    , WRONG_LENGTH        = 'Wrong length!';\n\n  var $map = createArrayMethod(1, function(O, length){\n    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);\n  });\n\n  var LITTLE_ENDIAN = fails(function(){\n    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;\n  });\n\n  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function(){\n    new Uint8Array(1).set({});\n  });\n\n  var strictToLength = function(it, SAME){\n    if(it === undefined)throw TypeError(WRONG_LENGTH);\n    var number = +it\n      , length = toLength(it);\n    if(SAME && !same(number, length))throw RangeError(WRONG_LENGTH);\n    return length;\n  };\n\n  var toOffset = function(it, BYTES){\n    var offset = toInteger(it);\n    if(offset < 0 || offset % BYTES)throw RangeError('Wrong offset!');\n    return offset;\n  };\n\n  var validate = function(it){\n    if(isObject(it) && TYPED_ARRAY in it)return it;\n    throw TypeError(it + ' is not a typed array!');\n  };\n\n  var allocate = function(C, length){\n    if(!(isObject(C) && TYPED_CONSTRUCTOR in C)){\n      throw TypeError('It is not a typed array constructor!');\n    } return new C(length);\n  };\n\n  var speciesFromList = function(O, list){\n    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);\n  };\n\n  var fromList = function(C, list){\n    var index  = 0\n      , length = list.length\n      , result = allocate(C, length);\n    while(length > index)result[index] = list[index++];\n    return result;\n  };\n\n  var addGetter = function(it, key, internal){\n    dP(it, key, {get: function(){ return this._d[internal]; }});\n  };\n\n  var $from = function from(source /*, mapfn, thisArg */){\n    var O       = toObject(source)\n      , aLen    = arguments.length\n      , mapfn   = aLen > 1 ? arguments[1] : undefined\n      , mapping = mapfn !== undefined\n      , iterFn  = getIterFn(O)\n      , i, length, values, result, step, iterator;\n    if(iterFn != undefined && !isArrayIter(iterFn)){\n      for(iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++){\n        values.push(step.value);\n      } O = values;\n    }\n    if(mapping && aLen > 2)mapfn = ctx(mapfn, arguments[2], 2);\n    for(i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++){\n      result[i] = mapping ? mapfn(O[i], i) : O[i];\n    }\n    return result;\n  };\n\n  var $of = function of(/*...items*/){\n    var index  = 0\n      , length = arguments.length\n      , result = allocate(this, length);\n    while(length > index)result[index] = arguments[index++];\n    return result;\n  };\n\n  // iOS Safari 6.x fails here\n  var TO_LOCALE_BUG = !!Uint8Array && fails(function(){ arrayToLocaleString.call(new Uint8Array(1)); });\n\n  var $toLocaleString = function toLocaleString(){\n    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);\n  };\n\n  var proto = {\n    copyWithin: function copyWithin(target, start /*, end */){\n      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    every: function every(callbackfn /*, thisArg */){\n      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    fill: function fill(value /*, start, end */){ // eslint-disable-line no-unused-vars\n      return arrayFill.apply(validate(this), arguments);\n    },\n    filter: function filter(callbackfn /*, thisArg */){\n      return speciesFromList(this, arrayFilter(validate(this), callbackfn,\n        arguments.length > 1 ? arguments[1] : undefined));\n    },\n    find: function find(predicate /*, thisArg */){\n      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    findIndex: function findIndex(predicate /*, thisArg */){\n      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    forEach: function forEach(callbackfn /*, thisArg */){\n      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    indexOf: function indexOf(searchElement /*, fromIndex */){\n      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    includes: function includes(searchElement /*, fromIndex */){\n      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    join: function join(separator){ // eslint-disable-line no-unused-vars\n      return arrayJoin.apply(validate(this), arguments);\n    },\n    lastIndexOf: function lastIndexOf(searchElement /*, fromIndex */){ // eslint-disable-line no-unused-vars\n      return arrayLastIndexOf.apply(validate(this), arguments);\n    },\n    map: function map(mapfn /*, thisArg */){\n      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    reduce: function reduce(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars\n      return arrayReduce.apply(validate(this), arguments);\n    },\n    reduceRight: function reduceRight(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars\n      return arrayReduceRight.apply(validate(this), arguments);\n    },\n    reverse: function reverse(){\n      var that   = this\n        , length = validate(that).length\n        , middle = Math.floor(length / 2)\n        , index  = 0\n        , value;\n      while(index < middle){\n        value         = that[index];\n        that[index++] = that[--length];\n        that[length]  = value;\n      } return that;\n    },\n    some: function some(callbackfn /*, thisArg */){\n      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    sort: function sort(comparefn){\n      return arraySort.call(validate(this), comparefn);\n    },\n    subarray: function subarray(begin, end){\n      var O      = validate(this)\n        , length = O.length\n        , $begin = toIndex(begin, length);\n      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(\n        O.buffer,\n        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,\n        toLength((end === undefined ? length : toIndex(end, length)) - $begin)\n      );\n    }\n  };\n\n  var $slice = function slice(start, end){\n    return speciesFromList(this, arraySlice.call(validate(this), start, end));\n  };\n\n  var $set = function set(arrayLike /*, offset */){\n    validate(this);\n    var offset = toOffset(arguments[1], 1)\n      , length = this.length\n      , src    = toObject(arrayLike)\n      , len    = toLength(src.length)\n      , index  = 0;\n    if(len + offset > length)throw RangeError(WRONG_LENGTH);\n    while(index < len)this[offset + index] = src[index++];\n  };\n\n  var $iterators = {\n    entries: function entries(){\n      return arrayEntries.call(validate(this));\n    },\n    keys: function keys(){\n      return arrayKeys.call(validate(this));\n    },\n    values: function values(){\n      return arrayValues.call(validate(this));\n    }\n  };\n\n  var isTAIndex = function(target, key){\n    return isObject(target)\n      && target[TYPED_ARRAY]\n      && typeof key != 'symbol'\n      && key in target\n      && String(+key) == String(key);\n  };\n  var $getDesc = function getOwnPropertyDescriptor(target, key){\n    return isTAIndex(target, key = toPrimitive(key, true))\n      ? propertyDesc(2, target[key])\n      : gOPD(target, key);\n  };\n  var $setDesc = function defineProperty(target, key, desc){\n    if(isTAIndex(target, key = toPrimitive(key, true))\n      && isObject(desc)\n      && has(desc, 'value')\n      && !has(desc, 'get')\n      && !has(desc, 'set')\n      // TODO: add validation descriptor w/o calling accessors\n      && !desc.configurable\n      && (!has(desc, 'writable') || desc.writable)\n      && (!has(desc, 'enumerable') || desc.enumerable)\n    ){\n      target[key] = desc.value;\n      return target;\n    } else return dP(target, key, desc);\n  };\n\n  if(!ALL_CONSTRUCTORS){\n    $GOPD.f = $getDesc;\n    $DP.f   = $setDesc;\n  }\n\n  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {\n    getOwnPropertyDescriptor: $getDesc,\n    defineProperty:           $setDesc\n  });\n\n  if(fails(function(){ arrayToString.call({}); })){\n    arrayToString = arrayToLocaleString = function toString(){\n      return arrayJoin.call(this);\n    }\n  }\n\n  var $TypedArrayPrototype$ = redefineAll({}, proto);\n  redefineAll($TypedArrayPrototype$, $iterators);\n  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);\n  redefineAll($TypedArrayPrototype$, {\n    slice:          $slice,\n    set:            $set,\n    constructor:    function(){ /* noop */ },\n    toString:       arrayToString,\n    toLocaleString: $toLocaleString\n  });\n  addGetter($TypedArrayPrototype$, 'buffer', 'b');\n  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');\n  addGetter($TypedArrayPrototype$, 'byteLength', 'l');\n  addGetter($TypedArrayPrototype$, 'length', 'e');\n  dP($TypedArrayPrototype$, TAG, {\n    get: function(){ return this[TYPED_ARRAY]; }\n  });\n\n  module.exports = function(KEY, BYTES, wrapper, CLAMPED){\n    CLAMPED = !!CLAMPED;\n    var NAME       = KEY + (CLAMPED ? 'Clamped' : '') + 'Array'\n      , ISNT_UINT8 = NAME != 'Uint8Array'\n      , GETTER     = 'get' + KEY\n      , SETTER     = 'set' + KEY\n      , TypedArray = global[NAME]\n      , Base       = TypedArray || {}\n      , TAC        = TypedArray && getPrototypeOf(TypedArray)\n      , FORCED     = !TypedArray || !$typed.ABV\n      , O          = {}\n      , TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];\n    var getter = function(that, index){\n      var data = that._d;\n      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);\n    };\n    var setter = function(that, index, value){\n      var data = that._d;\n      if(CLAMPED)value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;\n      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);\n    };\n    var addElement = function(that, index){\n      dP(that, index, {\n        get: function(){\n          return getter(this, index);\n        },\n        set: function(value){\n          return setter(this, index, value);\n        },\n        enumerable: true\n      });\n    };\n    if(FORCED){\n      TypedArray = wrapper(function(that, data, $offset, $length){\n        anInstance(that, TypedArray, NAME, '_d');\n        var index  = 0\n          , offset = 0\n          , buffer, byteLength, length, klass;\n        if(!isObject(data)){\n          length     = strictToLength(data, true)\n          byteLength = length * BYTES;\n          buffer     = new $ArrayBuffer(byteLength);\n        } else if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){\n          buffer = data;\n          offset = toOffset($offset, BYTES);\n          var $len = data.byteLength;\n          if($length === undefined){\n            if($len % BYTES)throw RangeError(WRONG_LENGTH);\n            byteLength = $len - offset;\n            if(byteLength < 0)throw RangeError(WRONG_LENGTH);\n          } else {\n            byteLength = toLength($length) * BYTES;\n            if(byteLength + offset > $len)throw RangeError(WRONG_LENGTH);\n          }\n          length = byteLength / BYTES;\n        } else if(TYPED_ARRAY in data){\n          return fromList(TypedArray, data);\n        } else {\n          return $from.call(TypedArray, data);\n        }\n        hide(that, '_d', {\n          b: buffer,\n          o: offset,\n          l: byteLength,\n          e: length,\n          v: new $DataView(buffer)\n        });\n        while(index < length)addElement(that, index++);\n      });\n      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);\n      hide(TypedArrayPrototype, 'constructor', TypedArray);\n    } else if(!$iterDetect(function(iter){\n      // V8 works with iterators, but fails in many other cases\n      // https://code.google.com/p/v8/issues/detail?id=4552\n      new TypedArray(null); // eslint-disable-line no-new\n      new TypedArray(iter); // eslint-disable-line no-new\n    }, true)){\n      TypedArray = wrapper(function(that, data, $offset, $length){\n        anInstance(that, TypedArray, NAME);\n        var klass;\n        // `ws` module bug, temporarily remove validation length for Uint8Array\n        // https://github.com/websockets/ws/pull/645\n        if(!isObject(data))return new Base(strictToLength(data, ISNT_UINT8));\n        if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){\n          return $length !== undefined\n            ? new Base(data, toOffset($offset, BYTES), $length)\n            : $offset !== undefined\n              ? new Base(data, toOffset($offset, BYTES))\n              : new Base(data);\n        }\n        if(TYPED_ARRAY in data)return fromList(TypedArray, data);\n        return $from.call(TypedArray, data);\n      });\n      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function(key){\n        if(!(key in TypedArray))hide(TypedArray, key, Base[key]);\n      });\n      TypedArray[PROTOTYPE] = TypedArrayPrototype;\n      if(!LIBRARY)TypedArrayPrototype.constructor = TypedArray;\n    }\n    var $nativeIterator   = TypedArrayPrototype[ITERATOR]\n      , CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined)\n      , $iterator         = $iterators.values;\n    hide(TypedArray, TYPED_CONSTRUCTOR, true);\n    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);\n    hide(TypedArrayPrototype, VIEW, true);\n    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);\n\n    if(CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)){\n      dP(TypedArrayPrototype, TAG, {\n        get: function(){ return NAME; }\n      });\n    }\n\n    O[NAME] = TypedArray;\n\n    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);\n\n    $export($export.S, NAME, {\n      BYTES_PER_ELEMENT: BYTES,\n      from: $from,\n      of: $of\n    });\n\n    if(!(BYTES_PER_ELEMENT in TypedArrayPrototype))hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);\n\n    $export($export.P, NAME, proto);\n\n    setSpecies(NAME);\n\n    $export($export.P + $export.F * FORCED_SET, NAME, {set: $set});\n\n    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);\n\n    $export($export.P + $export.F * (TypedArrayPrototype.toString != arrayToString), NAME, {toString: arrayToString});\n\n    $export($export.P + $export.F * fails(function(){\n      new TypedArray(1).slice();\n    }), NAME, {slice: $slice});\n\n    $export($export.P + $export.F * (fails(function(){\n      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString()\n    }) || !fails(function(){\n      TypedArrayPrototype.toLocaleString.call([1, 2]);\n    })), NAME, {toLocaleString: $toLocaleString});\n\n    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;\n    if(!LIBRARY && !CORRECT_ITER_NAME)hide(TypedArrayPrototype, ITERATOR, $iterator);\n  };\n} else module.exports = function(){ /* empty */ };\n},{\"./_an-instance\":128,\"./_array-copy-within\":130,\"./_array-fill\":131,\"./_array-includes\":133,\"./_array-methods\":134,\"./_classof\":139,\"./_ctx\":147,\"./_descriptors\":150,\"./_export\":154,\"./_fails\":156,\"./_global\":160,\"./_has\":161,\"./_hide\":162,\"./_is-array-iter\":168,\"./_is-object\":171,\"./_iter-detect\":176,\"./_iterators\":178,\"./_library\":180,\"./_object-create\":188,\"./_object-dp\":189,\"./_object-gopd\":192,\"./_object-gopn\":194,\"./_object-gpo\":196,\"./_property-desc\":207,\"./_redefine-all\":208,\"./_same-value\":211,\"./_set-species\":213,\"./_species-constructor\":217,\"./_to-index\":227,\"./_to-integer\":228,\"./_to-length\":230,\"./_to-object\":231,\"./_to-primitive\":232,\"./_typed\":235,\"./_typed-buffer\":234,\"./_uid\":236,\"./_wks\":239,\"./core.get-iterator-method\":240,\"./es6.array.iterator\":252}],234:[function(require,module,exports){\n'use strict';\nvar global         = require('./_global')\n  , DESCRIPTORS    = require('./_descriptors')\n  , LIBRARY        = require('./_library')\n  , $typed         = require('./_typed')\n  , hide           = require('./_hide')\n  , redefineAll    = require('./_redefine-all')\n  , fails          = require('./_fails')\n  , anInstance     = require('./_an-instance')\n  , toInteger      = require('./_to-integer')\n  , toLength       = require('./_to-length')\n  , gOPN           = require('./_object-gopn').f\n  , dP             = require('./_object-dp').f\n  , arrayFill      = require('./_array-fill')\n  , setToStringTag = require('./_set-to-string-tag')\n  , ARRAY_BUFFER   = 'ArrayBuffer'\n  , DATA_VIEW      = 'DataView'\n  , PROTOTYPE      = 'prototype'\n  , WRONG_LENGTH   = 'Wrong length!'\n  , WRONG_INDEX    = 'Wrong index!'\n  , $ArrayBuffer   = global[ARRAY_BUFFER]\n  , $DataView      = global[DATA_VIEW]\n  , Math           = global.Math\n  , RangeError     = global.RangeError\n  , Infinity       = global.Infinity\n  , BaseBuffer     = $ArrayBuffer\n  , abs            = Math.abs\n  , pow            = Math.pow\n  , floor          = Math.floor\n  , log            = Math.log\n  , LN2            = Math.LN2\n  , BUFFER         = 'buffer'\n  , BYTE_LENGTH    = 'byteLength'\n  , BYTE_OFFSET    = 'byteOffset'\n  , $BUFFER        = DESCRIPTORS ? '_b' : BUFFER\n  , $LENGTH        = DESCRIPTORS ? '_l' : BYTE_LENGTH\n  , $OFFSET        = DESCRIPTORS ? '_o' : BYTE_OFFSET;\n\n// IEEE754 conversions based on https://github.com/feross/ieee754\nvar packIEEE754 = function(value, mLen, nBytes){\n  var buffer = Array(nBytes)\n    , eLen   = nBytes * 8 - mLen - 1\n    , eMax   = (1 << eLen) - 1\n    , eBias  = eMax >> 1\n    , rt     = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0\n    , i      = 0\n    , s      = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0\n    , e, m, c;\n  value = abs(value)\n  if(value != value || value === Infinity){\n    m = value != value ? 1 : 0;\n    e = eMax;\n  } else {\n    e = floor(log(value) / LN2);\n    if(value * (c = pow(2, -e)) < 1){\n      e--;\n      c *= 2;\n    }\n    if(e + eBias >= 1){\n      value += rt / c;\n    } else {\n      value += rt * pow(2, 1 - eBias);\n    }\n    if(value * c >= 2){\n      e++;\n      c /= 2;\n    }\n    if(e + eBias >= eMax){\n      m = 0;\n      e = eMax;\n    } else if(e + eBias >= 1){\n      m = (value * c - 1) * pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * pow(2, eBias - 1) * pow(2, mLen);\n      e = 0;\n    }\n  }\n  for(; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);\n  e = e << mLen | m;\n  eLen += mLen;\n  for(; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);\n  buffer[--i] |= s * 128;\n  return buffer;\n};\nvar unpackIEEE754 = function(buffer, mLen, nBytes){\n  var eLen  = nBytes * 8 - mLen - 1\n    , eMax  = (1 << eLen) - 1\n    , eBias = eMax >> 1\n    , nBits = eLen - 7\n    , i     = nBytes - 1\n    , s     = buffer[i--]\n    , e     = s & 127\n    , m;\n  s >>= 7;\n  for(; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);\n  m = e & (1 << -nBits) - 1;\n  e >>= -nBits;\n  nBits += mLen;\n  for(; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);\n  if(e === 0){\n    e = 1 - eBias;\n  } else if(e === eMax){\n    return m ? NaN : s ? -Infinity : Infinity;\n  } else {\n    m = m + pow(2, mLen);\n    e = e - eBias;\n  } return (s ? -1 : 1) * m * pow(2, e - mLen);\n};\n\nvar unpackI32 = function(bytes){\n  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];\n};\nvar packI8 = function(it){\n  return [it & 0xff];\n};\nvar packI16 = function(it){\n  return [it & 0xff, it >> 8 & 0xff];\n};\nvar packI32 = function(it){\n  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];\n};\nvar packF64 = function(it){\n  return packIEEE754(it, 52, 8);\n};\nvar packF32 = function(it){\n  return packIEEE754(it, 23, 4);\n};\n\nvar addGetter = function(C, key, internal){\n  dP(C[PROTOTYPE], key, {get: function(){ return this[internal]; }});\n};\n\nvar get = function(view, bytes, index, isLittleEndian){\n  var numIndex = +index\n    , intIndex = toInteger(numIndex);\n  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);\n  var store = view[$BUFFER]._b\n    , start = intIndex + view[$OFFSET]\n    , pack  = store.slice(start, start + bytes);\n  return isLittleEndian ? pack : pack.reverse();\n};\nvar set = function(view, bytes, index, conversion, value, isLittleEndian){\n  var numIndex = +index\n    , intIndex = toInteger(numIndex);\n  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);\n  var store = view[$BUFFER]._b\n    , start = intIndex + view[$OFFSET]\n    , pack  = conversion(+value);\n  for(var i = 0; i < bytes; i++)store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];\n};\n\nvar validateArrayBufferArguments = function(that, length){\n  anInstance(that, $ArrayBuffer, ARRAY_BUFFER);\n  var numberLength = +length\n    , byteLength   = toLength(numberLength);\n  if(numberLength != byteLength)throw RangeError(WRONG_LENGTH);\n  return byteLength;\n};\n\nif(!$typed.ABV){\n  $ArrayBuffer = function ArrayBuffer(length){\n    var byteLength = validateArrayBufferArguments(this, length);\n    this._b       = arrayFill.call(Array(byteLength), 0);\n    this[$LENGTH] = byteLength;\n  };\n\n  $DataView = function DataView(buffer, byteOffset, byteLength){\n    anInstance(this, $DataView, DATA_VIEW);\n    anInstance(buffer, $ArrayBuffer, DATA_VIEW);\n    var bufferLength = buffer[$LENGTH]\n      , offset       = toInteger(byteOffset);\n    if(offset < 0 || offset > bufferLength)throw RangeError('Wrong offset!');\n    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);\n    if(offset + byteLength > bufferLength)throw RangeError(WRONG_LENGTH);\n    this[$BUFFER] = buffer;\n    this[$OFFSET] = offset;\n    this[$LENGTH] = byteLength;\n  };\n\n  if(DESCRIPTORS){\n    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');\n    addGetter($DataView, BUFFER, '_b');\n    addGetter($DataView, BYTE_LENGTH, '_l');\n    addGetter($DataView, BYTE_OFFSET, '_o');\n  }\n\n  redefineAll($DataView[PROTOTYPE], {\n    getInt8: function getInt8(byteOffset){\n      return get(this, 1, byteOffset)[0] << 24 >> 24;\n    },\n    getUint8: function getUint8(byteOffset){\n      return get(this, 1, byteOffset)[0];\n    },\n    getInt16: function getInt16(byteOffset /*, littleEndian */){\n      var bytes = get(this, 2, byteOffset, arguments[1]);\n      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;\n    },\n    getUint16: function getUint16(byteOffset /*, littleEndian */){\n      var bytes = get(this, 2, byteOffset, arguments[1]);\n      return bytes[1] << 8 | bytes[0];\n    },\n    getInt32: function getInt32(byteOffset /*, littleEndian */){\n      return unpackI32(get(this, 4, byteOffset, arguments[1]));\n    },\n    getUint32: function getUint32(byteOffset /*, littleEndian */){\n      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;\n    },\n    getFloat32: function getFloat32(byteOffset /*, littleEndian */){\n      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);\n    },\n    getFloat64: function getFloat64(byteOffset /*, littleEndian */){\n      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);\n    },\n    setInt8: function setInt8(byteOffset, value){\n      set(this, 1, byteOffset, packI8, value);\n    },\n    setUint8: function setUint8(byteOffset, value){\n      set(this, 1, byteOffset, packI8, value);\n    },\n    setInt16: function setInt16(byteOffset, value /*, littleEndian */){\n      set(this, 2, byteOffset, packI16, value, arguments[2]);\n    },\n    setUint16: function setUint16(byteOffset, value /*, littleEndian */){\n      set(this, 2, byteOffset, packI16, value, arguments[2]);\n    },\n    setInt32: function setInt32(byteOffset, value /*, littleEndian */){\n      set(this, 4, byteOffset, packI32, value, arguments[2]);\n    },\n    setUint32: function setUint32(byteOffset, value /*, littleEndian */){\n      set(this, 4, byteOffset, packI32, value, arguments[2]);\n    },\n    setFloat32: function setFloat32(byteOffset, value /*, littleEndian */){\n      set(this, 4, byteOffset, packF32, value, arguments[2]);\n    },\n    setFloat64: function setFloat64(byteOffset, value /*, littleEndian */){\n      set(this, 8, byteOffset, packF64, value, arguments[2]);\n    }\n  });\n} else {\n  if(!fails(function(){\n    new $ArrayBuffer;     // eslint-disable-line no-new\n  }) || !fails(function(){\n    new $ArrayBuffer(.5); // eslint-disable-line no-new\n  })){\n    $ArrayBuffer = function ArrayBuffer(length){\n      return new BaseBuffer(validateArrayBufferArguments(this, length));\n    };\n    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];\n    for(var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j; ){\n      if(!((key = keys[j++]) in $ArrayBuffer))hide($ArrayBuffer, key, BaseBuffer[key]);\n    };\n    if(!LIBRARY)ArrayBufferProto.constructor = $ArrayBuffer;\n  }\n  // iOS Safari 7.x bug\n  var view = new $DataView(new $ArrayBuffer(2))\n    , $setInt8 = $DataView[PROTOTYPE].setInt8;\n  view.setInt8(0, 2147483648);\n  view.setInt8(1, 2147483649);\n  if(view.getInt8(0) || !view.getInt8(1))redefineAll($DataView[PROTOTYPE], {\n    setInt8: function setInt8(byteOffset, value){\n      $setInt8.call(this, byteOffset, value << 24 >> 24);\n    },\n    setUint8: function setUint8(byteOffset, value){\n      $setInt8.call(this, byteOffset, value << 24 >> 24);\n    }\n  }, true);\n}\nsetToStringTag($ArrayBuffer, ARRAY_BUFFER);\nsetToStringTag($DataView, DATA_VIEW);\nhide($DataView[PROTOTYPE], $typed.VIEW, true);\nexports[ARRAY_BUFFER] = $ArrayBuffer;\nexports[DATA_VIEW] = $DataView;\n},{\"./_an-instance\":128,\"./_array-fill\":131,\"./_descriptors\":150,\"./_fails\":156,\"./_global\":160,\"./_hide\":162,\"./_library\":180,\"./_object-dp\":189,\"./_object-gopn\":194,\"./_redefine-all\":208,\"./_set-to-string-tag\":214,\"./_to-integer\":228,\"./_to-length\":230,\"./_typed\":235}],235:[function(require,module,exports){\nvar global = require('./_global')\n  , hide   = require('./_hide')\n  , uid    = require('./_uid')\n  , TYPED  = uid('typed_array')\n  , VIEW   = uid('view')\n  , ABV    = !!(global.ArrayBuffer && global.DataView)\n  , CONSTR = ABV\n  , i = 0, l = 9, Typed;\n\nvar TypedArrayConstructors = (\n  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'\n).split(',');\n\nwhile(i < l){\n  if(Typed = global[TypedArrayConstructors[i++]]){\n    hide(Typed.prototype, TYPED, true);\n    hide(Typed.prototype, VIEW, true);\n  } else CONSTR = false;\n}\n\nmodule.exports = {\n  ABV:    ABV,\n  CONSTR: CONSTR,\n  TYPED:  TYPED,\n  VIEW:   VIEW\n};\n},{\"./_global\":160,\"./_hide\":162,\"./_uid\":236}],236:[function(require,module,exports){\narguments[4][103][0].apply(exports,arguments)\n},{\"dup\":103}],237:[function(require,module,exports){\narguments[4][104][0].apply(exports,arguments)\n},{\"./_core\":145,\"./_global\":160,\"./_library\":180,\"./_object-dp\":189,\"./_wks-ext\":238,\"dup\":104}],238:[function(require,module,exports){\narguments[4][105][0].apply(exports,arguments)\n},{\"./_wks\":239,\"dup\":105}],239:[function(require,module,exports){\narguments[4][106][0].apply(exports,arguments)\n},{\"./_global\":160,\"./_shared\":216,\"./_uid\":236,\"dup\":106}],240:[function(require,module,exports){\narguments[4][107][0].apply(exports,arguments)\n},{\"./_classof\":139,\"./_core\":145,\"./_iterators\":178,\"./_wks\":239,\"dup\":107}],241:[function(require,module,exports){\n// https://github.com/benjamingr/RexExp.escape\nvar $export = require('./_export')\n  , $re     = require('./_replacer')(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n\n$export($export.S, 'RegExp', {escape: function escape(it){ return $re(it); }});\n\n},{\"./_export\":154,\"./_replacer\":210}],242:[function(require,module,exports){\n// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)\nvar $export = require('./_export');\n\n$export($export.P, 'Array', {copyWithin: require('./_array-copy-within')});\n\nrequire('./_add-to-unscopables')('copyWithin');\n},{\"./_add-to-unscopables\":127,\"./_array-copy-within\":130,\"./_export\":154}],243:[function(require,module,exports){\n'use strict';\nvar $export = require('./_export')\n  , $every  = require('./_array-methods')(4);\n\n$export($export.P + $export.F * !require('./_strict-method')([].every, true), 'Array', {\n  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])\n  every: function every(callbackfn /* , thisArg */){\n    return $every(this, callbackfn, arguments[1]);\n  }\n});\n},{\"./_array-methods\":134,\"./_export\":154,\"./_strict-method\":218}],244:[function(require,module,exports){\n// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)\nvar $export = require('./_export');\n\n$export($export.P, 'Array', {fill: require('./_array-fill')});\n\nrequire('./_add-to-unscopables')('fill');\n},{\"./_add-to-unscopables\":127,\"./_array-fill\":131,\"./_export\":154}],245:[function(require,module,exports){\n'use strict';\nvar $export = require('./_export')\n  , $filter = require('./_array-methods')(2);\n\n$export($export.P + $export.F * !require('./_strict-method')([].filter, true), 'Array', {\n  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])\n  filter: function filter(callbackfn /* , thisArg */){\n    return $filter(this, callbackfn, arguments[1]);\n  }\n});\n},{\"./_array-methods\":134,\"./_export\":154,\"./_strict-method\":218}],246:[function(require,module,exports){\n'use strict';\n// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)\nvar $export = require('./_export')\n  , $find   = require('./_array-methods')(6)\n  , KEY     = 'findIndex'\n  , forced  = true;\n// Shouldn't skip holes\nif(KEY in [])Array(1)[KEY](function(){ forced = false; });\n$export($export.P + $export.F * forced, 'Array', {\n  findIndex: function findIndex(callbackfn/*, that = undefined */){\n    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\nrequire('./_add-to-unscopables')(KEY);\n},{\"./_add-to-unscopables\":127,\"./_array-methods\":134,\"./_export\":154}],247:[function(require,module,exports){\n'use strict';\n// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)\nvar $export = require('./_export')\n  , $find   = require('./_array-methods')(5)\n  , KEY     = 'find'\n  , forced  = true;\n// Shouldn't skip holes\nif(KEY in [])Array(1)[KEY](function(){ forced = false; });\n$export($export.P + $export.F * forced, 'Array', {\n  find: function find(callbackfn/*, that = undefined */){\n    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\nrequire('./_add-to-unscopables')(KEY);\n},{\"./_add-to-unscopables\":127,\"./_array-methods\":134,\"./_export\":154}],248:[function(require,module,exports){\n'use strict';\nvar $export  = require('./_export')\n  , $forEach = require('./_array-methods')(0)\n  , STRICT   = require('./_strict-method')([].forEach, true);\n\n$export($export.P + $export.F * !STRICT, 'Array', {\n  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])\n  forEach: function forEach(callbackfn /* , thisArg */){\n    return $forEach(this, callbackfn, arguments[1]);\n  }\n});\n},{\"./_array-methods\":134,\"./_export\":154,\"./_strict-method\":218}],249:[function(require,module,exports){\narguments[4][108][0].apply(exports,arguments)\n},{\"./_create-property\":146,\"./_ctx\":147,\"./_export\":154,\"./_is-array-iter\":168,\"./_iter-call\":173,\"./_iter-detect\":176,\"./_to-length\":230,\"./_to-object\":231,\"./core.get-iterator-method\":240,\"dup\":108}],250:[function(require,module,exports){\n'use strict';\nvar $export       = require('./_export')\n  , $indexOf      = require('./_array-includes')(false)\n  , $native       = [].indexOf\n  , NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;\n\n$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {\n  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])\n  indexOf: function indexOf(searchElement /*, fromIndex = 0 */){\n    return NEGATIVE_ZERO\n      // convert -0 to +0\n      ? $native.apply(this, arguments) || 0\n      : $indexOf(this, searchElement, arguments[1]);\n  }\n});\n},{\"./_array-includes\":133,\"./_export\":154,\"./_strict-method\":218}],251:[function(require,module,exports){\n// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)\nvar $export = require('./_export');\n\n$export($export.S, 'Array', {isArray: require('./_is-array')});\n},{\"./_export\":154,\"./_is-array\":169}],252:[function(require,module,exports){\narguments[4][109][0].apply(exports,arguments)\n},{\"./_add-to-unscopables\":127,\"./_iter-define\":175,\"./_iter-step\":177,\"./_iterators\":178,\"./_to-iobject\":229,\"dup\":109}],253:[function(require,module,exports){\n'use strict';\n// 22.1.3.13 Array.prototype.join(separator)\nvar $export   = require('./_export')\n  , toIObject = require('./_to-iobject')\n  , arrayJoin = [].join;\n\n// fallback for not array-like strings\n$export($export.P + $export.F * (require('./_iobject') != Object || !require('./_strict-method')(arrayJoin)), 'Array', {\n  join: function join(separator){\n    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);\n  }\n});\n},{\"./_export\":154,\"./_iobject\":167,\"./_strict-method\":218,\"./_to-iobject\":229}],254:[function(require,module,exports){\n'use strict';\nvar $export       = require('./_export')\n  , toIObject     = require('./_to-iobject')\n  , toInteger     = require('./_to-integer')\n  , toLength      = require('./_to-length')\n  , $native       = [].lastIndexOf\n  , NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;\n\n$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {\n  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])\n  lastIndexOf: function lastIndexOf(searchElement /*, fromIndex = @[*-1] */){\n    // convert -0 to +0\n    if(NEGATIVE_ZERO)return $native.apply(this, arguments) || 0;\n    var O      = toIObject(this)\n      , length = toLength(O.length)\n      , index  = length - 1;\n    if(arguments.length > 1)index = Math.min(index, toInteger(arguments[1]));\n    if(index < 0)index = length + index;\n    for(;index >= 0; index--)if(index in O)if(O[index] === searchElement)return index || 0;\n    return -1;\n  }\n});\n},{\"./_export\":154,\"./_strict-method\":218,\"./_to-integer\":228,\"./_to-iobject\":229,\"./_to-length\":230}],255:[function(require,module,exports){\n'use strict';\nvar $export = require('./_export')\n  , $map    = require('./_array-methods')(1);\n\n$export($export.P + $export.F * !require('./_strict-method')([].map, true), 'Array', {\n  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])\n  map: function map(callbackfn /* , thisArg */){\n    return $map(this, callbackfn, arguments[1]);\n  }\n});\n},{\"./_array-methods\":134,\"./_export\":154,\"./_strict-method\":218}],256:[function(require,module,exports){\n'use strict';\nvar $export        = require('./_export')\n  , createProperty = require('./_create-property');\n\n// WebKit Array.of isn't generic\n$export($export.S + $export.F * require('./_fails')(function(){\n  function F(){}\n  return !(Array.of.call(F) instanceof F);\n}), 'Array', {\n  // 22.1.2.3 Array.of( ...items)\n  of: function of(/* ...args */){\n    var index  = 0\n      , aLen   = arguments.length\n      , result = new (typeof this == 'function' ? this : Array)(aLen);\n    while(aLen > index)createProperty(result, index, arguments[index++]);\n    result.length = aLen;\n    return result;\n  }\n});\n},{\"./_create-property\":146,\"./_export\":154,\"./_fails\":156}],257:[function(require,module,exports){\n'use strict';\nvar $export = require('./_export')\n  , $reduce = require('./_array-reduce');\n\n$export($export.P + $export.F * !require('./_strict-method')([].reduceRight, true), 'Array', {\n  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])\n  reduceRight: function reduceRight(callbackfn /* , initialValue */){\n    return $reduce(this, callbackfn, arguments.length, arguments[1], true);\n  }\n});\n},{\"./_array-reduce\":135,\"./_export\":154,\"./_strict-method\":218}],258:[function(require,module,exports){\n'use strict';\nvar $export = require('./_export')\n  , $reduce = require('./_array-reduce');\n\n$export($export.P + $export.F * !require('./_strict-method')([].reduce, true), 'Array', {\n  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])\n  reduce: function reduce(callbackfn /* , initialValue */){\n    return $reduce(this, callbackfn, arguments.length, arguments[1], false);\n  }\n});\n},{\"./_array-reduce\":135,\"./_export\":154,\"./_strict-method\":218}],259:[function(require,module,exports){\n'use strict';\nvar $export    = require('./_export')\n  , html       = require('./_html')\n  , cof        = require('./_cof')\n  , toIndex    = require('./_to-index')\n  , toLength   = require('./_to-length')\n  , arraySlice = [].slice;\n\n// fallback for not array-like ES3 strings and DOM objects\n$export($export.P + $export.F * require('./_fails')(function(){\n  if(html)arraySlice.call(html);\n}), 'Array', {\n  slice: function slice(begin, end){\n    var len   = toLength(this.length)\n      , klass = cof(this);\n    end = end === undefined ? len : end;\n    if(klass == 'Array')return arraySlice.call(this, begin, end);\n    var start  = toIndex(begin, len)\n      , upTo   = toIndex(end, len)\n      , size   = toLength(upTo - start)\n      , cloned = Array(size)\n      , i      = 0;\n    for(; i < size; i++)cloned[i] = klass == 'String'\n      ? this.charAt(start + i)\n      : this[start + i];\n    return cloned;\n  }\n});\n},{\"./_cof\":140,\"./_export\":154,\"./_fails\":156,\"./_html\":163,\"./_to-index\":227,\"./_to-length\":230}],260:[function(require,module,exports){\n'use strict';\nvar $export = require('./_export')\n  , $some   = require('./_array-methods')(3);\n\n$export($export.P + $export.F * !require('./_strict-method')([].some, true), 'Array', {\n  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])\n  some: function some(callbackfn /* , thisArg */){\n    return $some(this, callbackfn, arguments[1]);\n  }\n});\n},{\"./_array-methods\":134,\"./_export\":154,\"./_strict-method\":218}],261:[function(require,module,exports){\n'use strict';\nvar $export   = require('./_export')\n  , aFunction = require('./_a-function')\n  , toObject  = require('./_to-object')\n  , fails     = require('./_fails')\n  , $sort     = [].sort\n  , test      = [1, 2, 3];\n\n$export($export.P + $export.F * (fails(function(){\n  // IE8-\n  test.sort(undefined);\n}) || !fails(function(){\n  // V8 bug\n  test.sort(null);\n  // Old WebKit\n}) || !require('./_strict-method')($sort)), 'Array', {\n  // 22.1.3.25 Array.prototype.sort(comparefn)\n  sort: function sort(comparefn){\n    return comparefn === undefined\n      ? $sort.call(toObject(this))\n      : $sort.call(toObject(this), aFunction(comparefn));\n  }\n});\n},{\"./_a-function\":125,\"./_export\":154,\"./_fails\":156,\"./_strict-method\":218,\"./_to-object\":231}],262:[function(require,module,exports){\nrequire('./_set-species')('Array');\n},{\"./_set-species\":213}],263:[function(require,module,exports){\n// 20.3.3.1 / 15.9.4.4 Date.now()\nvar $export = require('./_export');\n\n$export($export.S, 'Date', {now: function(){ return new Date().getTime(); }});\n},{\"./_export\":154}],264:[function(require,module,exports){\n'use strict';\n// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()\nvar $export = require('./_export')\n  , fails   = require('./_fails')\n  , getTime = Date.prototype.getTime;\n\nvar lz = function(num){\n  return num > 9 ? num : '0' + num;\n};\n\n// PhantomJS / old WebKit has a broken implementations\n$export($export.P + $export.F * (fails(function(){\n  return new Date(-5e13 - 1).toISOString() != '0385-07-25T07:06:39.999Z';\n}) || !fails(function(){\n  new Date(NaN).toISOString();\n})), 'Date', {\n  toISOString: function toISOString(){\n    if(!isFinite(getTime.call(this)))throw RangeError('Invalid time value');\n    var d = this\n      , y = d.getUTCFullYear()\n      , m = d.getUTCMilliseconds()\n      , s = y < 0 ? '-' : y > 9999 ? '+' : '';\n    return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +\n      '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +\n      'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +\n      ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';\n  }\n});\n},{\"./_export\":154,\"./_fails\":156}],265:[function(require,module,exports){\n'use strict';\nvar $export     = require('./_export')\n  , toObject    = require('./_to-object')\n  , toPrimitive = require('./_to-primitive');\n\n$export($export.P + $export.F * require('./_fails')(function(){\n  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({toISOString: function(){ return 1; }}) !== 1;\n}), 'Date', {\n  toJSON: function toJSON(key){\n    var O  = toObject(this)\n      , pv = toPrimitive(O);\n    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();\n  }\n});\n},{\"./_export\":154,\"./_fails\":156,\"./_to-object\":231,\"./_to-primitive\":232}],266:[function(require,module,exports){\nvar TO_PRIMITIVE = require('./_wks')('toPrimitive')\n  , proto        = Date.prototype;\n\nif(!(TO_PRIMITIVE in proto))require('./_hide')(proto, TO_PRIMITIVE, require('./_date-to-primitive'));\n},{\"./_date-to-primitive\":148,\"./_hide\":162,\"./_wks\":239}],267:[function(require,module,exports){\nvar DateProto    = Date.prototype\n  , INVALID_DATE = 'Invalid Date'\n  , TO_STRING    = 'toString'\n  , $toString    = DateProto[TO_STRING]\n  , getTime      = DateProto.getTime;\nif(new Date(NaN) + '' != INVALID_DATE){\n  require('./_redefine')(DateProto, TO_STRING, function toString(){\n    var value = getTime.call(this);\n    return value === value ? $toString.call(this) : INVALID_DATE;\n  });\n}\n},{\"./_redefine\":209}],268:[function(require,module,exports){\n// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)\nvar $export = require('./_export');\n\n$export($export.P, 'Function', {bind: require('./_bind')});\n},{\"./_bind\":138,\"./_export\":154}],269:[function(require,module,exports){\n'use strict';\nvar isObject       = require('./_is-object')\n  , getPrototypeOf = require('./_object-gpo')\n  , HAS_INSTANCE   = require('./_wks')('hasInstance')\n  , FunctionProto  = Function.prototype;\n// 19.2.3.6 Function.prototype[@@hasInstance](V)\nif(!(HAS_INSTANCE in FunctionProto))require('./_object-dp').f(FunctionProto, HAS_INSTANCE, {value: function(O){\n  if(typeof this != 'function' || !isObject(O))return false;\n  if(!isObject(this.prototype))return O instanceof this;\n  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:\n  while(O = getPrototypeOf(O))if(this.prototype === O)return true;\n  return false;\n}});\n},{\"./_is-object\":171,\"./_object-dp\":189,\"./_object-gpo\":196,\"./_wks\":239}],270:[function(require,module,exports){\nvar dP         = require('./_object-dp').f\n  , createDesc = require('./_property-desc')\n  , has        = require('./_has')\n  , FProto     = Function.prototype\n  , nameRE     = /^\\s*function ([^ (]*)/\n  , NAME       = 'name';\n\nvar isExtensible = Object.isExtensible || function(){\n  return true;\n};\n\n// 19.2.4.2 name\nNAME in FProto || require('./_descriptors') && dP(FProto, NAME, {\n  configurable: true,\n  get: function(){\n    try {\n      var that = this\n        , name = ('' + that).match(nameRE)[1];\n      has(that, NAME) || !isExtensible(that) || dP(that, NAME, createDesc(5, name));\n      return name;\n    } catch(e){\n      return '';\n    }\n  }\n});\n},{\"./_descriptors\":150,\"./_has\":161,\"./_object-dp\":189,\"./_property-desc\":207}],271:[function(require,module,exports){\n'use strict';\nvar strong = require('./_collection-strong');\n\n// 23.1 Map Objects\nmodule.exports = require('./_collection')('Map', function(get){\n  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.1.3.6 Map.prototype.get(key)\n  get: function get(key){\n    var entry = strong.getEntry(this, key);\n    return entry && entry.v;\n  },\n  // 23.1.3.9 Map.prototype.set(key, value)\n  set: function set(key, value){\n    return strong.def(this, key === 0 ? 0 : key, value);\n  }\n}, strong, true);\n},{\"./_collection\":144,\"./_collection-strong\":141}],272:[function(require,module,exports){\n// 20.2.2.3 Math.acosh(x)\nvar $export = require('./_export')\n  , log1p   = require('./_math-log1p')\n  , sqrt    = Math.sqrt\n  , $acosh  = Math.acosh;\n\n$export($export.S + $export.F * !($acosh\n  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509\n  && Math.floor($acosh(Number.MAX_VALUE)) == 710\n  // Tor Browser bug: Math.acosh(Infinity) -> NaN \n  && $acosh(Infinity) == Infinity\n), 'Math', {\n  acosh: function acosh(x){\n    return (x = +x) < 1 ? NaN : x > 94906265.62425156\n      ? Math.log(x) + Math.LN2\n      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));\n  }\n});\n},{\"./_export\":154,\"./_math-log1p\":182}],273:[function(require,module,exports){\n// 20.2.2.5 Math.asinh(x)\nvar $export = require('./_export')\n  , $asinh  = Math.asinh;\n\nfunction asinh(x){\n  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));\n}\n\n// Tor Browser bug: Math.asinh(0) -> -0 \n$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {asinh: asinh});\n},{\"./_export\":154}],274:[function(require,module,exports){\n// 20.2.2.7 Math.atanh(x)\nvar $export = require('./_export')\n  , $atanh  = Math.atanh;\n\n// Tor Browser bug: Math.atanh(-0) -> 0 \n$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {\n  atanh: function atanh(x){\n    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;\n  }\n});\n},{\"./_export\":154}],275:[function(require,module,exports){\n// 20.2.2.9 Math.cbrt(x)\nvar $export = require('./_export')\n  , sign    = require('./_math-sign');\n\n$export($export.S, 'Math', {\n  cbrt: function cbrt(x){\n    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);\n  }\n});\n},{\"./_export\":154,\"./_math-sign\":183}],276:[function(require,module,exports){\n// 20.2.2.11 Math.clz32(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  clz32: function clz32(x){\n    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;\n  }\n});\n},{\"./_export\":154}],277:[function(require,module,exports){\n// 20.2.2.12 Math.cosh(x)\nvar $export = require('./_export')\n  , exp     = Math.exp;\n\n$export($export.S, 'Math', {\n  cosh: function cosh(x){\n    return (exp(x = +x) + exp(-x)) / 2;\n  }\n});\n},{\"./_export\":154}],278:[function(require,module,exports){\n// 20.2.2.14 Math.expm1(x)\nvar $export = require('./_export')\n  , $expm1  = require('./_math-expm1');\n\n$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {expm1: $expm1});\n},{\"./_export\":154,\"./_math-expm1\":181}],279:[function(require,module,exports){\n// 20.2.2.16 Math.fround(x)\nvar $export   = require('./_export')\n  , sign      = require('./_math-sign')\n  , pow       = Math.pow\n  , EPSILON   = pow(2, -52)\n  , EPSILON32 = pow(2, -23)\n  , MAX32     = pow(2, 127) * (2 - EPSILON32)\n  , MIN32     = pow(2, -126);\n\nvar roundTiesToEven = function(n){\n  return n + 1 / EPSILON - 1 / EPSILON;\n};\n\n\n$export($export.S, 'Math', {\n  fround: function fround(x){\n    var $abs  = Math.abs(x)\n      , $sign = sign(x)\n      , a, result;\n    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;\n    a = (1 + EPSILON32 / EPSILON) * $abs;\n    result = a - (a - $abs);\n    if(result > MAX32 || result != result)return $sign * Infinity;\n    return $sign * result;\n  }\n});\n},{\"./_export\":154,\"./_math-sign\":183}],280:[function(require,module,exports){\n// 20.2.2.17 Math.hypot([value1[, value2[,  ]]])\nvar $export = require('./_export')\n  , abs     = Math.abs;\n\n$export($export.S, 'Math', {\n  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars\n    var sum  = 0\n      , i    = 0\n      , aLen = arguments.length\n      , larg = 0\n      , arg, div;\n    while(i < aLen){\n      arg = abs(arguments[i++]);\n      if(larg < arg){\n        div  = larg / arg;\n        sum  = sum * div * div + 1;\n        larg = arg;\n      } else if(arg > 0){\n        div  = arg / larg;\n        sum += div * div;\n      } else sum += arg;\n    }\n    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);\n  }\n});\n},{\"./_export\":154}],281:[function(require,module,exports){\n// 20.2.2.18 Math.imul(x, y)\nvar $export = require('./_export')\n  , $imul   = Math.imul;\n\n// some WebKit versions fails with big numbers, some has wrong arity\n$export($export.S + $export.F * require('./_fails')(function(){\n  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;\n}), 'Math', {\n  imul: function imul(x, y){\n    var UINT16 = 0xffff\n      , xn = +x\n      , yn = +y\n      , xl = UINT16 & xn\n      , yl = UINT16 & yn;\n    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);\n  }\n});\n},{\"./_export\":154,\"./_fails\":156}],282:[function(require,module,exports){\n// 20.2.2.21 Math.log10(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  log10: function log10(x){\n    return Math.log(x) / Math.LN10;\n  }\n});\n},{\"./_export\":154}],283:[function(require,module,exports){\n// 20.2.2.20 Math.log1p(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {log1p: require('./_math-log1p')});\n},{\"./_export\":154,\"./_math-log1p\":182}],284:[function(require,module,exports){\n// 20.2.2.22 Math.log2(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  log2: function log2(x){\n    return Math.log(x) / Math.LN2;\n  }\n});\n},{\"./_export\":154}],285:[function(require,module,exports){\n// 20.2.2.28 Math.sign(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {sign: require('./_math-sign')});\n},{\"./_export\":154,\"./_math-sign\":183}],286:[function(require,module,exports){\n// 20.2.2.30 Math.sinh(x)\nvar $export = require('./_export')\n  , expm1   = require('./_math-expm1')\n  , exp     = Math.exp;\n\n// V8 near Chromium 38 has a problem with very small numbers\n$export($export.S + $export.F * require('./_fails')(function(){\n  return !Math.sinh(-2e-17) != -2e-17;\n}), 'Math', {\n  sinh: function sinh(x){\n    return Math.abs(x = +x) < 1\n      ? (expm1(x) - expm1(-x)) / 2\n      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);\n  }\n});\n},{\"./_export\":154,\"./_fails\":156,\"./_math-expm1\":181}],287:[function(require,module,exports){\n// 20.2.2.33 Math.tanh(x)\nvar $export = require('./_export')\n  , expm1   = require('./_math-expm1')\n  , exp     = Math.exp;\n\n$export($export.S, 'Math', {\n  tanh: function tanh(x){\n    var a = expm1(x = +x)\n      , b = expm1(-x);\n    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));\n  }\n});\n},{\"./_export\":154,\"./_math-expm1\":181}],288:[function(require,module,exports){\n// 20.2.2.34 Math.trunc(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  trunc: function trunc(it){\n    return (it > 0 ? Math.floor : Math.ceil)(it);\n  }\n});\n},{\"./_export\":154}],289:[function(require,module,exports){\n'use strict';\nvar global            = require('./_global')\n  , has               = require('./_has')\n  , cof               = require('./_cof')\n  , inheritIfRequired = require('./_inherit-if-required')\n  , toPrimitive       = require('./_to-primitive')\n  , fails             = require('./_fails')\n  , gOPN              = require('./_object-gopn').f\n  , gOPD              = require('./_object-gopd').f\n  , dP                = require('./_object-dp').f\n  , $trim             = require('./_string-trim').trim\n  , NUMBER            = 'Number'\n  , $Number           = global[NUMBER]\n  , Base              = $Number\n  , proto             = $Number.prototype\n  // Opera ~12 has broken Object#toString\n  , BROKEN_COF        = cof(require('./_object-create')(proto)) == NUMBER\n  , TRIM              = 'trim' in String.prototype;\n\n// 7.1.3 ToNumber(argument)\nvar toNumber = function(argument){\n  var it = toPrimitive(argument, false);\n  if(typeof it == 'string' && it.length > 2){\n    it = TRIM ? it.trim() : $trim(it, 3);\n    var first = it.charCodeAt(0)\n      , third, radix, maxCode;\n    if(first === 43 || first === 45){\n      third = it.charCodeAt(2);\n      if(third === 88 || third === 120)return NaN; // Number('+0x1') should be NaN, old V8 fix\n    } else if(first === 48){\n      switch(it.charCodeAt(1)){\n        case 66 : case 98  : radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i\n        case 79 : case 111 : radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i\n        default : return +it;\n      }\n      for(var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++){\n        code = digits.charCodeAt(i);\n        // parseInt parses a string to a first unavailable symbol\n        // but ToNumber should return NaN if a string contains unavailable symbols\n        if(code < 48 || code > maxCode)return NaN;\n      } return parseInt(digits, radix);\n    }\n  } return +it;\n};\n\nif(!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')){\n  $Number = function Number(value){\n    var it = arguments.length < 1 ? 0 : value\n      , that = this;\n    return that instanceof $Number\n      // check on 1..constructor(foo) case\n      && (BROKEN_COF ? fails(function(){ proto.valueOf.call(that); }) : cof(that) != NUMBER)\n        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);\n  };\n  for(var keys = require('./_descriptors') ? gOPN(Base) : (\n    // ES3:\n    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +\n    // ES6 (in case, if modules with ES6 Number statics required before):\n    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +\n    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'\n  ).split(','), j = 0, key; keys.length > j; j++){\n    if(has(Base, key = keys[j]) && !has($Number, key)){\n      dP($Number, key, gOPD(Base, key));\n    }\n  }\n  $Number.prototype = proto;\n  proto.constructor = $Number;\n  require('./_redefine')(global, NUMBER, $Number);\n}\n},{\"./_cof\":140,\"./_descriptors\":150,\"./_fails\":156,\"./_global\":160,\"./_has\":161,\"./_inherit-if-required\":165,\"./_object-create\":188,\"./_object-dp\":189,\"./_object-gopd\":192,\"./_object-gopn\":194,\"./_redefine\":209,\"./_string-trim\":224,\"./_to-primitive\":232}],290:[function(require,module,exports){\n// 20.1.2.1 Number.EPSILON\nvar $export = require('./_export');\n\n$export($export.S, 'Number', {EPSILON: Math.pow(2, -52)});\n},{\"./_export\":154}],291:[function(require,module,exports){\n// 20.1.2.2 Number.isFinite(number)\nvar $export   = require('./_export')\n  , _isFinite = require('./_global').isFinite;\n\n$export($export.S, 'Number', {\n  isFinite: function isFinite(it){\n    return typeof it == 'number' && _isFinite(it);\n  }\n});\n},{\"./_export\":154,\"./_global\":160}],292:[function(require,module,exports){\n// 20.1.2.3 Number.isInteger(number)\nvar $export = require('./_export');\n\n$export($export.S, 'Number', {isInteger: require('./_is-integer')});\n},{\"./_export\":154,\"./_is-integer\":170}],293:[function(require,module,exports){\n// 20.1.2.4 Number.isNaN(number)\nvar $export = require('./_export');\n\n$export($export.S, 'Number', {\n  isNaN: function isNaN(number){\n    return number != number;\n  }\n});\n},{\"./_export\":154}],294:[function(require,module,exports){\n// 20.1.2.5 Number.isSafeInteger(number)\nvar $export   = require('./_export')\n  , isInteger = require('./_is-integer')\n  , abs       = Math.abs;\n\n$export($export.S, 'Number', {\n  isSafeInteger: function isSafeInteger(number){\n    return isInteger(number) && abs(number) <= 0x1fffffffffffff;\n  }\n});\n},{\"./_export\":154,\"./_is-integer\":170}],295:[function(require,module,exports){\n// 20.1.2.6 Number.MAX_SAFE_INTEGER\nvar $export = require('./_export');\n\n$export($export.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});\n},{\"./_export\":154}],296:[function(require,module,exports){\n// 20.1.2.10 Number.MIN_SAFE_INTEGER\nvar $export = require('./_export');\n\n$export($export.S, 'Number', {MIN_SAFE_INTEGER: -0x1fffffffffffff});\n},{\"./_export\":154}],297:[function(require,module,exports){\nvar $export     = require('./_export')\n  , $parseFloat = require('./_parse-float');\n// 20.1.2.12 Number.parseFloat(string)\n$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', {parseFloat: $parseFloat});\n},{\"./_export\":154,\"./_parse-float\":203}],298:[function(require,module,exports){\nvar $export   = require('./_export')\n  , $parseInt = require('./_parse-int');\n// 20.1.2.13 Number.parseInt(string, radix)\n$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', {parseInt: $parseInt});\n},{\"./_export\":154,\"./_parse-int\":204}],299:[function(require,module,exports){\n'use strict';\nvar $export      = require('./_export')\n  , toInteger    = require('./_to-integer')\n  , aNumberValue = require('./_a-number-value')\n  , repeat       = require('./_string-repeat')\n  , $toFixed     = 1..toFixed\n  , floor        = Math.floor\n  , data         = [0, 0, 0, 0, 0, 0]\n  , ERROR        = 'Number.toFixed: incorrect invocation!'\n  , ZERO         = '0';\n\nvar multiply = function(n, c){\n  var i  = -1\n    , c2 = c;\n  while(++i < 6){\n    c2 += n * data[i];\n    data[i] = c2 % 1e7;\n    c2 = floor(c2 / 1e7);\n  }\n};\nvar divide = function(n){\n  var i = 6\n    , c = 0;\n  while(--i >= 0){\n    c += data[i];\n    data[i] = floor(c / n);\n    c = (c % n) * 1e7;\n  }\n};\nvar numToString = function(){\n  var i = 6\n    , s = '';\n  while(--i >= 0){\n    if(s !== '' || i === 0 || data[i] !== 0){\n      var t = String(data[i]);\n      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;\n    }\n  } return s;\n};\nvar pow = function(x, n, acc){\n  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);\n};\nvar log = function(x){\n  var n  = 0\n    , x2 = x;\n  while(x2 >= 4096){\n    n += 12;\n    x2 /= 4096;\n  }\n  while(x2 >= 2){\n    n  += 1;\n    x2 /= 2;\n  } return n;\n};\n\n$export($export.P + $export.F * (!!$toFixed && (\n  0.00008.toFixed(3) !== '0.000' ||\n  0.9.toFixed(0) !== '1' ||\n  1.255.toFixed(2) !== '1.25' ||\n  1000000000000000128..toFixed(0) !== '1000000000000000128'\n) || !require('./_fails')(function(){\n  // V8 ~ Android 4.3-\n  $toFixed.call({});\n})), 'Number', {\n  toFixed: function toFixed(fractionDigits){\n    var x = aNumberValue(this, ERROR)\n      , f = toInteger(fractionDigits)\n      , s = ''\n      , m = ZERO\n      , e, z, j, k;\n    if(f < 0 || f > 20)throw RangeError(ERROR);\n    if(x != x)return 'NaN';\n    if(x <= -1e21 || x >= 1e21)return String(x);\n    if(x < 0){\n      s = '-';\n      x = -x;\n    }\n    if(x > 1e-21){\n      e = log(x * pow(2, 69, 1)) - 69;\n      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);\n      z *= 0x10000000000000;\n      e = 52 - e;\n      if(e > 0){\n        multiply(0, z);\n        j = f;\n        while(j >= 7){\n          multiply(1e7, 0);\n          j -= 7;\n        }\n        multiply(pow(10, j, 1), 0);\n        j = e - 1;\n        while(j >= 23){\n          divide(1 << 23);\n          j -= 23;\n        }\n        divide(1 << j);\n        multiply(1, 1);\n        divide(2);\n        m = numToString();\n      } else {\n        multiply(0, z);\n        multiply(1 << -e, 0);\n        m = numToString() + repeat.call(ZERO, f);\n      }\n    }\n    if(f > 0){\n      k = m.length;\n      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));\n    } else {\n      m = s + m;\n    } return m;\n  }\n});\n},{\"./_a-number-value\":126,\"./_export\":154,\"./_fails\":156,\"./_string-repeat\":223,\"./_to-integer\":228}],300:[function(require,module,exports){\n'use strict';\nvar $export      = require('./_export')\n  , $fails       = require('./_fails')\n  , aNumberValue = require('./_a-number-value')\n  , $toPrecision = 1..toPrecision;\n\n$export($export.P + $export.F * ($fails(function(){\n  // IE7-\n  return $toPrecision.call(1, undefined) !== '1';\n}) || !$fails(function(){\n  // V8 ~ Android 4.3-\n  $toPrecision.call({});\n})), 'Number', {\n  toPrecision: function toPrecision(precision){\n    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');\n    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision); \n  }\n});\n},{\"./_a-number-value\":126,\"./_export\":154,\"./_fails\":156}],301:[function(require,module,exports){\narguments[4][110][0].apply(exports,arguments)\n},{\"./_export\":154,\"./_object-assign\":187,\"dup\":110}],302:[function(require,module,exports){\narguments[4][111][0].apply(exports,arguments)\n},{\"./_export\":154,\"./_object-create\":188,\"dup\":111}],303:[function(require,module,exports){\nvar $export = require('./_export');\n// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)\n$export($export.S + $export.F * !require('./_descriptors'), 'Object', {defineProperties: require('./_object-dps')});\n},{\"./_descriptors\":150,\"./_export\":154,\"./_object-dps\":190}],304:[function(require,module,exports){\narguments[4][112][0].apply(exports,arguments)\n},{\"./_descriptors\":150,\"./_export\":154,\"./_object-dp\":189,\"dup\":112}],305:[function(require,module,exports){\n// 19.1.2.5 Object.freeze(O)\nvar isObject = require('./_is-object')\n  , meta     = require('./_meta').onFreeze;\n\nrequire('./_object-sap')('freeze', function($freeze){\n  return function freeze(it){\n    return $freeze && isObject(it) ? $freeze(meta(it)) : it;\n  };\n});\n},{\"./_is-object\":171,\"./_meta\":184,\"./_object-sap\":200}],306:[function(require,module,exports){\narguments[4][113][0].apply(exports,arguments)\n},{\"./_object-gopd\":192,\"./_object-sap\":200,\"./_to-iobject\":229,\"dup\":113}],307:[function(require,module,exports){\n// 19.1.2.7 Object.getOwnPropertyNames(O)\nrequire('./_object-sap')('getOwnPropertyNames', function(){\n  return require('./_object-gopn-ext').f;\n});\n},{\"./_object-gopn-ext\":193,\"./_object-sap\":200}],308:[function(require,module,exports){\narguments[4][114][0].apply(exports,arguments)\n},{\"./_object-gpo\":196,\"./_object-sap\":200,\"./_to-object\":231,\"dup\":114}],309:[function(require,module,exports){\n// 19.1.2.11 Object.isExtensible(O)\nvar isObject = require('./_is-object');\n\nrequire('./_object-sap')('isExtensible', function($isExtensible){\n  return function isExtensible(it){\n    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;\n  };\n});\n},{\"./_is-object\":171,\"./_object-sap\":200}],310:[function(require,module,exports){\narguments[4][115][0].apply(exports,arguments)\n},{\"./_is-object\":171,\"./_object-sap\":200,\"dup\":115}],311:[function(require,module,exports){\n// 19.1.2.13 Object.isSealed(O)\nvar isObject = require('./_is-object');\n\nrequire('./_object-sap')('isSealed', function($isSealed){\n  return function isSealed(it){\n    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;\n  };\n});\n},{\"./_is-object\":171,\"./_object-sap\":200}],312:[function(require,module,exports){\n// 19.1.3.10 Object.is(value1, value2)\nvar $export = require('./_export');\n$export($export.S, 'Object', {is: require('./_same-value')});\n},{\"./_export\":154,\"./_same-value\":211}],313:[function(require,module,exports){\narguments[4][116][0].apply(exports,arguments)\n},{\"./_object-keys\":198,\"./_object-sap\":200,\"./_to-object\":231,\"dup\":116}],314:[function(require,module,exports){\n// 19.1.2.15 Object.preventExtensions(O)\nvar isObject = require('./_is-object')\n  , meta     = require('./_meta').onFreeze;\n\nrequire('./_object-sap')('preventExtensions', function($preventExtensions){\n  return function preventExtensions(it){\n    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;\n  };\n});\n},{\"./_is-object\":171,\"./_meta\":184,\"./_object-sap\":200}],315:[function(require,module,exports){\n// 19.1.2.17 Object.seal(O)\nvar isObject = require('./_is-object')\n  , meta     = require('./_meta').onFreeze;\n\nrequire('./_object-sap')('seal', function($seal){\n  return function seal(it){\n    return $seal && isObject(it) ? $seal(meta(it)) : it;\n  };\n});\n},{\"./_is-object\":171,\"./_meta\":184,\"./_object-sap\":200}],316:[function(require,module,exports){\narguments[4][117][0].apply(exports,arguments)\n},{\"./_export\":154,\"./_set-proto\":212,\"dup\":117}],317:[function(require,module,exports){\n'use strict';\n// 19.1.3.6 Object.prototype.toString()\nvar classof = require('./_classof')\n  , test    = {};\ntest[require('./_wks')('toStringTag')] = 'z';\nif(test + '' != '[object z]'){\n  require('./_redefine')(Object.prototype, 'toString', function toString(){\n    return '[object ' + classof(this) + ']';\n  }, true);\n}\n},{\"./_classof\":139,\"./_redefine\":209,\"./_wks\":239}],318:[function(require,module,exports){\nvar $export     = require('./_export')\n  , $parseFloat = require('./_parse-float');\n// 18.2.4 parseFloat(string)\n$export($export.G + $export.F * (parseFloat != $parseFloat), {parseFloat: $parseFloat});\n},{\"./_export\":154,\"./_parse-float\":203}],319:[function(require,module,exports){\nvar $export   = require('./_export')\n  , $parseInt = require('./_parse-int');\n// 18.2.5 parseInt(string, radix)\n$export($export.G + $export.F * (parseInt != $parseInt), {parseInt: $parseInt});\n},{\"./_export\":154,\"./_parse-int\":204}],320:[function(require,module,exports){\narguments[4][119][0].apply(exports,arguments)\n},{\"./_a-function\":125,\"./_an-instance\":128,\"./_classof\":139,\"./_core\":145,\"./_ctx\":147,\"./_export\":154,\"./_for-of\":159,\"./_global\":160,\"./_is-object\":171,\"./_iter-detect\":176,\"./_library\":180,\"./_microtask\":186,\"./_redefine-all\":208,\"./_set-species\":213,\"./_set-to-string-tag\":214,\"./_species-constructor\":217,\"./_task\":226,\"./_wks\":239,\"dup\":119}],321:[function(require,module,exports){\n// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)\nvar $export   = require('./_export')\n  , aFunction = require('./_a-function')\n  , anObject  = require('./_an-object')\n  , rApply    = (require('./_global').Reflect || {}).apply\n  , fApply    = Function.apply;\n// MS Edge argumentsList argument is optional\n$export($export.S + $export.F * !require('./_fails')(function(){\n  rApply(function(){});\n}), 'Reflect', {\n  apply: function apply(target, thisArgument, argumentsList){\n    var T = aFunction(target)\n      , L = anObject(argumentsList);\n    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);\n  }\n});\n},{\"./_a-function\":125,\"./_an-object\":129,\"./_export\":154,\"./_fails\":156,\"./_global\":160}],322:[function(require,module,exports){\n// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])\nvar $export    = require('./_export')\n  , create     = require('./_object-create')\n  , aFunction  = require('./_a-function')\n  , anObject   = require('./_an-object')\n  , isObject   = require('./_is-object')\n  , fails      = require('./_fails')\n  , bind       = require('./_bind')\n  , rConstruct = (require('./_global').Reflect || {}).construct;\n\n// MS Edge supports only 2 arguments and argumentsList argument is optional\n// FF Nightly sets third argument as `new.target`, but does not create `this` from it\nvar NEW_TARGET_BUG = fails(function(){\n  function F(){}\n  return !(rConstruct(function(){}, [], F) instanceof F);\n});\nvar ARGS_BUG = !fails(function(){\n  rConstruct(function(){});\n});\n\n$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {\n  construct: function construct(Target, args /*, newTarget*/){\n    aFunction(Target);\n    anObject(args);\n    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);\n    if(ARGS_BUG && !NEW_TARGET_BUG)return rConstruct(Target, args, newTarget);\n    if(Target == newTarget){\n      // w/o altered newTarget, optimization for 0-4 arguments\n      switch(args.length){\n        case 0: return new Target;\n        case 1: return new Target(args[0]);\n        case 2: return new Target(args[0], args[1]);\n        case 3: return new Target(args[0], args[1], args[2]);\n        case 4: return new Target(args[0], args[1], args[2], args[3]);\n      }\n      // w/o altered newTarget, lot of arguments case\n      var $args = [null];\n      $args.push.apply($args, args);\n      return new (bind.apply(Target, $args));\n    }\n    // with altered newTarget, not support built-in constructors\n    var proto    = newTarget.prototype\n      , instance = create(isObject(proto) ? proto : Object.prototype)\n      , result   = Function.apply.call(Target, instance, args);\n    return isObject(result) ? result : instance;\n  }\n});\n},{\"./_a-function\":125,\"./_an-object\":129,\"./_bind\":138,\"./_export\":154,\"./_fails\":156,\"./_global\":160,\"./_is-object\":171,\"./_object-create\":188}],323:[function(require,module,exports){\n// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)\nvar dP          = require('./_object-dp')\n  , $export     = require('./_export')\n  , anObject    = require('./_an-object')\n  , toPrimitive = require('./_to-primitive');\n\n// MS Edge has broken Reflect.defineProperty - throwing instead of returning false\n$export($export.S + $export.F * require('./_fails')(function(){\n  Reflect.defineProperty(dP.f({}, 1, {value: 1}), 1, {value: 2});\n}), 'Reflect', {\n  defineProperty: function defineProperty(target, propertyKey, attributes){\n    anObject(target);\n    propertyKey = toPrimitive(propertyKey, true);\n    anObject(attributes);\n    try {\n      dP.f(target, propertyKey, attributes);\n      return true;\n    } catch(e){\n      return false;\n    }\n  }\n});\n},{\"./_an-object\":129,\"./_export\":154,\"./_fails\":156,\"./_object-dp\":189,\"./_to-primitive\":232}],324:[function(require,module,exports){\n// 26.1.4 Reflect.deleteProperty(target, propertyKey)\nvar $export  = require('./_export')\n  , gOPD     = require('./_object-gopd').f\n  , anObject = require('./_an-object');\n\n$export($export.S, 'Reflect', {\n  deleteProperty: function deleteProperty(target, propertyKey){\n    var desc = gOPD(anObject(target), propertyKey);\n    return desc && !desc.configurable ? false : delete target[propertyKey];\n  }\n});\n},{\"./_an-object\":129,\"./_export\":154,\"./_object-gopd\":192}],325:[function(require,module,exports){\n'use strict';\n// 26.1.5 Reflect.enumerate(target)\nvar $export  = require('./_export')\n  , anObject = require('./_an-object');\nvar Enumerate = function(iterated){\n  this._t = anObject(iterated); // target\n  this._i = 0;                  // next index\n  var keys = this._k = []       // keys\n    , key;\n  for(key in iterated)keys.push(key);\n};\nrequire('./_iter-create')(Enumerate, 'Object', function(){\n  var that = this\n    , keys = that._k\n    , key;\n  do {\n    if(that._i >= keys.length)return {value: undefined, done: true};\n  } while(!((key = keys[that._i++]) in that._t));\n  return {value: key, done: false};\n});\n\n$export($export.S, 'Reflect', {\n  enumerate: function enumerate(target){\n    return new Enumerate(target);\n  }\n});\n},{\"./_an-object\":129,\"./_export\":154,\"./_iter-create\":174}],326:[function(require,module,exports){\n// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)\nvar gOPD     = require('./_object-gopd')\n  , $export  = require('./_export')\n  , anObject = require('./_an-object');\n\n$export($export.S, 'Reflect', {\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){\n    return gOPD.f(anObject(target), propertyKey);\n  }\n});\n},{\"./_an-object\":129,\"./_export\":154,\"./_object-gopd\":192}],327:[function(require,module,exports){\n// 26.1.8 Reflect.getPrototypeOf(target)\nvar $export  = require('./_export')\n  , getProto = require('./_object-gpo')\n  , anObject = require('./_an-object');\n\n$export($export.S, 'Reflect', {\n  getPrototypeOf: function getPrototypeOf(target){\n    return getProto(anObject(target));\n  }\n});\n},{\"./_an-object\":129,\"./_export\":154,\"./_object-gpo\":196}],328:[function(require,module,exports){\n// 26.1.6 Reflect.get(target, propertyKey [, receiver])\nvar gOPD           = require('./_object-gopd')\n  , getPrototypeOf = require('./_object-gpo')\n  , has            = require('./_has')\n  , $export        = require('./_export')\n  , isObject       = require('./_is-object')\n  , anObject       = require('./_an-object');\n\nfunction get(target, propertyKey/*, receiver*/){\n  var receiver = arguments.length < 3 ? target : arguments[2]\n    , desc, proto;\n  if(anObject(target) === receiver)return target[propertyKey];\n  if(desc = gOPD.f(target, propertyKey))return has(desc, 'value')\n    ? desc.value\n    : desc.get !== undefined\n      ? desc.get.call(receiver)\n      : undefined;\n  if(isObject(proto = getPrototypeOf(target)))return get(proto, propertyKey, receiver);\n}\n\n$export($export.S, 'Reflect', {get: get});\n},{\"./_an-object\":129,\"./_export\":154,\"./_has\":161,\"./_is-object\":171,\"./_object-gopd\":192,\"./_object-gpo\":196}],329:[function(require,module,exports){\n// 26.1.9 Reflect.has(target, propertyKey)\nvar $export = require('./_export');\n\n$export($export.S, 'Reflect', {\n  has: function has(target, propertyKey){\n    return propertyKey in target;\n  }\n});\n},{\"./_export\":154}],330:[function(require,module,exports){\n// 26.1.10 Reflect.isExtensible(target)\nvar $export       = require('./_export')\n  , anObject      = require('./_an-object')\n  , $isExtensible = Object.isExtensible;\n\n$export($export.S, 'Reflect', {\n  isExtensible: function isExtensible(target){\n    anObject(target);\n    return $isExtensible ? $isExtensible(target) : true;\n  }\n});\n},{\"./_an-object\":129,\"./_export\":154}],331:[function(require,module,exports){\n// 26.1.11 Reflect.ownKeys(target)\nvar $export = require('./_export');\n\n$export($export.S, 'Reflect', {ownKeys: require('./_own-keys')});\n},{\"./_export\":154,\"./_own-keys\":202}],332:[function(require,module,exports){\n// 26.1.12 Reflect.preventExtensions(target)\nvar $export            = require('./_export')\n  , anObject           = require('./_an-object')\n  , $preventExtensions = Object.preventExtensions;\n\n$export($export.S, 'Reflect', {\n  preventExtensions: function preventExtensions(target){\n    anObject(target);\n    try {\n      if($preventExtensions)$preventExtensions(target);\n      return true;\n    } catch(e){\n      return false;\n    }\n  }\n});\n},{\"./_an-object\":129,\"./_export\":154}],333:[function(require,module,exports){\n// 26.1.14 Reflect.setPrototypeOf(target, proto)\nvar $export  = require('./_export')\n  , setProto = require('./_set-proto');\n\nif(setProto)$export($export.S, 'Reflect', {\n  setPrototypeOf: function setPrototypeOf(target, proto){\n    setProto.check(target, proto);\n    try {\n      setProto.set(target, proto);\n      return true;\n    } catch(e){\n      return false;\n    }\n  }\n});\n},{\"./_export\":154,\"./_set-proto\":212}],334:[function(require,module,exports){\n// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])\nvar dP             = require('./_object-dp')\n  , gOPD           = require('./_object-gopd')\n  , getPrototypeOf = require('./_object-gpo')\n  , has            = require('./_has')\n  , $export        = require('./_export')\n  , createDesc     = require('./_property-desc')\n  , anObject       = require('./_an-object')\n  , isObject       = require('./_is-object');\n\nfunction set(target, propertyKey, V/*, receiver*/){\n  var receiver = arguments.length < 4 ? target : arguments[3]\n    , ownDesc  = gOPD.f(anObject(target), propertyKey)\n    , existingDescriptor, proto;\n  if(!ownDesc){\n    if(isObject(proto = getPrototypeOf(target))){\n      return set(proto, propertyKey, V, receiver);\n    }\n    ownDesc = createDesc(0);\n  }\n  if(has(ownDesc, 'value')){\n    if(ownDesc.writable === false || !isObject(receiver))return false;\n    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);\n    existingDescriptor.value = V;\n    dP.f(receiver, propertyKey, existingDescriptor);\n    return true;\n  }\n  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);\n}\n\n$export($export.S, 'Reflect', {set: set});\n},{\"./_an-object\":129,\"./_export\":154,\"./_has\":161,\"./_is-object\":171,\"./_object-dp\":189,\"./_object-gopd\":192,\"./_object-gpo\":196,\"./_property-desc\":207}],335:[function(require,module,exports){\nvar global            = require('./_global')\n  , inheritIfRequired = require('./_inherit-if-required')\n  , dP                = require('./_object-dp').f\n  , gOPN              = require('./_object-gopn').f\n  , isRegExp          = require('./_is-regexp')\n  , $flags            = require('./_flags')\n  , $RegExp           = global.RegExp\n  , Base              = $RegExp\n  , proto             = $RegExp.prototype\n  , re1               = /a/g\n  , re2               = /a/g\n  // \"new\" creates a new object, old webkit buggy here\n  , CORRECT_NEW       = new $RegExp(re1) !== re1;\n\nif(require('./_descriptors') && (!CORRECT_NEW || require('./_fails')(function(){\n  re2[require('./_wks')('match')] = false;\n  // RegExp constructor can alter flags and IsRegExp works correct with @@match\n  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';\n}))){\n  $RegExp = function RegExp(p, f){\n    var tiRE = this instanceof $RegExp\n      , piRE = isRegExp(p)\n      , fiU  = f === undefined;\n    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p\n      : inheritIfRequired(CORRECT_NEW\n        ? new Base(piRE && !fiU ? p.source : p, f)\n        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)\n      , tiRE ? this : proto, $RegExp);\n  };\n  var proxy = function(key){\n    key in $RegExp || dP($RegExp, key, {\n      configurable: true,\n      get: function(){ return Base[key]; },\n      set: function(it){ Base[key] = it; }\n    });\n  };\n  for(var keys = gOPN(Base), i = 0; keys.length > i; )proxy(keys[i++]);\n  proto.constructor = $RegExp;\n  $RegExp.prototype = proto;\n  require('./_redefine')(global, 'RegExp', $RegExp);\n}\n\nrequire('./_set-species')('RegExp');\n},{\"./_descriptors\":150,\"./_fails\":156,\"./_flags\":158,\"./_global\":160,\"./_inherit-if-required\":165,\"./_is-regexp\":172,\"./_object-dp\":189,\"./_object-gopn\":194,\"./_redefine\":209,\"./_set-species\":213,\"./_wks\":239}],336:[function(require,module,exports){\n// 21.2.5.3 get RegExp.prototype.flags()\nif(require('./_descriptors') && /./g.flags != 'g')require('./_object-dp').f(RegExp.prototype, 'flags', {\n  configurable: true,\n  get: require('./_flags')\n});\n},{\"./_descriptors\":150,\"./_flags\":158,\"./_object-dp\":189}],337:[function(require,module,exports){\n// @@match logic\nrequire('./_fix-re-wks')('match', 1, function(defined, MATCH, $match){\n  // 21.1.3.11 String.prototype.match(regexp)\n  return [function match(regexp){\n    'use strict';\n    var O  = defined(this)\n      , fn = regexp == undefined ? undefined : regexp[MATCH];\n    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));\n  }, $match];\n});\n},{\"./_fix-re-wks\":157}],338:[function(require,module,exports){\n// @@replace logic\nrequire('./_fix-re-wks')('replace', 2, function(defined, REPLACE, $replace){\n  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)\n  return [function replace(searchValue, replaceValue){\n    'use strict';\n    var O  = defined(this)\n      , fn = searchValue == undefined ? undefined : searchValue[REPLACE];\n    return fn !== undefined\n      ? fn.call(searchValue, O, replaceValue)\n      : $replace.call(String(O), searchValue, replaceValue);\n  }, $replace];\n});\n},{\"./_fix-re-wks\":157}],339:[function(require,module,exports){\n// @@search logic\nrequire('./_fix-re-wks')('search', 1, function(defined, SEARCH, $search){\n  // 21.1.3.15 String.prototype.search(regexp)\n  return [function search(regexp){\n    'use strict';\n    var O  = defined(this)\n      , fn = regexp == undefined ? undefined : regexp[SEARCH];\n    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));\n  }, $search];\n});\n},{\"./_fix-re-wks\":157}],340:[function(require,module,exports){\n// @@split logic\nrequire('./_fix-re-wks')('split', 2, function(defined, SPLIT, $split){\n  'use strict';\n  var isRegExp   = require('./_is-regexp')\n    , _split     = $split\n    , $push      = [].push\n    , $SPLIT     = 'split'\n    , LENGTH     = 'length'\n    , LAST_INDEX = 'lastIndex';\n  if(\n    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||\n    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||\n    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||\n    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||\n    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||\n    ''[$SPLIT](/.?/)[LENGTH]\n  ){\n    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group\n    // based on es5-shim implementation, need to rework it\n    $split = function(separator, limit){\n      var string = String(this);\n      if(separator === undefined && limit === 0)return [];\n      // If `separator` is not a regex, use native split\n      if(!isRegExp(separator))return _split.call(string, separator, limit);\n      var output = [];\n      var flags = (separator.ignoreCase ? 'i' : '') +\n                  (separator.multiline ? 'm' : '') +\n                  (separator.unicode ? 'u' : '') +\n                  (separator.sticky ? 'y' : '');\n      var lastLastIndex = 0;\n      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;\n      // Make `global` and avoid `lastIndex` issues by working with a copy\n      var separatorCopy = new RegExp(separator.source, flags + 'g');\n      var separator2, match, lastIndex, lastLength, i;\n      // Doesn't need flags gy, but they don't hurt\n      if(!NPCG)separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\\\s)', flags);\n      while(match = separatorCopy.exec(string)){\n        // `separatorCopy.lastIndex` is not reliable cross-browser\n        lastIndex = match.index + match[0][LENGTH];\n        if(lastIndex > lastLastIndex){\n          output.push(string.slice(lastLastIndex, match.index));\n          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG\n          if(!NPCG && match[LENGTH] > 1)match[0].replace(separator2, function(){\n            for(i = 1; i < arguments[LENGTH] - 2; i++)if(arguments[i] === undefined)match[i] = undefined;\n          });\n          if(match[LENGTH] > 1 && match.index < string[LENGTH])$push.apply(output, match.slice(1));\n          lastLength = match[0][LENGTH];\n          lastLastIndex = lastIndex;\n          if(output[LENGTH] >= splitLimit)break;\n        }\n        if(separatorCopy[LAST_INDEX] === match.index)separatorCopy[LAST_INDEX]++; // Avoid an infinite loop\n      }\n      if(lastLastIndex === string[LENGTH]){\n        if(lastLength || !separatorCopy.test(''))output.push('');\n      } else output.push(string.slice(lastLastIndex));\n      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;\n    };\n  // Chakra, V8\n  } else if('0'[$SPLIT](undefined, 0)[LENGTH]){\n    $split = function(separator, limit){\n      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);\n    };\n  }\n  // 21.1.3.17 String.prototype.split(separator, limit)\n  return [function split(separator, limit){\n    var O  = defined(this)\n      , fn = separator == undefined ? undefined : separator[SPLIT];\n    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);\n  }, $split];\n});\n},{\"./_fix-re-wks\":157,\"./_is-regexp\":172}],341:[function(require,module,exports){\n'use strict';\nrequire('./es6.regexp.flags');\nvar anObject    = require('./_an-object')\n  , $flags      = require('./_flags')\n  , DESCRIPTORS = require('./_descriptors')\n  , TO_STRING   = 'toString'\n  , $toString   = /./[TO_STRING];\n\nvar define = function(fn){\n  require('./_redefine')(RegExp.prototype, TO_STRING, fn, true);\n};\n\n// 21.2.5.14 RegExp.prototype.toString()\nif(require('./_fails')(function(){ return $toString.call({source: 'a', flags: 'b'}) != '/a/b'; })){\n  define(function toString(){\n    var R = anObject(this);\n    return '/'.concat(R.source, '/',\n      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);\n  });\n// FF44- RegExp#toString has a wrong name\n} else if($toString.name != TO_STRING){\n  define(function toString(){\n    return $toString.call(this);\n  });\n}\n},{\"./_an-object\":129,\"./_descriptors\":150,\"./_fails\":156,\"./_flags\":158,\"./_redefine\":209,\"./es6.regexp.flags\":336}],342:[function(require,module,exports){\n'use strict';\nvar strong = require('./_collection-strong');\n\n// 23.2 Set Objects\nmodule.exports = require('./_collection')('Set', function(get){\n  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.2.3.1 Set.prototype.add(value)\n  add: function add(value){\n    return strong.def(this, value = value === 0 ? 0 : value, value);\n  }\n}, strong);\n},{\"./_collection\":144,\"./_collection-strong\":141}],343:[function(require,module,exports){\n'use strict';\n// B.2.3.2 String.prototype.anchor(name)\nrequire('./_string-html')('anchor', function(createHTML){\n  return function anchor(name){\n    return createHTML(this, 'a', 'name', name);\n  }\n});\n},{\"./_string-html\":221}],344:[function(require,module,exports){\n'use strict';\n// B.2.3.3 String.prototype.big()\nrequire('./_string-html')('big', function(createHTML){\n  return function big(){\n    return createHTML(this, 'big', '', '');\n  }\n});\n},{\"./_string-html\":221}],345:[function(require,module,exports){\n'use strict';\n// B.2.3.4 String.prototype.blink()\nrequire('./_string-html')('blink', function(createHTML){\n  return function blink(){\n    return createHTML(this, 'blink', '', '');\n  }\n});\n},{\"./_string-html\":221}],346:[function(require,module,exports){\n'use strict';\n// B.2.3.5 String.prototype.bold()\nrequire('./_string-html')('bold', function(createHTML){\n  return function bold(){\n    return createHTML(this, 'b', '', '');\n  }\n});\n},{\"./_string-html\":221}],347:[function(require,module,exports){\n'use strict';\nvar $export = require('./_export')\n  , $at     = require('./_string-at')(false);\n$export($export.P, 'String', {\n  // 21.1.3.3 String.prototype.codePointAt(pos)\n  codePointAt: function codePointAt(pos){\n    return $at(this, pos);\n  }\n});\n},{\"./_export\":154,\"./_string-at\":219}],348:[function(require,module,exports){\n// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])\n'use strict';\nvar $export   = require('./_export')\n  , toLength  = require('./_to-length')\n  , context   = require('./_string-context')\n  , ENDS_WITH = 'endsWith'\n  , $endsWith = ''[ENDS_WITH];\n\n$export($export.P + $export.F * require('./_fails-is-regexp')(ENDS_WITH), 'String', {\n  endsWith: function endsWith(searchString /*, endPosition = @length */){\n    var that = context(this, searchString, ENDS_WITH)\n      , endPosition = arguments.length > 1 ? arguments[1] : undefined\n      , len    = toLength(that.length)\n      , end    = endPosition === undefined ? len : Math.min(toLength(endPosition), len)\n      , search = String(searchString);\n    return $endsWith\n      ? $endsWith.call(that, search, end)\n      : that.slice(end - search.length, end) === search;\n  }\n});\n},{\"./_export\":154,\"./_fails-is-regexp\":155,\"./_string-context\":220,\"./_to-length\":230}],349:[function(require,module,exports){\n'use strict';\n// B.2.3.6 String.prototype.fixed()\nrequire('./_string-html')('fixed', function(createHTML){\n  return function fixed(){\n    return createHTML(this, 'tt', '', '');\n  }\n});\n},{\"./_string-html\":221}],350:[function(require,module,exports){\n'use strict';\n// B.2.3.7 String.prototype.fontcolor(color)\nrequire('./_string-html')('fontcolor', function(createHTML){\n  return function fontcolor(color){\n    return createHTML(this, 'font', 'color', color);\n  }\n});\n},{\"./_string-html\":221}],351:[function(require,module,exports){\n'use strict';\n// B.2.3.8 String.prototype.fontsize(size)\nrequire('./_string-html')('fontsize', function(createHTML){\n  return function fontsize(size){\n    return createHTML(this, 'font', 'size', size);\n  }\n});\n},{\"./_string-html\":221}],352:[function(require,module,exports){\nvar $export        = require('./_export')\n  , toIndex        = require('./_to-index')\n  , fromCharCode   = String.fromCharCode\n  , $fromCodePoint = String.fromCodePoint;\n\n// length should be 1, old FF problem\n$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {\n  // 21.1.2.2 String.fromCodePoint(...codePoints)\n  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars\n    var res  = []\n      , aLen = arguments.length\n      , i    = 0\n      , code;\n    while(aLen > i){\n      code = +arguments[i++];\n      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');\n      res.push(code < 0x10000\n        ? fromCharCode(code)\n        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)\n      );\n    } return res.join('');\n  }\n});\n},{\"./_export\":154,\"./_to-index\":227}],353:[function(require,module,exports){\n// 21.1.3.7 String.prototype.includes(searchString, position = 0)\n'use strict';\nvar $export  = require('./_export')\n  , context  = require('./_string-context')\n  , INCLUDES = 'includes';\n\n$export($export.P + $export.F * require('./_fails-is-regexp')(INCLUDES), 'String', {\n  includes: function includes(searchString /*, position = 0 */){\n    return !!~context(this, searchString, INCLUDES)\n      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n},{\"./_export\":154,\"./_fails-is-regexp\":155,\"./_string-context\":220}],354:[function(require,module,exports){\n'use strict';\n// B.2.3.9 String.prototype.italics()\nrequire('./_string-html')('italics', function(createHTML){\n  return function italics(){\n    return createHTML(this, 'i', '', '');\n  }\n});\n},{\"./_string-html\":221}],355:[function(require,module,exports){\narguments[4][120][0].apply(exports,arguments)\n},{\"./_iter-define\":175,\"./_string-at\":219,\"dup\":120}],356:[function(require,module,exports){\n'use strict';\n// B.2.3.10 String.prototype.link(url)\nrequire('./_string-html')('link', function(createHTML){\n  return function link(url){\n    return createHTML(this, 'a', 'href', url);\n  }\n});\n},{\"./_string-html\":221}],357:[function(require,module,exports){\nvar $export   = require('./_export')\n  , toIObject = require('./_to-iobject')\n  , toLength  = require('./_to-length');\n\n$export($export.S, 'String', {\n  // 21.1.2.4 String.raw(callSite, ...substitutions)\n  raw: function raw(callSite){\n    var tpl  = toIObject(callSite.raw)\n      , len  = toLength(tpl.length)\n      , aLen = arguments.length\n      , res  = []\n      , i    = 0;\n    while(len > i){\n      res.push(String(tpl[i++]));\n      if(i < aLen)res.push(String(arguments[i]));\n    } return res.join('');\n  }\n});\n},{\"./_export\":154,\"./_to-iobject\":229,\"./_to-length\":230}],358:[function(require,module,exports){\nvar $export = require('./_export');\n\n$export($export.P, 'String', {\n  // 21.1.3.13 String.prototype.repeat(count)\n  repeat: require('./_string-repeat')\n});\n},{\"./_export\":154,\"./_string-repeat\":223}],359:[function(require,module,exports){\n'use strict';\n// B.2.3.11 String.prototype.small()\nrequire('./_string-html')('small', function(createHTML){\n  return function small(){\n    return createHTML(this, 'small', '', '');\n  }\n});\n},{\"./_string-html\":221}],360:[function(require,module,exports){\n// 21.1.3.18 String.prototype.startsWith(searchString [, position ])\n'use strict';\nvar $export     = require('./_export')\n  , toLength    = require('./_to-length')\n  , context     = require('./_string-context')\n  , STARTS_WITH = 'startsWith'\n  , $startsWith = ''[STARTS_WITH];\n\n$export($export.P + $export.F * require('./_fails-is-regexp')(STARTS_WITH), 'String', {\n  startsWith: function startsWith(searchString /*, position = 0 */){\n    var that   = context(this, searchString, STARTS_WITH)\n      , index  = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length))\n      , search = String(searchString);\n    return $startsWith\n      ? $startsWith.call(that, search, index)\n      : that.slice(index, index + search.length) === search;\n  }\n});\n},{\"./_export\":154,\"./_fails-is-regexp\":155,\"./_string-context\":220,\"./_to-length\":230}],361:[function(require,module,exports){\n'use strict';\n// B.2.3.12 String.prototype.strike()\nrequire('./_string-html')('strike', function(createHTML){\n  return function strike(){\n    return createHTML(this, 'strike', '', '');\n  }\n});\n},{\"./_string-html\":221}],362:[function(require,module,exports){\n'use strict';\n// B.2.3.13 String.prototype.sub()\nrequire('./_string-html')('sub', function(createHTML){\n  return function sub(){\n    return createHTML(this, 'sub', '', '');\n  }\n});\n},{\"./_string-html\":221}],363:[function(require,module,exports){\n'use strict';\n// B.2.3.14 String.prototype.sup()\nrequire('./_string-html')('sup', function(createHTML){\n  return function sup(){\n    return createHTML(this, 'sup', '', '');\n  }\n});\n},{\"./_string-html\":221}],364:[function(require,module,exports){\n'use strict';\n// 21.1.3.25 String.prototype.trim()\nrequire('./_string-trim')('trim', function($trim){\n  return function trim(){\n    return $trim(this, 3);\n  };\n});\n},{\"./_string-trim\":224}],365:[function(require,module,exports){\narguments[4][121][0].apply(exports,arguments)\n},{\"./_an-object\":129,\"./_descriptors\":150,\"./_enum-keys\":153,\"./_export\":154,\"./_fails\":156,\"./_global\":160,\"./_has\":161,\"./_hide\":162,\"./_is-array\":169,\"./_keyof\":179,\"./_library\":180,\"./_meta\":184,\"./_object-create\":188,\"./_object-dp\":189,\"./_object-gopd\":192,\"./_object-gopn\":194,\"./_object-gopn-ext\":193,\"./_object-gops\":195,\"./_object-keys\":198,\"./_object-pie\":199,\"./_property-desc\":207,\"./_redefine\":209,\"./_set-to-string-tag\":214,\"./_shared\":216,\"./_to-iobject\":229,\"./_to-primitive\":232,\"./_uid\":236,\"./_wks\":239,\"./_wks-define\":237,\"./_wks-ext\":238,\"dup\":121}],366:[function(require,module,exports){\n'use strict';\nvar $export      = require('./_export')\n  , $typed       = require('./_typed')\n  , buffer       = require('./_typed-buffer')\n  , anObject     = require('./_an-object')\n  , toIndex      = require('./_to-index')\n  , toLength     = require('./_to-length')\n  , isObject     = require('./_is-object')\n  , ArrayBuffer  = require('./_global').ArrayBuffer\n  , speciesConstructor = require('./_species-constructor')\n  , $ArrayBuffer = buffer.ArrayBuffer\n  , $DataView    = buffer.DataView\n  , $isView      = $typed.ABV && ArrayBuffer.isView\n  , $slice       = $ArrayBuffer.prototype.slice\n  , VIEW         = $typed.VIEW\n  , ARRAY_BUFFER = 'ArrayBuffer';\n\n$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {ArrayBuffer: $ArrayBuffer});\n\n$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {\n  // 24.1.3.1 ArrayBuffer.isView(arg)\n  isView: function isView(it){\n    return $isView && $isView(it) || isObject(it) && VIEW in it;\n  }\n});\n\n$export($export.P + $export.U + $export.F * require('./_fails')(function(){\n  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;\n}), ARRAY_BUFFER, {\n  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)\n  slice: function slice(start, end){\n    if($slice !== undefined && end === undefined)return $slice.call(anObject(this), start); // FF fix\n    var len    = anObject(this).byteLength\n      , first  = toIndex(start, len)\n      , final  = toIndex(end === undefined ? len : end, len)\n      , result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first))\n      , viewS  = new $DataView(this)\n      , viewT  = new $DataView(result)\n      , index  = 0;\n    while(first < final){\n      viewT.setUint8(index++, viewS.getUint8(first++));\n    } return result;\n  }\n});\n\nrequire('./_set-species')(ARRAY_BUFFER);\n},{\"./_an-object\":129,\"./_export\":154,\"./_fails\":156,\"./_global\":160,\"./_is-object\":171,\"./_set-species\":213,\"./_species-constructor\":217,\"./_to-index\":227,\"./_to-length\":230,\"./_typed\":235,\"./_typed-buffer\":234}],367:[function(require,module,exports){\nvar $export = require('./_export');\n$export($export.G + $export.W + $export.F * !require('./_typed').ABV, {\n  DataView: require('./_typed-buffer').DataView\n});\n},{\"./_export\":154,\"./_typed\":235,\"./_typed-buffer\":234}],368:[function(require,module,exports){\nrequire('./_typed-array')('Float32', 4, function(init){\n  return function Float32Array(data, byteOffset, length){\n    return init(this, data, byteOffset, length);\n  };\n});\n},{\"./_typed-array\":233}],369:[function(require,module,exports){\nrequire('./_typed-array')('Float64', 8, function(init){\n  return function Float64Array(data, byteOffset, length){\n    return init(this, data, byteOffset, length);\n  };\n});\n},{\"./_typed-array\":233}],370:[function(require,module,exports){\nrequire('./_typed-array')('Int16', 2, function(init){\n  return function Int16Array(data, byteOffset, length){\n    return init(this, data, byteOffset, length);\n  };\n});\n},{\"./_typed-array\":233}],371:[function(require,module,exports){\nrequire('./_typed-array')('Int32', 4, function(init){\n  return function Int32Array(data, byteOffset, length){\n    return init(this, data, byteOffset, length);\n  };\n});\n},{\"./_typed-array\":233}],372:[function(require,module,exports){\nrequire('./_typed-array')('Int8', 1, function(init){\n  return function Int8Array(data, byteOffset, length){\n    return init(this, data, byteOffset, length);\n  };\n});\n},{\"./_typed-array\":233}],373:[function(require,module,exports){\nrequire('./_typed-array')('Uint16', 2, function(init){\n  return function Uint16Array(data, byteOffset, length){\n    return init(this, data, byteOffset, length);\n  };\n});\n},{\"./_typed-array\":233}],374:[function(require,module,exports){\nrequire('./_typed-array')('Uint32', 4, function(init){\n  return function Uint32Array(data, byteOffset, length){\n    return init(this, data, byteOffset, length);\n  };\n});\n},{\"./_typed-array\":233}],375:[function(require,module,exports){\nrequire('./_typed-array')('Uint8', 1, function(init){\n  return function Uint8Array(data, byteOffset, length){\n    return init(this, data, byteOffset, length);\n  };\n});\n},{\"./_typed-array\":233}],376:[function(require,module,exports){\nrequire('./_typed-array')('Uint8', 1, function(init){\n  return function Uint8ClampedArray(data, byteOffset, length){\n    return init(this, data, byteOffset, length);\n  };\n}, true);\n},{\"./_typed-array\":233}],377:[function(require,module,exports){\n'use strict';\nvar each         = require('./_array-methods')(0)\n  , redefine     = require('./_redefine')\n  , meta         = require('./_meta')\n  , assign       = require('./_object-assign')\n  , weak         = require('./_collection-weak')\n  , isObject     = require('./_is-object')\n  , getWeak      = meta.getWeak\n  , isExtensible = Object.isExtensible\n  , uncaughtFrozenStore = weak.ufstore\n  , tmp          = {}\n  , InternalMap;\n\nvar wrapper = function(get){\n  return function WeakMap(){\n    return get(this, arguments.length > 0 ? arguments[0] : undefined);\n  };\n};\n\nvar methods = {\n  // 23.3.3.3 WeakMap.prototype.get(key)\n  get: function get(key){\n    if(isObject(key)){\n      var data = getWeak(key);\n      if(data === true)return uncaughtFrozenStore(this).get(key);\n      return data ? data[this._i] : undefined;\n    }\n  },\n  // 23.3.3.5 WeakMap.prototype.set(key, value)\n  set: function set(key, value){\n    return weak.def(this, key, value);\n  }\n};\n\n// 23.3 WeakMap Objects\nvar $WeakMap = module.exports = require('./_collection')('WeakMap', wrapper, methods, weak, true, true);\n\n// IE11 WeakMap frozen keys fix\nif(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){\n  InternalMap = weak.getConstructor(wrapper);\n  assign(InternalMap.prototype, methods);\n  meta.NEED = true;\n  each(['delete', 'has', 'get', 'set'], function(key){\n    var proto  = $WeakMap.prototype\n      , method = proto[key];\n    redefine(proto, key, function(a, b){\n      // store frozen objects on internal weakmap shim\n      if(isObject(a) && !isExtensible(a)){\n        if(!this._f)this._f = new InternalMap;\n        var result = this._f[key](a, b);\n        return key == 'set' ? this : result;\n      // store all the rest on native weakmap\n      } return method.call(this, a, b);\n    });\n  });\n}\n},{\"./_array-methods\":134,\"./_collection\":144,\"./_collection-weak\":143,\"./_is-object\":171,\"./_meta\":184,\"./_object-assign\":187,\"./_redefine\":209}],378:[function(require,module,exports){\n'use strict';\nvar weak = require('./_collection-weak');\n\n// 23.4 WeakSet Objects\nrequire('./_collection')('WeakSet', function(get){\n  return function WeakSet(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.4.3.1 WeakSet.prototype.add(value)\n  add: function add(value){\n    return weak.def(this, value, true);\n  }\n}, weak, false, true);\n},{\"./_collection\":144,\"./_collection-weak\":143}],379:[function(require,module,exports){\n'use strict';\n// https://github.com/tc39/Array.prototype.includes\nvar $export   = require('./_export')\n  , $includes = require('./_array-includes')(true);\n\n$export($export.P, 'Array', {\n  includes: function includes(el /*, fromIndex = 0 */){\n    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nrequire('./_add-to-unscopables')('includes');\n},{\"./_add-to-unscopables\":127,\"./_array-includes\":133,\"./_export\":154}],380:[function(require,module,exports){\n// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask\nvar $export   = require('./_export')\n  , microtask = require('./_microtask')()\n  , process   = require('./_global').process\n  , isNode    = require('./_cof')(process) == 'process';\n\n$export($export.G, {\n  asap: function asap(fn){\n    var domain = isNode && process.domain;\n    microtask(domain ? domain.bind(fn) : fn);\n  }\n});\n},{\"./_cof\":140,\"./_export\":154,\"./_global\":160,\"./_microtask\":186}],381:[function(require,module,exports){\n// https://github.com/ljharb/proposal-is-error\nvar $export = require('./_export')\n  , cof     = require('./_cof');\n\n$export($export.S, 'Error', {\n  isError: function isError(it){\n    return cof(it) === 'Error';\n  }\n});\n},{\"./_cof\":140,\"./_export\":154}],382:[function(require,module,exports){\n// https://github.com/DavidBruant/Map-Set.prototype.toJSON\nvar $export  = require('./_export');\n\n$export($export.P + $export.R, 'Map', {toJSON: require('./_collection-to-json')('Map')});\n},{\"./_collection-to-json\":142,\"./_export\":154}],383:[function(require,module,exports){\n// https://gist.github.com/BrendanEich/4294d5c212a6d2254703\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  iaddh: function iaddh(x0, x1, y0, y1){\n    var $x0 = x0 >>> 0\n      , $x1 = x1 >>> 0\n      , $y0 = y0 >>> 0;\n    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;\n  }\n});\n},{\"./_export\":154}],384:[function(require,module,exports){\n// https://gist.github.com/BrendanEich/4294d5c212a6d2254703\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  imulh: function imulh(u, v){\n    var UINT16 = 0xffff\n      , $u = +u\n      , $v = +v\n      , u0 = $u & UINT16\n      , v0 = $v & UINT16\n      , u1 = $u >> 16\n      , v1 = $v >> 16\n      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);\n    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);\n  }\n});\n},{\"./_export\":154}],385:[function(require,module,exports){\n// https://gist.github.com/BrendanEich/4294d5c212a6d2254703\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  isubh: function isubh(x0, x1, y0, y1){\n    var $x0 = x0 >>> 0\n      , $x1 = x1 >>> 0\n      , $y0 = y0 >>> 0;\n    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;\n  }\n});\n},{\"./_export\":154}],386:[function(require,module,exports){\n// https://gist.github.com/BrendanEich/4294d5c212a6d2254703\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  umulh: function umulh(u, v){\n    var UINT16 = 0xffff\n      , $u = +u\n      , $v = +v\n      , u0 = $u & UINT16\n      , v0 = $v & UINT16\n      , u1 = $u >>> 16\n      , v1 = $v >>> 16\n      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);\n    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);\n  }\n});\n},{\"./_export\":154}],387:[function(require,module,exports){\n'use strict';\nvar $export         = require('./_export')\n  , toObject        = require('./_to-object')\n  , aFunction       = require('./_a-function')\n  , $defineProperty = require('./_object-dp');\n\n// B.2.2.2 Object.prototype.__defineGetter__(P, getter)\nrequire('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {\n  __defineGetter__: function __defineGetter__(P, getter){\n    $defineProperty.f(toObject(this), P, {get: aFunction(getter), enumerable: true, configurable: true});\n  }\n});\n},{\"./_a-function\":125,\"./_descriptors\":150,\"./_export\":154,\"./_object-dp\":189,\"./_object-forced-pam\":191,\"./_to-object\":231}],388:[function(require,module,exports){\n'use strict';\nvar $export         = require('./_export')\n  , toObject        = require('./_to-object')\n  , aFunction       = require('./_a-function')\n  , $defineProperty = require('./_object-dp');\n\n// B.2.2.3 Object.prototype.__defineSetter__(P, setter)\nrequire('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {\n  __defineSetter__: function __defineSetter__(P, setter){\n    $defineProperty.f(toObject(this), P, {set: aFunction(setter), enumerable: true, configurable: true});\n  }\n});\n},{\"./_a-function\":125,\"./_descriptors\":150,\"./_export\":154,\"./_object-dp\":189,\"./_object-forced-pam\":191,\"./_to-object\":231}],389:[function(require,module,exports){\n// https://github.com/tc39/proposal-object-values-entries\nvar $export  = require('./_export')\n  , $entries = require('./_object-to-array')(true);\n\n$export($export.S, 'Object', {\n  entries: function entries(it){\n    return $entries(it);\n  }\n});\n},{\"./_export\":154,\"./_object-to-array\":201}],390:[function(require,module,exports){\n// https://github.com/tc39/proposal-object-getownpropertydescriptors\nvar $export        = require('./_export')\n  , ownKeys        = require('./_own-keys')\n  , toIObject      = require('./_to-iobject')\n  , gOPD           = require('./_object-gopd')\n  , createProperty = require('./_create-property');\n\n$export($export.S, 'Object', {\n  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){\n    var O       = toIObject(object)\n      , getDesc = gOPD.f\n      , keys    = ownKeys(O)\n      , result  = {}\n      , i       = 0\n      , key;\n    while(keys.length > i)createProperty(result, key = keys[i++], getDesc(O, key));\n    return result;\n  }\n});\n},{\"./_create-property\":146,\"./_export\":154,\"./_object-gopd\":192,\"./_own-keys\":202,\"./_to-iobject\":229}],391:[function(require,module,exports){\n'use strict';\nvar $export                  = require('./_export')\n  , toObject                 = require('./_to-object')\n  , toPrimitive              = require('./_to-primitive')\n  , getPrototypeOf           = require('./_object-gpo')\n  , getOwnPropertyDescriptor = require('./_object-gopd').f;\n\n// B.2.2.4 Object.prototype.__lookupGetter__(P)\nrequire('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {\n  __lookupGetter__: function __lookupGetter__(P){\n    var O = toObject(this)\n      , K = toPrimitive(P, true)\n      , D;\n    do {\n      if(D = getOwnPropertyDescriptor(O, K))return D.get;\n    } while(O = getPrototypeOf(O));\n  }\n});\n},{\"./_descriptors\":150,\"./_export\":154,\"./_object-forced-pam\":191,\"./_object-gopd\":192,\"./_object-gpo\":196,\"./_to-object\":231,\"./_to-primitive\":232}],392:[function(require,module,exports){\n'use strict';\nvar $export                  = require('./_export')\n  , toObject                 = require('./_to-object')\n  , toPrimitive              = require('./_to-primitive')\n  , getPrototypeOf           = require('./_object-gpo')\n  , getOwnPropertyDescriptor = require('./_object-gopd').f;\n\n// B.2.2.5 Object.prototype.__lookupSetter__(P)\nrequire('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {\n  __lookupSetter__: function __lookupSetter__(P){\n    var O = toObject(this)\n      , K = toPrimitive(P, true)\n      , D;\n    do {\n      if(D = getOwnPropertyDescriptor(O, K))return D.set;\n    } while(O = getPrototypeOf(O));\n  }\n});\n},{\"./_descriptors\":150,\"./_export\":154,\"./_object-forced-pam\":191,\"./_object-gopd\":192,\"./_object-gpo\":196,\"./_to-object\":231,\"./_to-primitive\":232}],393:[function(require,module,exports){\n// https://github.com/tc39/proposal-object-values-entries\nvar $export = require('./_export')\n  , $values = require('./_object-to-array')(false);\n\n$export($export.S, 'Object', {\n  values: function values(it){\n    return $values(it);\n  }\n});\n},{\"./_export\":154,\"./_object-to-array\":201}],394:[function(require,module,exports){\n'use strict';\n// https://github.com/zenparsing/es-observable\nvar $export     = require('./_export')\n  , global      = require('./_global')\n  , core        = require('./_core')\n  , microtask   = require('./_microtask')()\n  , OBSERVABLE  = require('./_wks')('observable')\n  , aFunction   = require('./_a-function')\n  , anObject    = require('./_an-object')\n  , anInstance  = require('./_an-instance')\n  , redefineAll = require('./_redefine-all')\n  , hide        = require('./_hide')\n  , forOf       = require('./_for-of')\n  , RETURN      = forOf.RETURN;\n\nvar getMethod = function(fn){\n  return fn == null ? undefined : aFunction(fn);\n};\n\nvar cleanupSubscription = function(subscription){\n  var cleanup = subscription._c;\n  if(cleanup){\n    subscription._c = undefined;\n    cleanup();\n  }\n};\n\nvar subscriptionClosed = function(subscription){\n  return subscription._o === undefined;\n};\n\nvar closeSubscription = function(subscription){\n  if(!subscriptionClosed(subscription)){\n    subscription._o = undefined;\n    cleanupSubscription(subscription);\n  }\n};\n\nvar Subscription = function(observer, subscriber){\n  anObject(observer);\n  this._c = undefined;\n  this._o = observer;\n  observer = new SubscriptionObserver(this);\n  try {\n    var cleanup      = subscriber(observer)\n      , subscription = cleanup;\n    if(cleanup != null){\n      if(typeof cleanup.unsubscribe === 'function')cleanup = function(){ subscription.unsubscribe(); };\n      else aFunction(cleanup);\n      this._c = cleanup;\n    }\n  } catch(e){\n    observer.error(e);\n    return;\n  } if(subscriptionClosed(this))cleanupSubscription(this);\n};\n\nSubscription.prototype = redefineAll({}, {\n  unsubscribe: function unsubscribe(){ closeSubscription(this); }\n});\n\nvar SubscriptionObserver = function(subscription){\n  this._s = subscription;\n};\n\nSubscriptionObserver.prototype = redefineAll({}, {\n  next: function next(value){\n    var subscription = this._s;\n    if(!subscriptionClosed(subscription)){\n      var observer = subscription._o;\n      try {\n        var m = getMethod(observer.next);\n        if(m)return m.call(observer, value);\n      } catch(e){\n        try {\n          closeSubscription(subscription);\n        } finally {\n          throw e;\n        }\n      }\n    }\n  },\n  error: function error(value){\n    var subscription = this._s;\n    if(subscriptionClosed(subscription))throw value;\n    var observer = subscription._o;\n    subscription._o = undefined;\n    try {\n      var m = getMethod(observer.error);\n      if(!m)throw value;\n      value = m.call(observer, value);\n    } catch(e){\n      try {\n        cleanupSubscription(subscription);\n      } finally {\n        throw e;\n      }\n    } cleanupSubscription(subscription);\n    return value;\n  },\n  complete: function complete(value){\n    var subscription = this._s;\n    if(!subscriptionClosed(subscription)){\n      var observer = subscription._o;\n      subscription._o = undefined;\n      try {\n        var m = getMethod(observer.complete);\n        value = m ? m.call(observer, value) : undefined;\n      } catch(e){\n        try {\n          cleanupSubscription(subscription);\n        } finally {\n          throw e;\n        }\n      } cleanupSubscription(subscription);\n      return value;\n    }\n  }\n});\n\nvar $Observable = function Observable(subscriber){\n  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);\n};\n\nredefineAll($Observable.prototype, {\n  subscribe: function subscribe(observer){\n    return new Subscription(observer, this._f);\n  },\n  forEach: function forEach(fn){\n    var that = this;\n    return new (core.Promise || global.Promise)(function(resolve, reject){\n      aFunction(fn);\n      var subscription = that.subscribe({\n        next : function(value){\n          try {\n            return fn(value);\n          } catch(e){\n            reject(e);\n            subscription.unsubscribe();\n          }\n        },\n        error: reject,\n        complete: resolve\n      });\n    });\n  }\n});\n\nredefineAll($Observable, {\n  from: function from(x){\n    var C = typeof this === 'function' ? this : $Observable;\n    var method = getMethod(anObject(x)[OBSERVABLE]);\n    if(method){\n      var observable = anObject(method.call(x));\n      return observable.constructor === C ? observable : new C(function(observer){\n        return observable.subscribe(observer);\n      });\n    }\n    return new C(function(observer){\n      var done = false;\n      microtask(function(){\n        if(!done){\n          try {\n            if(forOf(x, false, function(it){\n              observer.next(it);\n              if(done)return RETURN;\n            }) === RETURN)return;\n          } catch(e){\n            if(done)throw e;\n            observer.error(e);\n            return;\n          } observer.complete();\n        }\n      });\n      return function(){ done = true; };\n    });\n  },\n  of: function of(){\n    for(var i = 0, l = arguments.length, items = Array(l); i < l;)items[i] = arguments[i++];\n    return new (typeof this === 'function' ? this : $Observable)(function(observer){\n      var done = false;\n      microtask(function(){\n        if(!done){\n          for(var i = 0; i < items.length; ++i){\n            observer.next(items[i]);\n            if(done)return;\n          } observer.complete();\n        }\n      });\n      return function(){ done = true; };\n    });\n  }\n});\n\nhide($Observable.prototype, OBSERVABLE, function(){ return this; });\n\n$export($export.G, {Observable: $Observable});\n\nrequire('./_set-species')('Observable');\n},{\"./_a-function\":125,\"./_an-instance\":128,\"./_an-object\":129,\"./_core\":145,\"./_export\":154,\"./_for-of\":159,\"./_global\":160,\"./_hide\":162,\"./_microtask\":186,\"./_redefine-all\":208,\"./_set-species\":213,\"./_wks\":239}],395:[function(require,module,exports){\nvar metadata                  = require('./_metadata')\n  , anObject                  = require('./_an-object')\n  , toMetaKey                 = metadata.key\n  , ordinaryDefineOwnMetadata = metadata.set;\n\nmetadata.exp({defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey){\n  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));\n}});\n},{\"./_an-object\":129,\"./_metadata\":185}],396:[function(require,module,exports){\nvar metadata               = require('./_metadata')\n  , anObject               = require('./_an-object')\n  , toMetaKey              = metadata.key\n  , getOrCreateMetadataMap = metadata.map\n  , store                  = metadata.store;\n\nmetadata.exp({deleteMetadata: function deleteMetadata(metadataKey, target /*, targetKey */){\n  var targetKey   = arguments.length < 3 ? undefined : toMetaKey(arguments[2])\n    , metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);\n  if(metadataMap === undefined || !metadataMap['delete'](metadataKey))return false;\n  if(metadataMap.size)return true;\n  var targetMetadata = store.get(target);\n  targetMetadata['delete'](targetKey);\n  return !!targetMetadata.size || store['delete'](target);\n}});\n},{\"./_an-object\":129,\"./_metadata\":185}],397:[function(require,module,exports){\nvar Set                     = require('./es6.set')\n  , from                    = require('./_array-from-iterable')\n  , metadata                = require('./_metadata')\n  , anObject                = require('./_an-object')\n  , getPrototypeOf          = require('./_object-gpo')\n  , ordinaryOwnMetadataKeys = metadata.keys\n  , toMetaKey               = metadata.key;\n\nvar ordinaryMetadataKeys = function(O, P){\n  var oKeys  = ordinaryOwnMetadataKeys(O, P)\n    , parent = getPrototypeOf(O);\n  if(parent === null)return oKeys;\n  var pKeys  = ordinaryMetadataKeys(parent, P);\n  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;\n};\n\nmetadata.exp({getMetadataKeys: function getMetadataKeys(target /*, targetKey */){\n  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));\n}});\n},{\"./_an-object\":129,\"./_array-from-iterable\":132,\"./_metadata\":185,\"./_object-gpo\":196,\"./es6.set\":342}],398:[function(require,module,exports){\nvar metadata               = require('./_metadata')\n  , anObject               = require('./_an-object')\n  , getPrototypeOf         = require('./_object-gpo')\n  , ordinaryHasOwnMetadata = metadata.has\n  , ordinaryGetOwnMetadata = metadata.get\n  , toMetaKey              = metadata.key;\n\nvar ordinaryGetMetadata = function(MetadataKey, O, P){\n  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);\n  if(hasOwn)return ordinaryGetOwnMetadata(MetadataKey, O, P);\n  var parent = getPrototypeOf(O);\n  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;\n};\n\nmetadata.exp({getMetadata: function getMetadata(metadataKey, target /*, targetKey */){\n  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));\n}});\n},{\"./_an-object\":129,\"./_metadata\":185,\"./_object-gpo\":196}],399:[function(require,module,exports){\nvar metadata                = require('./_metadata')\n  , anObject                = require('./_an-object')\n  , ordinaryOwnMetadataKeys = metadata.keys\n  , toMetaKey               = metadata.key;\n\nmetadata.exp({getOwnMetadataKeys: function getOwnMetadataKeys(target /*, targetKey */){\n  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));\n}});\n},{\"./_an-object\":129,\"./_metadata\":185}],400:[function(require,module,exports){\nvar metadata               = require('./_metadata')\n  , anObject               = require('./_an-object')\n  , ordinaryGetOwnMetadata = metadata.get\n  , toMetaKey              = metadata.key;\n\nmetadata.exp({getOwnMetadata: function getOwnMetadata(metadataKey, target /*, targetKey */){\n  return ordinaryGetOwnMetadata(metadataKey, anObject(target)\n    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));\n}});\n},{\"./_an-object\":129,\"./_metadata\":185}],401:[function(require,module,exports){\nvar metadata               = require('./_metadata')\n  , anObject               = require('./_an-object')\n  , getPrototypeOf         = require('./_object-gpo')\n  , ordinaryHasOwnMetadata = metadata.has\n  , toMetaKey              = metadata.key;\n\nvar ordinaryHasMetadata = function(MetadataKey, O, P){\n  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);\n  if(hasOwn)return true;\n  var parent = getPrototypeOf(O);\n  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;\n};\n\nmetadata.exp({hasMetadata: function hasMetadata(metadataKey, target /*, targetKey */){\n  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));\n}});\n},{\"./_an-object\":129,\"./_metadata\":185,\"./_object-gpo\":196}],402:[function(require,module,exports){\nvar metadata               = require('./_metadata')\n  , anObject               = require('./_an-object')\n  , ordinaryHasOwnMetadata = metadata.has\n  , toMetaKey              = metadata.key;\n\nmetadata.exp({hasOwnMetadata: function hasOwnMetadata(metadataKey, target /*, targetKey */){\n  return ordinaryHasOwnMetadata(metadataKey, anObject(target)\n    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));\n}});\n},{\"./_an-object\":129,\"./_metadata\":185}],403:[function(require,module,exports){\nvar metadata                  = require('./_metadata')\n  , anObject                  = require('./_an-object')\n  , aFunction                 = require('./_a-function')\n  , toMetaKey                 = metadata.key\n  , ordinaryDefineOwnMetadata = metadata.set;\n\nmetadata.exp({metadata: function metadata(metadataKey, metadataValue){\n  return function decorator(target, targetKey){\n    ordinaryDefineOwnMetadata(\n      metadataKey, metadataValue,\n      (targetKey !== undefined ? anObject : aFunction)(target),\n      toMetaKey(targetKey)\n    );\n  };\n}});\n},{\"./_a-function\":125,\"./_an-object\":129,\"./_metadata\":185}],404:[function(require,module,exports){\n// https://github.com/DavidBruant/Map-Set.prototype.toJSON\nvar $export  = require('./_export');\n\n$export($export.P + $export.R, 'Set', {toJSON: require('./_collection-to-json')('Set')});\n},{\"./_collection-to-json\":142,\"./_export\":154}],405:[function(require,module,exports){\n'use strict';\n// https://github.com/mathiasbynens/String.prototype.at\nvar $export = require('./_export')\n  , $at     = require('./_string-at')(true);\n\n$export($export.P, 'String', {\n  at: function at(pos){\n    return $at(this, pos);\n  }\n});\n},{\"./_export\":154,\"./_string-at\":219}],406:[function(require,module,exports){\n'use strict';\n// https://tc39.github.io/String.prototype.matchAll/\nvar $export     = require('./_export')\n  , defined     = require('./_defined')\n  , toLength    = require('./_to-length')\n  , isRegExp    = require('./_is-regexp')\n  , getFlags    = require('./_flags')\n  , RegExpProto = RegExp.prototype;\n\nvar $RegExpStringIterator = function(regexp, string){\n  this._r = regexp;\n  this._s = string;\n};\n\nrequire('./_iter-create')($RegExpStringIterator, 'RegExp String', function next(){\n  var match = this._r.exec(this._s);\n  return {value: match, done: match === null};\n});\n\n$export($export.P, 'String', {\n  matchAll: function matchAll(regexp){\n    defined(this);\n    if(!isRegExp(regexp))throw TypeError(regexp + ' is not a regexp!');\n    var S     = String(this)\n      , flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp)\n      , rx    = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);\n    rx.lastIndex = toLength(regexp.lastIndex);\n    return new $RegExpStringIterator(rx, S);\n  }\n});\n},{\"./_defined\":149,\"./_export\":154,\"./_flags\":158,\"./_is-regexp\":172,\"./_iter-create\":174,\"./_to-length\":230}],407:[function(require,module,exports){\n'use strict';\n// https://github.com/tc39/proposal-string-pad-start-end\nvar $export = require('./_export')\n  , $pad    = require('./_string-pad');\n\n$export($export.P, 'String', {\n  padEnd: function padEnd(maxLength /*, fillString = ' ' */){\n    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);\n  }\n});\n},{\"./_export\":154,\"./_string-pad\":222}],408:[function(require,module,exports){\n'use strict';\n// https://github.com/tc39/proposal-string-pad-start-end\nvar $export = require('./_export')\n  , $pad    = require('./_string-pad');\n\n$export($export.P, 'String', {\n  padStart: function padStart(maxLength /*, fillString = ' ' */){\n    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);\n  }\n});\n},{\"./_export\":154,\"./_string-pad\":222}],409:[function(require,module,exports){\n'use strict';\n// https://github.com/sebmarkbage/ecmascript-string-left-right-trim\nrequire('./_string-trim')('trimLeft', function($trim){\n  return function trimLeft(){\n    return $trim(this, 1);\n  };\n}, 'trimStart');\n},{\"./_string-trim\":224}],410:[function(require,module,exports){\n'use strict';\n// https://github.com/sebmarkbage/ecmascript-string-left-right-trim\nrequire('./_string-trim')('trimRight', function($trim){\n  return function trimRight(){\n    return $trim(this, 2);\n  };\n}, 'trimEnd');\n},{\"./_string-trim\":224}],411:[function(require,module,exports){\narguments[4][122][0].apply(exports,arguments)\n},{\"./_wks-define\":237,\"dup\":122}],412:[function(require,module,exports){\narguments[4][123][0].apply(exports,arguments)\n},{\"./_wks-define\":237,\"dup\":123}],413:[function(require,module,exports){\n// https://github.com/ljharb/proposal-global\nvar $export = require('./_export');\n\n$export($export.S, 'System', {global: require('./_global')});\n},{\"./_export\":154,\"./_global\":160}],414:[function(require,module,exports){\nvar $iterators    = require('./es6.array.iterator')\n  , redefine      = require('./_redefine')\n  , global        = require('./_global')\n  , hide          = require('./_hide')\n  , Iterators     = require('./_iterators')\n  , wks           = require('./_wks')\n  , ITERATOR      = wks('iterator')\n  , TO_STRING_TAG = wks('toStringTag')\n  , ArrayValues   = Iterators.Array;\n\nfor(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){\n  var NAME       = collections[i]\n    , Collection = global[NAME]\n    , proto      = Collection && Collection.prototype\n    , key;\n  if(proto){\n    if(!proto[ITERATOR])hide(proto, ITERATOR, ArrayValues);\n    if(!proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);\n    Iterators[NAME] = ArrayValues;\n    for(key in $iterators)if(!proto[key])redefine(proto, key, $iterators[key], true);\n  }\n}\n},{\"./_global\":160,\"./_hide\":162,\"./_iterators\":178,\"./_redefine\":209,\"./_wks\":239,\"./es6.array.iterator\":252}],415:[function(require,module,exports){\nvar $export = require('./_export')\n  , $task   = require('./_task');\n$export($export.G + $export.B, {\n  setImmediate:   $task.set,\n  clearImmediate: $task.clear\n});\n},{\"./_export\":154,\"./_task\":226}],416:[function(require,module,exports){\n// ie9- setTimeout & setInterval additional parameters fix\nvar global     = require('./_global')\n  , $export    = require('./_export')\n  , invoke     = require('./_invoke')\n  , partial    = require('./_partial')\n  , navigator  = global.navigator\n  , MSIE       = !!navigator && /MSIE .\\./.test(navigator.userAgent); // <- dirty ie9- check\nvar wrap = function(set){\n  return MSIE ? function(fn, time /*, ...args */){\n    return set(invoke(\n      partial,\n      [].slice.call(arguments, 2),\n      typeof fn == 'function' ? fn : Function(fn)\n    ), time);\n  } : set;\n};\n$export($export.G + $export.B + $export.F * MSIE, {\n  setTimeout:  wrap(global.setTimeout),\n  setInterval: wrap(global.setInterval)\n});\n},{\"./_export\":154,\"./_global\":160,\"./_invoke\":166,\"./_partial\":205}],417:[function(require,module,exports){\nrequire('./modules/es6.symbol');\nrequire('./modules/es6.object.create');\nrequire('./modules/es6.object.define-property');\nrequire('./modules/es6.object.define-properties');\nrequire('./modules/es6.object.get-own-property-descriptor');\nrequire('./modules/es6.object.get-prototype-of');\nrequire('./modules/es6.object.keys');\nrequire('./modules/es6.object.get-own-property-names');\nrequire('./modules/es6.object.freeze');\nrequire('./modules/es6.object.seal');\nrequire('./modules/es6.object.prevent-extensions');\nrequire('./modules/es6.object.is-frozen');\nrequire('./modules/es6.object.is-sealed');\nrequire('./modules/es6.object.is-extensible');\nrequire('./modules/es6.object.assign');\nrequire('./modules/es6.object.is');\nrequire('./modules/es6.object.set-prototype-of');\nrequire('./modules/es6.object.to-string');\nrequire('./modules/es6.function.bind');\nrequire('./modules/es6.function.name');\nrequire('./modules/es6.function.has-instance');\nrequire('./modules/es6.parse-int');\nrequire('./modules/es6.parse-float');\nrequire('./modules/es6.number.constructor');\nrequire('./modules/es6.number.to-fixed');\nrequire('./modules/es6.number.to-precision');\nrequire('./modules/es6.number.epsilon');\nrequire('./modules/es6.number.is-finite');\nrequire('./modules/es6.number.is-integer');\nrequire('./modules/es6.number.is-nan');\nrequire('./modules/es6.number.is-safe-integer');\nrequire('./modules/es6.number.max-safe-integer');\nrequire('./modules/es6.number.min-safe-integer');\nrequire('./modules/es6.number.parse-float');\nrequire('./modules/es6.number.parse-int');\nrequire('./modules/es6.math.acosh');\nrequire('./modules/es6.math.asinh');\nrequire('./modules/es6.math.atanh');\nrequire('./modules/es6.math.cbrt');\nrequire('./modules/es6.math.clz32');\nrequire('./modules/es6.math.cosh');\nrequire('./modules/es6.math.expm1');\nrequire('./modules/es6.math.fround');\nrequire('./modules/es6.math.hypot');\nrequire('./modules/es6.math.imul');\nrequire('./modules/es6.math.log10');\nrequire('./modules/es6.math.log1p');\nrequire('./modules/es6.math.log2');\nrequire('./modules/es6.math.sign');\nrequire('./modules/es6.math.sinh');\nrequire('./modules/es6.math.tanh');\nrequire('./modules/es6.math.trunc');\nrequire('./modules/es6.string.from-code-point');\nrequire('./modules/es6.string.raw');\nrequire('./modules/es6.string.trim');\nrequire('./modules/es6.string.iterator');\nrequire('./modules/es6.string.code-point-at');\nrequire('./modules/es6.string.ends-with');\nrequire('./modules/es6.string.includes');\nrequire('./modules/es6.string.repeat');\nrequire('./modules/es6.string.starts-with');\nrequire('./modules/es6.string.anchor');\nrequire('./modules/es6.string.big');\nrequire('./modules/es6.string.blink');\nrequire('./modules/es6.string.bold');\nrequire('./modules/es6.string.fixed');\nrequire('./modules/es6.string.fontcolor');\nrequire('./modules/es6.string.fontsize');\nrequire('./modules/es6.string.italics');\nrequire('./modules/es6.string.link');\nrequire('./modules/es6.string.small');\nrequire('./modules/es6.string.strike');\nrequire('./modules/es6.string.sub');\nrequire('./modules/es6.string.sup');\nrequire('./modules/es6.date.now');\nrequire('./modules/es6.date.to-json');\nrequire('./modules/es6.date.to-iso-string');\nrequire('./modules/es6.date.to-string');\nrequire('./modules/es6.date.to-primitive');\nrequire('./modules/es6.array.is-array');\nrequire('./modules/es6.array.from');\nrequire('./modules/es6.array.of');\nrequire('./modules/es6.array.join');\nrequire('./modules/es6.array.slice');\nrequire('./modules/es6.array.sort');\nrequire('./modules/es6.array.for-each');\nrequire('./modules/es6.array.map');\nrequire('./modules/es6.array.filter');\nrequire('./modules/es6.array.some');\nrequire('./modules/es6.array.every');\nrequire('./modules/es6.array.reduce');\nrequire('./modules/es6.array.reduce-right');\nrequire('./modules/es6.array.index-of');\nrequire('./modules/es6.array.last-index-of');\nrequire('./modules/es6.array.copy-within');\nrequire('./modules/es6.array.fill');\nrequire('./modules/es6.array.find');\nrequire('./modules/es6.array.find-index');\nrequire('./modules/es6.array.species');\nrequire('./modules/es6.array.iterator');\nrequire('./modules/es6.regexp.constructor');\nrequire('./modules/es6.regexp.to-string');\nrequire('./modules/es6.regexp.flags');\nrequire('./modules/es6.regexp.match');\nrequire('./modules/es6.regexp.replace');\nrequire('./modules/es6.regexp.search');\nrequire('./modules/es6.regexp.split');\nrequire('./modules/es6.promise');\nrequire('./modules/es6.map');\nrequire('./modules/es6.set');\nrequire('./modules/es6.weak-map');\nrequire('./modules/es6.weak-set');\nrequire('./modules/es6.typed.array-buffer');\nrequire('./modules/es6.typed.data-view');\nrequire('./modules/es6.typed.int8-array');\nrequire('./modules/es6.typed.uint8-array');\nrequire('./modules/es6.typed.uint8-clamped-array');\nrequire('./modules/es6.typed.int16-array');\nrequire('./modules/es6.typed.uint16-array');\nrequire('./modules/es6.typed.int32-array');\nrequire('./modules/es6.typed.uint32-array');\nrequire('./modules/es6.typed.float32-array');\nrequire('./modules/es6.typed.float64-array');\nrequire('./modules/es6.reflect.apply');\nrequire('./modules/es6.reflect.construct');\nrequire('./modules/es6.reflect.define-property');\nrequire('./modules/es6.reflect.delete-property');\nrequire('./modules/es6.reflect.enumerate');\nrequire('./modules/es6.reflect.get');\nrequire('./modules/es6.reflect.get-own-property-descriptor');\nrequire('./modules/es6.reflect.get-prototype-of');\nrequire('./modules/es6.reflect.has');\nrequire('./modules/es6.reflect.is-extensible');\nrequire('./modules/es6.reflect.own-keys');\nrequire('./modules/es6.reflect.prevent-extensions');\nrequire('./modules/es6.reflect.set');\nrequire('./modules/es6.reflect.set-prototype-of');\nrequire('./modules/es7.array.includes');\nrequire('./modules/es7.string.at');\nrequire('./modules/es7.string.pad-start');\nrequire('./modules/es7.string.pad-end');\nrequire('./modules/es7.string.trim-left');\nrequire('./modules/es7.string.trim-right');\nrequire('./modules/es7.string.match-all');\nrequire('./modules/es7.symbol.async-iterator');\nrequire('./modules/es7.symbol.observable');\nrequire('./modules/es7.object.get-own-property-descriptors');\nrequire('./modules/es7.object.values');\nrequire('./modules/es7.object.entries');\nrequire('./modules/es7.object.define-getter');\nrequire('./modules/es7.object.define-setter');\nrequire('./modules/es7.object.lookup-getter');\nrequire('./modules/es7.object.lookup-setter');\nrequire('./modules/es7.map.to-json');\nrequire('./modules/es7.set.to-json');\nrequire('./modules/es7.system.global');\nrequire('./modules/es7.error.is-error');\nrequire('./modules/es7.math.iaddh');\nrequire('./modules/es7.math.isubh');\nrequire('./modules/es7.math.imulh');\nrequire('./modules/es7.math.umulh');\nrequire('./modules/es7.reflect.define-metadata');\nrequire('./modules/es7.reflect.delete-metadata');\nrequire('./modules/es7.reflect.get-metadata');\nrequire('./modules/es7.reflect.get-metadata-keys');\nrequire('./modules/es7.reflect.get-own-metadata');\nrequire('./modules/es7.reflect.get-own-metadata-keys');\nrequire('./modules/es7.reflect.has-metadata');\nrequire('./modules/es7.reflect.has-own-metadata');\nrequire('./modules/es7.reflect.metadata');\nrequire('./modules/es7.asap');\nrequire('./modules/es7.observable');\nrequire('./modules/web.timers');\nrequire('./modules/web.immediate');\nrequire('./modules/web.dom.iterable');\nmodule.exports = require('./modules/_core');\n},{\"./modules/_core\":145,\"./modules/es6.array.copy-within\":242,\"./modules/es6.array.every\":243,\"./modules/es6.array.fill\":244,\"./modules/es6.array.filter\":245,\"./modules/es6.array.find\":247,\"./modules/es6.array.find-index\":246,\"./modules/es6.array.for-each\":248,\"./modules/es6.array.from\":249,\"./modules/es6.array.index-of\":250,\"./modules/es6.array.is-array\":251,\"./modules/es6.array.iterator\":252,\"./modules/es6.array.join\":253,\"./modules/es6.array.last-index-of\":254,\"./modules/es6.array.map\":255,\"./modules/es6.array.of\":256,\"./modules/es6.array.reduce\":258,\"./modules/es6.array.reduce-right\":257,\"./modules/es6.array.slice\":259,\"./modules/es6.array.some\":260,\"./modules/es6.array.sort\":261,\"./modules/es6.array.species\":262,\"./modules/es6.date.now\":263,\"./modules/es6.date.to-iso-string\":264,\"./modules/es6.date.to-json\":265,\"./modules/es6.date.to-primitive\":266,\"./modules/es6.date.to-string\":267,\"./modules/es6.function.bind\":268,\"./modules/es6.function.has-instance\":269,\"./modules/es6.function.name\":270,\"./modules/es6.map\":271,\"./modules/es6.math.acosh\":272,\"./modules/es6.math.asinh\":273,\"./modules/es6.math.atanh\":274,\"./modules/es6.math.cbrt\":275,\"./modules/es6.math.clz32\":276,\"./modules/es6.math.cosh\":277,\"./modules/es6.math.expm1\":278,\"./modules/es6.math.fround\":279,\"./modules/es6.math.hypot\":280,\"./modules/es6.math.imul\":281,\"./modules/es6.math.log10\":282,\"./modules/es6.math.log1p\":283,\"./modules/es6.math.log2\":284,\"./modules/es6.math.sign\":285,\"./modules/es6.math.sinh\":286,\"./modules/es6.math.tanh\":287,\"./modules/es6.math.trunc\":288,\"./modules/es6.number.constructor\":289,\"./modules/es6.number.epsilon\":290,\"./modules/es6.number.is-finite\":291,\"./modules/es6.number.is-integer\":292,\"./modules/es6.number.is-nan\":293,\"./modules/es6.number.is-safe-integer\":294,\"./modules/es6.number.max-safe-integer\":295,\"./modules/es6.number.min-safe-integer\":296,\"./modules/es6.number.parse-float\":297,\"./modules/es6.number.parse-int\":298,\"./modules/es6.number.to-fixed\":299,\"./modules/es6.number.to-precision\":300,\"./modules/es6.object.assign\":301,\"./modules/es6.object.create\":302,\"./modules/es6.object.define-properties\":303,\"./modules/es6.object.define-property\":304,\"./modules/es6.object.freeze\":305,\"./modules/es6.object.get-own-property-descriptor\":306,\"./modules/es6.object.get-own-property-names\":307,\"./modules/es6.object.get-prototype-of\":308,\"./modules/es6.object.is\":312,\"./modules/es6.object.is-extensible\":309,\"./modules/es6.object.is-frozen\":310,\"./modules/es6.object.is-sealed\":311,\"./modules/es6.object.keys\":313,\"./modules/es6.object.prevent-extensions\":314,\"./modules/es6.object.seal\":315,\"./modules/es6.object.set-prototype-of\":316,\"./modules/es6.object.to-string\":317,\"./modules/es6.parse-float\":318,\"./modules/es6.parse-int\":319,\"./modules/es6.promise\":320,\"./modules/es6.reflect.apply\":321,\"./modules/es6.reflect.construct\":322,\"./modules/es6.reflect.define-property\":323,\"./modules/es6.reflect.delete-property\":324,\"./modules/es6.reflect.enumerate\":325,\"./modules/es6.reflect.get\":328,\"./modules/es6.reflect.get-own-property-descriptor\":326,\"./modules/es6.reflect.get-prototype-of\":327,\"./modules/es6.reflect.has\":329,\"./modules/es6.reflect.is-extensible\":330,\"./modules/es6.reflect.own-keys\":331,\"./modules/es6.reflect.prevent-extensions\":332,\"./modules/es6.reflect.set\":334,\"./modules/es6.reflect.set-prototype-of\":333,\"./modules/es6.regexp.constructor\":335,\"./modules/es6.regexp.flags\":336,\"./modules/es6.regexp.match\":337,\"./modules/es6.regexp.replace\":338,\"./modules/es6.regexp.search\":339,\"./modules/es6.regexp.split\":340,\"./modules/es6.regexp.to-string\":341,\"./modules/es6.set\":342,\"./modules/es6.string.anchor\":343,\"./modules/es6.string.big\":344,\"./modules/es6.string.blink\":345,\"./modules/es6.string.bold\":346,\"./modules/es6.string.code-point-at\":347,\"./modules/es6.string.ends-with\":348,\"./modules/es6.string.fixed\":349,\"./modules/es6.string.fontcolor\":350,\"./modules/es6.string.fontsize\":351,\"./modules/es6.string.from-code-point\":352,\"./modules/es6.string.includes\":353,\"./modules/es6.string.italics\":354,\"./modules/es6.string.iterator\":355,\"./modules/es6.string.link\":356,\"./modules/es6.string.raw\":357,\"./modules/es6.string.repeat\":358,\"./modules/es6.string.small\":359,\"./modules/es6.string.starts-with\":360,\"./modules/es6.string.strike\":361,\"./modules/es6.string.sub\":362,\"./modules/es6.string.sup\":363,\"./modules/es6.string.trim\":364,\"./modules/es6.symbol\":365,\"./modules/es6.typed.array-buffer\":366,\"./modules/es6.typed.data-view\":367,\"./modules/es6.typed.float32-array\":368,\"./modules/es6.typed.float64-array\":369,\"./modules/es6.typed.int16-array\":370,\"./modules/es6.typed.int32-array\":371,\"./modules/es6.typed.int8-array\":372,\"./modules/es6.typed.uint16-array\":373,\"./modules/es6.typed.uint32-array\":374,\"./modules/es6.typed.uint8-array\":375,\"./modules/es6.typed.uint8-clamped-array\":376,\"./modules/es6.weak-map\":377,\"./modules/es6.weak-set\":378,\"./modules/es7.array.includes\":379,\"./modules/es7.asap\":380,\"./modules/es7.error.is-error\":381,\"./modules/es7.map.to-json\":382,\"./modules/es7.math.iaddh\":383,\"./modules/es7.math.imulh\":384,\"./modules/es7.math.isubh\":385,\"./modules/es7.math.umulh\":386,\"./modules/es7.object.define-getter\":387,\"./modules/es7.object.define-setter\":388,\"./modules/es7.object.entries\":389,\"./modules/es7.object.get-own-property-descriptors\":390,\"./modules/es7.object.lookup-getter\":391,\"./modules/es7.object.lookup-setter\":392,\"./modules/es7.object.values\":393,\"./modules/es7.observable\":394,\"./modules/es7.reflect.define-metadata\":395,\"./modules/es7.reflect.delete-metadata\":396,\"./modules/es7.reflect.get-metadata\":398,\"./modules/es7.reflect.get-metadata-keys\":397,\"./modules/es7.reflect.get-own-metadata\":400,\"./modules/es7.reflect.get-own-metadata-keys\":399,\"./modules/es7.reflect.has-metadata\":401,\"./modules/es7.reflect.has-own-metadata\":402,\"./modules/es7.reflect.metadata\":403,\"./modules/es7.set.to-json\":404,\"./modules/es7.string.at\":405,\"./modules/es7.string.match-all\":406,\"./modules/es7.string.pad-end\":407,\"./modules/es7.string.pad-start\":408,\"./modules/es7.string.trim-left\":409,\"./modules/es7.string.trim-right\":410,\"./modules/es7.symbol.async-iterator\":411,\"./modules/es7.symbol.observable\":412,\"./modules/es7.system.global\":413,\"./modules/web.dom.iterable\":414,\"./modules/web.immediate\":415,\"./modules/web.timers\":416}],418:[function(require,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],419:[function(require,module,exports){\n(function (process,global){\n/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    if (typeof process === \"object\" && process.domain) {\n      invoke = process.domain.bind(invoke);\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          if (method === \"return\" ||\n              (method === \"throw\" && delegate.iterator[method] === undefined)) {\n            // A return or throw (when the delegate iterator has no throw\n            // method) always terminates the yield* loop.\n            context.delegate = null;\n\n            // If the delegate iterator has a return method, give it a\n            // chance to clean up.\n            var returnMethod = delegate.iterator[\"return\"];\n            if (returnMethod) {\n              var record = tryCatch(returnMethod, delegate.iterator, arg);\n              if (record.type === \"throw\") {\n                // If the return method threw an exception, let that\n                // exception prevail over the original return or throw.\n                method = \"throw\";\n                arg = record.arg;\n                continue;\n              }\n            }\n\n            if (method === \"return\") {\n              // Continue with the outer return, now that the delegate\n              // iterator has been terminated.\n              continue;\n            }\n          }\n\n          var record = tryCatch(\n            delegate.iterator[method],\n            delegate.iterator,\n            arg\n          );\n\n          if (record.type === \"throw\") {\n            context.delegate = null;\n\n            // Like returning generator.throw(uncaught), but without the\n            // overhead of an extra function call.\n            method = \"throw\";\n            arg = record.arg;\n            continue;\n          }\n\n          // Delegate generator ran and handled its own exceptions so\n          // regardless of what the method was, we continue as if it is\n          // \"next\" with an undefined arg.\n          method = \"next\";\n          arg = undefined;\n\n          var info = record.arg;\n          if (info.done) {\n            context[delegate.resultName] = info.value;\n            context.next = delegate.nextLoc;\n          } else {\n            state = GenStateSuspendedYield;\n            return info;\n          }\n\n          context.delegate = null;\n        }\n\n        if (method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = arg;\n\n        } else if (method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw arg;\n          }\n\n          if (context.dispatchException(arg)) {\n            // If the dispatched exception was caught by a catch block,\n            // then let that catch block handle the exception normally.\n            method = \"next\";\n            arg = undefined;\n          }\n\n        } else if (method === \"return\") {\n          context.abrupt(\"return\", arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          var info = {\n            value: record.arg,\n            done: context.done\n          };\n\n          if (record.arg === ContinueSentinel) {\n            if (context.delegate && method === \"next\") {\n              // Deliberately forget the last sent value so that we don't\n              // accidentally pass it on to the delegate.\n              arg = undefined;\n            }\n          } else {\n            return info;\n          }\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(arg) call above.\n          method = \"throw\";\n          arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n        return !!caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.next = finallyEntry.finallyLoc;\n      } else {\n        this.complete(record);\n      }\n\n      return ContinueSentinel;\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = record.arg;\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // Among the various tricks for obtaining a reference to the global\n  // object, this seems to be the most reliable technique that does not\n  // use indirect eval (which violates Content Security Policy).\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this\n);\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"_process\":418}],420:[function(require,module,exports){\n(function (global){\n/**\n* Copyright 2016 PT Inovao e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n\n// Distribution file for MessageFactory.js \n// version: 0.5.1\n// Last build: Wed Dec 21 2016 12:02:37 GMT+0000 (WET)\n\n!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var t;t=\"undefined\"!=typeof window?window:\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:this,t.MessageFactory=e()}}(function(){var e;return function t(e,r,n){function o(a,s){if(!r[a]){if(!e[a]){var u=\"function\"==typeof require&&require;if(!s&&u)return u(a,!0);if(i)return i(a,!0);var c=new Error(\"Cannot find module '\"+a+\"'\");throw c.code=\"MODULE_NOT_FOUND\",c}var l=r[a]={exports:{}};e[a][0].call(l.exports,function(t){var r=e[a][1][t];return o(r?r:t)},l,l.exports,t,e,r,n)}return r[a].exports}for(var i=\"function\"==typeof require&&require,a=0;a<n.length;a++)o(n[a]);return o}({1:[function(e,t,r){t.exports={\"default\":e(\"core-js/library/fn/json/stringify\"),__esModule:!0}},{\"core-js/library/fn/json/stringify\":16}],2:[function(e,t,r){t.exports={\"default\":e(\"core-js/library/fn/object/create\"),__esModule:!0}},{\"core-js/library/fn/object/create\":17}],3:[function(e,t,r){t.exports={\"default\":e(\"core-js/library/fn/object/define-property\"),__esModule:!0}},{\"core-js/library/fn/object/define-property\":18}],4:[function(e,t,r){t.exports={\"default\":e(\"core-js/library/fn/object/freeze\"),__esModule:!0}},{\"core-js/library/fn/object/freeze\":19}],5:[function(e,t,r){t.exports={\"default\":e(\"core-js/library/fn/object/get-prototype-of\"),__esModule:!0}},{\"core-js/library/fn/object/get-prototype-of\":20}],6:[function(e,t,r){t.exports={\"default\":e(\"core-js/library/fn/object/keys\"),__esModule:!0}},{\"core-js/library/fn/object/keys\":21}],7:[function(e,t,r){t.exports={\"default\":e(\"core-js/library/fn/object/set-prototype-of\"),__esModule:!0}},{\"core-js/library/fn/object/set-prototype-of\":22}],8:[function(e,t,r){t.exports={\"default\":e(\"core-js/library/fn/symbol\"),__esModule:!0}},{\"core-js/library/fn/symbol\":23}],9:[function(e,t,r){t.exports={\"default\":e(\"core-js/library/fn/symbol/iterator\"),__esModule:!0}},{\"core-js/library/fn/symbol/iterator\":24}],10:[function(e,t,r){\"use strict\";r.__esModule=!0,r[\"default\"]=function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}},{}],11:[function(e,t,r){\"use strict\";function n(e){return e&&e.__esModule?e:{\"default\":e}}r.__esModule=!0;var o=e(\"../core-js/object/define-property\"),i=n(o);r[\"default\"]=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),(0,i[\"default\"])(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}()},{\"../core-js/object/define-property\":3}],12:[function(e,t,r){\"use strict\";function n(e){return e&&e.__esModule?e:{\"default\":e}}r.__esModule=!0;var o=e(\"../core-js/object/set-prototype-of\"),i=n(o),a=e(\"../core-js/object/create\"),s=n(a),u=e(\"../helpers/typeof\"),c=n(u);r[\"default\"]=function(e,t){if(\"function\"!=typeof t&&null!==t)throw new TypeError(\"Super expression must either be null or a function, not \"+(\"undefined\"==typeof t?\"undefined\":(0,c[\"default\"])(t)));e.prototype=(0,s[\"default\"])(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(i[\"default\"]?(0,i[\"default\"])(e,t):e.__proto__=t)}},{\"../core-js/object/create\":2,\"../core-js/object/set-prototype-of\":7,\"../helpers/typeof\":14}],13:[function(e,t,r){\"use strict\";function n(e){return e&&e.__esModule?e:{\"default\":e}}r.__esModule=!0;var o=e(\"../helpers/typeof\"),i=n(o);r[\"default\"]=function(e,t){if(!e)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!t||\"object\"!==(\"undefined\"==typeof t?\"undefined\":(0,i[\"default\"])(t))&&\"function\"!=typeof t?e:t}},{\"../helpers/typeof\":14}],14:[function(e,t,r){\"use strict\";function n(e){return e&&e.__esModule?e:{\"default\":e}}r.__esModule=!0;var o=e(\"../core-js/symbol/iterator\"),i=n(o),a=e(\"../core-js/symbol\"),s=n(a),u=\"function\"==typeof s[\"default\"]&&\"symbol\"==typeof i[\"default\"]?function(e){return typeof e}:function(e){return e&&\"function\"==typeof s[\"default\"]&&e.constructor===s[\"default\"]&&e!==s[\"default\"].prototype?\"symbol\":typeof e};r[\"default\"]=\"function\"==typeof s[\"default\"]&&\"symbol\"===u(i[\"default\"])?function(e){return\"undefined\"==typeof e?\"undefined\":u(e)}:function(e){return e&&\"function\"==typeof s[\"default\"]&&e.constructor===s[\"default\"]&&e!==s[\"default\"].prototype?\"symbol\":\"undefined\"==typeof e?\"undefined\":u(e)}},{\"../core-js/symbol\":8,\"../core-js/symbol/iterator\":9}],15:[function(e,t,r){t.exports=e(\"regenerator-runtime\")},{\"regenerator-runtime\":97}],16:[function(e,t,r){var n=e(\"../../modules/_core\"),o=n.JSON||(n.JSON={stringify:JSON.stringify});t.exports=function(e){return o.stringify.apply(o,arguments)}},{\"../../modules/_core\":30}],17:[function(e,t,r){e(\"../../modules/es6.object.create\");var n=e(\"../../modules/_core\").Object;t.exports=function(e,t){return n.create(e,t)}},{\"../../modules/_core\":30,\"../../modules/es6.object.create\":84}],18:[function(e,t,r){e(\"../../modules/es6.object.define-property\");var n=e(\"../../modules/_core\").Object;t.exports=function(e,t,r){return n.defineProperty(e,t,r)}},{\"../../modules/_core\":30,\"../../modules/es6.object.define-property\":85}],19:[function(e,t,r){e(\"../../modules/es6.object.freeze\"),t.exports=e(\"../../modules/_core\").Object.freeze},{\"../../modules/_core\":30,\"../../modules/es6.object.freeze\":86}],20:[function(e,t,r){e(\"../../modules/es6.object.get-prototype-of\"),t.exports=e(\"../../modules/_core\").Object.getPrototypeOf},{\"../../modules/_core\":30,\"../../modules/es6.object.get-prototype-of\":87}],21:[function(e,t,r){e(\"../../modules/es6.object.keys\"),t.exports=e(\"../../modules/_core\").Object.keys},{\"../../modules/_core\":30,\"../../modules/es6.object.keys\":88}],22:[function(e,t,r){e(\"../../modules/es6.object.set-prototype-of\"),t.exports=e(\"../../modules/_core\").Object.setPrototypeOf},{\"../../modules/_core\":30,\"../../modules/es6.object.set-prototype-of\":89}],23:[function(e,t,r){e(\"../../modules/es6.symbol\"),e(\"../../modules/es6.object.to-string\"),e(\"../../modules/es7.symbol.async-iterator\"),e(\"../../modules/es7.symbol.observable\"),t.exports=e(\"../../modules/_core\").Symbol},{\"../../modules/_core\":30,\"../../modules/es6.object.to-string\":90,\"../../modules/es6.symbol\":92,\"../../modules/es7.symbol.async-iterator\":93,\"../../modules/es7.symbol.observable\":94}],24:[function(e,t,r){e(\"../../modules/es6.string.iterator\"),e(\"../../modules/web.dom.iterable\"),t.exports=e(\"../../modules/_wks-ext\").f(\"iterator\")},{\"../../modules/_wks-ext\":81,\"../../modules/es6.string.iterator\":91,\"../../modules/web.dom.iterable\":95}],25:[function(e,t,r){t.exports=function(e){if(\"function\"!=typeof e)throw TypeError(e+\" is not a function!\");return e}},{}],26:[function(e,t,r){t.exports=function(){}},{}],27:[function(e,t,r){var n=e(\"./_is-object\");t.exports=function(e){if(!n(e))throw TypeError(e+\" is not an object!\");return e}},{\"./_is-object\":46}],28:[function(e,t,r){var n=e(\"./_to-iobject\"),o=e(\"./_to-length\"),i=e(\"./_to-index\");t.exports=function(e){return function(t,r,a){var s,u=n(t),c=o(u.length),l=i(a,c);if(e&&r!=r){for(;c>l;)if(s=u[l++],s!=s)return!0}else for(;c>l;l++)if((e||l in u)&&u[l]===r)return e||l||0;return!e&&-1}}},{\"./_to-index\":73,\"./_to-iobject\":75,\"./_to-length\":76}],29:[function(e,t,r){var n={}.toString;t.exports=function(e){return n.call(e).slice(8,-1)}},{}],30:[function(e,t,r){var n=t.exports={version:\"2.4.0\"};\"number\"==typeof __e&&(__e=n)},{}],31:[function(e,t,r){var n=e(\"./_a-function\");t.exports=function(e,t,r){if(n(e),void 0===t)return e;switch(r){case 1:return function(r){return e.call(t,r)};case 2:return function(r,n){return e.call(t,r,n)};case 3:return function(r,n,o){return e.call(t,r,n,o)}}return function(){return e.apply(t,arguments)}}},{\"./_a-function\":25}],32:[function(e,t,r){t.exports=function(e){if(void 0==e)throw TypeError(\"Can't call method on  \"+e);return e}},{}],33:[function(e,t,r){t.exports=!e(\"./_fails\")(function(){return 7!=Object.defineProperty({},\"a\",{get:function(){return 7}}).a})},{\"./_fails\":38}],34:[function(e,t,r){var n=e(\"./_is-object\"),o=e(\"./_global\").document,i=n(o)&&n(o.createElement);t.exports=function(e){return i?o.createElement(e):{}}},{\"./_global\":39,\"./_is-object\":46}],35:[function(e,t,r){t.exports=\"constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf\".split(\",\")},{}],36:[function(e,t,r){var n=e(\"./_object-keys\"),o=e(\"./_object-gops\"),i=e(\"./_object-pie\");t.exports=function(e){var t=n(e),r=o.f;if(r)for(var a,s=r(e),u=i.f,c=0;s.length>c;)u.call(e,a=s[c++])&&t.push(a);return t}},{\"./_object-gops\":60,\"./_object-keys\":63,\"./_object-pie\":64}],37:[function(e,t,r){var n=e(\"./_global\"),o=e(\"./_core\"),i=e(\"./_ctx\"),a=e(\"./_hide\"),s=\"prototype\",u=function(e,t,r){var c,l,f,d=e&u.F,p=e&u.G,h=e&u.S,y=e&u.P,m=e&u.B,v=e&u.W,_=p?o:o[t]||(o[t]={}),b=_[s],g=p?n:h?n[t]:(n[t]||{})[s];p&&(r=t);for(c in r)l=!d&&g&&void 0!==g[c],l&&c in _||(f=l?g[c]:r[c],_[c]=p&&\"function\"!=typeof g[c]?r[c]:m&&l?i(f,n):v&&g[c]==f?function(e){var t=function(t,r,n){if(this instanceof e){switch(arguments.length){case 0:return new e;case 1:return new e(t);case 2:return new e(t,r)}return new e(t,r,n)}return e.apply(this,arguments)};return t[s]=e[s],t}(f):y&&\"function\"==typeof f?i(Function.call,f):f,y&&((_.virtual||(_.virtual={}))[c]=f,e&u.R&&b&&!b[c]&&a(b,c,f)))};u.F=1,u.G=2,u.S=4,u.P=8,u.B=16,u.W=32,u.U=64,u.R=128,t.exports=u},{\"./_core\":30,\"./_ctx\":31,\"./_global\":39,\"./_hide\":41}],38:[function(e,t,r){t.exports=function(e){try{return!!e()}catch(t){return!0}}},{}],39:[function(e,t,r){var n=t.exports=\"undefined\"!=typeof window&&window.Math==Math?window:\"undefined\"!=typeof self&&self.Math==Math?self:Function(\"return this\")();\"number\"==typeof __g&&(__g=n)},{}],40:[function(e,t,r){var n={}.hasOwnProperty;t.exports=function(e,t){return n.call(e,t)}},{}],41:[function(e,t,r){var n=e(\"./_object-dp\"),o=e(\"./_property-desc\");t.exports=e(\"./_descriptors\")?function(e,t,r){return n.f(e,t,o(1,r))}:function(e,t,r){return e[t]=r,e}},{\"./_descriptors\":33,\"./_object-dp\":55,\"./_property-desc\":66}],42:[function(e,t,r){t.exports=e(\"./_global\").document&&document.documentElement},{\"./_global\":39}],43:[function(e,t,r){t.exports=!e(\"./_descriptors\")&&!e(\"./_fails\")(function(){return 7!=Object.defineProperty(e(\"./_dom-create\")(\"div\"),\"a\",{get:function(){return 7}}).a})},{\"./_descriptors\":33,\"./_dom-create\":34,\"./_fails\":38}],44:[function(e,t,r){var n=e(\"./_cof\");t.exports=Object(\"z\").propertyIsEnumerable(0)?Object:function(e){return\"String\"==n(e)?e.split(\"\"):Object(e)}},{\"./_cof\":29}],45:[function(e,t,r){var n=e(\"./_cof\");t.exports=Array.isArray||function(e){return\"Array\"==n(e)}},{\"./_cof\":29}],46:[function(e,t,r){t.exports=function(e){return\"object\"==typeof e?null!==e:\"function\"==typeof e}},{}],47:[function(e,t,r){\"use strict\";var n=e(\"./_object-create\"),o=e(\"./_property-desc\"),i=e(\"./_set-to-string-tag\"),a={};e(\"./_hide\")(a,e(\"./_wks\")(\"iterator\"),function(){return this}),t.exports=function(e,t,r){e.prototype=n(a,{next:o(1,r)}),i(e,t+\" Iterator\")}},{\"./_hide\":41,\"./_object-create\":54,\"./_property-desc\":66,\"./_set-to-string-tag\":69,\"./_wks\":82}],48:[function(e,t,r){\"use strict\";var n=e(\"./_library\"),o=e(\"./_export\"),i=e(\"./_redefine\"),a=e(\"./_hide\"),s=e(\"./_has\"),u=e(\"./_iterators\"),c=e(\"./_iter-create\"),l=e(\"./_set-to-string-tag\"),f=e(\"./_object-gpo\"),d=e(\"./_wks\")(\"iterator\"),p=!([].keys&&\"next\"in[].keys()),h=\"@@iterator\",y=\"keys\",m=\"values\",v=function(){return this};t.exports=function(e,t,r,_,b,g,E){c(r,t,_);var j,w,O,M=function(e){if(!p&&e in R)return R[e];switch(e){case y:return function(){return new r(this,e)};case m:return function(){return new r(this,e)}}return function(){return new r(this,e)}},x=t+\" Iterator\",P=b==m,k=!1,R=e.prototype,S=R[d]||R[h]||b&&R[b],T=S||M(b),A=b?P?M(\"entries\"):T:void 0,N=\"Array\"==t?R.entries||S:S;if(N&&(O=f(N.call(new e)),O!==Object.prototype&&(l(O,x,!0),n||s(O,d)||a(O,d,v))),P&&S&&S.name!==m&&(k=!0,T=function(){return S.call(this)}),n&&!E||!p&&!k&&R[d]||a(R,d,T),u[t]=T,u[x]=v,b)if(j={values:P?T:M(m),keys:g?T:M(y),entries:A},E)for(w in j)w in R||i(R,w,j[w]);else o(o.P+o.F*(p||k),t,j);return j}},{\"./_export\":37,\"./_has\":40,\"./_hide\":41,\"./_iter-create\":47,\"./_iterators\":50,\"./_library\":52,\"./_object-gpo\":61,\"./_redefine\":67,\"./_set-to-string-tag\":69,\"./_wks\":82}],49:[function(e,t,r){t.exports=function(e,t){return{value:t,done:!!e}}},{}],50:[function(e,t,r){t.exports={}},{}],51:[function(e,t,r){var n=e(\"./_object-keys\"),o=e(\"./_to-iobject\");t.exports=function(e,t){for(var r,i=o(e),a=n(i),s=a.length,u=0;s>u;)if(i[r=a[u++]]===t)return r}},{\"./_object-keys\":63,\"./_to-iobject\":75}],52:[function(e,t,r){t.exports=!0},{}],53:[function(e,t,r){var n=e(\"./_uid\")(\"meta\"),o=e(\"./_is-object\"),i=e(\"./_has\"),a=e(\"./_object-dp\").f,s=0,u=Object.isExtensible||function(){return!0},c=!e(\"./_fails\")(function(){return u(Object.preventExtensions({}))}),l=function(e){a(e,n,{value:{i:\"O\"+ ++s,w:{}}})},f=function(e,t){if(!o(e))return\"symbol\"==typeof e?e:(\"string\"==typeof e?\"S\":\"P\")+e;if(!i(e,n)){if(!u(e))return\"F\";if(!t)return\"E\";l(e)}return e[n].i},d=function(e,t){if(!i(e,n)){if(!u(e))return!0;if(!t)return!1;l(e)}return e[n].w},p=function(e){return c&&h.NEED&&u(e)&&!i(e,n)&&l(e),e},h=t.exports={KEY:n,NEED:!1,fastKey:f,getWeak:d,onFreeze:p}},{\"./_fails\":38,\"./_has\":40,\"./_is-object\":46,\"./_object-dp\":55,\"./_uid\":79}],54:[function(e,t,r){var n=e(\"./_an-object\"),o=e(\"./_object-dps\"),i=e(\"./_enum-bug-keys\"),a=e(\"./_shared-key\")(\"IE_PROTO\"),s=function(){},u=\"prototype\",c=function(){var t,r=e(\"./_dom-create\")(\"iframe\"),n=i.length,o=\"<\",a=\">\";for(r.style.display=\"none\",e(\"./_html\").appendChild(r),r.src=\"javascript:\",t=r.contentWindow.document,t.open(),t.write(o+\"script\"+a+\"document.F=Object\"+o+\"/script\"+a),t.close(),c=t.F;n--;)delete c[u][i[n]];return c()};t.exports=Object.create||function(e,t){var r;return null!==e?(s[u]=n(e),r=new s,s[u]=null,r[a]=e):r=c(),void 0===t?r:o(r,t)}},{\"./_an-object\":27,\"./_dom-create\":34,\"./_enum-bug-keys\":35,\"./_html\":42,\"./_object-dps\":56,\"./_shared-key\":70}],55:[function(e,t,r){var n=e(\"./_an-object\"),o=e(\"./_ie8-dom-define\"),i=e(\"./_to-primitive\"),a=Object.defineProperty;r.f=e(\"./_descriptors\")?Object.defineProperty:function(e,t,r){if(n(e),t=i(t,!0),n(r),o)try{return a(e,t,r)}catch(s){}if(\"get\"in r||\"set\"in r)throw TypeError(\"Accessors not supported!\");return\"value\"in r&&(e[t]=r.value),e}},{\"./_an-object\":27,\"./_descriptors\":33,\"./_ie8-dom-define\":43,\"./_to-primitive\":78}],56:[function(e,t,r){var n=e(\"./_object-dp\"),o=e(\"./_an-object\"),i=e(\"./_object-keys\");t.exports=e(\"./_descriptors\")?Object.defineProperties:function(e,t){o(e);for(var r,a=i(t),s=a.length,u=0;s>u;)n.f(e,r=a[u++],t[r]);return e}},{\"./_an-object\":27,\"./_descriptors\":33,\"./_object-dp\":55,\"./_object-keys\":63}],57:[function(e,t,r){var n=e(\"./_object-pie\"),o=e(\"./_property-desc\"),i=e(\"./_to-iobject\"),a=e(\"./_to-primitive\"),s=e(\"./_has\"),u=e(\"./_ie8-dom-define\"),c=Object.getOwnPropertyDescriptor;r.f=e(\"./_descriptors\")?c:function(e,t){if(e=i(e),t=a(t,!0),u)try{return c(e,t)}catch(r){}if(s(e,t))return o(!n.f.call(e,t),e[t])}},{\"./_descriptors\":33,\"./_has\":40,\"./_ie8-dom-define\":43,\"./_object-pie\":64,\"./_property-desc\":66,\"./_to-iobject\":75,\"./_to-primitive\":78}],58:[function(e,t,r){var n=e(\"./_to-iobject\"),o=e(\"./_object-gopn\").f,i={}.toString,a=\"object\"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],s=function(e){try{return o(e)}catch(t){return a.slice()}};t.exports.f=function(e){return a&&\"[object Window]\"==i.call(e)?s(e):o(n(e))}},{\"./_object-gopn\":59,\"./_to-iobject\":75}],59:[function(e,t,r){var n=e(\"./_object-keys-internal\"),o=e(\"./_enum-bug-keys\").concat(\"length\",\"prototype\");r.f=Object.getOwnPropertyNames||function(e){return n(e,o)}},{\"./_enum-bug-keys\":35,\"./_object-keys-internal\":62}],60:[function(e,t,r){r.f=Object.getOwnPropertySymbols},{}],61:[function(e,t,r){var n=e(\"./_has\"),o=e(\"./_to-object\"),i=e(\"./_shared-key\")(\"IE_PROTO\"),a=Object.prototype;t.exports=Object.getPrototypeOf||function(e){return e=o(e),n(e,i)?e[i]:\"function\"==typeof e.constructor&&e instanceof e.constructor?e.constructor.prototype:e instanceof Object?a:null}},{\"./_has\":40,\"./_shared-key\":70,\"./_to-object\":77}],62:[function(e,t,r){var n=e(\"./_has\"),o=e(\"./_to-iobject\"),i=e(\"./_array-includes\")(!1),a=e(\"./_shared-key\")(\"IE_PROTO\");t.exports=function(e,t){var r,s=o(e),u=0,c=[];for(r in s)r!=a&&n(s,r)&&c.push(r);for(;t.length>u;)n(s,r=t[u++])&&(~i(c,r)||c.push(r));return c}},{\"./_array-includes\":28,\"./_has\":40,\"./_shared-key\":70,\"./_to-iobject\":75}],63:[function(e,t,r){var n=e(\"./_object-keys-internal\"),o=e(\"./_enum-bug-keys\");t.exports=Object.keys||function(e){return n(e,o)}},{\"./_enum-bug-keys\":35,\"./_object-keys-internal\":62}],64:[function(e,t,r){r.f={}.propertyIsEnumerable},{}],65:[function(e,t,r){var n=e(\"./_export\"),o=e(\"./_core\"),i=e(\"./_fails\");t.exports=function(e,t){var r=(o.Object||{})[e]||Object[e],a={};a[e]=t(r),n(n.S+n.F*i(function(){r(1)}),\"Object\",a)}},{\"./_core\":30,\"./_export\":37,\"./_fails\":38}],66:[function(e,t,r){t.exports=function(e,t){return{enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:t}}},{}],67:[function(e,t,r){t.exports=e(\"./_hide\")},{\"./_hide\":41}],68:[function(e,t,r){var n=e(\"./_is-object\"),o=e(\"./_an-object\"),i=function(e,t){if(o(e),!n(t)&&null!==t)throw TypeError(t+\": can't set as prototype!\")};t.exports={set:Object.setPrototypeOf||(\"__proto__\"in{}?function(t,r,n){try{n=e(\"./_ctx\")(Function.call,e(\"./_object-gopd\").f(Object.prototype,\"__proto__\").set,2),n(t,[]),r=!(t instanceof Array)}catch(o){r=!0}return function(e,t){return i(e,t),r?e.__proto__=t:n(e,t),e}}({},!1):void 0),check:i}},{\"./_an-object\":27,\"./_ctx\":31,\"./_is-object\":46,\"./_object-gopd\":57}],69:[function(e,t,r){var n=e(\"./_object-dp\").f,o=e(\"./_has\"),i=e(\"./_wks\")(\"toStringTag\");t.exports=function(e,t,r){e&&!o(e=r?e:e.prototype,i)&&n(e,i,{configurable:!0,value:t})}},{\"./_has\":40,\"./_object-dp\":55,\"./_wks\":82}],70:[function(e,t,r){var n=e(\"./_shared\")(\"keys\"),o=e(\"./_uid\");t.exports=function(e){return n[e]||(n[e]=o(e))}},{\"./_shared\":71,\"./_uid\":79}],71:[function(e,t,r){var n=e(\"./_global\"),o=\"__core-js_shared__\",i=n[o]||(n[o]={});t.exports=function(e){return i[e]||(i[e]={})}},{\"./_global\":39}],72:[function(e,t,r){var n=e(\"./_to-integer\"),o=e(\"./_defined\");t.exports=function(e){return function(t,r){var i,a,s=String(o(t)),u=n(r),c=s.length;return u<0||u>=c?e?\"\":void 0:(i=s.charCodeAt(u),i<55296||i>56319||u+1===c||(a=s.charCodeAt(u+1))<56320||a>57343?e?s.charAt(u):i:e?s.slice(u,u+2):(i-55296<<10)+(a-56320)+65536)}}},{\"./_defined\":32,\"./_to-integer\":74}],73:[function(e,t,r){var n=e(\"./_to-integer\"),o=Math.max,i=Math.min;t.exports=function(e,t){return e=n(e),e<0?o(e+t,0):i(e,t)}},{\"./_to-integer\":74}],74:[function(e,t,r){var n=Math.ceil,o=Math.floor;t.exports=function(e){return isNaN(e=+e)?0:(e>0?o:n)(e)}},{}],75:[function(e,t,r){var n=e(\"./_iobject\"),o=e(\"./_defined\");t.exports=function(e){return n(o(e))}},{\"./_defined\":32,\"./_iobject\":44}],76:[function(e,t,r){var n=e(\"./_to-integer\"),o=Math.min;t.exports=function(e){return e>0?o(n(e),9007199254740991):0}},{\"./_to-integer\":74}],77:[function(e,t,r){var n=e(\"./_defined\");t.exports=function(e){return Object(n(e))}},{\"./_defined\":32}],78:[function(e,t,r){var n=e(\"./_is-object\");t.exports=function(e,t){if(!n(e))return e;var r,o;if(t&&\"function\"==typeof(r=e.toString)&&!n(o=r.call(e)))return o;if(\"function\"==typeof(r=e.valueOf)&&!n(o=r.call(e)))return o;if(!t&&\"function\"==typeof(r=e.toString)&&!n(o=r.call(e)))return o;throw TypeError(\"Can't convert object to primitive value\")}},{\"./_is-object\":46}],79:[function(e,t,r){var n=0,o=Math.random();t.exports=function(e){return\"Symbol(\".concat(void 0===e?\"\":e,\")_\",(++n+o).toString(36))}},{}],80:[function(e,t,r){var n=e(\"./_global\"),o=e(\"./_core\"),i=e(\"./_library\"),a=e(\"./_wks-ext\"),s=e(\"./_object-dp\").f;t.exports=function(e){var t=o.Symbol||(o.Symbol=i?{}:n.Symbol||{});\"_\"==e.charAt(0)||e in t||s(t,e,{value:a.f(e)})}},{\"./_core\":30,\"./_global\":39,\"./_library\":52,\"./_object-dp\":55,\"./_wks-ext\":81}],81:[function(e,t,r){r.f=e(\"./_wks\")},{\"./_wks\":82}],82:[function(e,t,r){var n=e(\"./_shared\")(\"wks\"),o=e(\"./_uid\"),i=e(\"./_global\").Symbol,a=\"function\"==typeof i,s=t.exports=function(e){return n[e]||(n[e]=a&&i[e]||(a?i:o)(\"Symbol.\"+e))};s.store=n},{\"./_global\":39,\"./_shared\":71,\"./_uid\":79}],83:[function(e,t,r){\"use strict\";var n=e(\"./_add-to-unscopables\"),o=e(\"./_iter-step\"),i=e(\"./_iterators\"),a=e(\"./_to-iobject\");t.exports=e(\"./_iter-define\")(Array,\"Array\",function(e,t){this._t=a(e),this._i=0,this._k=t},function(){var e=this._t,t=this._k,r=this._i++;return!e||r>=e.length?(this._t=void 0,o(1)):\"keys\"==t?o(0,r):\"values\"==t?o(0,e[r]):o(0,[r,e[r]])},\"values\"),i.Arguments=i.Array,n(\"keys\"),n(\"values\"),n(\"entries\")},{\"./_add-to-unscopables\":26,\"./_iter-define\":48,\"./_iter-step\":49,\"./_iterators\":50,\"./_to-iobject\":75}],84:[function(e,t,r){var n=e(\"./_export\");n(n.S,\"Object\",{create:e(\"./_object-create\")})},{\"./_export\":37,\"./_object-create\":54}],85:[function(e,t,r){var n=e(\"./_export\");n(n.S+n.F*!e(\"./_descriptors\"),\"Object\",{defineProperty:e(\"./_object-dp\").f})},{\"./_descriptors\":33,\"./_export\":37,\"./_object-dp\":55}],86:[function(e,t,r){var n=e(\"./_is-object\"),o=e(\"./_meta\").onFreeze;e(\"./_object-sap\")(\"freeze\",function(e){return function(t){return e&&n(t)?e(o(t)):t}})},{\"./_is-object\":46,\"./_meta\":53,\"./_object-sap\":65}],87:[function(e,t,r){var n=e(\"./_to-object\"),o=e(\"./_object-gpo\");e(\"./_object-sap\")(\"getPrototypeOf\",function(){return function(e){return o(n(e))}})},{\"./_object-gpo\":61,\"./_object-sap\":65,\"./_to-object\":77}],88:[function(e,t,r){var n=e(\"./_to-object\"),o=e(\"./_object-keys\");e(\"./_object-sap\")(\"keys\",function(){return function(e){return o(n(e))}})},{\"./_object-keys\":63,\"./_object-sap\":65,\"./_to-object\":77}],89:[function(e,t,r){var n=e(\"./_export\");n(n.S,\"Object\",{setPrototypeOf:e(\"./_set-proto\").set})},{\"./_export\":37,\"./_set-proto\":68}],90:[function(e,t,r){},{}],91:[function(e,t,r){\"use strict\";var n=e(\"./_string-at\")(!0);e(\"./_iter-define\")(String,\"String\",function(e){this._t=String(e),this._i=0},function(){var e,t=this._t,r=this._i;return r>=t.length?{value:void 0,done:!0}:(e=n(t,r),this._i+=e.length,{value:e,done:!1})})},{\"./_iter-define\":48,\"./_string-at\":72}],92:[function(e,t,r){\"use strict\";var n=e(\"./_global\"),o=e(\"./_has\"),i=e(\"./_descriptors\"),a=e(\"./_export\"),s=e(\"./_redefine\"),u=e(\"./_meta\").KEY,c=e(\"./_fails\"),l=e(\"./_shared\"),f=e(\"./_set-to-string-tag\"),d=e(\"./_uid\"),p=e(\"./_wks\"),h=e(\"./_wks-ext\"),y=e(\"./_wks-define\"),m=e(\"./_keyof\"),v=e(\"./_enum-keys\"),_=e(\"./_is-array\"),b=e(\"./_an-object\"),g=e(\"./_to-iobject\"),E=e(\"./_to-primitive\"),j=e(\"./_property-desc\"),w=e(\"./_object-create\"),O=e(\"./_object-gopn-ext\"),M=e(\"./_object-gopd\"),x=e(\"./_object-dp\"),P=e(\"./_object-keys\"),k=M.f,R=x.f,S=O.f,T=n.Symbol,A=n.JSON,N=A&&A.stringify,I=\"prototype\",U=p(\"_hidden\"),C=p(\"toPrimitive\"),L={}.propertyIsEnumerable,F=l(\"symbol-registry\"),B=l(\"symbols\"),D=l(\"op-symbols\"),G=Object[I],K=\"function\"==typeof T,Y=n.QObject,q=!Y||!Y[I]||!Y[I].findChild,z=i&&c(function(){return 7!=w(R({},\"a\",{get:function(){return R(this,\"a\",{value:7}).a}})).a})?function(e,t,r){var n=k(G,t);n&&delete G[t],R(e,t,r),n&&e!==G&&R(G,t,n)}:R,H=function(e){var t=B[e]=w(T[I]);return t._k=e,t},W=K&&\"symbol\"==typeof T.iterator?function(e){return\"symbol\"==typeof e}:function(e){return e instanceof T},J=function(e,t,r){return e===G&&J(D,t,r),b(e),t=E(t,!0),b(r),o(B,t)?(r.enumerable?(o(e,U)&&e[U][t]&&(e[U][t]=!1),r=w(r,{enumerable:j(0,!1)})):(o(e,U)||R(e,U,j(1,{})),e[U][t]=!0),z(e,t,r)):R(e,t,r)},V=function(e,t){b(e);for(var r,n=v(t=g(t)),o=0,i=n.length;i>o;)J(e,r=n[o++],t[r]);return e},$=function(e,t){return void 0===t?w(e):V(w(e),t)},X=function(e){var t=L.call(this,e=E(e,!0));return!(this===G&&o(B,e)&&!o(D,e))&&(!(t||!o(this,e)||!o(B,e)||o(this,U)&&this[U][e])||t)},Q=function(e,t){if(e=g(e),t=E(t,!0),e!==G||!o(B,t)||o(D,t)){var r=k(e,t);return!r||!o(B,t)||o(e,U)&&e[U][t]||(r.enumerable=!0),r}},Z=function(e){for(var t,r=S(g(e)),n=[],i=0;r.length>i;)o(B,t=r[i++])||t==U||t==u||n.push(t);return n},ee=function(e){for(var t,r=e===G,n=S(r?D:g(e)),i=[],a=0;n.length>a;)!o(B,t=n[a++])||r&&!o(G,t)||i.push(B[t]);return i};K||(T=function(){if(this instanceof T)throw TypeError(\"Symbol is not a constructor!\");var e=d(arguments.length>0?arguments[0]:void 0),t=function(r){this===G&&t.call(D,r),o(this,U)&&o(this[U],e)&&(this[U][e]=!1),z(this,e,j(1,r))};return i&&q&&z(G,e,{configurable:!0,set:t}),H(e)},s(T[I],\"toString\",function(){return this._k}),M.f=Q,x.f=J,e(\"./_object-gopn\").f=O.f=Z,e(\"./_object-pie\").f=X,e(\"./_object-gops\").f=ee,i&&!e(\"./_library\")&&s(G,\"propertyIsEnumerable\",X,!0),h.f=function(e){return H(p(e))}),a(a.G+a.W+a.F*!K,{Symbol:T});for(var te=\"hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables\".split(\",\"),re=0;te.length>re;)p(te[re++]);for(var te=P(p.store),re=0;te.length>re;)y(te[re++]);a(a.S+a.F*!K,\"Symbol\",{\"for\":function(e){return o(F,e+=\"\")?F[e]:F[e]=T(e)},keyFor:function(e){if(W(e))return m(F,e);throw TypeError(e+\" is not a symbol!\")},useSetter:function(){q=!0},useSimple:function(){q=!1}}),a(a.S+a.F*!K,\"Object\",{create:$,defineProperty:J,defineProperties:V,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:ee}),A&&a(a.S+a.F*(!K||c(function(){var e=T();return\"[null]\"!=N([e])||\"{}\"!=N({a:e})||\"{}\"!=N(Object(e))})),\"JSON\",{stringify:function(e){if(void 0!==e&&!W(e)){for(var t,r,n=[e],o=1;arguments.length>o;)n.push(arguments[o++]);return t=n[1],\"function\"==typeof t&&(r=t),!r&&_(t)||(t=function(e,t){if(r&&(t=r.call(this,e,t)),!W(t))return t}),n[1]=t,N.apply(A,n)}}}),T[I][C]||e(\"./_hide\")(T[I],C,T[I].valueOf),f(T,\"Symbol\"),f(Math,\"Math\",!0),f(n.JSON,\"JSON\",!0)},{\"./_an-object\":27,\"./_descriptors\":33,\"./_enum-keys\":36,\"./_export\":37,\"./_fails\":38,\"./_global\":39,\"./_has\":40,\"./_hide\":41,\"./_is-array\":45,\"./_keyof\":51,\"./_library\":52,\"./_meta\":53,\"./_object-create\":54,\"./_object-dp\":55,\"./_object-gopd\":57,\"./_object-gopn\":59,\"./_object-gopn-ext\":58,\"./_object-gops\":60,\"./_object-keys\":63,\"./_object-pie\":64,\"./_property-desc\":66,\"./_redefine\":67,\"./_set-to-string-tag\":69,\"./_shared\":71,\"./_to-iobject\":75,\"./_to-primitive\":78,\"./_uid\":79,\"./_wks\":82,\"./_wks-define\":80,\"./_wks-ext\":81}],93:[function(e,t,r){e(\"./_wks-define\")(\"asyncIterator\")},{\"./_wks-define\":80}],94:[function(e,t,r){e(\"./_wks-define\")(\"observable\")},{\"./_wks-define\":80}],95:[function(e,t,r){e(\"./es6.array.iterator\");for(var n=e(\"./_global\"),o=e(\"./_hide\"),i=e(\"./_iterators\"),a=e(\"./_wks\")(\"toStringTag\"),s=[\"NodeList\",\"DOMTokenList\",\"MediaList\",\"StyleSheetList\",\"CSSRuleList\"],u=0;u<5;u++){var c=s[u],l=n[c],f=l&&l.prototype;f&&!f[a]&&o(f,a,c),i[c]=i.Array}},{\"./_global\":39,\"./_hide\":41,\"./_iterators\":50,\"./_wks\":82,\"./es6.array.iterator\":83}],96:[function(e,t,r){function n(){throw new Error(\"setTimeout has not been defined\")}function o(){throw new Error(\"clearTimeout has not been defined\")}function i(e){if(f===setTimeout)return setTimeout(e,0);if((f===n||!f)&&setTimeout)return f=setTimeout,setTimeout(e,0);try{return f(e,0)}catch(t){try{return f.call(null,e,0)}catch(t){return f.call(this,e,0)}}}function a(e){if(d===clearTimeout)return clearTimeout(e);if((d===o||!d)&&clearTimeout)return d=clearTimeout,clearTimeout(e);try{return d(e)}catch(t){try{return d.call(null,e)}catch(t){return d.call(this,e)}}}function s(){m&&h&&(m=!1,h.length?y=h.concat(y):v=-1,y.length&&u())}function u(){if(!m){var e=i(s);m=!0;for(var t=y.length;t;){for(h=y,y=[];++v<t;)h&&h[v].run();v=-1,t=y.length}h=null,m=!1,a(e)}}function c(e,t){this.fun=e,this.array=t}function l(){}var f,d,p=t.exports={};!function(){try{f=\"function\"==typeof setTimeout?setTimeout:n}catch(e){f=n}try{d=\"function\"==typeof clearTimeout?clearTimeout:o}catch(e){d=o}}();var h,y=[],m=!1,v=-1;p.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)t[r-1]=arguments[r];y.push(new c(e,t)),1!==y.length||m||i(u)},c.prototype.run=function(){this.fun.apply(null,this.array)},p.title=\"browser\",p.browser=!0,p.env={},p.argv=[],p.version=\"\",p.versions={},p.on=l,p.addListener=l,p.once=l,p.off=l,p.removeListener=l,p.removeAllListeners=l,p.emit=l,p.binding=function(e){throw new Error(\"process.binding is not supported\")},p.cwd=function(){return\"/\"},p.chdir=function(e){throw new Error(\"process.chdir is not supported\")},p.umask=function(){return 0}},{}],97:[function(e,t,r){(function(r){var n=\"object\"==typeof r?r:\"object\"==typeof window?window:\"object\"==typeof self?self:this,o=n.regeneratorRuntime&&Object.getOwnPropertyNames(n).indexOf(\"regeneratorRuntime\")>=0,i=o&&n.regeneratorRuntime;if(n.regeneratorRuntime=void 0,t.exports=e(\"./runtime\"),o)n.regeneratorRuntime=i;else try{delete n.regeneratorRuntime}catch(a){n.regeneratorRuntime=void 0}}).call(this,\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{\"./runtime\":98}],98:[function(e,t,r){(function(e,r){!function(r){\"use strict\";function n(e,t,r,n){var o=Object.create((t||i).prototype),a=new h(n||[]);return o._invoke=f(e,r,a),o}function o(e,t,r){try{return{type:\"normal\",arg:e.call(t,r)}}catch(n){return{type:\"throw\",arg:n}}}function i(){}function a(){}function s(){}function u(e){[\"next\",\"throw\",\"return\"].forEach(function(t){e[t]=function(e){return this._invoke(t,e)}})}function c(e){this.arg=e}function l(t){function r(e,n,i,a){var s=o(t[e],t,n);if(\"throw\"!==s.type){var u=s.arg,l=u.value;return l instanceof c?Promise.resolve(l.arg).then(function(e){r(\"next\",e,i,a)},function(e){r(\"throw\",e,i,a)}):Promise.resolve(l).then(function(e){u.value=e,i(u)},a)}a(s.arg)}function n(e,t){function n(){return new Promise(function(n,o){r(e,t,n,o)})}return i=i?i.then(n,n):n()}\"object\"==typeof e&&e.domain&&(r=e.domain.bind(r));var i;this._invoke=n}function f(e,t,r){var n=O;return function(i,a){if(n===x)throw new Error(\"Generator is already running\");if(n===P){if(\"throw\"===i)throw a;return m()}for(;;){var s=r.delegate;if(s){if(\"return\"===i||\"throw\"===i&&s.iterator[i]===v){r.delegate=null;var u=s.iterator[\"return\"];if(u){var c=o(u,s.iterator,a);if(\"throw\"===c.type){i=\"throw\",a=c.arg;continue}}if(\"return\"===i)continue}var c=o(s.iterator[i],s.iterator,a);if(\"throw\"===c.type){r.delegate=null,i=\"throw\",a=c.arg;continue}i=\"next\",a=v;var l=c.arg;if(!l.done)return n=M,l;r[s.resultName]=l.value,r.next=s.nextLoc,r.delegate=null}if(\"next\"===i)r.sent=r._sent=a;else if(\"throw\"===i){if(n===O)throw n=P,a;r.dispatchException(a)&&(i=\"next\",a=v)}else\"return\"===i&&r.abrupt(\"return\",a);n=x;var c=o(e,t,r);if(\"normal\"===c.type){n=r.done?P:M;var l={value:c.arg,done:r.done};if(c.arg!==k)return l;r.delegate&&\"next\"===i&&(a=v)}else\"throw\"===c.type&&(n=P,i=\"throw\",a=c.arg)}}}function d(e){var t={tryLoc:e[0]};1 in e&&(t.catchLoc=e[1]),2 in e&&(t.finallyLoc=e[2],t.afterLoc=e[3]),this.tryEntries.push(t)}function p(e){var t=e.completion||{};t.type=\"normal\",delete t.arg,e.completion=t}function h(e){this.tryEntries=[{tryLoc:\"root\"}],e.forEach(d,this),this.reset(!0)}function y(e){if(e){var t=e[g];if(t)return t.call(e);if(\"function\"==typeof e.next)return e;if(!isNaN(e.length)){var r=-1,n=function o(){for(;++r<e.length;)if(_.call(e,r))return o.value=e[r],o.done=!1,o;return o.value=v,o.done=!0,o};return n.next=n}}return{next:m}}function m(){return{value:v,done:!0}}var v,_=Object.prototype.hasOwnProperty,b=\"function\"==typeof Symbol?Symbol:{},g=b.iterator||\"@@iterator\",E=b.toStringTag||\"@@toStringTag\",j=\"object\"==typeof t,w=r.regeneratorRuntime;if(w)return void(j&&(t.exports=w));w=r.regeneratorRuntime=j?t.exports:{},w.wrap=n;var O=\"suspendedStart\",M=\"suspendedYield\",x=\"executing\",P=\"completed\",k={},R=s.prototype=i.prototype;a.prototype=R.constructor=s,s.constructor=a,s[E]=a.displayName=\"GeneratorFunction\",w.isGeneratorFunction=function(e){var t=\"function\"==typeof e&&e.constructor;return!!t&&(t===a||\"GeneratorFunction\"===(t.displayName||t.name))},w.mark=function(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,s):(e.__proto__=s,E in e||(e[E]=\"GeneratorFunction\")),\ne.prototype=Object.create(R),e},w.awrap=function(e){return new c(e)},u(l.prototype),w.async=function(e,t,r,o){var i=new l(n(e,t,r,o));return w.isGeneratorFunction(t)?i:i.next().then(function(e){return e.done?e.value:i.next()})},u(R),R[g]=function(){return this},R[E]=\"Generator\",R.toString=function(){return\"[object Generator]\"},w.keys=function(e){var t=[];for(var r in e)t.push(r);return t.reverse(),function n(){for(;t.length;){var r=t.pop();if(r in e)return n.value=r,n.done=!1,n}return n.done=!0,n}},w.values=y,h.prototype={constructor:h,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=v,this.done=!1,this.delegate=null,this.tryEntries.forEach(p),!e)for(var t in this)\"t\"===t.charAt(0)&&_.call(this,t)&&!isNaN(+t.slice(1))&&(this[t]=v)},stop:function(){this.done=!0;var e=this.tryEntries[0],t=e.completion;if(\"throw\"===t.type)throw t.arg;return this.rval},dispatchException:function(e){function t(t,n){return i.type=\"throw\",i.arg=e,r.next=t,!!n}if(this.done)throw e;for(var r=this,n=this.tryEntries.length-1;n>=0;--n){var o=this.tryEntries[n],i=o.completion;if(\"root\"===o.tryLoc)return t(\"end\");if(o.tryLoc<=this.prev){var a=_.call(o,\"catchLoc\"),s=_.call(o,\"finallyLoc\");if(a&&s){if(this.prev<o.catchLoc)return t(o.catchLoc,!0);if(this.prev<o.finallyLoc)return t(o.finallyLoc)}else if(a){if(this.prev<o.catchLoc)return t(o.catchLoc,!0)}else{if(!s)throw new Error(\"try statement without catch or finally\");if(this.prev<o.finallyLoc)return t(o.finallyLoc)}}}},abrupt:function(e,t){for(var r=this.tryEntries.length-1;r>=0;--r){var n=this.tryEntries[r];if(n.tryLoc<=this.prev&&_.call(n,\"finallyLoc\")&&this.prev<n.finallyLoc){var o=n;break}}o&&(\"break\"===e||\"continue\"===e)&&o.tryLoc<=t&&t<=o.finallyLoc&&(o=null);var i=o?o.completion:{};return i.type=e,i.arg=t,o?this.next=o.finallyLoc:this.complete(i),k},complete:function(e,t){if(\"throw\"===e.type)throw e.arg;\"break\"===e.type||\"continue\"===e.type?this.next=e.arg:\"return\"===e.type?(this.rval=e.arg,this.next=\"end\"):\"normal\"===e.type&&t&&(this.next=t)},finish:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var r=this.tryEntries[t];if(r.finallyLoc===e)return this.complete(r.completion,r.afterLoc),p(r),k}},\"catch\":function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var r=this.tryEntries[t];if(r.tryLoc===e){var n=r.completion;if(\"throw\"===n.type){var o=n.arg;p(r)}return o}}throw new Error(\"illegal catch attempt\")},delegateYield:function(e,t,r){return this.delegate={iterator:y(e),resultName:t,nextLoc:r},k}}}(\"object\"==typeof r?r:\"object\"==typeof window?window:\"object\"==typeof self?self:this)}).call(this,e(\"_process\"),\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{_process:96}],99:[function(t,r,n){!function(t,n){\"function\"==typeof e&&e.amd?e([],n):\"undefined\"!=typeof r&&r.exports?r.exports=n():t.tv4=n()}(this,function(){function e(e){return encodeURI(e).replace(/%25[0-9][0-9]/g,function(e){return\"%\"+e.substring(3)})}function t(t){var r=\"\";d[t.charAt(0)]&&(r=t.charAt(0),t=t.substring(1));var n=\"\",o=\"\",i=!0,a=!1,s=!1;\"+\"===r?i=!1:\".\"===r?(o=\".\",n=\".\"):\"/\"===r?(o=\"/\",n=\"/\"):\"#\"===r?(o=\"#\",i=!1):\";\"===r?(o=\";\",n=\";\",a=!0,s=!0):\"?\"===r?(o=\"?\",n=\"&\",a=!0):\"&\"===r&&(o=\"&\",n=\"&\",a=!0);for(var u=[],c=t.split(\",\"),l=[],f={},h=0;h<c.length;h++){var y=c[h],m=null;if(y.indexOf(\":\")!==-1){var v=y.split(\":\");y=v[0],m=parseInt(v[1],10)}for(var _={};p[y.charAt(y.length-1)];)_[y.charAt(y.length-1)]=!0,y=y.substring(0,y.length-1);var b={truncate:m,name:y,suffices:_};l.push(b),f[y]=b,u.push(y)}var g=function(t){for(var r=\"\",u=0,c=0;c<l.length;c++){var f=l[c],d=t(f.name);if(null===d||void 0===d||Array.isArray(d)&&0===d.length||\"object\"==typeof d&&0===Object.keys(d).length)u++;else if(r+=c===u?o:n||\",\",Array.isArray(d)){a&&(r+=f.name+\"=\");for(var p=0;p<d.length;p++)p>0&&(r+=f.suffices[\"*\"]?n||\",\":\",\",f.suffices[\"*\"]&&a&&(r+=f.name+\"=\")),r+=i?encodeURIComponent(d[p]).replace(/!/g,\"%21\"):e(d[p])}else if(\"object\"==typeof d){a&&!f.suffices[\"*\"]&&(r+=f.name+\"=\");var h=!0;for(var y in d)h||(r+=f.suffices[\"*\"]?n||\",\":\",\"),h=!1,r+=i?encodeURIComponent(y).replace(/!/g,\"%21\"):e(y),r+=f.suffices[\"*\"]?\"=\":\",\",r+=i?encodeURIComponent(d[y]).replace(/!/g,\"%21\"):e(d[y])}else a&&(r+=f.name,s&&\"\"===d||(r+=\"=\")),null!=f.truncate&&(d=d.substring(0,f.truncate)),r+=i?encodeURIComponent(d).replace(/!/g,\"%21\"):e(d)}return r};return g.varNames=u,{prefix:o,substitution:g}}function r(e){if(!(this instanceof r))return new r(e);for(var n=e.split(\"{\"),o=[n.shift()],i=[],a=[],s=[];n.length>0;){var u=n.shift(),c=u.split(\"}\")[0],l=u.substring(c.length+1),f=t(c);a.push(f.substitution),i.push(f.prefix),o.push(l),s=s.concat(f.substitution.varNames)}this.fill=function(e){for(var t=o[0],r=0;r<a.length;r++){var n=a[r];t+=n(e),t+=o[r+1]}return t},this.varNames=s,this.template=e}function n(e,t){if(e===t)return!0;if(e&&t&&\"object\"==typeof e&&\"object\"==typeof t){if(Array.isArray(e)!==Array.isArray(t))return!1;if(Array.isArray(e)){if(e.length!==t.length)return!1;for(var r=0;r<e.length;r++)if(!n(e[r],t[r]))return!1}else{var o;for(o in e)if(void 0===t[o]&&void 0!==e[o])return!1;for(o in t)if(void 0===e[o]&&void 0!==t[o])return!1;for(o in e)if(!n(e[o],t[o]))return!1}return!0}return!1}function o(e){var t=String(e).replace(/^\\s+|\\s+$/g,\"\").match(/^([^:\\/?#]+:)?(\\/\\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\\/?#]*)(?::(\\d*))?))?([^?#]*)(\\?[^#]*)?(#[\\s\\S]*)?/);return t?{href:t[0]||\"\",protocol:t[1]||\"\",authority:t[2]||\"\",host:t[3]||\"\",hostname:t[4]||\"\",port:t[5]||\"\",pathname:t[6]||\"\",search:t[7]||\"\",hash:t[8]||\"\"}:null}function i(e,t){function r(e){var t=[];return e.replace(/^(\\.\\.?(\\/|$))+/,\"\").replace(/\\/(\\.(\\/|$))+/g,\"/\").replace(/\\/\\.\\.$/,\"/../\").replace(/\\/?[^\\/]*/g,function(e){\"/..\"===e?t.pop():t.push(e)}),t.join(\"\").replace(/^\\//,\"/\"===e.charAt(0)?\"/\":\"\")}return t=o(t||\"\"),e=o(e||\"\"),t&&e?(t.protocol||e.protocol)+(t.protocol||t.authority?t.authority:e.authority)+r(t.protocol||t.authority||\"/\"===t.pathname.charAt(0)?t.pathname:t.pathname?(e.authority&&!e.pathname?\"/\":\"\")+e.pathname.slice(0,e.pathname.lastIndexOf(\"/\")+1)+t.pathname:e.pathname)+(t.protocol||t.authority||t.pathname?t.search:t.search||e.search)+t.hash:null}function a(e){return e.split(\"#\")[0]}function s(e,t){if(e&&\"object\"==typeof e)if(void 0===t?t=e.id:\"string\"==typeof e.id&&(t=i(t,e.id),e.id=t),Array.isArray(e))for(var r=0;r<e.length;r++)s(e[r],t);else{\"string\"==typeof e.$ref&&(e.$ref=i(t,e.$ref));for(var n in e)\"enum\"!==n&&s(e[n],t)}}function u(e){e=e||\"en\";var t=E[e];return function(e){var r=t[e.code]||g[e.code];if(\"string\"!=typeof r)return\"Unknown error code \"+e.code+\": \"+JSON.stringify(e.messageParams);var n=e.params;return r.replace(/\\{([^{}]*)\\}/g,function(e,t){var r=n[t];return\"string\"==typeof r||\"number\"==typeof r?r:e})}}function c(e,t,r,n,o){if(Error.call(this),void 0===e)throw new Error(\"No error code supplied: \"+n);this.message=\"\",this.params=t,this.code=e,this.dataPath=r||\"\",this.schemaPath=n||\"\",this.subErrors=o||null;var i=new Error(this.message);if(this.stack=i.stack||i.stacktrace,!this.stack)try{throw i}catch(i){this.stack=i.stack||i.stacktrace}}function l(e,t){if(t.substring(0,e.length)===e){var r=t.substring(e.length);if(t.length>0&&\"/\"===t.charAt(e.length-1)||\"#\"===r.charAt(0)||\"?\"===r.charAt(0))return!0}return!1}function f(e){var t,r,n=new h,o={setErrorReporter:function(e){return\"string\"==typeof e?this.language(e):(r=e,!0)},addFormat:function(){n.addFormat.apply(n,arguments)},language:function(e){return e?(E[e]||(e=e.split(\"-\")[0]),!!E[e]&&(t=e,e)):t},addLanguage:function(e,t){var r;for(r in v)t[r]&&!t[v[r]]&&(t[v[r]]=t[r]);var n=e.split(\"-\")[0];if(E[n]){E[e]=Object.create(E[n]);for(r in t)\"undefined\"==typeof E[n][r]&&(E[n][r]=t[r]),E[e][r]=t[r]}else E[e]=t,E[n]=t;return this},freshApi:function(e){var t=f();return e&&t.language(e),t},validate:function(e,o,i,a){var s=u(t),c=r?function(e,t,n){return r(e,t,n)||s(e,t,n)}:s,l=new h(n,(!1),c,i,a);\"string\"==typeof o&&(o={$ref:o}),l.addSchema(\"\",o);var f=l.validateAll(e,o,null,null,\"\");return!f&&a&&(f=l.banUnknownProperties(e,o)),this.error=f,this.missing=l.missing,this.valid=null===f,this.valid},validateResult:function(){var e={};return this.validate.apply(e,arguments),e},validateMultiple:function(e,o,i,a){var s=u(t),c=r?function(e,t,n){return r(e,t,n)||s(e,t,n)}:s,l=new h(n,(!0),c,i,a);\"string\"==typeof o&&(o={$ref:o}),l.addSchema(\"\",o),l.validateAll(e,o,null,null,\"\"),a&&l.banUnknownProperties(e,o);var f={};return f.errors=l.errors,f.missing=l.missing,f.valid=0===f.errors.length,f},addSchema:function(){return n.addSchema.apply(n,arguments)},getSchema:function(){return n.getSchema.apply(n,arguments)},getSchemaMap:function(){return n.getSchemaMap.apply(n,arguments)},getSchemaUris:function(){return n.getSchemaUris.apply(n,arguments)},getMissingUris:function(){return n.getMissingUris.apply(n,arguments)},dropSchemas:function(){n.dropSchemas.apply(n,arguments)},defineKeyword:function(){n.defineKeyword.apply(n,arguments)},defineError:function(e,t,r){if(\"string\"!=typeof e||!/^[A-Z]+(_[A-Z]+)*$/.test(e))throw new Error(\"Code name must be a string in UPPER_CASE_WITH_UNDERSCORES\");if(\"number\"!=typeof t||t%1!==0||t<1e4)throw new Error(\"Code number must be an integer > 10000\");if(\"undefined\"!=typeof v[e])throw new Error(\"Error already defined: \"+e+\" as \"+v[e]);if(\"undefined\"!=typeof _[t])throw new Error(\"Error code already used: \"+_[t]+\" as \"+t);v[e]=t,_[t]=e,g[e]=g[t]=r;for(var n in E){var o=E[n];o[e]&&(o[t]=o[t]||o[e])}},reset:function(){n.reset(),this.error=null,this.missing=[],this.valid=!0},missing:[],error:null,valid:!0,normSchema:s,resolveUrl:i,getDocumentUri:a,errorCodes:v};return o.language(e||\"en\"),o}Object.keys||(Object.keys=function(){var e=Object.prototype.hasOwnProperty,t=!{toString:null}.propertyIsEnumerable(\"toString\"),r=[\"toString\",\"toLocaleString\",\"valueOf\",\"hasOwnProperty\",\"isPrototypeOf\",\"propertyIsEnumerable\",\"constructor\"],n=r.length;return function(o){if(\"object\"!=typeof o&&\"function\"!=typeof o||null===o)throw new TypeError(\"Object.keys called on non-object\");var i=[];for(var a in o)e.call(o,a)&&i.push(a);if(t)for(var s=0;s<n;s++)e.call(o,r[s])&&i.push(r[s]);return i}}()),Object.create||(Object.create=function(){function e(){}return function(t){if(1!==arguments.length)throw new Error(\"Object.create implementation only accepts one parameter.\");return e.prototype=t,new e}}()),Array.isArray||(Array.isArray=function(e){return\"[object Array]\"===Object.prototype.toString.call(e)}),Array.prototype.indexOf||(Array.prototype.indexOf=function(e){if(null===this)throw new TypeError;var t=Object(this),r=t.length>>>0;if(0===r)return-1;var n=0;if(arguments.length>1&&(n=Number(arguments[1]),n!==n?n=0:0!==n&&n!==1/0&&n!==-(1/0)&&(n=(n>0||-1)*Math.floor(Math.abs(n)))),n>=r)return-1;for(var o=n>=0?n:Math.max(r-Math.abs(n),0);o<r;o++)if(o in t&&t[o]===e)return o;return-1}),Object.isFrozen||(Object.isFrozen=function(e){for(var t=\"tv4_test_frozen_key\";e.hasOwnProperty(t);)t+=Math.random();try{return e[t]=!0,delete e[t],!1}catch(r){return!0}});var d={\"+\":!0,\"#\":!0,\".\":!0,\"/\":!0,\";\":!0,\"?\":!0,\"&\":!0},p={\"*\":!0};r.prototype={toString:function(){return this.template},fillFromObject:function(e){return this.fill(function(t){return e[t]})}};var h=function(e,t,r,n,o){if(this.missing=[],this.missingMap={},this.formatValidators=e?Object.create(e.formatValidators):{},this.schemas=e?Object.create(e.schemas):{},this.collectMultiple=t,this.errors=[],this.handleError=t?this.collectError:this.returnError,n&&(this.checkRecursive=!0,this.scanned=[],this.scannedFrozen=[],this.scannedFrozenSchemas=[],this.scannedFrozenValidationErrors=[],this.validatedSchemasKey=\"tv4_validation_id\",this.validationErrorsKey=\"tv4_validation_errors_id\"),o&&(this.trackUnknownProperties=!0,this.knownPropertyPaths={},this.unknownPropertyPaths={}),this.errorReporter=r||u(\"en\"),\"string\"==typeof this.errorReporter)throw new Error(\"debug\");if(this.definedKeywords={},e)for(var i in e.definedKeywords)this.definedKeywords[i]=e.definedKeywords[i].slice(0)};h.prototype.defineKeyword=function(e,t){this.definedKeywords[e]=this.definedKeywords[e]||[],this.definedKeywords[e].push(t)},h.prototype.createError=function(e,t,r,n,o,i,a){var s=new c(e,t,r,n,o);return s.message=this.errorReporter(s,i,a),s},h.prototype.returnError=function(e){return e},h.prototype.collectError=function(e){return e&&this.errors.push(e),null},h.prototype.prefixErrors=function(e,t,r){for(var n=e;n<this.errors.length;n++)this.errors[n]=this.errors[n].prefixWith(t,r);return this},h.prototype.banUnknownProperties=function(e,t){for(var r in this.unknownPropertyPaths){var n=this.createError(v.UNKNOWN_PROPERTY,{path:r},r,\"\",null,e,t),o=this.handleError(n);if(o)return o}return null},h.prototype.addFormat=function(e,t){if(\"object\"==typeof e){for(var r in e)this.addFormat(r,e[r]);return this}this.formatValidators[e]=t},h.prototype.resolveRefs=function(e,t){if(void 0!==e.$ref){if(t=t||{},t[e.$ref])return this.createError(v.CIRCULAR_REFERENCE,{urls:Object.keys(t).join(\", \")},\"\",\"\",null,void 0,e);t[e.$ref]=!0,e=this.getSchema(e.$ref,t)}return e},h.prototype.getSchema=function(e,t){var r;if(void 0!==this.schemas[e])return r=this.schemas[e],this.resolveRefs(r,t);var n=e,o=\"\";if(e.indexOf(\"#\")!==-1&&(o=e.substring(e.indexOf(\"#\")+1),n=e.substring(0,e.indexOf(\"#\"))),\"object\"==typeof this.schemas[n]){r=this.schemas[n];var i=decodeURIComponent(o);if(\"\"===i)return this.resolveRefs(r,t);if(\"/\"!==i.charAt(0))return;for(var a=i.split(\"/\").slice(1),s=0;s<a.length;s++){var u=a[s].replace(/~1/g,\"/\").replace(/~0/g,\"~\");if(void 0===r[u]){r=void 0;break}r=r[u]}if(void 0!==r)return this.resolveRefs(r,t)}void 0===this.missing[n]&&(this.missing.push(n),this.missing[n]=n,this.missingMap[n]=n)},h.prototype.searchSchemas=function(e,t){if(Array.isArray(e))for(var r=0;r<e.length;r++)this.searchSchemas(e[r],t);else if(e&&\"object\"==typeof e){\"string\"==typeof e.id&&l(t,e.id)&&void 0===this.schemas[e.id]&&(this.schemas[e.id]=e);for(var n in e)if(\"enum\"!==n)if(\"object\"==typeof e[n])this.searchSchemas(e[n],t);else if(\"$ref\"===n){var o=a(e[n]);o&&void 0===this.schemas[o]&&void 0===this.missingMap[o]&&(this.missingMap[o]=o)}}},h.prototype.addSchema=function(e,t){if(\"string\"!=typeof e||\"undefined\"==typeof t){if(\"object\"!=typeof e||\"string\"!=typeof e.id)return;t=e,e=t.id}e===a(e)+\"#\"&&(e=a(e)),this.schemas[e]=t,delete this.missingMap[e],s(t,e),this.searchSchemas(t,e)},h.prototype.getSchemaMap=function(){var e={};for(var t in this.schemas)e[t]=this.schemas[t];return e},h.prototype.getSchemaUris=function(e){var t=[];for(var r in this.schemas)e&&!e.test(r)||t.push(r);return t},h.prototype.getMissingUris=function(e){var t=[];for(var r in this.missingMap)e&&!e.test(r)||t.push(r);return t},h.prototype.dropSchemas=function(){this.schemas={},this.reset()},h.prototype.reset=function(){this.missing=[],this.missingMap={},this.errors=[]},h.prototype.validateAll=function(e,t,r,n,o){var i;if(t=this.resolveRefs(t),!t)return null;if(t instanceof c)return this.errors.push(t),t;var a,s=this.errors.length,u=null,l=null;if(this.checkRecursive&&e&&\"object\"==typeof e){if(i=!this.scanned.length,e[this.validatedSchemasKey]){var f=e[this.validatedSchemasKey].indexOf(t);if(f!==-1)return this.errors=this.errors.concat(e[this.validationErrorsKey][f]),null}if(Object.isFrozen(e)&&(a=this.scannedFrozen.indexOf(e),a!==-1)){var d=this.scannedFrozenSchemas[a].indexOf(t);if(d!==-1)return this.errors=this.errors.concat(this.scannedFrozenValidationErrors[a][d]),null}if(this.scanned.push(e),Object.isFrozen(e))a===-1&&(a=this.scannedFrozen.length,this.scannedFrozen.push(e),this.scannedFrozenSchemas.push([])),u=this.scannedFrozenSchemas[a].length,this.scannedFrozenSchemas[a][u]=t,this.scannedFrozenValidationErrors[a][u]=[];else{if(!e[this.validatedSchemasKey])try{Object.defineProperty(e,this.validatedSchemasKey,{value:[],configurable:!0}),Object.defineProperty(e,this.validationErrorsKey,{value:[],configurable:!0})}catch(p){e[this.validatedSchemasKey]=[],e[this.validationErrorsKey]=[]}l=e[this.validatedSchemasKey].length,e[this.validatedSchemasKey][l]=t,e[this.validationErrorsKey][l]=[]}}var h=this.errors.length,y=this.validateBasic(e,t,o)||this.validateNumeric(e,t,o)||this.validateString(e,t,o)||this.validateArray(e,t,o)||this.validateObject(e,t,o)||this.validateCombinations(e,t,o)||this.validateHypermedia(e,t,o)||this.validateFormat(e,t,o)||this.validateDefinedKeywords(e,t,o)||null;if(i){for(;this.scanned.length;){var m=this.scanned.pop();delete m[this.validatedSchemasKey]}this.scannedFrozen=[],this.scannedFrozenSchemas=[]}if(y||h!==this.errors.length)for(;r&&r.length||n&&n.length;){var v=r&&r.length?\"\"+r.pop():null,_=n&&n.length?\"\"+n.pop():null;y&&(y=y.prefixWith(v,_)),this.prefixErrors(h,v,_)}return null!==u?this.scannedFrozenValidationErrors[a][u]=this.errors.slice(s):null!==l&&(e[this.validationErrorsKey][l]=this.errors.slice(s)),this.handleError(y)},h.prototype.validateFormat=function(e,t){if(\"string\"!=typeof t.format||!this.formatValidators[t.format])return null;var r=this.formatValidators[t.format].call(null,e,t);return\"string\"==typeof r||\"number\"==typeof r?this.createError(v.FORMAT_CUSTOM,{message:r},\"\",\"/format\",null,e,t):r&&\"object\"==typeof r?this.createError(v.FORMAT_CUSTOM,{message:r.message||\"?\"},r.dataPath||\"\",r.schemaPath||\"/format\",null,e,t):null},h.prototype.validateDefinedKeywords=function(e,t,r){for(var n in this.definedKeywords)if(\"undefined\"!=typeof t[n])for(var o=this.definedKeywords[n],i=0;i<o.length;i++){var a=o[i],s=a(e,t[n],t,r);if(\"string\"==typeof s||\"number\"==typeof s)return this.createError(v.KEYWORD_CUSTOM,{key:n,message:s},\"\",\"\",null,e,t).prefixWith(null,n);if(s&&\"object\"==typeof s){var u=s.code;if(\"string\"==typeof u){if(!v[u])throw new Error(\"Undefined error code (use defineError): \"+u);u=v[u]}else\"number\"!=typeof u&&(u=v.KEYWORD_CUSTOM);var c=\"object\"==typeof s.message?s.message:{key:n,message:s.message||\"?\"},l=s.schemaPath||\"/\"+n.replace(/~/g,\"~0\").replace(/\\//g,\"~1\");return this.createError(u,c,s.dataPath||null,l,null,e,t)}}return null},h.prototype.validateBasic=function(e,t,r){var n;return(n=this.validateType(e,t,r))?n.prefixWith(null,\"type\"):(n=this.validateEnum(e,t,r))?n.prefixWith(null,\"type\"):null},h.prototype.validateType=function(e,t){if(void 0===t.type)return null;var r=typeof e;null===e?r=\"null\":Array.isArray(e)&&(r=\"array\");var n=t.type;Array.isArray(n)||(n=[n]);for(var o=0;o<n.length;o++){var i=n[o];if(i===r||\"integer\"===i&&\"number\"===r&&e%1===0)return null}return this.createError(v.INVALID_TYPE,{type:r,expected:n.join(\"/\")},\"\",\"\",null,e,t)},h.prototype.validateEnum=function(e,t){if(void 0===t[\"enum\"])return null;for(var r=0;r<t[\"enum\"].length;r++){var o=t[\"enum\"][r];if(n(e,o))return null}return this.createError(v.ENUM_MISMATCH,{value:\"undefined\"!=typeof JSON?JSON.stringify(e):e},\"\",\"\",null,e,t)},h.prototype.validateNumeric=function(e,t,r){return this.validateMultipleOf(e,t,r)||this.validateMinMax(e,t,r)||this.validateNaN(e,t,r)||null};var y=Math.pow(2,-51),m=1-y;h.prototype.validateMultipleOf=function(e,t){var r=t.multipleOf||t.divisibleBy;if(void 0===r)return null;if(\"number\"==typeof e){var n=e/r%1;if(n>=y&&n<m)return this.createError(v.NUMBER_MULTIPLE_OF,{value:e,multipleOf:r},\"\",\"\",null,e,t)}return null},h.prototype.validateMinMax=function(e,t){if(\"number\"!=typeof e)return null;if(void 0!==t.minimum){if(e<t.minimum)return this.createError(v.NUMBER_MINIMUM,{value:e,minimum:t.minimum},\"\",\"/minimum\",null,e,t);if(t.exclusiveMinimum&&e===t.minimum)return this.createError(v.NUMBER_MINIMUM_EXCLUSIVE,{value:e,minimum:t.minimum},\"\",\"/exclusiveMinimum\",null,e,t)}if(void 0!==t.maximum){if(e>t.maximum)return this.createError(v.NUMBER_MAXIMUM,{value:e,maximum:t.maximum},\"\",\"/maximum\",null,e,t);if(t.exclusiveMaximum&&e===t.maximum)return this.createError(v.NUMBER_MAXIMUM_EXCLUSIVE,{value:e,maximum:t.maximum},\"\",\"/exclusiveMaximum\",null,e,t)}return null},h.prototype.validateNaN=function(e,t){return\"number\"!=typeof e?null:isNaN(e)===!0||e===1/0||e===-(1/0)?this.createError(v.NUMBER_NOT_A_NUMBER,{value:e},\"\",\"/type\",null,e,t):null},h.prototype.validateString=function(e,t,r){return this.validateStringLength(e,t,r)||this.validateStringPattern(e,t,r)||null},h.prototype.validateStringLength=function(e,t){return\"string\"!=typeof e?null:void 0!==t.minLength&&e.length<t.minLength?this.createError(v.STRING_LENGTH_SHORT,{length:e.length,minimum:t.minLength},\"\",\"/minLength\",null,e,t):void 0!==t.maxLength&&e.length>t.maxLength?this.createError(v.STRING_LENGTH_LONG,{length:e.length,maximum:t.maxLength},\"\",\"/maxLength\",null,e,t):null},h.prototype.validateStringPattern=function(e,t){if(\"string\"!=typeof e||\"string\"!=typeof t.pattern&&!(t.pattern instanceof RegExp))return null;var r;if(t.pattern instanceof RegExp)r=t.pattern;else{var n,o=\"\",i=t.pattern.match(/^\\/(.+)\\/([img]*)$/);i?(n=i[1],o=i[2]):n=t.pattern,r=new RegExp(n,o)}return r.test(e)?null:this.createError(v.STRING_PATTERN,{pattern:t.pattern},\"\",\"/pattern\",null,e,t)},h.prototype.validateArray=function(e,t,r){return Array.isArray(e)?this.validateArrayLength(e,t,r)||this.validateArrayUniqueItems(e,t,r)||this.validateArrayItems(e,t,r)||null:null},h.prototype.validateArrayLength=function(e,t){var r;return void 0!==t.minItems&&e.length<t.minItems&&(r=this.createError(v.ARRAY_LENGTH_SHORT,{length:e.length,minimum:t.minItems},\"\",\"/minItems\",null,e,t),this.handleError(r))?r:void 0!==t.maxItems&&e.length>t.maxItems&&(r=this.createError(v.ARRAY_LENGTH_LONG,{length:e.length,maximum:t.maxItems},\"\",\"/maxItems\",null,e,t),this.handleError(r))?r:null},h.prototype.validateArrayUniqueItems=function(e,t){if(t.uniqueItems)for(var r=0;r<e.length;r++)for(var o=r+1;o<e.length;o++)if(n(e[r],e[o])){var i=this.createError(v.ARRAY_UNIQUE,{match1:r,match2:o},\"\",\"/uniqueItems\",null,e,t);if(this.handleError(i))return i}return null},h.prototype.validateArrayItems=function(e,t,r){if(void 0===t.items)return null;var n,o;if(Array.isArray(t.items)){for(o=0;o<e.length;o++)if(o<t.items.length){if(n=this.validateAll(e[o],t.items[o],[o],[\"items\",o],r+\"/\"+o))return n}else if(void 0!==t.additionalItems)if(\"boolean\"==typeof t.additionalItems){if(!t.additionalItems&&(n=this.createError(v.ARRAY_ADDITIONAL_ITEMS,{},\"/\"+o,\"/additionalItems\",null,e,t),this.handleError(n)))return n}else if(n=this.validateAll(e[o],t.additionalItems,[o],[\"additionalItems\"],r+\"/\"+o))return n}else for(o=0;o<e.length;o++)if(n=this.validateAll(e[o],t.items,[o],[\"items\"],r+\"/\"+o))return n;return null},h.prototype.validateObject=function(e,t,r){return\"object\"!=typeof e||null===e||Array.isArray(e)?null:this.validateObjectMinMaxProperties(e,t,r)||this.validateObjectRequiredProperties(e,t,r)||this.validateObjectProperties(e,t,r)||this.validateObjectDependencies(e,t,r)||null},h.prototype.validateObjectMinMaxProperties=function(e,t){var r,n=Object.keys(e);return void 0!==t.minProperties&&n.length<t.minProperties&&(r=this.createError(v.OBJECT_PROPERTIES_MINIMUM,{propertyCount:n.length,minimum:t.minProperties},\"\",\"/minProperties\",null,e,t),this.handleError(r))?r:void 0!==t.maxProperties&&n.length>t.maxProperties&&(r=this.createError(v.OBJECT_PROPERTIES_MAXIMUM,{propertyCount:n.length,maximum:t.maxProperties},\"\",\"/maxProperties\",null,e,t),this.handleError(r))?r:null},h.prototype.validateObjectRequiredProperties=function(e,t){if(void 0!==t.required)for(var r=0;r<t.required.length;r++){var n=t.required[r];if(void 0===e[n]){var o=this.createError(v.OBJECT_REQUIRED,{key:n},\"\",\"/required/\"+r,null,e,t);if(this.handleError(o))return o}}return null},h.prototype.validateObjectProperties=function(e,t,r){var n;for(var o in e){var i=r+\"/\"+o.replace(/~/g,\"~0\").replace(/\\//g,\"~1\"),a=!1;if(void 0!==t.properties&&void 0!==t.properties[o]&&(a=!0,n=this.validateAll(e[o],t.properties[o],[o],[\"properties\",o],i)))return n;if(void 0!==t.patternProperties)for(var s in t.patternProperties){var u=new RegExp(s);if(u.test(o)&&(a=!0,n=this.validateAll(e[o],t.patternProperties[s],[o],[\"patternProperties\",s],i)))return n}if(a)this.trackUnknownProperties&&(this.knownPropertyPaths[i]=!0,delete this.unknownPropertyPaths[i]);else if(void 0!==t.additionalProperties){if(this.trackUnknownProperties&&(this.knownPropertyPaths[i]=!0,delete this.unknownPropertyPaths[i]),\"boolean\"==typeof t.additionalProperties){if(!t.additionalProperties&&(n=this.createError(v.OBJECT_ADDITIONAL_PROPERTIES,{key:o},\"\",\"/additionalProperties\",null,e,t).prefixWith(o,null),this.handleError(n)))return n}else if(n=this.validateAll(e[o],t.additionalProperties,[o],[\"additionalProperties\"],i))return n}else this.trackUnknownProperties&&!this.knownPropertyPaths[i]&&(this.unknownPropertyPaths[i]=!0)}return null},h.prototype.validateObjectDependencies=function(e,t,r){var n;if(void 0!==t.dependencies)for(var o in t.dependencies)if(void 0!==e[o]){var i=t.dependencies[o];if(\"string\"==typeof i){if(void 0===e[i]&&(n=this.createError(v.OBJECT_DEPENDENCY_KEY,{key:o,missing:i},\"\",\"\",null,e,t).prefixWith(null,o).prefixWith(null,\"dependencies\"),this.handleError(n)))return n}else if(Array.isArray(i))for(var a=0;a<i.length;a++){var s=i[a];if(void 0===e[s]&&(n=this.createError(v.OBJECT_DEPENDENCY_KEY,{key:o,missing:s},\"\",\"/\"+a,null,e,t).prefixWith(null,o).prefixWith(null,\"dependencies\"),this.handleError(n)))return n}else if(n=this.validateAll(e,i,[],[\"dependencies\",o],r))return n}return null},h.prototype.validateCombinations=function(e,t,r){return this.validateAllOf(e,t,r)||this.validateAnyOf(e,t,r)||this.validateOneOf(e,t,r)||this.validateNot(e,t,r)||null},h.prototype.validateAllOf=function(e,t,r){if(void 0===t.allOf)return null;for(var n,o=0;o<t.allOf.length;o++){var i=t.allOf[o];if(n=this.validateAll(e,i,[],[\"allOf\",o],r))return n}return null},h.prototype.validateAnyOf=function(e,t,r){if(void 0===t.anyOf)return null;var n,o,i=[],a=this.errors.length;this.trackUnknownProperties&&(n=this.unknownPropertyPaths,o=this.knownPropertyPaths);for(var s=!0,u=0;u<t.anyOf.length;u++){this.trackUnknownProperties&&(this.unknownPropertyPaths={},this.knownPropertyPaths={});var c=t.anyOf[u],l=this.errors.length,f=this.validateAll(e,c,[],[\"anyOf\",u],r);if(null===f&&l===this.errors.length){if(this.errors=this.errors.slice(0,a),this.trackUnknownProperties){for(var d in this.knownPropertyPaths)o[d]=!0,delete n[d];for(var p in this.unknownPropertyPaths)o[p]||(n[p]=!0);s=!1;continue}return null}f&&i.push(f.prefixWith(null,\"\"+u).prefixWith(null,\"anyOf\"))}return this.trackUnknownProperties&&(this.unknownPropertyPaths=n,this.knownPropertyPaths=o),s?(i=i.concat(this.errors.slice(a)),this.errors=this.errors.slice(0,a),this.createError(v.ANY_OF_MISSING,{},\"\",\"/anyOf\",i,e,t)):void 0},h.prototype.validateOneOf=function(e,t,r){if(void 0===t.oneOf)return null;var n,o,i=null,a=[],s=this.errors.length;this.trackUnknownProperties&&(n=this.unknownPropertyPaths,o=this.knownPropertyPaths);for(var u=0;u<t.oneOf.length;u++){this.trackUnknownProperties&&(this.unknownPropertyPaths={},this.knownPropertyPaths={});var c=t.oneOf[u],l=this.errors.length,f=this.validateAll(e,c,[],[\"oneOf\",u],r);if(null===f&&l===this.errors.length){if(null!==i)return this.errors=this.errors.slice(0,s),this.createError(v.ONE_OF_MULTIPLE,{index1:i,index2:u},\"\",\"/oneOf\",null,e,t);if(i=u,this.trackUnknownProperties){for(var d in this.knownPropertyPaths)o[d]=!0,delete n[d];for(var p in this.unknownPropertyPaths)o[p]||(n[p]=!0)}}else f&&a.push(f)}return this.trackUnknownProperties&&(this.unknownPropertyPaths=n,this.knownPropertyPaths=o),null===i?(a=a.concat(this.errors.slice(s)),this.errors=this.errors.slice(0,s),this.createError(v.ONE_OF_MISSING,{},\"\",\"/oneOf\",a,e,t)):(this.errors=this.errors.slice(0,s),null)},h.prototype.validateNot=function(e,t,r){if(void 0===t.not)return null;var n,o,i=this.errors.length;this.trackUnknownProperties&&(n=this.unknownPropertyPaths,o=this.knownPropertyPaths,this.unknownPropertyPaths={},this.knownPropertyPaths={});var a=this.validateAll(e,t.not,null,null,r),s=this.errors.slice(i);return this.errors=this.errors.slice(0,i),this.trackUnknownProperties&&(this.unknownPropertyPaths=n,this.knownPropertyPaths=o),null===a&&0===s.length?this.createError(v.NOT_PASSED,{},\"\",\"/not\",null,e,t):null},h.prototype.validateHypermedia=function(e,t,n){if(!t.links)return null;for(var o,i=0;i<t.links.length;i++){var a=t.links[i];if(\"describedby\"===a.rel){for(var s=new r(a.href),u=!0,c=0;c<s.varNames.length;c++)if(!(s.varNames[c]in e)){u=!1;break}if(u){var l=s.fillFromObject(e),f={$ref:l};if(o=this.validateAll(e,f,[],[\"links\",i],n))return o}}}};var v={INVALID_TYPE:0,ENUM_MISMATCH:1,ANY_OF_MISSING:10,ONE_OF_MISSING:11,ONE_OF_MULTIPLE:12,NOT_PASSED:13,NUMBER_MULTIPLE_OF:100,NUMBER_MINIMUM:101,NUMBER_MINIMUM_EXCLUSIVE:102,NUMBER_MAXIMUM:103,NUMBER_MAXIMUM_EXCLUSIVE:104,NUMBER_NOT_A_NUMBER:105,STRING_LENGTH_SHORT:200,STRING_LENGTH_LONG:201,STRING_PATTERN:202,OBJECT_PROPERTIES_MINIMUM:300,OBJECT_PROPERTIES_MAXIMUM:301,OBJECT_REQUIRED:302,OBJECT_ADDITIONAL_PROPERTIES:303,OBJECT_DEPENDENCY_KEY:304,ARRAY_LENGTH_SHORT:400,ARRAY_LENGTH_LONG:401,ARRAY_UNIQUE:402,ARRAY_ADDITIONAL_ITEMS:403,FORMAT_CUSTOM:500,KEYWORD_CUSTOM:501,CIRCULAR_REFERENCE:600,UNKNOWN_PROPERTY:1e3},_={};for(var b in v)_[v[b]]=b;var g={INVALID_TYPE:\"Invalid type: {type} (expected {expected})\",ENUM_MISMATCH:\"No enum match for: {value}\",ANY_OF_MISSING:'Data does not match any schemas from \"anyOf\"',ONE_OF_MISSING:'Data does not match any schemas from \"oneOf\"',ONE_OF_MULTIPLE:'Data is valid against more than one schema from \"oneOf\": indices {index1} and {index2}',NOT_PASSED:'Data matches schema from \"not\"',NUMBER_MULTIPLE_OF:\"Value {value} is not a multiple of {multipleOf}\",NUMBER_MINIMUM:\"Value {value} is less than minimum {minimum}\",NUMBER_MINIMUM_EXCLUSIVE:\"Value {value} is equal to exclusive minimum {minimum}\",NUMBER_MAXIMUM:\"Value {value} is greater than maximum {maximum}\",NUMBER_MAXIMUM_EXCLUSIVE:\"Value {value} is equal to exclusive maximum {maximum}\",NUMBER_NOT_A_NUMBER:\"Value {value} is not a valid number\",STRING_LENGTH_SHORT:\"String is too short ({length} chars), minimum {minimum}\",STRING_LENGTH_LONG:\"String is too long ({length} chars), maximum {maximum}\",STRING_PATTERN:\"String does not match pattern: {pattern}\",OBJECT_PROPERTIES_MINIMUM:\"Too few properties defined ({propertyCount}), minimum {minimum}\",OBJECT_PROPERTIES_MAXIMUM:\"Too many properties defined ({propertyCount}), maximum {maximum}\",OBJECT_REQUIRED:\"Missing required property: {key}\",OBJECT_ADDITIONAL_PROPERTIES:\"Additional properties not allowed\",OBJECT_DEPENDENCY_KEY:\"Dependency failed - key must exist: {missing} (due to key: {key})\",ARRAY_LENGTH_SHORT:\"Array is too short ({length}), minimum {minimum}\",ARRAY_LENGTH_LONG:\"Array is too long ({length}), maximum {maximum}\",ARRAY_UNIQUE:\"Array items are not unique (indices {match1} and {match2})\",ARRAY_ADDITIONAL_ITEMS:\"Additional items not allowed\",FORMAT_CUSTOM:\"Format validation failed ({message})\",KEYWORD_CUSTOM:\"Keyword failed: {key} ({message})\",CIRCULAR_REFERENCE:\"Circular $refs: {urls}\",UNKNOWN_PROPERTY:\"Unknown property (not in schema)\"};c.prototype=Object.create(Error.prototype),c.prototype.constructor=c,c.prototype.name=\"ValidationError\",c.prototype.prefixWith=function(e,t){if(null!==e&&(e=e.replace(/~/g,\"~0\").replace(/\\//g,\"~1\"),this.dataPath=\"/\"+e+this.dataPath),null!==t&&(t=t.replace(/~/g,\"~0\").replace(/\\//g,\"~1\"),this.schemaPath=\"/\"+t+this.schemaPath),null!==this.subErrors)for(var r=0;r<this.subErrors.length;r++)this.subErrors[r].prefixWith(e,t);return this};var E={},j=f();return j.addLanguage(\"en-gb\",g),j.tv4=j,j})},{}],100:[function(e,t,r){\"use strict\";function n(e){return e&&e.__esModule?e:{\"default\":e}}Object.defineProperty(r,\"__esModule\",{value:!0}),r.MessageFactory=void 0;var o=e(\"./message-factory/MessageFactory\"),i=n(o);r.MessageFactory=i[\"default\"]},{\"./message-factory/MessageFactory\":103}],101:[function(e,t,r){\"use strict\";function n(e){return e&&e.__esModule?e:{\"default\":e}}Object.defineProperty(r,\"__esModule\",{value:!0}),r.MessageType=r.Message=void 0;var o=e(\"babel-runtime/core-js/object/get-prototype-of\"),i=n(o),a=e(\"babel-runtime/helpers/classCallCheck\"),s=n(a),u=e(\"babel-runtime/helpers/createClass\"),c=n(u),l=e(\"babel-runtime/helpers/possibleConstructorReturn\"),f=n(l),d=e(\"babel-runtime/helpers/inherits\"),p=n(d),h=e(\"../reTHINKObject/RethinkObject.js\"),y=n(h),m=r.Message=function(e){\nfunction t(e,r,n,o,a){(0,s[\"default\"])(this,t);var u=(0,f[\"default\"])(this,(t.__proto__||(0,i[\"default\"])(t)).call(this));return u.id=e,u.from=r,u.to=n,u.type=o,u.body=a,u}return(0,p[\"default\"])(t,e),(0,c[\"default\"])(t,[{key:\"assertIdentity\",value:function(e,t){if(!e||!t)throw new Error(\"message, token to be removed, and assertedIdentity must be provided\");var r=this.body;return r.idToken=null,r.assertedIdentity=t,this.body=r,this}},{key:\"addIdToken\",value:function(e){if(!e)throw new Error(\"message, token to be added, must be provided\");var t=this.body;return t.idToken=e,this.body=t,this}},{key:\"addAccessToken\",value:function(e){if(!e)throw new Error(\"message, token to be added, must be provided\");var t=this.body;return t.accessToken=e,this.body=t,this}}]),t}(y[\"default\"]);r.MessageType={CREATE:\"create\",READ:\"read\",UPDATE:\"update\",DELETE:\"delete\",SUBSCRIBE:\"subscribe\",UNSUBSCRIBE:\"unsubscribe\",RESPONSE:\"response\",FORWARD:\"forward\",EXECUTE:\"execute\"};r[\"default\"]=m},{\"../reTHINKObject/RethinkObject.js\":104,\"babel-runtime/core-js/object/get-prototype-of\":5,\"babel-runtime/helpers/classCallCheck\":10,\"babel-runtime/helpers/createClass\":11,\"babel-runtime/helpers/inherits\":12,\"babel-runtime/helpers/possibleConstructorReturn\":13}],102:[function(e,t,r){\"use strict\";function n(e){return e&&e.__esModule?e:{\"default\":e}}function o(e){var t=(0,u[\"default\"])(e).reduce(function(t,r){return t[e[r]]=r,t},{});return(0,a[\"default\"])((0,u[\"default\"])(e).reduce(function(t,r){return t[r]=e[r],t},function(e){return t[e]}))}Object.defineProperty(r,\"__esModule\",{value:!0}),r.UPDATE_OPERATION=r.ATTRIBUTE_TYPE=r.REASON_PHRASE=r.RESPONSE_CODE=r.ExecuteMessageBody=r.ResponseMessageBody=r.ForwardMessageBody=r.UpdateMessageBody=r.DeleteMessageBody=r.ReadMessageBody=r.CreateMessageBody=r.MessageBody=void 0;var i=e(\"babel-runtime/core-js/object/freeze\"),a=n(i),s=e(\"babel-runtime/core-js/object/keys\"),u=n(s),c=e(\"babel-runtime/core-js/object/get-prototype-of\"),l=n(c),f=e(\"babel-runtime/helpers/classCallCheck\"),d=n(f),p=e(\"babel-runtime/helpers/createClass\"),h=n(p),y=e(\"babel-runtime/helpers/possibleConstructorReturn\"),m=n(y),v=e(\"babel-runtime/helpers/inherits\"),_=n(v);r.Enum=o;var b=e(\"../reTHINKObject/RethinkObject.js\"),g=n(b),E=r.MessageBody=function(e){function t(e,r,n,o,i){(0,d[\"default\"])(this,t);var a=(0,m[\"default\"])(this,(t.__proto__||(0,l[\"default\"])(t)).call(this));return a.idToken=e,a.accessToken=r,a.resource=n,a.schema=o,a.assertedIdentity=i,a}return(0,_[\"default\"])(t,e),(0,h[\"default\"])(t,[{key:\"addVia\",value:function(e){if(!e)throw new Error(\"via URL to be added, must be provided\");return this.via=e,this}}]),t}(g[\"default\"]),j=(r.CreateMessageBody=function(e){function t(e,r,n,o,i,a,s){if((0,d[\"default\"])(this,t),!e)throw new Error(\"The value parameter is null\");var u=(0,m[\"default\"])(this,(t.__proto__||(0,l[\"default\"])(t)).call(this,n,o,i,a,s,a,s));return u.value=e,r&&(u.policy=r),u}return(0,_[\"default\"])(t,e),t}(E),r.ReadMessageBody=function(e){function t(e,r,n,o,i,a,s,u){(0,d[\"default\"])(this,t);var c=(0,m[\"default\"])(this,(t.__proto__||(0,l[\"default\"])(t)).call(this,e,r,n,o,i));return a&&(c.attribute=a),s&&(c.criteriaSyntax=s),u&&(c.criteria=u),c}return(0,_[\"default\"])(t,e),t}(E),r.DeleteMessageBody=function(e){function t(e,r,n,o,i,a){if((0,d[\"default\"])(this,t),n instanceof Array){var s=(0,m[\"default\"])(this,(t.__proto__||(0,l[\"default\"])(t)).call(this,e,r,null,o,i));s.childrenResources=n}else var s=(0,m[\"default\"])(this,(t.__proto__||(0,l[\"default\"])(t)).call(this,e,r,n,o,i));return a&&(s.attribute=a),(0,m[\"default\"])(s)}return(0,_[\"default\"])(t,e),t}(E),r.UpdateMessageBody=function(e){function t(e,r,n,o,i,a,s){(0,d[\"default\"])(this,t);var u=(0,m[\"default\"])(this,(t.__proto__||(0,l[\"default\"])(t)).call(this,e,r,n,o,i));return u.attribute=a,u.value=s,u}return(0,_[\"default\"])(t,e),(0,h[\"default\"])(t,[{key:\"addAttributeType\",value:function(e){e&&(this.attributeType=e)}},{key:\"addOperation\",value:function(e){e&&(this.operation=e)}}]),t}(E),r.ForwardMessageBody=function(e){function t(e,r,n,o,i,a){(0,d[\"default\"])(this,t);var s=(0,m[\"default\"])(this,(t.__proto__||(0,l[\"default\"])(t)).call(this,e,r,n,o,i));return s.message=a,s}return(0,_[\"default\"])(t,e),t}(E),r.ResponseMessageBody=function(e){function t(e,r,n,o,i){(0,d[\"default\"])(this,t);var a=(0,m[\"default\"])(this,(t.__proto__||(0,l[\"default\"])(t)).call(this,e,r,n));return o&&(a.code=o,a.description=j[o]),i&&(a.value=i),a}return(0,_[\"default\"])(t,e),t}(E),r.ExecuteMessageBody=function(e){function t(e,r,n,o,i,a,s){(0,d[\"default\"])(this,t);var u=(0,m[\"default\"])(this,(t.__proto__||(0,l[\"default\"])(t)).call(this,e,r,n,o,i));return u.method=a,s&&(s instanceof Array?u.params=s:u.params=[s]),u}return(0,_[\"default\"])(t,e),t}(E),r.RESPONSE_CODE=o({100:\"100\",101:\"101\",200:\"200\",201:\"201\",202:\"202\",203:\"203\",204:\"204\",205:\"205\",206:\"206\",300:\"300\",301:\"301\",302:\"302\",303:\"303\",304:\"304\",305:\"305\",307:\"307\",400:\"400\",401:\"401\",402:\"402\",403:\"403\",404:\"404\",405:\"405\",406:\"406\",407:\"407\",408:\"408\",409:\"409\",410:\"410\",411:\"411\",412:\"412\",413:\"413\",414:\"414\",415:\"415\",416:\"416\",417:\"417\",426:\"426\",500:\"500\",501:\"501\",502:\"502\",503:\"503\",504:\"504\",505:\"505\"}),r.REASON_PHRASE=o({100:\"Continue\",101:\"Switching Protocols\",200:\"OK\",201:\"Created\",202:\"Accepted\",203:\"Non-Authoritative Information\",204:\"No Content\",205:\"Reset Content\",206:\"Partial Content\",300:\"Multiple Choices\",301:\"Moved Permanently\",302:\"Found\",303:\"See Other\",304:\"Not Modified\",305:\"Use Proxy\",307:\"Temporary Redirect\",400:\"Bad Request\",401:\"Unauthorized\",402:\"Payment Required\",403:\"Forbidden\",404:\"Not Found\",405:\"Method Not Allowed\",406:\"Not Acceptable\",407:\"Proxy Authentication Required\",408:\"Request Timeout\",409:\"Conflict\",410:\"Gone\",411:\"Length Required\",412:\"Precondition Failed\",413:\"Payload Too Large\",414:\"Request-URI Too Long\",415:\"Unsupported Media Type\",416:\"Range Not Satisfiable\",417:\"Expectation Failed\",426:\"Upgrade Required\",500:\"Internal Server Error\",501:\"Not Implemented\",502:\"Bad Gateway\",503:\"Service Unavailable\",504:\"Gateway Time-out\",505:\"HTTP Version Not Supported\"}));r.ATTRIBUTE_TYPE=o({OBJECT:\"OBJECT\",ARRAY:\"ARRAY\"}),r.UPDATE_OPERATION=o({ADD:\"ADD\",REMOVE:\"REMOVE\"});r[\"default\"]=E},{\"../reTHINKObject/RethinkObject.js\":104,\"babel-runtime/core-js/object/freeze\":4,\"babel-runtime/core-js/object/get-prototype-of\":5,\"babel-runtime/core-js/object/keys\":6,\"babel-runtime/helpers/classCallCheck\":10,\"babel-runtime/helpers/createClass\":11,\"babel-runtime/helpers/inherits\":12,\"babel-runtime/helpers/possibleConstructorReturn\":13}],103:[function(e,t,r){\"use strict\";function n(e){return e&&e.__esModule?e:{\"default\":e}}Object.defineProperty(r,\"__esModule\",{value:!0}),r.IdGenerator=void 0;var o=e(\"babel-runtime/regenerator\"),i=n(o),a=e(\"babel-runtime/helpers/classCallCheck\"),s=n(a),u=e(\"babel-runtime/helpers/createClass\"),c=n(u),l=e(\"./Message.js\"),f=n(l),d=e(\"./MessageBody.js\"),p=function(){function e(){(0,s[\"default\"])(this,e),this.myGenerator=(new h).idMaker()}return(0,c[\"default\"])(e,[{key:\"createCreateMessageRequest\",value:function(e,t,r,n){if(!e||!t||!r)throw new Error(\"from, to, and value of object to be created MUST be specified\");var o=this.myGenerator.next().value,i=new d.CreateMessageBody(r,n,(void 0),(void 0),(void 0),(void 0),(void 0)),a=new f[\"default\"](o,e,t,l.MessageType.CREATE,i);return a}},{key:\"createForwardMessageRequest\",value:function(e,t,r){if(!e||!t||!r)throw new Error(\"from, to, and message to forward MUST be specified\");var n=this.myGenerator.next().value,o=new d.ForwardMessageBody((void 0),(void 0),(void 0),(void 0),(void 0),r),i=new f[\"default\"](n,e,t,l.MessageType.FORWARD,o);return i}},{key:\"createDeleteMessageRequest\",value:function(e,t,r,n){if(!e||!t)throw new Error(\"from and to parameters MUST be specified\");var o=this.myGenerator.next().value,i=new d.DeleteMessageBody((void 0),(void 0),r,n,(void 0),(void 0)),a=new f[\"default\"](o,e,t,l.MessageType.DELETE,i);return a}},{key:\"createUpdateMessageRequest\",value:function(e,t,r,n,o){if(!e||!t||!r)throw new Error(\"from, and to and value MUST be specified\");var i=this.myGenerator.next().value,a=new d.UpdateMessageBody((void 0),(void 0),n,(void 0),(void 0),o,r),s=new f[\"default\"](i,e,t,l.MessageType.UPDATE,a);return s}},{key:\"createReadMessageRequest\",value:function(e,t,r,n){if(!e||!t||!r)throw new Error(\"from, to and the resource to read from MUST be specified\");var o=this.myGenerator.next().value,i=new d.ReadMessageBody((void 0),(void 0),r,(void 0),(void 0),n,(void 0),(void 0)),a=new f[\"default\"](o,e,t,l.MessageType.READ,i);return a}},{key:\"createSubscribeMessageRequest\",value:function(e,t,r){if(!e||!t||!r)throw new Error(\"from, to and the resource to subscribe to MUST be specified\");var n=this.myGenerator.next().value,o=new d.MessageBody((void 0),(void 0),r,(void 0),(void 0)),i=new f[\"default\"](n,e,t,l.MessageType.SUBSCRIBE,o);return i}},{key:\"createUnsubscribeMessageRequest\",value:function(e,t,r){if(!e||!t||!r)throw new Error(\"from, to and the resource to subscribe to MUST be specified\");var n=this.myGenerator.next().value,o=new d.MessageBody((void 0),(void 0),r,(void 0),(void 0)),i=new f[\"default\"](n,e,t,l.MessageType.UNSUBSCRIBE,o);return i}},{key:\"createExecuteMessageRequest\",value:function(e,t,r,n){if(!e||!t||!r)throw new Error(\"from, to and the method to execute MUST be specified\");var o=this.myGenerator.next().value,i=new d.ExecuteMessageBody((void 0),(void 0),(void 0),(void 0),(void 0),r,n),a=new f[\"default\"](o,e,t,l.MessageType.EXECUTE,i);return a}},{key:\"createMessageResponse\",value:function(e,t,r,n){if(!t)throw new Error(\"response Code MUST be specified\");var o=new d.ResponseMessageBody((void 0),(void 0),(void 0),t,r,n);return new f[\"default\"](e.id,e.to,e.from,l.MessageType.RESPONSE,o)}},{key:\"generateMessageResponse\",value:function(e,t,r){if(!e||!t)throw new Error(\"message and response code MUST be specified\");var n=e.body,o=n.idToken,i=n.accessToken,a=n.resource,s=new d.ResponseMessageBody(o,i,a,t,r),u=this.myGenerator.next().value;return new f[\"default\"](u,e.to,e.from,l.MessageType.RESPONSE,s)}}]),e}(),h=r.IdGenerator=function(){function e(){(0,s[\"default\"])(this,e)}return(0,c[\"default\"])(e,[{key:\"idMaker\",value:i[\"default\"].mark(function t(){var e;return i[\"default\"].wrap(function(t){for(;;)switch(t.prev=t.next){case 0:e=1;case 1:if(!(e<1e6)){t.next=6;break}return t.next=4,e++;case 4:t.next=1;break;case 6:case\"end\":return t.stop()}},t,this)})}]),e}();r[\"default\"]=p},{\"./Message.js\":101,\"./MessageBody.js\":102,\"babel-runtime/helpers/classCallCheck\":10,\"babel-runtime/helpers/createClass\":11,\"babel-runtime/regenerator\":15}],104:[function(e,t,r){\"use strict\";function n(e){return e&&e.__esModule?e:{\"default\":e}}Object.defineProperty(r,\"__esModule\",{value:!0}),r.RethinkObject=void 0;var o=e(\"babel-runtime/core-js/json/stringify\"),i=n(o),a=e(\"babel-runtime/helpers/classCallCheck\"),s=n(a),u=e(\"babel-runtime/helpers/createClass\"),c=n(u),l=e(\"tv4\"),f=n(l),d=r.RethinkObject=function(){function e(){(0,s[\"default\"])(this,e)}return(0,c[\"default\"])(e,[{key:\"validate\",value:function(e){f[\"default\"].addSchema(e.id,e);var t=f[\"default\"].validateMultiple(JSON.parse((0,i[\"default\"])(this)),e);return t.errors.forEach(function(e){delete e.stack}),(!t.valid||t.missing.length>0)&&(console.warn(\"Object validation \"+(t.valid?\"succeeded, but schema contained references:\":\"failed:\"),(0,i[\"default\"])(t,null,2)),console.log(\"Object:\",(0,i[\"default\"])(this,null,2))),t.valid}}]),e}();r[\"default\"]=d},{\"babel-runtime/core-js/json/stringify\":1,\"babel-runtime/helpers/classCallCheck\":10,\"babel-runtime/helpers/createClass\":11,tv4:99}]},{},[100])(100)});\n\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],421:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n* Copyright 2016 PT Inovao e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n// import MessageFactory from '../../resources/MessageFactory';\n\n/**\n * Class will ask to the message node for addresses\n */\nvar AddressAllocation = function () {\n  /* private\n  _url: URL\n  _bus: MiniBus\n  */\n\n  /**\n   * Create an Address Allocation\n   * @param  {URL.URL}      url - url from who is sending the message\n   * @param  {MiniBus}      bus - MiniBus used for address allocation\n   */\n  function AddressAllocation(url, bus, registry) {\n    (0, _classCallCheck3.default)(this, AddressAllocation);\n\n    var _this = this;\n\n    // let messageFactory = new MessageFactory();\n    //\n    // _this._messageFactory = messageFactory;\n    _this._url = url;\n    _this._bus = bus;\n    _this._registry = registry;\n  }\n\n  /**\n   * get the URL value\n   * @return {string} The url value;\n   */\n\n\n  (0, _createClass3.default)(AddressAllocation, [{\n    key: 'create',\n\n\n    /**\n     * Ask for creation of a number of Hyperty addresses, to the domain message node.\n     * @param  {Domain} domain - Domain of the message node.\n     * @param  {number} number - Number of addresses to request\n     * @returns {Promise<HypertyURL>}  A list of HypertyURL's\n     */\n    value: function create(domain, number, info, scheme, reuseURL) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n\n        if (reuseURL) {\n\n          _this._registry.checkRegisteredURLs(info).then(function (urls) {\n\n            if (urls) {\n              console.info('[AddressAllocation - ' + scheme + '] - Reuse URL');\n              var value = { newAddress: false, address: urls };\n              resolve(value);\n            } else {\n              console.info('[AddressAllocation - reuseURL] - Object ' + reuseURL + ' not found');\n              reject('URL Not Found');\n            }\n          }).catch(function (reason) {\n            reject(reason);\n          });\n        } else {\n\n          _this._registry.checkRegisteredURLs(info).then(function (urls) {\n\n            // if there is already a URL, then returns that URL, otherwise request a new URL\n            if (urls) {\n\n              console.info('[AddressAllocation - ' + scheme + '] - Reuse URL');\n              var value = { newAddress: false, address: urls };\n              resolve(value);\n            } else {\n\n              // if there is no URL saved request a new URL\n              _this._allocateNewAddress(domain, scheme, number).then(function (allocated) {\n                resolve(allocated);\n              }).catch(function (reason) {\n                reject(reason);\n              });\n            }\n          }).catch(function (reason) {\n            reject(reason);\n          });\n        }\n      });\n    }\n  }, {\n    key: '_allocateNewAddress',\n    value: function _allocateNewAddress(domain, scheme, number) {\n      var _this2 = this;\n\n      return new _promise2.default(function (resolve, reject) {\n\n        var msg = {\n          type: 'create', from: _this2._url, to: 'domain://msg-node.' + domain + '/address-allocation',\n          body: { value: { number: number } }\n        };\n\n        if (scheme !== 'hypert') msg.body.scheme = scheme;\n\n        console.info('[AddressAllocation - ' + scheme + '] - Request new URL');\n\n        // TODO: change this response Message using the MessageFactory\n        _this2._bus.postMessage(msg, function (reply) {\n          if (reply.body.code === 200) {\n            var result = { newAddress: true, address: reply.body.value.allocated };\n            resolve(result);\n          } else {\n            reject(reply.body.desc);\n          }\n        });\n      });\n    }\n\n    /**\n    * Send a request to the domain message node, to deallocate one or more addresses\n    * @param  {Domain} domain - Domain of the message node.\n    * @param  {addresses} addresses to request the deallocation\n    * @returns {Promise}  the response by the message node\n    */\n\n  }, {\n    key: 'delete',\n    value: function _delete(domain, addresses) {\n      var _this = this;\n\n      var message = {\n        type: 'delete', from: _this._url, to: 'domain://msg-node.' + domain + '/address-allocation',\n        body: { childrenResources: addresses }\n      };\n\n      return new _promise2.default(function (resolve, reject) {\n\n        _this._bus.postMessage(message, function (reply) {\n          console.log('reply', reply);\n          if (reply.body.code === 200) {\n            resolve(reply.body.code);\n          } else {\n            reject(reply.body.desc);\n          }\n        });\n      });\n    }\n  }, {\n    key: 'url',\n    get: function get() {\n      return this._url;\n    }\n  }]);\n  return AddressAllocation;\n}();\n\nexports.default = AddressAllocation;\nmodule.exports = exports['default'];\n\n},{\"babel-runtime/core-js/promise\":12,\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16}],422:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n* Copyright 2016 PT Inovao e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n\n/**\n* @author micaelpedrosa@gmail.com\n* Minimal interface and implementation to send and receive messages. It can be reused in many type of components.\n* Components that need a message system should receive this class as a dependency or extend it.\n* Extensions should implement the following private methods: _onPostMessage and _registerExternalListener\n*/\nvar Bus = function () {\n  /* private\n  _msgId: number;\n  _subscriptions: <url: MsgListener[]>\n   _responseTimeOut: number\n  _responseCallbacks: <url+id: (msg) => void>\n   */\n\n  function Bus() {\n    (0, _classCallCheck3.default)(this, Bus);\n\n    var _this = this;\n    _this._msgId = 0;\n    _this._subscriptions = {};\n\n    _this._responseTimeOut = 5000; //default to 3s\n    _this._responseCallbacks = {};\n\n    _this._registerExternalListener();\n  }\n\n  /**\n  * Register listener to receive message when \"msg.to === url\".\n  * Special url \"*\" for default listener is accepted to intercept all messages.\n  * @param {URL} url Address to intercept, tha is in the message \"to\"\n  * @param {Listener} listener listener\n  * @return {MsgListener} instance of MsgListener\n  */\n\n\n  (0, _createClass3.default)(Bus, [{\n    key: 'addListener',\n    value: function addListener(url, listener) {\n      var _this = this;\n\n      var item = new MsgListener(_this._subscriptions, url, listener);\n      var itemList = _this._subscriptions[url];\n      if (!itemList) {\n        itemList = [];\n        _this._subscriptions[url] = itemList;\n      }\n\n      itemList.push(item);\n      return item;\n    }\n\n    /**\n     * Manually add a response listener. Only one listener per message ID should exist.\n     * ATENTION, there is no timeout for this listener.\n     * The listener should be removed with a removeResponseListener, failing to do this will result in a unreleased memory problem.\n     * @param {URL} url Origin address of the message sent, \"msg.from\".\n     * @param {number} msgId Message ID that is returned from the postMessage.\n     * @param {Function} responseListener Callback function for the response\n     */\n\n  }, {\n    key: 'addResponseListener',\n    value: function addResponseListener(url, msgId, responseListener) {\n      this._responseCallbacks[url + msgId] = responseListener;\n    }\n\n    /**\n     * Remove the response listener.\n     * @param {URL} url Origin address of the message sent, \"msg.from\".\n     * @param {number} msgId  Message ID that is returned from the postMessage\n     */\n\n  }, {\n    key: 'removeResponseListener',\n    value: function removeResponseListener(url, msgId) {\n      delete this._responseCallbacks[url + msgId];\n    }\n\n    /**\n     * Remove all existent listeners for the URL\n     * @param  {URL} url Address registered\n     */\n\n  }, {\n    key: 'removeAllListenersOf',\n    value: function removeAllListenersOf(url) {\n      delete this._subscriptions[url];\n    }\n\n    /**\n     * Helper method to bind listeners (in both directions) into other MiniBus target.\n     * @param  {URL} outUrl Outbound URL, register listener for url in direction \"this -> target\"\n     * @param  {URL} inUrl Inbound URL, register listener for url in direction \"target -> this\"\n     * @param  {MiniBus} target The other target MiniBus\n     * @return {Bound} an object that contains the properties [thisListener, targetListener] and the unbind method.\n     */\n\n  }, {\n    key: 'bind',\n    value: function bind(outUrl, inUrl, target) {\n      var _this2 = this;\n\n      var _this = this;\n\n      var thisListn = _this.addListener(outUrl, function (msg) {\n        target.postMessage(msg);\n      });\n\n      var targetListn = target.addListener(inUrl, function (msg) {\n        _this.postMessage(msg);\n      });\n\n      return {\n        thisListener: thisListn,\n        targetListener: targetListn,\n        unbind: function unbind() {\n          _this2.thisListener.remove();\n          _this2.targetListener.remove();\n        }\n      };\n    }\n\n    //publish on default listeners\n\n  }, {\n    key: '_publishOnDefault',\n    value: function _publishOnDefault(msg) {\n      //is there any \"*\" (default) listeners?\n      var itemList = this._subscriptions['*'];\n      if (itemList) {\n        this._publishOn(itemList, msg);\n      }\n    }\n\n    //publish on a subscription list.\n\n  }, {\n    key: '_publishOn',\n    value: function _publishOn(itemList, msg) {\n      itemList.forEach(function (sub) {\n        sub._callback(msg);\n      });\n    }\n  }, {\n    key: '_responseCallback',\n    value: function _responseCallback(inMsg, responseCallback) {\n      var _this = this;\n\n      //automatic management of response handlers\n      if (responseCallback) {\n        (function () {\n          var responseId = inMsg.from + inMsg.id;\n          _this._responseCallbacks[responseId] = responseCallback;\n\n          setTimeout(function () {\n            var responseFun = _this._responseCallbacks[responseId];\n            delete _this._responseCallbacks[responseId];\n\n            if (responseFun) {\n              var errorMsg = {\n                id: inMsg.id, type: 'response',\n                body: { code: 408, desc: 'Response timeout!', value: inMsg }\n              };\n\n              responseFun(errorMsg);\n            }\n          }, _this._responseTimeOut);\n        })();\n      }\n    }\n  }, {\n    key: '_onResponse',\n    value: function _onResponse(msg) {\n      var _this = this;\n\n      if (msg.type === 'response') {\n        var responseId = msg.to + msg.id;\n        var responseFun = _this._responseCallbacks[responseId];\n\n        //if it's a provisional response, don't delete response listener\n        if (msg.body.code >= 200) {\n          delete _this._responseCallbacks[responseId];\n        }\n\n        if (responseFun) {\n          responseFun(msg);\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    //receive messages from external interface\n\n  }, {\n    key: '_onMessage',\n    value: function _onMessage(msg) {\n      var _this = this;\n\n      if (!_this._onResponse(msg)) {\n        var itemList = _this._subscriptions[msg.to];\n        if (itemList) {\n          _this._publishOn(itemList, msg);\n        } else {\n          _this._publishOnDefault(msg);\n        }\n      }\n    }\n  }, {\n    key: '_genId',\n    value: function _genId(inMsg) {\n      //TODO: how do we manage message ID's? Should it be a global runtime counter, or per URL address?\n      //Global counter will not work, because there will be multiple MiniBus instances!\n      //Per URL, can be a lot of data to maintain!\n      //Maybe a counter per MiniBus instance. This is the assumed solution for now.\n      if (!inMsg.id || inMsg.id === 0) {\n        this._msgId++;\n        inMsg.id = this._msgId;\n      }\n    }\n\n    /**\n    * Send messages to local listeners, or if not exists to external listeners.\n    * It's has an optional mechanism for automatic management of response handlers.\n    * The response handler will be unregistered after receiving the response, or after response timeout (default to 3s).\n    * @param  {Message} msg Message to send. Message ID is automatically added to the message.\n    * @param  {Function} responseCallback Optional parameter, if the developer what's automatic response management.\n    * @return {number} Returns the message ID, in case it should be needed for manual management of the response handler.\n    */\n\n  }, {\n    key: 'postMessage',\n    value: function postMessage(inMsg, responseCallback) {}\n\n    /**\n     * Not public available, used by the class extension implementation, to process messages from the public \"postMessage\" without a registered listener.\n     * Used to send the message to an external interface, like a WebWorker, IFrame, etc.\n     * @param  {Message.Message} msg Message\n     */\n\n  }, {\n    key: '_onPostMessage',\n    value: function _onPostMessage(msg) {} /*implementation will send message to external system*/\n\n    /**\n     * Not public available, used by the class extension implementation, to process all messages that enter the MiniBus from an external interface, like a WebWorker, IFrame, etc.\n     * This method is called one time in the constructor to register external listeners.\n     * The implementation will probably call the \"_onMessage\" method to publish in the local listeners.\n     * DO NOT call \"postMessage\", there is a danger that the message enters in a cycle!\n     */\n\n  }, {\n    key: '_registerExternalListener',\n    value: function _registerExternalListener() {/*implementation will register external listener and call \"this._onMessage(msg)\" */}\n  }]);\n  return Bus;\n}();\n\nvar MsgListener = function () {\n  /* private\n  _subscriptions: <string: MsgListener[]>;\n  _url: string;\n  _callback: (msg) => void;\n  */\n\n  function MsgListener(subscriptions, url, callback) {\n    (0, _classCallCheck3.default)(this, MsgListener);\n\n    var _this = this;\n\n    _this._subscriptions = subscriptions;\n    _this._url = url;\n    _this._callback = callback;\n  }\n\n  (0, _createClass3.default)(MsgListener, [{\n    key: 'remove',\n\n\n    /**\n     * Remove this listener from the Bus\n     */\n    value: function remove() {\n      var _this = this;\n\n      var subs = _this._subscriptions[_this._url];\n      if (subs) {\n        var index = subs.indexOf(_this);\n        subs.splice(index, 1);\n\n        //if there are no listeners, remove the subscription entirely.\n        if (subs.length === 0) {\n          delete _this._subscriptions[_this._url];\n        }\n      }\n    }\n  }, {\n    key: 'url',\n    get: function get() {\n      return this._url;\n    }\n  }]);\n  return MsgListener;\n}();\n\nexports.default = Bus;\nmodule.exports = exports['default'];\n\n},{\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16}],423:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _stringify = require('babel-runtime/core-js/json/stringify');\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _Bus2 = require('./Bus');\n\nvar _Bus3 = _interopRequireDefault(_Bus2);\n\nvar _Pipeline = require('./Pipeline');\n\nvar _Pipeline2 = _interopRequireDefault(_Pipeline);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n* @author micaelpedrosa@gmail.com\n* Message BUS Interface is an extension of the Bus\n* It doesn't support the default '*' listener, instead it uses the registry.resolve(..)\n*/\n/**\n* Copyright 2016 PT Inovao e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\nvar MessageBus = function (_Bus) {\n  (0, _inherits3.default)(MessageBus, _Bus);\n\n  /* private\n  _registry: Registry\n  _forwards: { <from-url>: { fl: MsgListener, sandboxToUrls: Map(Sandbox, [to-url]), urlToSandbox: { to-url: Sandbox } } }\n   _pipeline: Pipeline\n  */\n\n  //TODO: future optimization\n  //1. message batch processing with setInterval\n  //2. resolve default gateway/protostub with register.resolve\n\n  function MessageBus(registry) {\n    (0, _classCallCheck3.default)(this, MessageBus);\n\n    var _this2 = (0, _possibleConstructorReturn3.default)(this, (MessageBus.__proto__ || (0, _getPrototypeOf2.default)(MessageBus)).call(this));\n\n    _this2._registry = registry;\n    _this2._forwards = {};\n\n    _this2._pipeline = new _Pipeline2.default(function (error) {\n      console.log('PIPELINE-ERROR: ', (0, _stringify2.default)(error));\n    });\n    return _this2;\n  }\n\n  (0, _createClass3.default)(MessageBus, [{\n    key: 'postMessage',\n\n\n    /**\n     * Post a message for routing. It will first search for a listener, if there is no one, it sends to a external routing using the _onPostMessage.\n     * External routing use the registry.resolve(..) method to decide the destination sandbox.\n     * @param  {Message} inMsg            JSON with mandatory Message structure {id, type, from, to}\n     * @param  {Callback} responseCallback Optional callback if a response is expected from the request. A response will be always sent, even if it is a \"Timeout\".\n     * @return {number}                  the Message id\n     */\n    value: function postMessage(inMsg, responseCallback) {\n      var _this = this;\n\n      _this._genId(inMsg);\n\n      _this._pipeline.process(inMsg, function (msg) {\n\n        _this._responseCallback(inMsg, responseCallback);\n\n        if (!_this._onResponse(msg)) {\n          var itemList = _this._subscriptions[msg.to];\n          if (itemList) {\n            //do not publish on default address, because of loopback cycle\n            _this._publishOn(itemList, msg);\n          } else {\n            //if there is no listener, send to external interface\n            _this._onPostMessage(msg);\n          }\n        }\n      });\n\n      return inMsg.id;\n    }\n\n    /**\n     * Adds an external publish address listener. Every message for the address will be forwarded to the external routing by _onPostMessage.\n     * This means, even if there is a listener for the address, it will also send the message to the external routing.\n     * @param {URL} from Publish address.\n     */\n\n  }, {\n    key: 'addPublish',\n    value: function addPublish(from) {\n      var _this3 = this;\n\n      var _this = this;\n\n      //verify if forward exist\n      var refCount = _this._forwards[from];\n      if (!refCount) {\n        var forwardListener = _this.addListener(from, function (msg) {\n          console.log('MB-PUBLISH: ( ' + from + ' )');\n          _this._onPostMessage(msg);\n        });\n\n        refCount = {\n          counter: 0,\n          fl: forwardListener,\n          remove: function remove() {\n            _this3.counter--;\n            if (_this3.counter === 0) {\n              _this3.fl.remove();\n              delete _this._forwards[from];\n            }\n          }\n        };\n\n        _this._forwards[from] = refCount;\n      }\n\n      refCount.counter++;\n      return refCount;\n    }\n\n    /**\n     * Adds a forward listener for a message destination. Every message reaching an address will be also sent to the forward address.\n     * @param {URL} from Message destination, it's actually the field \"to\" of the message.\n     * @param {URL} to   Forward address.\n     */\n\n  }, {\n    key: 'addForward',\n    value: function addForward(from, to) {\n      var _this = this;\n\n      return _this.addListener(from, function (msg) {\n        console.log('MB-FORWARD: ( ' + from + ' to ' + to + ' )');\n        _this.forward(to, msg);\n      });\n    }\n\n    /**\n     * Just forward's a message to the forward address. Listeners should be available for the forward address.\n     * @param  {URL} url Forward address.\n     * @param  {Message} msg Message to forward\n     */\n\n  }, {\n    key: 'forward',\n    value: function forward(url, msg) {\n      var _this = this;\n\n      var itemList = _this._subscriptions[url];\n      if (itemList) {\n        _this._publishOn(itemList, msg);\n      }\n    }\n\n    //default route, if there are no listeners available for a message destination.\n\n  }, {\n    key: '_onPostMessage',\n    value: function _onPostMessage(msg) {\n      var _this = this;\n\n      //resolve external protostub...\n      _this._registry.resolve(msg.to).then(function (route) {\n        _this.forward(route, msg);\n      }).catch(function (e) {\n        console.log('RESOLVE-ERROR: ', e);\n      });\n    }\n  }, {\n    key: 'pipeline',\n    get: function get() {\n      return this._pipeline;\n    }\n  }]);\n  return MessageBus;\n}(_Bus3.default);\n\nexports.default = MessageBus;\nmodule.exports = exports['default'];\n\n},{\"./Bus\":422,\"./Pipeline\":424,\"babel-runtime/core-js/json/stringify\":3,\"babel-runtime/core-js/object/get-prototype-of\":8,\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16,\"babel-runtime/helpers/inherits\":18,\"babel-runtime/helpers/possibleConstructorReturn\":19}],424:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require(\"babel-runtime/helpers/createClass\");\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n* Copyright 2016 PT Inovao e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n\n/**\n* @author micaelpedrosa@gmail.com\n* Sequencial processor of methods. Similar to how Sequential Promise's work, but better fit for message processing.\n* Normal use for this, is to intercept all messages with configured handlers, and act accordingly.\n*/\nvar Pipeline = function () {\n  /* public\n    handlers: ((PipeContext) => void)[]\n    onFail: (error) => void\n  */\n\n  function Pipeline(_onFail) {\n    (0, _classCallCheck3.default)(this, Pipeline);\n\n    var _this = this;\n\n    _this.handlers = [];\n    _this.onFail = _onFail;\n  }\n\n  /**\n   * Insert a message in the pipeline queue. All messages are wrapped with a PipeContext.\n   * @param  {Message} msg       Message for the queue\n   * @param  {Callback} onDeliver When message is finished processing from all handlers, it will be delivered in this callback.\n   */\n\n\n  (0, _createClass3.default)(Pipeline, [{\n    key: \"process\",\n    value: function process(msg, onDeliver) {\n      var _this = this;\n\n      if (_this.handlers.length > 0) {\n        var iter = new Iterator(_this.handlers);\n        iter.next(new PipeContext(_this, iter, msg, onDeliver));\n      } else {\n        onDeliver(msg);\n      }\n    }\n  }]);\n  return Pipeline;\n}();\n\n/**\n* @author micaelpedrosa@gmail.com\n* Wrapper around a message that adds actions that can be fired by any interceptor handler.\n* The Pipeline is asynchronous, so an handler should always call an action, the default one is \"next()\"\n*/\n\n\nvar PipeContext = function () {\n  /* private\n    _inStop: boolean\n     _pipeline: Pipeline\n    _iter: Iterator\n    _msg: Message\n  */\n\n  function PipeContext(pipeline, iter, msg, onDeliver) {\n    (0, _classCallCheck3.default)(this, PipeContext);\n\n    var _this = this;\n\n    _this._inStop = false;\n\n    _this._pipeline = pipeline;\n    _this._iter = iter;\n    _this._msg = msg;\n    _this._onDeliver = onDeliver;\n  }\n\n  (0, _createClass3.default)(PipeContext, [{\n    key: \"next\",\n\n\n    /**\n     * Proceed to the next interceptor handler, unless there was an error. If it's the last one, proceed to onDeliver handler.\n     */\n    value: function next() {\n      var _this = this;\n\n      if (!_this._inStop) {\n        if (_this._iter.hasNext) {\n          _this._iter.next(_this);\n        } else {\n          _this._onDeliver(_this._msg);\n        }\n      }\n    }\n\n    /**\n     * Proceed directly to the onDeliver handler, unless there was an error.\n     */\n\n  }, {\n    key: \"deliver\",\n    value: function deliver() {\n      var _this = this;\n      if (!_this._inStop) {\n        _this._inStop = true;\n        _this._onDeliver(_this._msg);\n      }\n    }\n\n    /**\n     * Mark the context with an error and proceed to the onFail handler.\n     * @param  {[type]} error [description]\n     */\n\n  }, {\n    key: \"fail\",\n    value: function fail(error) {\n      var _this = this;\n\n      if (!_this._inStop) {\n        _this._inStop = true;\n        if (_this._pipeline.onFail) {\n          _this._pipeline.onFail(error);\n        }\n      }\n    }\n  }, {\n    key: \"pipeline\",\n    get: function get() {\n      return this._pipeline;\n    }\n  }, {\n    key: \"msg\",\n    get: function get() {\n      return this._msg;\n    },\n    set: function set(inMsg) {\n      this._msg = inMsg;\n    }\n  }]);\n  return PipeContext;\n}();\n\nvar Iterator = function () {\n  /* private\n    _index: number\n    _array: []\n  */\n\n  function Iterator(array) {\n    (0, _classCallCheck3.default)(this, Iterator);\n\n    this._index = -1;\n    this._array = array;\n  }\n\n  (0, _createClass3.default)(Iterator, [{\n    key: \"hasNext\",\n    get: function get() {\n      return this._index < this._array.length - 1;\n    }\n  }, {\n    key: \"next\",\n    get: function get() {\n      this._index++;\n      return this._array[this._index];\n    }\n  }]);\n  return Iterator;\n}();\n\nexports.default = Pipeline;\nmodule.exports = exports[\"default\"];\n\n},{\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16}],425:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n* Class with the cryptographic functions for the authentication protocol\n*\n*/\nvar Crypto = function () {\n  function Crypto() {\n    (0, _classCallCheck3.default)(this, Crypto);\n\n    var _this = this;\n  }\n\n  /**\n  * encode a byteArray value in base 64 encode\n  * @param   {byteArray}    value    byteArray value\n  * @return  {string}   encoded value\n  */\n\n\n  (0, _createClass3.default)(Crypto, [{\n    key: 'encode',\n    value: function encode(value) {\n      return btoa(value);\n    }\n\n    /**\n    * decode a base64 value in a new Uint8Array\n    * @param   {string}    value    value encoded in base 64\n    * @return  {byteArray} decodedValue\n    */\n\n  }, {\n    key: 'decode',\n    value: function decode(value) {\n      return new Uint8Array(JSON.parse('[' + atob(value) + ']'));\n    }\n  }, {\n    key: 'encryptRSA',\n    value: function encryptRSA(pubKey, data) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n        _this._importRSAencryptKey(new Uint8Array(pubKey)).then(function (publicKey) {\n\n          crypto.subtle.encrypt({\n            name: 'RSA-OAEP'\n          }, publicKey, //from generateKey or importKey above\n          data //ArrayBuffer of data you want to encrypt\n          ).then(function (encrypted) {\n            //returns an ArrayBuffer containing the encrypted data\n            //console.log('crypto-encryptRSA', new Uint8Array(encrypted));\n            resolve(new Uint8Array(encrypted));\n          }).catch(function (err) {\n            console.log('crypto-encryptRSA', err);\n            reject(err);\n          });\n        });\n      });\n    }\n  }, {\n    key: 'decryptRSA',\n    value: function decryptRSA(privKey, data) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n        _this._importRSAdecryptKey(privKey).then(function (privateKey) {\n\n          crypto.subtle.decrypt({\n            name: 'RSA-OAEP'\n          }, privateKey, //from generateKey or importKey above\n          data //ArrayBuffer of the data\n          ).then(function (decrypted) {\n\n            var decryptedData = new Uint8Array(decrypted);\n\n            //console.log('crypto-decryptRSA', decryptedData);\n            resolve(decryptedData);\n          }).catch(function (err) {\n            console.log('crypto-decryptRSA', err);\n            reject(err);\n          });\n        });\n      });\n    }\n  }, {\n    key: 'signRSA',\n    value: function signRSA(privKey, data) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n        _this._importRSAsignKey(privKey).then(function (privateKey) {\n\n          crypto.subtle.sign({\n            name: 'RSASSA-PKCS1-v1_5'\n          }, privateKey, //from generateKey or importKey above\n          _this._utf8Encode(data) //ArrayBuffer of data you want to sign\n          ).then(function (signature) {\n            //returns an ArrayBuffer containing the signature\n            //console.log('crypto-signRSA', new Uint8Array(signature));\n            resolve(new Uint8Array(signature));\n          }).catch(function (err) {\n            console.log('crypto-signRSA', err);\n            reject(err);\n          });\n        });\n      });\n    }\n  }, {\n    key: 'verifyRSA',\n    value: function verifyRSA(pubKey, data, signature) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n        _this._importRSAverifyKey(pubKey).then(function (publicKey) {\n\n          crypto.subtle.verify({\n            name: 'RSASSA-PKCS1-v1_5'\n          }, publicKey, //from generateKey or importKey above\n          signature, //ArrayBuffer of the signature\n          _this._utf8Encode(data) //ArrayBuffer of the data\n          ).then(function (isvalid) {\n            //returns a boolean on whether the signature is true or not\n            //console.log('crypto-verifyRSA', isvalid);\n            resolve(isvalid);\n          }).catch(function (err) {\n            console.log('crypto-verifyRSA', err);\n            reject(err);\n          });\n        });\n      });\n    }\n  }, {\n    key: 'encryptAES',\n    value: function encryptAES(key, data, iv) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n        _this._importAESkey(key).then(function (aesKey) {\n\n          crypto.subtle.encrypt({\n            name: 'AES-CBC',\n            //Don't re-use initialization vectors!\n            //Always generate a new iv every time your encrypt!\n            iv: iv\n          }, aesKey, //from generateKey or importKey above\n          _this._utf8Encode(data) //ArrayBuffer of data you want to encrypt\n          ).then(function (encrypted) {\n            //returns an ArrayBuffer containing the encrypted data\n            //console.log('crypto-encryptAES', new Uint8Array(encrypted));\n            resolve(new Uint8Array(encrypted));\n          }).catch(function (err) {\n            console.log('crypto-encryptAES', err);\n            reject(err);\n          });\n        });\n      });\n    }\n  }, {\n    key: 'decryptAES',\n    value: function decryptAES(key, data, iv) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n        _this._importAESkey(key).then(function (aesKey) {\n\n          crypto.subtle.decrypt({\n            name: 'AES-CBC',\n            iv: iv\n          }, aesKey, //from generateKey or importKey above\n          data //ArrayBuffer of the data\n          ).then(function (decrypted) {\n\n            var decodedData = _this._utf8Decode(new Uint8Array(decrypted));\n            //console.log('crypto-decryptAES', decodedData);\n            resolve(decodedData);\n          }).catch(function (err) {\n            console.log('crypto-decryptAES', err);\n            reject(err);\n          });\n        });\n      });\n    }\n\n    /**\n    * creates a hash using the HMAC algorithm\n    * @param  {byteArray}    key       key to be used in the hmac\n    * @param  {string}      data       information to be hashed\n    * @return  {byteArray}   signature  resulting hash\n    */\n\n  }, {\n    key: 'hashHMAC',\n    value: function hashHMAC(key, data) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n\n        _this._importHMACkey(key).then(function (hmacKey) {\n\n          crypto.subtle.sign({\n            name: 'HMAC'\n          }, hmacKey, //from generateKey or importKey above\n          _this._utf8Encode(data) //ArrayBuffer of data you want to sign\n          ).then(function (signature) {\n            //console.log('crypto-hashHMAC', signature);\n\n            //returns an ArrayBuffer containing the signature\n            resolve(new Uint8Array(signature));\n          }).catch(function (err) {\n            console.log('crypto-hashHMAC', err);\n            reject(err);\n          });\n        });\n      });\n    }\n\n    /**\n    * verifies an hash using the HMAC algorithm\n    * @param  {byteArray}    key       key to be used in the hmac\n    * @param  {string}      data       information to be hashed to compare\n    * @param  {byteArray}  signature   hash to compare with the received data\n    * @return  {boolean}   isvalid     boolean saying if the data corresponds to the hash received\n    */\n\n  }, {\n    key: 'verifyHMAC',\n    value: function verifyHMAC(key, data, signature) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n\n        _this._importHMACkey(key).then(function (hmacKey) {\n\n          crypto.subtle.verify({\n            name: 'HMAC'\n          }, hmacKey, //from generateKey or importKey above\n          signature, //ArrayBuffer of the signature\n          _this._utf8Encode(data) //ArrayBuffer of the data\n          ).then(function (isvalid) {\n            //returns a boolean on whether the signature is true or not\n            //console.log('crypto-verifyHMAC', isvalid);\n            isvalid ? resolve(isvalid) : reject(isvalid);\n          }).catch(function (err) {\n            console.error('crypto-verifyHMAC', err);\n            reject(err);\n          });\n        });\n      });\n    }\n\n    /**\n    * generates a RSA public/private key pair with a modulus length of 2048 bits\n    * @return  {JSON}   keyPair    json containing the public and private keys\n    */\n\n  }, {\n    key: 'generateRSAKeyPair',\n    value: function generateRSAKeyPair() {\n      var _this = this;\n      var keyPair = {};\n\n      return new _promise2.default(function (resolve, reject) {\n        crypto.subtle.generateKey({\n          name: 'RSA-PSS',\n          modulusLength: 2048, //can be 1024, 2048, or 4096\n          publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n          hash: { name: 'SHA-256' } //can be 'SHA-1', 'SHA-256', 'SHA-384', or 'SHA-512'\n        }, true, //whether the key is extractable (i.e. can be used in exportKey)\n        ['sign', 'verify'] //can be any combination of 'sign' and 'verify'\n\n        ).then(function (key) {\n          //returns a keypair object\n          //console.log(key);\n\n          crypto.subtle.exportKey('spki', //can be 'jwk' (public or private), 'spki' (public only), or 'pkcs8' (private only)\n          key.publicKey //can be a publicKey or privateKey, as long as extractable was true\n          ).then(function (publicKey) {\n            //returns the exported key data\n            keyPair.public = new Uint8Array(publicKey);\n            return crypto.subtle.exportKey('pkcs8', //can be 'jwk' (public or private), 'spki' (public only), or 'pkcs8' (private only)\n            key.privateKey //can be a publicKey or privateKey, as long as extractable was true\n            );\n          }).then(function (privateKey) {\n            keyPair.private = new Uint8Array(privateKey);\n            //console.log('crypto-generateRSAKeyPair', keyPair);\n\n            resolve(keyPair);\n          }).catch(function (err) {\n            console.error(err);\n            reject(err);\n          });\n        }).catch(function (err) {\n          console.error(err);\n          reject(err);\n        });\n      });\n    }\n\n    /**\n    * Generates a 128 bit random value.\n    * @return {byteArray}  array    random value\n    */\n\n  }, {\n    key: 'generateIV',\n    value: function generateIV() {\n      var _this = this;\n\n      var array = new Uint8Array(16);\n      crypto.getRandomValues(array);\n\n      return array;\n    }\n\n    /**\n    * Generates a 256 bit random value. 32 bits are extrated from the machine time,\n    * the remaining are generated randomly\n    * @return {byteArray}  array    random value\n    */\n\n  }, {\n    key: 'generateRandom',\n    value: function generateRandom() {\n      var _this = this;\n\n      var array = new Uint8Array(32);\n      crypto.getRandomValues(array);\n\n      var date = Date.now();\n      var dateEncoded = _this._utf8Encode(date);\n\n      //extract the least significant 4 bytes in the date\n      var finalDate = dateEncoded.slice(dateEncoded.length - 4, dateEncoded.length);\n\n      // add in the first 4 bytes of the array the bytes extracted previously;\n      for (var i = 0; i < 4; i++) {\n        array[i] = finalDate[i];\n      }\n      return array;\n    }\n\n    /**\n    * generates a premaster secret (PMS) of 48 bytes (384 bits) randomly\n    * @return {byteArray}  array    premaster secret key\n    */\n\n  }, {\n    key: 'generatePMS',\n    value: function generatePMS() {\n      var _this = this;\n\n      var array = new Uint8Array(48);\n      crypto.getRandomValues(array);\n      return array;\n    }\n\n    /**\n    * generates a masterKey secret (PMS) of 48 bytes (384 bits) using the premaster secret and\n    * two randoms\n    * @return {byteArray}  array    master secret key with 48 bytes\n    */\n\n  }, {\n    key: 'generateMasterSecret',\n    value: function generateMasterSecret(hmacKey, data) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n        var key = new Uint8Array(48);\n        var seed = data;\n\n        _this._digest(hmacKey).then(function (digestedKey) {\n\n          _this.hashHMAC(digestedKey, seed).then(function (keypart0) {\n\n            //copy the first 32 bytes into the key\n            for (var i = 0; i < 32; i++) {\n              key[i] = keypart0[i];\n            }\n            return _this.hashHMAC(digestedKey, seed + keypart0);\n          }).then(function (keypart1) {\n\n            //copy the first 16 bytes to the key remaining 16 bytes\n            for (var i = 0; i < 16; i++) {\n              key[i + 32] = keypart1[i];\n            }\n            //console.log('crypto-generateMasterSecret', key);\n            resolve(key);\n          }).catch(function (err) {\n            console.log('crypto-generateMasterSecret', err);\n            reject(err);\n          });\n        });\n      });\n    }\n\n    /**\n    * generates both users MAC and encryption keys. generate as output an array\n    * with 4 byteArray each with 32 bytes\n    * @param  {byteArray}        secret       secret to be used in the HMAC function\n    * @param  {String}           data         information to be used as seed\n    * @return {Array<byteArray>} key          array with the information to generate keys\n    */\n\n  }, {\n    key: 'generateKeys',\n    value: function generateKeys(hmacKey, data) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n\n        var key = [];\n        var seed = data;\n\n        // iterate 4 times to obtain a 1024 key size\n        _this.hashHMAC(hmacKey, seed).then(function (keypart0) {\n          key.push(keypart0);\n          return _this.hashHMAC(hmacKey, seed + keypart0);\n        }).then(function (keypart1) {\n          key.push(keypart1);\n          return _this.hashHMAC(hmacKey, seed + keypart1);\n        }).then(function (keypart2) {\n          key.push(keypart2);\n          return _this.hashHMAC(hmacKey, seed + keypart2);\n        }).then(function (keypart3) {\n          key.push(keypart3);\n\n          //console.log('crypto-generateKeys', key);\n          resolve(key);\n        }).catch(function (err) {\n          //console.log('crypto-generateKeys', err);\n          reject(err);\n        });\n\n        //console.log(hmacKey, data);\n      });\n    }\n  }, {\n    key: '_importRSAsignKey',\n    value: function _importRSAsignKey(privKey) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n        crypto.subtle.importKey('pkcs8', //can be 'jwk' (public or private), 'spki' (public only), or 'pkcs8' (private only)\n        privKey, { //these are the algorithm options\n          name: 'RSASSA-PKCS1-v1_5',\n          hash: { name: 'SHA-256' } //can be 'SHA-1', 'SHA-256', 'SHA-384', or 'SHA-512'\n        }, true, //whether the key is extractable (i.e. can be used in exportKey)\n        ['sign'] //'verify' for public key import, 'sign' for private key imports\n        ).then(function (privateKey) {\n          //returns a publicKey (or privateKey if you are importing a private key)\n          //console.log('crypto-_importRSAsignKey', privateKey);\n          resolve(privateKey);\n        }).catch(function (err) {\n          console.error('crypto-_importRSAsignKey', err);\n          reject(err);\n        });\n      });\n    }\n  }, {\n    key: '_importRSAverifyKey',\n    value: function _importRSAverifyKey(pubKey) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n        crypto.subtle.importKey('spki', //can be 'jwk' (public or private), 'spki' (public only), or 'pkcs8' (private only)\n        pubKey, { //these are the algorithm options\n          name: 'RSASSA-PKCS1-v1_5',\n          hash: { name: 'SHA-256' } //can be 'SHA-1', 'SHA-256', 'SHA-384', or 'SHA-512'\n        }, true, //whether the key is extractable (i.e. can be used in exportKey)\n        ['verify'] //'verify' for public key import, 'sign' for private key imports\n        ).then(function (publicKey) {\n          //returns a publicKey (or privateKey if you are importing a private key)\n          //console.log('crypto-_importRSAverifyKey', publicKey);\n          resolve(publicKey);\n        }).catch(function (err) {\n          console.error('crypto-_importRSAverifyKey', err);\n          reject(err);\n        });\n      });\n    }\n  }, {\n    key: '_importRSAencryptKey',\n    value: function _importRSAencryptKey(pubKey) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n        crypto.subtle.importKey('spki', //can be 'jwk' (public or private), 'spki' (public only), or 'pkcs8' (private only)\n        pubKey, { //these are the algorithm options\n          name: 'RSA-OAEP',\n          hash: { name: 'SHA-256' } //can be 'SHA-1', 'SHA-256', 'SHA-384', or 'SHA-512'\n        }, true, //whether the key is extractable (i.e. can be used in exportKey)\n        ['encrypt'] //'encrypt' or 'wrapKey' for public key import or\n        //'decrypt' or 'unwrapKey' for private key imports\n        ).then(function (publicKey) {\n          //returns a publicKey (or privateKey if you are importing a private key)\n          //console.log('crypto-_importRSAencryptKey', publicKey);\n          resolve(publicKey);\n        }).catch(function (err) {\n          console.error('crypto-_importRSAencryptKey', err);\n          reject(err);\n        });\n      });\n    }\n  }, {\n    key: '_importRSAdecryptKey',\n    value: function _importRSAdecryptKey(privKey) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n        crypto.subtle.importKey('pkcs8', //can be 'jwk' (public or private), 'spki' (public only), or 'pkcs8' (private only)\n        privKey, { //these are the algorithm options\n          name: 'RSA-OAEP',\n          hash: { name: 'SHA-256' } //can be 'SHA-1', 'SHA-256', 'SHA-384', or 'SHA-512'\n        }, true, //whether the key is extractable (i.e. can be used in exportKey)\n        ['decrypt'] //'encrypt' or 'wrapKey' for public key import or\n        //'decrypt' or 'unwrapKey' for private key imports\n        ).then(function (privateKey) {\n          //returns a publicKey (or privateKey if you are importing a private key)\n          //console.log('crypto-_importRSAdecryptKey', privateKey);\n          resolve(privateKey);\n        }).catch(function (err) {\n          console.error('crypto-_importRSAdecryptKey', err);\n          reject(err);\n        });\n      });\n    }\n  }, {\n    key: 'concatPMSwithRandoms',\n    value: function concatPMSwithRandoms(pms, toRandom, fromRandom) {\n      var _this = this;\n\n      var finalKey = new Uint8Array(pms.length + toRandom.length + fromRandom.length);\n\n      // add PremasterKey\n      for (var i = 0; i < pms.length; i++) {\n        finalKey[i] = pms[i];\n      }\n\n      //add to random\n      for (var _i = 0; _i < toRandom.length; _i++) {\n        finalKey[_i + pms.length] = pms[_i];\n      }\n\n      //add from random\n      for (var _i2 = 0; _i2 < fromRandom.length; _i2++) {\n        finalKey[_i2 + pms.length + toRandom.length] = pms[_i2];\n      }\n\n      return finalKey;\n    }\n  }, {\n    key: '_generate256bitKey',\n    value: function _generate256bitKey() {\n      var array = new Uint8Array(32);\n      crypto.getRandomValues(array);\n\n      return array;\n    }\n\n    /**\n    * imports the secret to the HMAC function\n    * @param  {byteArray}   arrayBuffer     bytes to import as key\n    * @return {JSON}       key              key ready to be used in the HMAC cryptographic function\n    */\n\n  }, {\n    key: '_importHMACkey',\n    value: function _importHMACkey(arrayBuffer) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n\n        _this._digest(arrayBuffer).then(function (key) {\n\n          crypto.subtle.importKey('raw', //can be 'jwk' or 'raw'\n          key, { //this is the algorithm options\n            name: 'HMAC',\n            hash: { name: 'SHA-256' }, //can be 'SHA-1', 'SHA-256', 'SHA-384', or 'SHA-512'\n            length: 256 //optional, if you want your key length to differ from the hash function's block length\n          }, true, //whether the key is extractable (i.e. can be used in exportKey)\n          ['sign', 'verify'] //can be any combination of 'sign' and 'verify'\n          ).then(function (key) {\n            //returns the symmetric key\n            //console.log('crypto-_importHMACkey', key);\n            resolve(key);\n          }).catch(function (err) {\n            reject(err);\n          });\n        });\n      });\n    }\n  }, {\n    key: '_digest',\n    value: function _digest(value) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n        crypto.subtle.digest({\n          name: 'SHA-256'\n        }, value //The data you want to hash as an ArrayBuffer\n        ).then(function (hash) {\n          //returns the hash as an ArrayBuffer\n          //console.log('crypto-digest', new Uint8Array(hash));\n          resolve(new Uint8Array(hash));\n        }).catch(function (err) {\n          console.error(err);\n          reject(err);\n        });\n      });\n    }\n  }, {\n    key: '_importAESkey',\n    value: function _importAESkey(arrayBuffer) {\n      return new _promise2.default(function (resolve, reject) {\n        crypto.subtle.importKey('raw', //can be 'jwk' or 'raw'\n        arrayBuffer, { //this is the algorithm options\n          name: 'AES-CBC'\n        }, true, //whether the key is extractable (i.e. can be used in exportKey)\n        ['encrypt', 'decrypt'] //can be 'encrypt', 'decrypt', 'wrapKey', or 'unwrapKey'\n        ).then(function (key) {\n          //returns the symmetric key\n          //console.log('crypto-importAESkey', key);\n          resolve(key);\n        }).catch(function (err) {\n          console.error('crypto-importAESkey', err);\n          reject(err);\n        });\n      });\n    }\n  }, {\n    key: '_utf8Encode',\n    value: function _utf8Encode(s) {\n      return new TextEncoder('utf-8').encode(s);\n    }\n  }, {\n    key: '_utf8Decode',\n    value: function _utf8Decode(s) {\n      return new TextDecoder('utf-8').decode(s);\n    }\n  }]);\n  return Crypto;\n}();\n\nexports.default = Crypto;\nmodule.exports = exports['default'];\n\n},{\"babel-runtime/core-js/promise\":12,\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16}],426:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n* fake class for the gui to select the identity,\n* TODO replace with the proper identity GUI\n*\n*/\nvar GuiFake = function GuiFake(url, messageBus) {\n  (0, _classCallCheck3.default)(this, GuiFake);\n\n  var _this = this;\n\n  _this._url = url;\n  _this._waitTime = 10000;\n  _this._messageBus = messageBus;\n\n  _this._messageBus.addListener(_this._url, function (msg) {\n\n    var identities = msg.body.value.identities;\n    var idps = msg.body.value.idps;\n\n    var value = void 0;\n\n    if (identities[0] !== undefined) {\n      value = { type: 'identity', value: identities[0], code: 200 };\n    } else {\n      value = { type: 'idp', value: idps[0], code: 200 };\n    }\n\n    var replyMsg = { id: msg.id, type: 'response', to: msg.from, from: msg.to, body: value };\n\n    // to test on the identity side the listener without the timeout\n    // can represent the time the user takes to choose and identity\n    if (msg.body.value === 'wait') {\n\n      setTimeout(function () {\n        _this._messageBus.postMessage(replyMsg);\n      }, _this._waitTime);\n    } else {\n      _this._messageBus.postMessage(replyMsg);\n    }\n  });\n};\n\nexports.default = GuiFake;\nmodule.exports = exports['default'];\n\n},{\"babel-runtime/helpers/classCallCheck\":15}],427:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n* The Identity Data Model is used to model the reTHINK User entity. The Identity data model is handled by Identity Management functionality.\n*\n*/\nvar Identity = function () {\n  function Identity(guid, type) {\n    (0, _classCallCheck3.default)(this, Identity);\n\n    var _this = this;\n\n    _this.guid = guid;\n    _this.type = type;\n    _this.identifiersList = {};\n  }\n\n  (0, _createClass3.default)(Identity, [{\n    key: 'addIdentity',\n    value: function addIdentity(identifier) {\n      var _this = this;\n      var identityInformation = {\n        idAssertion: '',\n        serviceAddress: '',\n        authenticationData: '',\n        authorisationData: '',\n        userProfile: ''\n      };\n      _this.identifiersList[identifier] = identityInformation;\n    }\n  }, {\n    key: 'addIdAssertion',\n    value: function addIdAssertion(identifier, assertion, idp, scope) {\n      var _this = this;\n\n      var newIdAssertion = new IdAssertion(assertion, idp, scope);\n\n      _this.idAssertionList.push(newIdAssertion);\n    }\n  }]);\n  return Identity;\n}();\n\nvar IdAssertion = function IdAssertion(assertion, idp, scope) {\n  (0, _classCallCheck3.default)(this, IdAssertion);\n\n  var _this = this;\n\n  _this.assertion = assertion;\n  _this.idp = idp;\n  _this.scope = scope;\n};\n\nvar IdValidation = function () {\n  function IdValidation(identity, contents) {\n    (0, _classCallCheck3.default)(this, IdValidation);\n\n    var _this = this;\n    _this.identity = identity;\n    _this.contents = contents;\n  }\n\n  (0, _createClass3.default)(IdValidation, [{\n    key: 'validates',\n    value: function validates(identity, contents) {\n      //TODO implement the logic\n\n    }\n  }]);\n  return IdValidation;\n}();\n\nexports.default = Identity;\nmodule.exports = exports['default'];\n\n},{\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16}],428:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _stringify = require('babel-runtime/core-js/json/stringify');\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _utils = require('../utils/utils.js');\n\nvar _Identity = require('./Identity');\n\nvar _Identity2 = _interopRequireDefault(_Identity);\n\nvar _Crypto = require('./Crypto');\n\nvar _Crypto2 = _interopRequireDefault(_Crypto);\n\nvar _GuiFake = require('./GuiFake');\n\nvar _GuiFake2 = _interopRequireDefault(_GuiFake);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n*\n* The Identity Module (Id Module) is the component responsible for handling the\n* user identity and the association of this identity with the Hyperty instances,\n* in order to make Hyperty instances identifiable. The identity in the reTHINK project\n* is not fixed to a unique Identity Service Provider, but obtained through several\n* different Identity sources. With this approach, the Id Module provides to the user the\n* option to choose the preferred method for authentication.\n* This module will thus able to support multiple Identity acquisition methods,\n* such as OpenID connect 1.0, Kerberos System, or authentication through smart cards.\n* For example, a user with a Google account can use the Google as an Identity Provider to provide Identity Tokens,\n*  which can be used by the Identity Module to associate it with a Hyperty instance.\n*\n* The Identity Module uses a node package, the HelloJS, which is a client-side JavaScript API for authentication\n* that facilitates the requests for the OpenID connect protocol. This method allows for some abstraction\n* when making requests for different Identity Providers, such as OpenID connect used by Google, Facebook, Microsoft, for example.\n*\n* When a request for a user identity is made using the method loginWithRP(identifier, scope),\n* this method will analyse the Identity Provider chosen to obtain an identity and will use the HelloJS node package\n* with the selected Identity Provider and identity scope. After the HelloJS request for an Access Token\n* to the Identity Providers, the user will be prompted to authenticate towards the Identity Provider.\n* Upon receiving the Access Token, this token is validated with a RESTful web service request to an endpoint\n* on the Identity Provider Authorization Server, and after the validation is done,\n* an ID token is obtained with the information according to the scope required.\n* This ID token is then preserved in this module that can obtained through the getIdentities()\n* and is passed as return value of the loginWithRP function. The methods generateAssertion and validateAssertion have not yet been developed.\n*\n*/\nvar IdentityModule = function () {\n\n  /**\n  * This is the constructor to initialise the Identity Module it does not require any input.\n  */\n  function IdentityModule(runtimeURL, runtimeCapabilities, storageManager) {\n    (0, _classCallCheck3.default)(this, IdentityModule);\n\n    var _this = this;\n\n    if (!runtimeURL) throw new Error('runtimeURL is missing.');\n    if (!storageManager) throw new Error('storageManager is missing');\n\n    _this._runtimeURL = runtimeURL;\n    _this.storageManager = storageManager;\n    _this._idmURL = _this._runtimeURL + '/idm';\n    _this._guiURL = _this._runtimeURL + '/identity-gui';\n    _this.runtimeCapabilities = runtimeCapabilities;\n\n    _this._domain = (0, _utils.divideURL)(_this._runtimeURL).domain;\n\n    //to store items with this format: {identity: identityURL, token: tokenID}\n    _this.identities = [];\n    _this.emailsList = [];\n    var newIdentity = new _Identity2.default('guid', 'HUMAN');\n    _this.identity = newIdentity;\n    _this.crypto = new _Crypto2.default();\n\n    //stores the association of the dataObject and the Hyperty registered within\n    _this.dataObjectsIdentity = {};\n\n    // hashTable to store all the crypto information between two hyperties\n    _this.chatKeys = {};\n\n    // hashTable to store the symmetric keys to be used in the chat group\n    _this.dataObjectSessionKeys = {};\n\n    //failsafe to enable/disable all the criptographic functions\n    _this.isToUseEncryption = true;\n\n    // variable to know if the GUI is deployed to choose the identity. if the real GUI is not deployed, a fake gui is deployed instead.\n    _this.guiDeployed = false;\n\n    // verification of nodeJS, and in case it is nodeJS then disable encryption\n    // TODO improve later, this exists because the crypto lib uses browser cryptographic methods\n    //_this.isToUseEncryption = (window) ? true : false;\n\n    _this._loadIdentities();\n  }\n\n  /**\n  * return the messageBus in this Registry\n  * @param {MessageBus}           messageBus\n  */\n\n\n  (0, _createClass3.default)(IdentityModule, [{\n    key: 'getIdentities',\n\n\n    /**\n    * Function to return all the identities registered within a session by a user.\n    * These identities are returned in an array containing a JSON package for each user identity.\n    * @return {Array<Identities>}         Identities\n    */\n    value: function getIdentities() {\n      var _this = this;\n      return _this.identities;\n    }\n\n    /**\n    * gets all the information from a given userURL\n    * @param  {String}  userURL     user url\n    * @return {JSON}    identity    identity bundle from the userURL\n    */\n\n  }, {\n    key: 'getIdentity',\n    value: function getIdentity(userURL) {\n      var _this = this;\n\n      for (var index in _this.identities) {\n\n        var identity = _this.identities[index];\n        if (identity.identity === userURL) {\n          return identity;\n        }\n      }\n\n      throw 'identity not found';\n    }\n  }, {\n    key: '_loadIdentities',\n    value: function _loadIdentities() {\n      var _this = this;\n      return new _promise2.default(function (resolve) {\n\n        _this.storageManager.get('idModule:identities').then(function (identities) {\n\n          if (identities) {\n            _this.identities = identities;\n          }\n          resolve();\n        });\n      });\n    }\n  }, {\n    key: 'deployGUI',\n    value: function deployGUI() {\n      var _this = this;\n      _this.guiDeployed = true;\n    }\n  }, {\n    key: 'getIdentityOfHyperty',\n    value: function getIdentityOfHyperty(hypertyURL) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n        var splitURL = hypertyURL.split('://');\n        if (splitURL[0] !== 'hyperty') {\n          _this._getHypertyFromDataObject(hypertyURL).then(function (returnedHypertyURL) {\n            var userURL = _this.registry.getHypertyOwner(returnedHypertyURL);\n            if (userURL) {\n\n              for (var index in _this.identities) {\n                var identity = _this.identities[index];\n                if (identity.identity === userURL) {\n                  return resolve(identity.messageInfo);\n                }\n              }\n            } else {\n              return reject('no identity was found ');\n            }\n          });\n        } else {\n          var userURL = _this.registry.getHypertyOwner(hypertyURL);\n          if (userURL) {\n\n            for (var index in _this.identities) {\n              var identity = _this.identities[index];\n              if (identity.identity === userURL) {\n                return resolve(identity.messageInfo);\n              }\n            }\n          } else {\n            return reject('no identity was found.');\n          }\n        }\n      });\n    }\n  }, {\n    key: 'getIdentitiesToChoose',\n    value: function getIdentitiesToChoose() {\n      var _this = this;\n      var identities = _this.emailsList;\n      var idps = ['google.com', 'microsoft.com', 'orange.fr'];\n\n      return { identities: identities, idps: idps };\n    }\n\n    /**\n    * Function to return all the users URLs registered within a session\n    * These users URLs are returned in an array of strings.\n    * @param  {Boolean}  emailFormat (Optional)   boolean to indicate to return in email format\n    * @return {Array<String>}         users\n    */\n\n  }, {\n    key: 'getUsersIDs',\n    value: function getUsersIDs(emailFormat) {\n      var _this = this;\n      var users = [];\n\n      //if request comes with the emailFormat option, then convert url to email format\n      var converter = emailFormat ? _utils.getUserEmailFromURL : function (value) {\n        return value;\n      };\n\n      for (var index in _this.identities) {\n        var identity = _this.identities[index];\n        users.push(converter(identity.identity));\n      }\n      return users;\n    }\n\n    /**\n    * Function to return the selected Identity within a session\n    * @return {Identity}        identity         identity\n    */\n\n  }, {\n    key: 'getCurrentIdentity',\n    value: function getCurrentIdentity() {\n      var _this = this;\n      return _this.currentIdentity;\n    }\n\n    /**\n    * Function to set the current Identity with a given Identity\n    * @param {Identity}        identity         identity\n    */\n\n  }, {\n    key: 'setCurrentIdentity',\n    value: function setCurrentIdentity(identity) {\n      var _this = this;\n      _this.currentIdentity = identity;\n    }\n\n    /**\n    * Function to remove an identity from the Identities array\n    * @param {String}    userID      userID\n    */\n\n  }, {\n    key: 'deleteIdentity',\n    value: function deleteIdentity(userID) {\n      var _this = this;\n\n      var userURL = (0, _utils.convertToUserURL)(userID);\n\n      for (var identity in _this.identities) {\n        if (_this.identities[identity].identity === userURL) {\n          _this.identities.splice(identity, 1);\n        }\n      }\n    }\n\n    /**\n    * Function to unregister an identity from the emailsList array and not show in to the GUI\n    * @param {String}    email      email\n    */\n\n  }, {\n    key: 'unregisterIdentity',\n    value: function unregisterIdentity(email) {\n      var _this = this;\n\n      for (var e in _this.emailsList) {\n        if (_this.emailsList[e] === email) {\n          _this.emailsList.splice(e, 1);\n        }\n      }\n    }\n\n    /**\n    * Function that resolve and create the domainURL in case it is provided one. If not, resolve the default domainURL\n    * @param {String}     idpDomain     idpDomain (Optional)\n    */\n\n  }, {\n    key: '_resolveDomain',\n    value: function _resolveDomain(idpDomain) {\n      if (!idpDomain) {\n        return 'domain-idp://google.com';\n      } else {\n        return 'domain-idp://' + idpDomain;\n      }\n    }\n\n    /**\n    * Function that sends a request to the GUI using messages. Sends all identities registered and\n    * the Idps supported, and return the identity/idp received by the GUI\n    * @param {Array<identity>}  identities      list of identitiies\n    * @param {Array<String>}    idps            list of idps to authenticate\n    * @return {Promise}         returns a chosen identity or idp\n    */\n\n  }, {\n    key: 'requestIdentityToGUI',\n    value: function requestIdentityToGUI(identities, idps) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n\n        //condition to check if the real GUI is deployed. If not, deploys a fake gui\n        if (_this.guiDeployed === false) {\n\n          var guiFake = new _GuiFake2.default(_this._guiURL, _this._messageBus);\n          _this.guiFake = guiFake;\n          _this.guiDeployed = true;\n        }\n\n        var message = { type: 'create', to: _this._guiURL, from: _this._idmURL,\n          body: { value: { identities: identities, idps: idps } } };\n\n        var id = _this._messageBus.postMessage(message);\n\n        //add listener without timout\n        _this._messageBus.addResponseListener(_this._idmURL, id, function (msg) {\n          _this._messageBus.removeResponseListener(_this._idmURL, id);\n\n          if (msg.body.code === 200) {\n            var selectedIdentity = msg.body;\n\n            console.log('selectedIdentity: ', selectedIdentity.value);\n            resolve(selectedIdentity);\n          } else {\n            reject('error on requesting an identity to the GUI');\n          }\n        });\n      });\n    }\n  }, {\n    key: 'openPopup',\n    value: function openPopup(urlreceived) {\n\n      return new _promise2.default(function (resolve, reject) {\n\n        var win = window.open(urlreceived, 'openIDrequest', 'width=800, height=600');\n        if (window.cordova) {\n          win.addEventListener('loadstart', function (e) {\n            var url = e.url;\n            var code = /\\&code=(.+)$/.exec(url);\n            var error = /\\&error=(.+)$/.exec(url);\n\n            if (code || error) {\n              win.close();\n              resolve(url);\n            }\n          });\n        } else {\n          (function () {\n            var pollTimer = setInterval(function () {\n              try {\n                if (win.closed) {\n                  reject('Some error occured when trying to get identity.');\n                  clearInterval(pollTimer);\n                }\n\n                if (win.document.URL.indexOf('id_token') !== -1 || win.document.URL.indexOf(location.origin) !== -1) {\n                  window.clearInterval(pollTimer);\n                  var url = win.document.URL;\n\n                  win.close();\n                  resolve(url);\n                }\n              } catch (e) {\n                //console.log(e);\n              }\n            }, 500);\n          })();\n        }\n      });\n    }\n\n    /**\n    * Function that fetch an identityAssertion from a user.\n    *\n    * @return {IdAssertion}              IdAssertion\n    */\n\n  }, {\n    key: 'getIdentityAssertion',\n    value: function getIdentityAssertion(identifier, origin, usernameHint, idpDomain) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n\n        //CHECK whether is browser environment or nodejs\n        //if it is browser, then create a fake identity\n\n        _this.runtimeCapabilities.isAvailable('browser').then(function (result) {\n          console.log('runtime browser identity acquisition ', result);\n\n          if (!result) return;\n\n          var identitiesInfo = _this.getIdentitiesToChoose();\n\n          _this.requestIdentityToGUI(identitiesInfo.identities, identitiesInfo.idps).then(function (value) {\n\n            if (value.type === 'identity') {\n\n              var chosenID = (0, _utils.getUserURLFromEmail)(value.value);\n\n              // returns the identity info from the chosen id\n              for (var i in _this.identities) {\n                if (_this.identities[i].identity === chosenID) {\n                  return resolve(_this.identities[i].messageInfo);\n                }\n              }\n              reject('no identity was found .');\n            } else if (value.type === 'idp') {\n\n              _this.callGenerateMethods(value.value, origin).then(function (value) {\n                resolve(value);\n              }, function (err) {\n                reject(err);\n              });\n            } else {\n              reject('error on GUI received message.');\n            }\n          });\n        }).catch(function (error) {\n          console.log('Error on identity acquisition ', error);\n          reject(error);\n        });\n\n        _this.runtimeCapabilities.isAvailable('node').then(function (result) {\n          console.log('node identity acquisition ', result);\n\n          if (!result) return;\n\n          if (_this.currentIdentity !== undefined) {\n            //TODO verify whether the token is still valid or not.\n            // should be needed to make further requests, to obtain a valid token\n            return resolve(_this.currentIdentity);\n          } else {\n            (function () {\n              console.log('getIdentityAssertion for nodejs');\n              var randomNumber = Math.floor(Math.random() * 10000 + 1);\n              var identityBundle = {\n                assertion: 'assertion',\n                idp: 'nodejs',\n                userProfile: {\n                  avatar: 'https://lh3.googleusercontent.com/-WaCrjVMMV-Q/AAAAAAAAAAI/AAAAAAAAAAs/8OlVqCpSB9c/photo.jpg',\n                  cn: 'test nodejs',\n                  username: 'nodejs-' + randomNumber + '@nodejs.com',\n                  userURL: 'user://nodejs.com/nodejs-' + randomNumber\n                } };\n              _this.currentIdentity = identityBundle;\n              _this.identities.push(identityBundle);\n              _this.storageManager.set('idModule:identities', 0, _this.identities).then(function () {\n\n                return resolve(identityBundle);\n              });\n            })();\n          }\n        }).catch(function (error) {\n          console.log('Error on identity acquisition ', error);\n          reject(error);\n        });\n      });\n    }\n  }, {\n    key: 'callGenerateMethods',\n    value: function callGenerateMethods(idp, origin) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n\n        var publicKey = void 0;\n        var userkeyPair = void 0;\n\n        //generates the RSA key pair\n        _this.crypto.generateRSAKeyPair().then(function (keyPair) {\n\n          publicKey = btoa(keyPair.public);\n          userkeyPair = keyPair;\n          return _this.generateAssertion(publicKey, origin, '', userkeyPair, idp);\n        }).then(function (url) {\n          return _this.generateAssertion(publicKey, origin, url, userkeyPair, idp);\n        }).then(function (value) {\n          if (value) {\n            resolve(value);\n          } else {\n            reject('Error on obtaining Identity');\n          }\n        }).catch(function (err) {\n          console.log(err);\n          reject(err);\n        });\n      });\n    }\n  }, {\n    key: 'sendGenerateMessage',\n    value: function sendGenerateMessage(contents, origin, usernameHint, idpDomain) {\n      var _this = this;\n      var domain = _this._resolveDomain(idpDomain);\n      var message = void 0;\n\n      return new _promise2.default(function (resolve, reject) {\n        message = { type: 'execute', to: domain, from: _this._idmURL, body: { resource: 'identity', method: 'generateAssertion', params: { contents: contents, origin: origin, usernameHint: usernameHint } } };\n        _this._messageBus.postMessage(message, function (res) {\n          var result = res.body.value;\n\n          resolve(result);\n        });\n      });\n    }\n  }, {\n    key: 'storeIdentity',\n    value: function storeIdentity(result, keyPair) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n\n        var splitedAssertion = result.assertion.split('.');\n        var assertionParsed = void 0;\n\n        //verify if the token contains the 3 components, or just the assertion\n        if (splitedAssertion[1]) {\n          assertionParsed = JSON.parse(atob(splitedAssertion[1]));\n        } else {\n\n          assertionParsed = JSON.parse(atob(result.assertion));\n        }\n        var idToken = void 0;\n\n        //TODO remove the verification and remove the tokenIDJSON from the google idpProxy;\n        if (assertionParsed.tokenIDJSON) {\n          idToken = assertionParsed.tokenIDJSON;\n        } else {\n          idToken = assertionParsed;\n        }\n\n        var email = idToken.email || idToken.sub;\n\n        var identifier = (0, _utils.getUserURLFromEmail)(email);\n\n        result.identity = identifier;\n\n        _this.identity.addIdentity(result);\n\n        // check if exists any infoToken in the result received\n        var infoToken = result.infoToken ? result.infoToken : {};\n\n        var commonName = idToken.name || email.substring(0, email.indexOf('@'));\n        var userProfileBundle = { username: email, cn: commonName, avatar: infoToken.picture, locale: infoToken.locale, userURL: identifier };\n\n        //creation of a new JSON with the identity to send via messages\n        var newIdentity = { userProfile: userProfileBundle, idp: result.idp.domain, assertion: result.assertion };\n        result.messageInfo = newIdentity;\n        result.keyPair = keyPair;\n\n        _this.currentIdentity = newIdentity;\n\n        //verify if the id already exists. If already exists then do not add to the identities list;\n        var idAlreadyExists = false;\n        var oldId = void 0;\n        for (var identity in _this.identities) {\n          if (_this.identities[identity].identity === result.identity) {\n            idAlreadyExists = true;\n            oldId = _this.identities[identity].messageInfo;\n          }\n        }\n\n        if (idAlreadyExists) {\n          resolve(oldId);\n          var exists = false;\n\n          //check if the identity exists in emailList, if not add it\n          //This is useful if an identity was previously registered but was later unregistered\n          for (var i in _this.emailsList) {\n            if (_this.emailsList[i] === email) {\n              exists = true;\n              break;\n            }\n          }\n          if (!exists) {\n            _this.emailsList.push(email);\n          }\n        } else {\n          _this.emailsList.push(email);\n          _this.identities.push(result);\n          _this.storageManager.set('idModule:identities', 0, _this.identities).then(function () {\n\n            resolve(newIdentity);\n          });\n        }\n      });\n    }\n\n    /**\n    * Requests the IdpProxy from a given Domain for an identityAssertion\n    *\n    * @param  {DOMString} contents     contents\n    * @param  {DOMString} origin       origin\n    * @param  {DOMString} usernameHint usernameHint\n    * @param  {JSON}      keyPair       user keyPair\n    * @return {IdAssertion}              IdAssertion\n    */\n\n  }, {\n    key: 'generateAssertion',\n    value: function generateAssertion(contents, origin, usernameHint, keyPair, idpDomain) {\n      var _this = this;\n\n      console.log('generateAssertion');\n\n      return new _promise2.default(function (resolve, reject) {\n\n        _this.sendGenerateMessage(contents, origin, usernameHint, idpDomain).then(function (result) {\n\n          if (result.loginUrl) {\n\n            _this.openPopup(result.loginUrl).then(function (value) {\n              resolve(value);\n            }, function (err) {\n              reject(err);\n            });\n          } else if (result) {\n\n            _this.storeIdentity(result, keyPair).then(function (value) {\n              resolve(value);\n            }, function (err) {\n              reject(err);\n            });\n          } else {\n            reject('error on obtaining identity information');\n          }\n        });\n      });\n    }\n\n    /**\n    * OTHER USER'S IDENTITY\n    */\n\n    /**\n    * Requests the IdpProxy from a given Domain to validate an IdentityAssertion\n    * Returns a promise with the result from the validation.\n    * @param  {DOMString} assertion\n    * @param  {DOMString} origin       origin\n    * @return {Promise}         Promise         promise with the result from the validation\n    */\n\n  }, {\n    key: 'validateAssertion',\n    value: function validateAssertion(assertion, origin, idpDomain) {\n      var _this = this;\n\n      var domain = _this._resolveDomain(idpDomain);\n\n      var message = { type: 'execute', to: domain, from: _this._idmURL, body: { resource: 'identity', method: 'validateAssertion',\n          params: { assertion: assertion, origin: origin } } };\n\n      return new _promise2.default(function (resolve, reject) {\n        _this._messageBus.postMessage(message, function (result) {\n          if (result.body.code === 200) {\n            resolve(result.body.value);\n          } else {\n            reject('error', result.body.code);\n          }\n        });\n      });\n    }\n  }, {\n    key: 'encryptMessage',\n    value: function encryptMessage(message) {\n      var _this = this;\n\n      console.log('encrypt message ');\n\n      return new _promise2.default(function (resolve, reject) {\n        var isHandShakeType = message.type === 'handshake';\n\n        //if is not to apply encryption, then returns resolve\n        if (!_this.isToUseEncryption && !isHandShakeType) {\n          console.log('encryption disabled');\n          return resolve(message);\n        }\n\n        //TODO remove this logic and move it to a util function\n        var splitedToURL = message.to.split('/');\n        var dataObjectURL = splitedToURL[0] + '//' + splitedToURL[2] + '/' + splitedToURL[3];\n        if (splitedToURL.length > 6) {\n          dataObjectURL = splitedToURL[0] + '//' + splitedToURL[2] + '/' + splitedToURL[3] + '/' + splitedToURL[4];\n        }\n\n        var isToDataObject = (0, _utils.isDataObjectURL)(dataObjectURL);\n        var isFromHyperty = (0, _utils.divideURL)(message.from).type === 'hyperty';\n        var isToHyperty = (0, _utils.divideURL)(message.to).type === 'hyperty';\n\n        if (message.type === 'update') {\n          resolve(message);\n        }\n\n        if (isFromHyperty && isToHyperty) {\n          var userURL = _this._registry.getHypertyOwner(message.from);\n          if (userURL) {\n            (function () {\n\n              // check if exists any keys between two users\n              var chatKeys = _this.chatKeys[message.from + '<->' + message.to];\n              if (!chatKeys) {\n                chatKeys = _this._newChatCrypto(message, userURL);\n                console.log('createChatKey encrypt', message.from + message.to);\n                _this.chatKeys[message.from + '<->' + message.to] = chatKeys;\n                message.body.handshakePhase = 'startHandShake';\n              }\n\n              if (chatKeys.authenticated && !isHandShakeType) {\n                (function () {\n\n                  var iv = _this.crypto.generateIV();\n                  _this.crypto.encryptAES(chatKeys.keys.hypertyFromSessionKey, message.body.value, iv).then(function (encryptedValue) {\n\n                    var filteredMessage = _this._filterMessageToHash(message, message.body.value + iv, chatKeys.hypertyFrom.messageInfo);\n\n                    _this.crypto.hashHMAC(chatKeys.keys.hypertyFromHashKey, filteredMessage).then(function (hash) {\n                      //console.log('result of hash ', hash);\n                      var value = { iv: _this.crypto.encode(iv), value: _this.crypto.encode(encryptedValue), hash: _this.crypto.encode(hash) };\n                      message.body.value = (0, _stringify2.default)(value);\n\n                      resolve(message);\n                    });\n                  });\n\n                  // if is a handshake message, just resolve it\n                })();\n              } else if (isHandShakeType) {\n                resolve(message);\n\n                // else, starts a new handshake protocol\n              } else {\n                _this._doHandShakePhase(message, chatKeys).then(function (value) {\n                  _this.chatKeys[message.from + '<->' + message.to] = value.chatKeys;\n\n                  _this._messageBus.postMessage(value.message);\n                  reject('encrypt handshake protocol phase ');\n                });\n              }\n            })();\n          }\n\n          //if from hyperty to a dataObjectURL\n        } else if (isFromHyperty && isToDataObject) {\n          (function () {\n            console.log('dataObject value to encrypt: ', message.body.value);\n\n            var dataObjectKey = _this.dataObjectSessionKeys[dataObjectURL];\n\n            //if no key exists, create a new one if is the reporter of dataObject\n            if (!dataObjectKey) {\n              var isHypertyReporter = _this.registry.getReporterURLSynchonous(dataObjectURL);\n\n              // if the hyperty is the reporter of the dataObject then generates a session key\n              if (isHypertyReporter && isHypertyReporter === message.from) {\n\n                var sessionKey = _this.crypto.generateRandom();\n                _this.dataObjectSessionKeys[dataObjectURL] = { sessionKey: sessionKey, isToEncrypt: true };\n\n                dataObjectKey = _this.dataObjectSessionKeys[dataObjectURL];\n              }\n            }\n\n            //check if there is already a session key for the chat room\n            if (dataObjectKey) {\n\n              // and if is to apply encryption, encrypt the messages\n              if (dataObjectKey.isToEncrypt) {\n                (function () {\n                  var iv = _this.crypto.generateIV();\n\n                  _this.crypto.encryptAES(dataObjectKey.sessionKey, _this.crypto.encode((0, _stringify2.default)(message.body.value)), iv).then(function (encryptedValue) {\n\n                    var filteredMessage = _this._filterMessageToHash(message, message.body.value + iv, dataObjectKey.sessionKey);\n\n                    _this.crypto.hashHMAC(dataObjectKey.sessionKey, filteredMessage).then(function (hash) {\n                      //console.log('hash ', hash);\n\n                      var newValue = { value: _this.crypto.encode(encryptedValue), iv: _this.crypto.encode(iv), hash: _this.crypto.encode(hash) };\n\n                      message.body.value = (0, _stringify2.default)(newValue);\n                      resolve(message);\n                    });\n                  });\n\n                  // if not, just send the message\n                })();\n              } else {\n                resolve(message);\n              }\n\n              // start the generation of a new session Key\n            } else {\n              reject('failed to decrypt message');\n            }\n          })();\n        }\n      });\n    }\n  }, {\n    key: 'decryptMessage',\n    value: function decryptMessage(message) {\n      var _this = this;\n\n      console.log('decrypt message ');\n\n      return new _promise2.default(function (resolve, reject) {\n        var isHandShakeType = message.type === 'handshake';\n\n        //if is not to apply encryption, then returns resolve\n        if (!_this.isToUseEncryption && !isHandShakeType) {\n          console.log('decryption disabled');\n          return resolve(message);\n        }\n\n        //TODO remove this logic and move it to a util function\n\n        var splitedToURL = message.to.split('/');\n        var dataObjectURL = splitedToURL[0] + '//' + splitedToURL[2] + '/' + splitedToURL[3];\n        if (splitedToURL.length > 6) {\n          dataObjectURL = splitedToURL[0] + '//' + splitedToURL[2] + '/' + splitedToURL[3] + '/' + splitedToURL[4];\n        }\n\n        var isToDataObject = (0, _utils.isDataObjectURL)(dataObjectURL);\n        var isFromHyperty = (0, _utils.divideURL)(message.from).type === 'hyperty';\n        var isToHyperty = (0, _utils.divideURL)(message.to).type === 'hyperty';\n\n        if (message.type === 'update') {\n          resolve(message);\n        }\n\n        //is is hyperty to hyperty communication\n        if (isFromHyperty && isToHyperty) {\n          //console.log('decrypt hyperty to hyperty');\n          var userURL = _this._registry.getHypertyOwner(message.to);\n          if (userURL) {\n            (function () {\n\n              var chatKeys = _this.chatKeys[message.to + '<->' + message.from];\n              if (!chatKeys) {\n                chatKeys = _this._newChatCrypto(message, userURL, 'decrypt');\n                _this.chatKeys[message.to + '<->' + message.from] = chatKeys;\n              }\n\n              if (chatKeys.authenticated && !isHandShakeType) {\n                (function () {\n                  var value = JSON.parse(message.body.value);\n                  var iv = _this.crypto.decode(value.iv);\n                  var data = _this.crypto.decode(value.value);\n                  var hash = _this.crypto.decode(value.hash);\n                  _this.crypto.decryptAES(chatKeys.keys.hypertyToSessionKey, data, iv).then(function (decryptedData) {\n                    console.log('decrypted value ', decryptedData);\n                    message.body.value = decryptedData;\n\n                    var filteredMessage = _this._filterMessageToHash(message, decryptedData + iv);\n\n                    _this.crypto.verifyHMAC(chatKeys.keys.hypertyToHashKey, filteredMessage, hash).then(function (result) {\n                      //console.log('result of hash verification! ', result);\n                      message.body.assertedIdentity = true;\n                      resolve(message);\n                    });\n                  });\n                })();\n              } else if (isHandShakeType) {\n                _this._doHandShakePhase(message, chatKeys).then(function (value) {\n\n                  //if it was started by doMutualAuthentication then ends the protocol\n                  if (value === 'handShakeEnd') {\n                    reject('decrypt handshake protocol phase ');\n\n                    // if was started by a message, then resend that message\n                  } else {\n                    _this.chatKeys[message.to + '<->' + message.from] = value.chatKeys;\n                    _this._messageBus.postMessage(value.message);\n                    reject('decrypt handshake protocol phase ');\n                  }\n                });\n              } else {\n                reject('wrong message do decrypt');\n              }\n            })();\n          } else {\n            reject('error on decrypt message');\n          }\n\n          //if from hyperty to a dataObjectURL\n        } else if (isFromHyperty && isToDataObject) {\n          (function () {\n            console.log('dataObject value to decrypt: ', message.body);\n\n            var dataObjectKey = _this.dataObjectSessionKeys[dataObjectURL];\n\n            if (dataObjectKey) {\n\n              //check if is to apply encryption\n              if (dataObjectKey.isToEncrypt) {\n                (function () {\n                  var parsedValue = JSON.parse(message.body.value);\n                  var iv = _this.crypto.decode(parsedValue.iv);\n                  var encryptedValue = _this.crypto.decode(parsedValue.value);\n                  var hash = _this.crypto.decode(parsedValue.hash);\n\n                  _this.crypto.decryptAES(dataObjectKey.sessionKey, encryptedValue, iv).then(function (decryptedValue) {\n                    var parsedValue = JSON.parse(atob(decryptedValue));\n                    console.log('decrypted Value,', parsedValue);\n                    message.body.value = parsedValue;\n\n                    var filteredMessage = _this._filterMessageToHash(message, parsedValue + iv);\n\n                    _this.crypto.verifyHMAC(dataObjectKey.sessionKey, filteredMessage, hash).then(function (result) {\n                      //console.log('result of hash verification! ', result);\n\n                      message.body.assertedIdentity = true;\n                      resolve(message);\n                    });\n                  });\n\n                  //if not, just return the message\n                })();\n              } else {\n                message.body.assertedIdentity = true;\n                resolve(message);\n              }\n            } else {\n              message.body.assertedIdentity = true;\n              resolve(message);\n\n              //reject('no sessionKey for chat room found');\n            }\n          })();\n        } else {\n          reject('wrong message to decrypt');\n        }\n      });\n    }\n  }, {\n    key: 'doMutualAuthentication',\n    value: function doMutualAuthentication(sender, receiver) {\n      console.log('doMutualAuthentication: ', sender, receiver);\n      var _this = this;\n      var dataObjectURL = void 0;\n\n      // check if the sender is a dataObject and if so stores that value\n      var reporterURL = _this.registry.getReporterURLSynchonous(sender);\n      if (reporterURL) {\n        dataObjectURL = sender;\n        sender = reporterURL;\n      }\n\n      var msg = {\n        to: receiver,\n        from: sender,\n        callback: undefined,\n        body: { handshakePhase: 'startHandShake', ignore: 'ignoreMessage' }\n      };\n\n      return new _promise2.default(function (resolve, reject) {\n\n        if (!sender || !receiver) {\n          return reject('sender or receiver missing on doMutualAuthentication');\n        }\n\n        var chatKeys = _this.chatKeys[sender + '<->' + receiver];\n        var userURL = _this._registry.getHypertyOwner(sender);\n\n        if (userURL) {\n\n          if (!chatKeys) {\n            // callback to resolve when finish the mutual authentication\n            var resolved = function resolved(value) {\n              console.log('callback value:', value);\n              resolve(value);\n            };\n            msg.callback = resolved;\n            msg.dataObjectURL = dataObjectURL;\n\n            chatKeys = _this._newChatCrypto(msg, userURL);\n            _this.chatKeys[sender + '<->' + receiver] = chatKeys;\n          }\n\n          if (chatKeys.authenticated) {\n\n            var startSessionKeyExchange = {\n              to: sender,\n              from: receiver\n            };\n            chatKeys.dataObjectURL = dataObjectURL;\n            _this._sendReporterSessionKey(startSessionKeyExchange, chatKeys).then(function (value) {\n\n              _this._messageBus.postMessage(value.message);\n              resolve('exchange of chat sessionKey initiated');\n            });\n          } else {\n\n            _this._doHandShakePhase(msg, chatKeys);\n          }\n        } else {\n          reject('error on doMutualAuthentication');\n        }\n      });\n    }\n  }, {\n    key: '_doHandShakePhase',\n    value: function _doHandShakePhase(message, chatKeys) {\n      var _this = this;\n\n      //console.log('handshakeType');\n\n      return new _promise2.default(function (resolve, reject) {\n\n        var handshakeType = message.body.handshakePhase;\n        var iv = void 0;\n        var hash = void 0;\n        var value = {};\n        var filteredMessage = void 0;\n\n        (function () {\n          switch (handshakeType) {\n\n            case 'startHandShake':\n              chatKeys.keys.fromRandom = _this.crypto.generateRandom();\n\n              var startHandShakeMsg = {\n                type: 'handshake',\n                to: message.to,\n                from: message.from,\n                body: {\n                  handshakePhase: 'senderHello',\n                  value: _this.crypto.encode(chatKeys.keys.fromRandom)\n                }\n              };\n              chatKeys.handshakeHistory.senderHello = _this._filterMessageToHash(startHandShakeMsg, undefined, chatKeys.hypertyFrom.messageInfo);\n\n              // check if was the encrypt function or the mutual authentication that request the\n              // start of the handShakePhase.\n              if (chatKeys.initialMessage) {\n                resolve({ message: startHandShakeMsg, chatKeys: chatKeys });\n              } else {\n                _this.chatKeys[message.from + '<->' + message.to] = chatKeys;\n                _this._messageBus.postMessage(startHandShakeMsg);\n              }\n\n              break;\n            case 'senderHello':\n\n              console.log('senderHello');\n              chatKeys.handshakeHistory.senderHello = _this._filterMessageToHash(message);\n              chatKeys.keys.fromRandom = _this.crypto.decode(message.body.value);\n              chatKeys.keys.toRandom = _this.crypto.generateRandom();\n\n              var senderHelloMsg = {\n                type: 'handshake',\n                to: message.from,\n                from: message.to,\n                body: {\n                  handshakePhase: 'receiverHello',\n                  value: _this.crypto.encode(chatKeys.keys.toRandom)\n                }\n              };\n              chatKeys.handshakeHistory.receiverHello = _this._filterMessageToHash(senderHelloMsg, undefined, chatKeys.hypertyFrom.messageInfo);\n              resolve({ message: senderHelloMsg, chatKeys: chatKeys });\n\n              break;\n            case 'receiverHello':\n\n              console.log('receiverHello');\n              chatKeys.handshakeHistory.receiverHello = _this._filterMessageToHash(message);\n\n              _this.validateAssertion(message.body.identity.assertion, undefined, message.body.identity.idp).then(function (value) {\n\n                //TODO remove later this verification as soon as all the IdP proxy are updated in the example\n                var encodedpublicKey = typeof value.contents === 'string' ? value.contents : value.contents.nonce;\n\n                var receiverPublicKey = _this.crypto.decode(encodedpublicKey);\n                var premasterSecret = _this.crypto.generatePMS();\n                var toRandom = message.body.value;\n                chatKeys.hypertyTo.assertion = message.body.identity.assertion;\n                chatKeys.hypertyTo.publicKey = receiverPublicKey;\n                chatKeys.hypertyTo.userID = value.contents.email;\n                chatKeys.keys.toRandom = _this.crypto.decode(toRandom);\n                chatKeys.keys.premasterKey = premasterSecret;\n\n                var concatKey = _this.crypto.concatPMSwithRandoms(premasterSecret, chatKeys.keys.toRandom, chatKeys.keys.fromRandom);\n\n                return _this.crypto.generateMasterSecret(concatKey, 'messageHistoric' + chatKeys.keys.toRandom + chatKeys.keys.fromRandom);\n\n                //generate the master key\n              }).then(function (masterKey) {\n                chatKeys.keys.masterKey = masterKey;\n\n                return _this.crypto.generateKeys(masterKey, 'key expansion' + chatKeys.keys.toRandom + chatKeys.keys.fromRandom);\n\n                //generate the symmetric and hash keys\n              }).then(function (keys) {\n\n                chatKeys.keys.hypertyToSessionKey = new Uint8Array(keys[0]);\n                chatKeys.keys.hypertyFromSessionKey = new Uint8Array(keys[1]);\n                chatKeys.keys.hypertyToHashKey = new Uint8Array(keys[2]);\n                chatKeys.keys.hypertyFromHashKey = new Uint8Array(keys[3]);\n                iv = _this.crypto.generateIV();\n                value.iv = _this.crypto.encode(iv);\n\n                var messageStructure = {\n                  type: 'handshake',\n                  to: message.from,\n                  from: message.to,\n                  body: {\n                    handshakePhase: 'senderCertificate'\n                  }\n                };\n\n                // hash the value and the iv\n                filteredMessage = _this._filterMessageToHash(messageStructure, 'ok' + iv, chatKeys.hypertyFrom.messageInfo);\n                return _this.crypto.hashHMAC(chatKeys.keys.hypertyFromHashKey, filteredMessage);\n              }).then(function (hash) {\n                value.hash = _this.crypto.encode(hash);\n\n                //encrypt the data\n                return _this.crypto.encryptAES(chatKeys.keys.hypertyFromSessionKey, 'ok', iv);\n              }).then(function (encryptedData) {\n                value.symetricEncryption = _this.crypto.encode(encryptedData);\n\n                return _this.crypto.encryptRSA(chatKeys.hypertyTo.publicKey, chatKeys.keys.premasterKey);\n              }).then(function (encryptedValue) {\n\n                value.assymetricEncryption = _this.crypto.encode(encryptedValue);\n\n                var messageStructure = {\n                  type: 'handshake',\n                  to: message.from,\n                  from: message.to,\n                  body: {\n                    handshakePhase: 'senderCertificate'\n                  }\n                };\n\n                var messageToHash = _this._filterMessageToHash(messageStructure, chatKeys.keys.premasterKey, chatKeys.hypertyFrom.messageInfo);\n\n                return _this.crypto.signRSA(chatKeys.hypertyFrom.privateKey, (0, _stringify2.default)(chatKeys.handshakeHistory) + (0, _stringify2.default)(messageToHash));\n              }).then(function (signature) {\n\n                value.signature = _this.crypto.encode(signature);\n\n                var receiverHelloMsg = {\n                  type: 'handshake',\n                  to: message.from,\n                  from: message.to,\n                  body: {\n                    handshakePhase: 'senderCertificate',\n                    value: btoa((0, _stringify2.default)(value))\n                  }\n                };\n                chatKeys.handshakeHistory.senderCertificate = _this._filterMessageToHash(receiverHelloMsg, 'ok' + iv, chatKeys.hypertyFrom.messageInfo);\n\n                resolve({ message: receiverHelloMsg, chatKeys: chatKeys });\n              }, function (error) {\n                return reject(error);\n              });\n\n              break;\n            case 'senderCertificate':\n\n              console.log('senderCertificate');\n              var receivedValue = JSON.parse(atob(message.body.value));\n\n              _this.validateAssertion(message.body.identity.assertion, undefined, message.body.identity.idp).then(function (value) {\n                var encryptedPMS = _this.crypto.decode(receivedValue.assymetricEncryption);\n\n                //TODO remove later this verification as soon as all the IdP proxy are updated in the example\n                var encodedpublicKey = typeof value.contents === 'string' ? value.contents : value.contents.nonce;\n\n                var senderPublicKey = _this.crypto.decode(encodedpublicKey);\n                chatKeys.hypertyTo.assertion = message.body.identity.assertion;\n                chatKeys.hypertyTo.publicKey = senderPublicKey;\n                chatKeys.hypertyTo.userID = value.contents.email;\n\n                return _this.crypto.decryptRSA(chatKeys.hypertyFrom.privateKey, encryptedPMS);\n              }, function (error) {\n                console.log(error);\n                reject('Error during authentication of identity');\n\n                //obtain the PremasterKey using the private key\n              }).then(function (pms) {\n\n                chatKeys.keys.premasterKey = new Uint8Array(pms);\n\n                var signature = _this.crypto.decode(receivedValue.signature);\n\n                var receivedmsgToHash = _this._filterMessageToHash(message, chatKeys.keys.premasterKey);\n\n                return _this.crypto.verifyRSA(chatKeys.hypertyTo.publicKey, (0, _stringify2.default)(chatKeys.handshakeHistory) + (0, _stringify2.default)(receivedmsgToHash), signature);\n\n                // validates the signature received\n              }).then(function (signValidationResult) {\n\n                console.log('signature validation result ', signValidationResult);\n                var concatKey = _this.crypto.concatPMSwithRandoms(chatKeys.keys.premasterKey, chatKeys.keys.toRandom, chatKeys.keys.fromRandom);\n\n                return _this.crypto.generateMasterSecret(concatKey, 'messageHistoric' + chatKeys.keys.toRandom + chatKeys.keys.fromRandom);\n\n                // generates the master keys from the Premaster key and the randoms\n              }).then(function (masterKey) {\n                chatKeys.keys.masterKey = masterKey;\n\n                return _this.crypto.generateKeys(masterKey, 'key expansion' + chatKeys.keys.toRandom + chatKeys.keys.fromRandom);\n\n                // generates the symmetric keys to be used in the symmetric encryption\n              }).then(function (keys) {\n                chatKeys.keys.hypertyFromSessionKey = new Uint8Array(keys[0]);\n                chatKeys.keys.hypertyToSessionKey = new Uint8Array(keys[1]);\n                chatKeys.keys.hypertyFromHashKey = new Uint8Array(keys[2]);\n                chatKeys.keys.hypertyToHashKey = new Uint8Array(keys[3]);\n                iv = _this.crypto.decode(receivedValue.iv);\n                var data = _this.crypto.decode(receivedValue.symetricEncryption);\n\n                return _this.crypto.decryptAES(chatKeys.keys.hypertyToSessionKey, data, iv);\n              }).then(function (decryptedData) {\n                //console.log('decryptedData', decryptedData);\n\n                chatKeys.handshakeHistory.senderCertificate = _this._filterMessageToHash(message, decryptedData + iv);\n\n                var hashReceived = _this.crypto.decode(receivedValue.hash);\n\n                filteredMessage = _this._filterMessageToHash(message, decryptedData + iv);\n\n                return _this.crypto.verifyHMAC(chatKeys.keys.hypertyToHashKey, filteredMessage, hashReceived);\n              }).then(function (verifiedHash) {\n\n                //console.log('result of hash verification ', verifiedHash);\n                var receiverFinishedMessage = {\n                  type: 'handshake',\n                  to: message.from,\n                  from: message.to,\n                  body: {\n                    handshakePhase: 'receiverFinishedMessage'\n                  }\n                };\n                iv = _this.crypto.generateIV();\n                value.iv = _this.crypto.encode(iv);\n\n                filteredMessage = _this._filterMessageToHash(receiverFinishedMessage, 'ok!' + iv, chatKeys.hypertyFrom.messageInfo);\n\n                return _this.crypto.hashHMAC(chatKeys.keys.hypertyFromHashKey, receiverFinishedMessage);\n              }).then(function (hash) {\n\n                value.hash = _this.crypto.encode(hash);\n                return _this.crypto.encryptAES(chatKeys.keys.hypertyFromSessionKey, 'ok!', iv);\n              }).then(function (encryptedValue) {\n                value.value = _this.crypto.encode(encryptedValue);\n                var receiverFinishedMessage = {\n                  type: 'handshake',\n                  to: message.from,\n                  from: message.to,\n                  body: {\n                    handshakePhase: 'receiverFinishedMessage',\n                    value: btoa((0, _stringify2.default)(value))\n                  }\n                };\n\n                chatKeys.handshakeHistory.receiverFinishedMessage = _this._filterMessageToHash(receiverFinishedMessage, 'ok!' + iv, chatKeys.hypertyFrom.messageInfo);\n                chatKeys.authenticated = true;\n                resolve({ message: receiverFinishedMessage, chatKeys: chatKeys });\n              });\n\n              break;\n            case 'receiverFinishedMessage':\n\n              console.log('receiverFinishedMessage');\n              chatKeys.authenticated = true;\n\n              value = JSON.parse(atob(message.body.value));\n\n              iv = _this.crypto.decode(value.iv);\n              var data = _this.crypto.decode(value.value);\n              hash = _this.crypto.decode(value.hash);\n\n              _this.crypto.decryptAES(chatKeys.keys.hypertyToSessionKey, data, iv).then(function (decryptedData) {\n                console.log('decryptedData', decryptedData);\n                chatKeys.handshakeHistory.receiverFinishedMessage = _this._filterMessageToHash(message, decryptedData + iv);\n\n                var filteredMessage = _this._filterMessageToHash(message, data + iv);\n                _this.crypto.verifyHMAC(chatKeys.keys.hypertyToHashKey, filteredMessage, hash).then(function (result) {\n                  console.log('hash result', result);\n\n                  // check if there was an initial message that was blocked and send it\n                  if (chatKeys.initialMessage) {\n                    var initialMessage = {\n                      type: 'create',\n                      to: message.from,\n                      from: message.to,\n                      body: {\n                        value: chatKeys.initialMessage.body.value\n                      }\n                    };\n\n                    resolve({ message: initialMessage, chatKeys: chatKeys });\n\n                    //sends the sessionKey to the subscriber hyperty\n                  } else {\n                    _this._sendReporterSessionKey(message, chatKeys).then(function (value) {\n                      resolve(value);\n                    });\n                  }\n                });\n              });\n\n              break;\n            case 'reporterSessionKey':\n\n              console.log('reporterSessionKey');\n\n              var valueIVandHash = JSON.parse(atob(message.body.value));\n              hash = _this.crypto.decode(valueIVandHash.hash);\n              iv = _this.crypto.decode(valueIVandHash.iv);\n              var encryptedValue = _this.crypto.decode(valueIVandHash.value);\n              var parsedValue = void 0;\n              var sessionKey = void 0;\n              var dataObjectURL = void 0;\n              var receiverAcknowledgeMsg = void 0;\n\n              console.log('[reporterSessionKey] - decryptAES: ', chatKeys.keys.hypertyToSessionKey, encryptedValue, iv);\n\n              _this.crypto.decryptAES(chatKeys.keys.hypertyToSessionKey, encryptedValue, iv).then(function (decryptedValue) {\n\n                parsedValue = JSON.parse(decryptedValue);\n                sessionKey = _this.crypto.decode(parsedValue.value);\n                dataObjectURL = parsedValue.dataObjectURL;\n\n                var messageToHash = _this._filterMessageToHash(message, decryptedValue + iv);\n\n                return _this.crypto.verifyHMAC(chatKeys.keys.hypertyToHashKey, messageToHash, hash);\n              }).then(function (hashResult) {\n\n                //console.log('hash successfully validated ', hashResult);\n\n                _this.dataObjectSessionKeys[dataObjectURL] = { sessionKey: sessionKey, isToEncrypt: true };\n\n                iv = _this.crypto.generateIV();\n                value.iv = _this.crypto.encode(iv);\n\n                return _this.crypto.encryptAES(chatKeys.keys.hypertyFromSessionKey, 'ok!!', iv);\n              }).then(function (encryptedValue) {\n\n                receiverAcknowledgeMsg = {\n                  type: 'handshake',\n                  to: message.from,\n                  from: message.to,\n                  body: {\n                    handshakePhase: 'receiverAcknowledge'\n                  }\n                };\n\n                value.value = _this.crypto.encode(encryptedValue);\n                var messageToHash = _this._filterMessageToHash(receiverAcknowledgeMsg, 'ok!!' + iv, chatKeys.hypertyFrom.messageInfo);\n\n                return _this.crypto.hashHMAC(chatKeys.keys.hypertyFromHashKey, messageToHash);\n              }).then(function (hashedMessage) {\n                var finalValue = btoa((0, _stringify2.default)({ value: value.value, hash: _this.crypto.encode(hashedMessage), iv: value.iv }));\n\n                receiverAcknowledgeMsg.body.value = finalValue;\n                resolve({ message: receiverAcknowledgeMsg, chatKeys: chatKeys });\n              });\n\n              break;\n            case 'receiverAcknowledge':\n\n              console.log('receiverAcknowledge');\n\n              var receivedvalueIVandHash = JSON.parse(atob(message.body.value));\n              var receivedHash = _this.crypto.decode(receivedvalueIVandHash.hash);\n              iv = _this.crypto.decode(receivedvalueIVandHash.iv);\n              var receivedEncryptedValue = _this.crypto.decode(receivedvalueIVandHash.value);\n\n              _this.crypto.decryptAES(chatKeys.keys.hypertyToSessionKey, receivedEncryptedValue, iv).then(function (decryptedValue) {\n\n                var filteredMessage = _this._filterMessageToHash(message, decryptedValue + iv);\n                return _this.crypto.verifyHMAC(chatKeys.keys.hypertyToHashKey, filteredMessage, receivedHash);\n              }).then(function (hashResult) {\n                //console.log('hashResult ', hashResult);\n\n                var callback = chatKeys.callback;\n\n                if (callback) {\n                  callback('handShakeEnd');\n                }\n                resolve('handShakeEnd');\n              });\n\n              break;\n            default:\n              reject(message);\n          }\n        })();\n      });\n    }\n  }, {\n    key: '_sendReporterSessionKey',\n    value: function _sendReporterSessionKey(message, chatKeys) {\n      var _this = this;\n      var sessionKeyBundle = _this.dataObjectSessionKeys[chatKeys.dataObjectURL];\n      var reporterSessionKeyMsg = void 0;\n      var valueToEncrypt = void 0;\n      var sessionKey = void 0;\n      var iv = void 0;\n      var value = {};\n\n      return new _promise2.default(function (resolve, reject) {\n\n        //if there is not yet a session Key, generates a new one\n        if (!sessionKeyBundle) {\n          sessionKey = _this.crypto.generateRandom();\n          _this.dataObjectSessionKeys[chatKeys.dataObjectURL] = { sessionKey: sessionKey, isToEncrypt: true };\n        } else {\n          sessionKey = sessionKeyBundle.sessionKey;\n        }\n\n        valueToEncrypt = (0, _stringify2.default)({ value: _this.crypto.encode(sessionKey), dataObjectURL: chatKeys.dataObjectURL });\n\n        iv = _this.crypto.generateIV();\n        value.iv = _this.crypto.encode(iv);\n        _this.crypto.encryptAES(chatKeys.keys.hypertyFromSessionKey, valueToEncrypt, iv).then(function (encryptedValue) {\n\n          reporterSessionKeyMsg = {\n            type: 'handshake',\n            to: message.from,\n            from: message.to,\n            body: {\n              handshakePhase: 'reporterSessionKey',\n              value: _this.crypto.encode(encryptedValue)\n            }\n          };\n\n          var filteredMessage = _this._filterMessageToHash(reporterSessionKeyMsg, valueToEncrypt + iv, chatKeys.hypertyFrom.messageInfo);\n\n          return _this.crypto.hashHMAC(chatKeys.keys.hypertyFromHashKey, filteredMessage);\n        }).then(function (hashedMessage) {\n\n          var valueWithHash = btoa((0, _stringify2.default)({ value: reporterSessionKeyMsg.body.value, hash: _this.crypto.encode(hashedMessage), iv: value.iv }));\n\n          reporterSessionKeyMsg.body.value = valueWithHash;\n          resolve({ message: reporterSessionKeyMsg, chatKeys: chatKeys });\n        });\n      });\n    }\n\n    /**\n    * returns the reporter associated to the dataObject URL\n    * @param   {String}   dataObjectURL         dataObject url\n    * @return   {String}  reporter              dataObject url reporter\n    */\n\n  }, {\n    key: '_getHypertyFromDataObject',\n    value: function _getHypertyFromDataObject(dataObjectURL) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n\n        //TODO remove this logic and move it to a util function\n\n        var splitedURL = dataObjectURL.split('/');\n        var finalURL = splitedURL[0] + '//' + splitedURL[2] + '/' + splitedURL[3];\n        if (splitedURL.length > 6) {\n          finalURL = splitedURL[0] + '//' + splitedURL[2] + '/' + splitedURL[3] + '/' + splitedURL[4];\n        }\n\n        // check if is the creator of the hyperty\n        var reporterURL = _this.registry.getReporterURLSynchonous(finalURL);\n\n        if (reporterURL) {\n          resolve(reporterURL);\n        } else {\n          // check if there is already an association from an hypertyURL to the dataObject\n          var storedReporterURL = _this.dataObjectsIdentity[finalURL];\n\n          if (storedReporterURL) {\n            resolve(storedReporterURL);\n          } else {\n            // check if there is any hyperty that subscribed the dataObjectURL\n            var subscriberHyperty = _this.registry.getDataObjectSubscriberHyperty(dataObjectURL);\n\n            if (subscriberHyperty) {\n              resolve(subscriberHyperty);\n            } else {\n\n              // search in domain registry for the hyperty associated to the dataObject\n              // search in case is a subscriber who wants to know the reporter\n              _this.registry.discoverDataObjectPerURL(finalURL, splitedURL[2]).then(function (dataObject) {\n                _this.dataObjectsIdentity[finalURL] = dataObject.reporter;\n                resolve(dataObject.reporter);\n              }, function (err) {\n                reject(err);\n              });\n            }\n          }\n        }\n      });\n    }\n\n    /**\n    * filter the messages to hash, by removing some fields not generated by the runtime core\n    * @param {Message}  message                     message\n    * @param {String}  decryptedValue (Optional)    value from body.value in case it originally comes encrypted\n    * @param {JSON}  identity(Optional)    add the hyperty identity associated in case is not added to the initial message\n    * @return {Message}  new message filtered\n    */\n\n  }, {\n    key: '_filterMessageToHash',\n    value: function _filterMessageToHash(message, decryptedValue, identity) {\n\n      return {\n        type: message.type,\n        from: message.from,\n        to: message.to,\n        body: {\n          identity: identity || message.body.identity,\n          value: decryptedValue || message.body.value,\n          handshakePhase: message.body.handshakePhase\n        }\n      };\n    }\n\n    /**\n    * generates the initial structure for the keys between two users\n    * @param {JSON}    message              initial message that triggers the mutual authentication\n    * @param {String}  userURL              userURL\n    * @param {boolean} receiver(Optional)  indicates if is the sender or the receiver that creates a new chat crypto\n    * @return {JSON} newChatCrypto  new JSON structure for the chat crypto\n    */\n\n  }, {\n    key: '_newChatCrypto',\n    value: function _newChatCrypto(message, userURL, receiver) {\n      var _this = this;\n\n      //check whether is the sender or the receiver to create a new chatCrypto\n      //to mantain consistency on the keys if the receiver create a new chatCrypto,\n      //then invert the fields\n      var from = receiver ? message.to : message.from;\n      var to = receiver ? message.from : message.to;\n\n      var userInfo = _this.getIdentity(userURL);\n\n      var newChatCrypto = {\n        hypertyFrom: {\n          hyperty: from,\n          userID: userInfo.messageInfo.userProfile.username,\n          privateKey: userInfo.keyPair.private,\n          publicKey: userInfo.keyPair.public,\n          assertion: userInfo.assertion,\n          messageInfo: userInfo.messageInfo\n        },\n        hypertyTo: {\n          hyperty: to,\n          userID: undefined,\n          publicKey: undefined,\n          assertion: undefined\n        },\n        keys: {\n          hypertyToSessionKey: undefined,\n          hypertyFromSessionKey: undefined,\n          hypertyToHashKey: undefined,\n          hypertyFromHashKey: undefined,\n          toRandom: undefined,\n          fromRandom: undefined,\n          premasterKey: undefined,\n          masterKey: undefined\n        },\n        handshakeHistory: {\n          senderHello: undefined,\n          receiverHello: undefined,\n          senderCertificate: undefined,\n          receiverFinishedMessage: undefined\n        },\n        initialMessage: message.body.ignore ? undefined : message,\n        callback: message.callback,\n        authenticated: false,\n        dataObjectURL: message.dataObjectURL\n      };\n\n      return newChatCrypto;\n    }\n  }, {\n    key: 'messageBus',\n    get: function get() {\n      var _this = this;\n      return _this._messageBus;\n    }\n\n    /**\n    * Set the messageBus in this Registry\n    * @param {MessageBus}           messageBus\n    */\n    ,\n    set: function set(messageBus) {\n      var _this = this;\n      _this._messageBus = messageBus;\n    }\n\n    /**\n    * return the registry in this idModule\n    * @param {registry}           registry\n    */\n\n  }, {\n    key: 'registry',\n    get: function get() {\n      var _this = this;\n      return _this._registry;\n    }\n\n    /**\n    * Set the registry in this idModule\n    * @param {registry}     reg\n    */\n    ,\n    set: function set(registry) {\n      var _this = this;\n      _this._registry = registry;\n    }\n  }]);\n  return IdentityModule;\n}();\n\nexports.default = IdentityModule;\nmodule.exports = exports['default'];\n\n},{\"../utils/utils.js\":457,\"./Crypto\":425,\"./GuiFake\":426,\"./Identity\":427,\"babel-runtime/core-js/json/stringify\":3,\"babel-runtime/core-js/promise\":12,\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16}],429:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ActionsService = function () {\n  function ActionsService(context) {\n    (0, _classCallCheck3.default)(this, ActionsService);\n\n    this.context = context;\n  }\n\n  (0, _createClass3.default)(ActionsService, [{\n    key: 'enforcePolicies',\n    value: function enforcePolicies(message, isIncomingMessage) {\n      var _this = this;\n      return new _promise2.default(function (resolve, reject) {\n\n        var policies = _this.context.getPolicies(message, isIncomingMessage);\n\n        if (policies !== undefined) {\n          if (policies.serviceProviderPolicy !== undefined) {\n            policies.serviceProviderPolicy.enforceActions(_this.context, message).then(function (messages) {\n              resolve(messages);\n            }, function (error) {\n              reject(error);\n            });\n          } else {\n            if (policies.userPolicy !== undefined) {\n              policies.userPolicy.enforceActions(_this.context, message).then(function (messages) {\n                resolve(messages);\n              }, function (error) {\n                reject(error);\n              });\n            } else {\n              resolve([message]);\n            }\n          }\n        } else {\n          resolve([message]);\n        }\n      });\n    }\n  }, {\n    key: 'forwardToID',\n    value: function forwardToID(message, email) {\n      var _this = this;\n      if (!_this.context.runtimeRegistry) throw new Error('forward message to given ID is unsupported in this environment');\n\n      return new _promise2.default(function (resolve, reject) {\n        if (_this.context.runtimeRegistry.hypertiesList[0].hypertyURL === message.to) {\n          var splitTo = message.to.split('://');\n          if (splitTo[0] !== 'runtime') {\n            _this.context.runtimeRegistry.discoverHypertyPerUser(email).then(function (result) {\n              message.to = result.hypertyURL;\n              message.body.via = undefined;\n              resolve(message);\n              _this.context.runtimeRegistry._messageBus.postMessage(message);\n            }, function (error) {\n              reject(error);\n            });\n          } else {\n            resolve(message);\n          }\n        } else {\n          resolve(message);\n        }\n      });\n    }\n  }, {\n    key: 'forwardToHyperty',\n    value: function forwardToHyperty(message, hypertyURL) {\n      var _this = this;\n      if (!_this.context.runtimeRegistry) throw new Error('forward message to given ID is unsupported in this environment');\n\n      return new _promise2.default(function (resolve) {\n        if (_this.context.runtimeRegistry.hypertiesList[0].hypertyURL === message.to) {\n          var splitTo = message.to.split('://');\n          if (splitTo[0] !== 'runtime') {\n            message.to = hypertyURL;\n            message.body.via = undefined;\n            resolve(message);\n            _this.context.runtimeRegistry._messageBus.postMessage(message);\n          } else {\n            resolve(message);\n          }\n        } else {\n          resolve(message);\n        }\n      });\n    }\n  }, {\n    key: 'sendAutomaticMessage',\n    value: function sendAutomaticMessage(message, text) {\n      var _this = this;\n      return new _promise2.default(function (resolve) {\n        var automaticMessage = {\n          from: message.to,\n          to: message.from,\n          body: {\n            value: text\n          },\n          type: message.type\n        };\n        resolve(message);\n        _this.context.runtimeRegistry._messageBus.postMessage(automaticMessage);\n      });\n    }\n  }]);\n  return ActionsService;\n}();\n\nexports.default = ActionsService;\nmodule.exports = exports['default'];\n\n},{\"babel-runtime/core-js/promise\":12,\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16}],430:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Operators = function () {\n  function Operators() {\n    (0, _classCallCheck3.default)(this, Operators);\n  }\n\n  (0, _createClass3.default)(Operators, [{\n    key: 'and',\n    value: function and(params) {\n      return params[0] && params[1];\n    }\n  }, {\n    key: 'between',\n    value: function between(params) {\n      var start = parseInt(params[0][0]);\n      var end = parseInt(params[0][1]);\n      var now = params[1];\n\n      if (end < start) {\n        now = now < start ? now += 2400 : now;\n        end += 2400;\n      }\n\n      return now > start && now < end;\n    }\n  }, {\n    key: 'equals',\n    value: function equals(params) {\n      return String(params[0]) === '*' || String(params[0]) === String(params[1]);\n    }\n  }, {\n    key: 'greaterThan',\n    value: function greaterThan(params) {\n      return params[1] > params[0];\n    }\n  }, {\n    key: 'in',\n    value: function _in(params) {\n      return params[0].indexOf(params[1]) > -1;\n    }\n  }, {\n    key: 'lessThan',\n    value: function lessThan(params) {\n      return params[1] < params[0];\n    }\n  }, {\n    key: 'not',\n    value: function not(params) {\n      return !params[0];\n    }\n  }, {\n    key: 'or',\n    value: function or(params) {\n      return params[0] || params[1];\n    }\n  }]);\n  return Operators;\n}();\n\nexports.default = Operators;\nmodule.exports = exports['default'];\n\n},{\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16}],431:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _Operators = require('./Operators');\n\nvar _Operators2 = _interopRequireDefault(_Operators);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n* The Policy Decision Point (PDP) decides if a message is to be authorised by checking a set of\n* policies. The resource to be verified is specified in the first word of the 'condition' field of\n* a Policy object. The implementation that verifies if the message is compliant with a policy is\n* specified in a hashtable to allow dynamic definition of the implementation, providing\n* extensibility to the Policy Engine functionalities.\n*/\nvar PDP = function () {\n  function PDP(context) {\n    (0, _classCallCheck3.default)(this, PDP);\n\n    this.context = context;\n    this.operators = new _Operators2.default();\n  }\n\n  (0, _createClass3.default)(PDP, [{\n    key: 'evaluatePolicies',\n    value: function evaluatePolicies(message, isIncomingMessage) {\n      var policies = this.context.getPolicies(message, isIncomingMessage);\n      var result = 'Not Applicable';\n\n      if (policies !== undefined) {\n        result = this.evaluatePolicy(message, policies.serviceProviderPolicy, isIncomingMessage);\n        if (result || result === 'Not Applicable') {\n          var userResult = this.evaluatePolicy(message, policies.userPolicy, isIncomingMessage);\n          if (userResult !== 'Not Applicable') {\n            result = userResult;\n          }\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: 'evaluatePolicy',\n    value: function evaluatePolicy(message, policy, isIncoming) {\n      var result = 'Not Applicable';\n      if (policy) {\n        result = policy.evaluateRules(this.context, message, isIncoming);\n      }\n\n      return result;\n    }\n  }]);\n  return PDP;\n}();\n\nexports.default = PDP;\nmodule.exports = exports['default'];\n\n},{\"./Operators\":430,\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16}],432:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _ActionsService = require('./ActionsService');\n\nvar _ActionsService2 = _interopRequireDefault(_ActionsService);\n\nvar _PDP = require('./PDP');\n\nvar _PDP2 = _interopRequireDefault(_PDP);\n\nvar _Policy = require('./Policy');\n\nvar _Policy2 = _interopRequireDefault(_Policy);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar PEP = function () {\n\n  /**\n  * Creates a Policy Enforcement Point (PEP) instance\n  * @param    {Object}    context\n  */\n  function PEP(context) {\n    (0, _classCallCheck3.default)(this, PEP);\n\n    var _this = this;\n\n    _this.pdp = new _PDP2.default(context);\n    _this.actionsService = new _ActionsService2.default(context);\n    _this.context = context;\n    context.pep = _this;\n\n    //TODO should be added a trigger to verify when the loadConfigurations is successfully completed\n    context.loadConfigurations();\n  }\n\n  /**\n  * Adds a policy to the Policy Enforcement Point (PEP). The policy can be created by the service\n  * provider or by the user.\n  * @param    {String}    source\n  * @param    {String}    key\n  * @param    {Object}    policy\n  */\n\n\n  (0, _createClass3.default)(PEP, [{\n    key: 'addPolicy',\n    value: function addPolicy(source, key, policy, combiningAlgorithm) {\n      if (!source) throw new Error('source is not defined');\n      if (!key) throw new Error('key is not defined');\n\n      if (policy === undefined) {\n        policy = new _Policy2.default(key, [], [], combiningAlgorithm);\n      } else {\n        if (!(policy instanceof _Policy2.default)) {\n          policy = new _Policy2.default(policy.key, policy.rules, policy.actions, policy.combiningAlgorithm);\n        }\n      }\n\n      switch (source) {\n        case 'SERVICE_PROVIDER':\n          this.context.savePolicies(source, policy, key);\n          break;\n        case 'USER':\n          this.context.userPolicies[key] = policy;\n          this.context.savePolicies(source);\n          break;\n        default:\n          throw Error('Unknown policy source: ' + source);\n      }\n    }\n  }, {\n    key: 'authorise',\n    value: function authorise(message) {\n      var _this2 = this;\n\n      console.log('--- Policy Engine ---');\n      console.log(message);\n      if (!message) throw new Error('message is not defined');\n      if (!message.from) throw new Error('message.from is not defined');\n      if (!message.to) throw new Error('message.to is not defined');\n      if (!message.type) throw new Error('message.type is not defined');\n      message.body = message.body || {};\n\n      return new _promise2.default(function (resolve, reject) {\n\n        message.body = message.body || {};\n        var _this = _this2;\n        var result = void 0;\n        if (_this._isToVerify(message)) {\n          (function () {\n            var isIncoming = _this._isIncomingMessage(message);\n            _this.context.prepareForEvaluation(message, isIncoming).then(function (message) {\n              result = _this.pdp.evaluatePolicies(message, isIncoming);\n              if (result === 'Not Applicable') {\n                result = _this.context.defaultBehaviour;\n                message.body.auth = false;\n              }\n              _this.actionsService.enforcePolicies(message, isIncoming).then(function (messages) {\n                for (var i in messages) {\n                  message = messages[i];\n                  _this.context.prepareToForward(message, isIncoming, result).then(function (message) {\n                    if (result) {\n                      message.body.auth = message.body.auth === undefined ? true : message.body.auth;\n                      resolve(message);\n                    } else {\n                      var errorMessage = { body: { code: 403, description: 'Blocked by policy' }, from: message.to, to: message.from, type: 'response' };\n                      reject(errorMessage);\n                    }\n                  }, function (error) {\n                    reject(error);\n                  });\n                }\n              }, function (error) {\n                reject(error);\n              });\n            }, function (error) {\n              reject(error);\n            });\n          })();\n        } else {\n          result = _this.context.defaultBehaviour;\n          if (result) {\n            message.body.auth = false;\n            resolve(message);\n          } else {\n            var errorMessage = { body: { code: 403, description: 'Blocked by policy' }, from: message.to, to: message.from, type: 'response' };\n            reject(errorMessage);\n          }\n        }\n      });\n    }\n  }, {\n    key: 'authoriseSync',\n    value: function authoriseSync(message) {\n      var result = void 0;\n      message.body = message.body || {};\n      if (this._isToVerify(message)) {\n        var isIncoming = this._isIncomingMessage(message);\n        message = this.context.prepareForEvaluation(message, isIncoming);\n        result = this.pdp.evaluatePolicies(message, isIncoming);\n        if (result === 'Not Applicable') {\n          result = this.context.defaultBehaviour;\n          message.body.auth = false;\n        }\n        this.actionsService.enforcePolicies(message, isIncoming);\n        message = this.context.prepareToForward(message, isIncoming, result);\n        if (result) {\n          message.body.auth = message.body.auth === undefined ? true : message.body.auth;\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        result = this.context.defaultBehaviour;\n        if (result) {\n          message.body.auth = false;\n          return true;\n        } else {\n          return false;\n        }\n      }\n    }\n  }, {\n    key: '_isIncomingMessage',\n    value: function _isIncomingMessage(message) {\n      return message.body !== undefined && message.body.identity !== undefined ? true : false;\n    }\n\n    /**\n    * Identifies the messages to be verified by the Policy Engine\n    * @param    {Message}   message\n    * @returns  {boolean}   returns true if the message requires encryption/decryption\n    *                       or if its type equals 'handshake'; false otherwise\n    */\n\n  }, {\n    key: '_isToVerify',\n    value: function _isToVerify(message) {\n      var schemasToIgnore = ['domain', 'domain-idp', 'global', 'hyperty-runtime', 'runtime'];\n      var splitFrom = message.from.split('://');\n      var fromSchema = splitFrom[0];\n      var splitTo = message.to.split('://');\n      var toSchema = splitTo[0];\n\n      if (message.from === fromSchema || message.to === toSchema || message.type === 'read' || message.type === 'response') {\n        return false;\n      } else {\n        return schemasToIgnore.indexOf(fromSchema) === -1 || schemasToIgnore.indexOf(toSchema) === -1;\n      }\n    }\n  }, {\n    key: 'removePolicy',\n    value: function removePolicy(source, key) {\n      if (!source) throw new Error('source is not defined');\n      if (source !== '*' && !key) throw new Error('key is not defined');\n\n      switch (source) {\n        case '*':\n          this.context.serviceProviderPolicy = {};\n          this.context.userPolicies = {};\n          this.context.activeUserPolicy = undefined;\n          this.context.savePolicies('USER');\n          this.context.savePolicies('SERVICE_PROVIDER');\n          this.context.saveActivePolicy();\n          break;\n        case 'SERVICE_PROVIDER':\n          delete this.context.serviceProviderPolicy[key];\n          this.context.savePolicies();\n          break;\n        case 'USER':\n          delete this.context.userPolicies[key];\n          if (key === this.context.activeUserPolicy) {\n            this.context.activeUserPolicy = undefined;\n            this.context.saveActivePolicy();\n          }\n          this.context.savePolicies('USER');\n          break;\n        default:\n          throw Error('Unknown policy source: ' + source);\n      }\n    }\n  }]);\n  return PEP;\n}();\n\nexports.default = PEP;\nmodule.exports = exports['default'];\n\n},{\"./ActionsService\":429,\"./PDP\":431,\"./Policy\":433,\"babel-runtime/core-js/promise\":12,\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16}],433:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _AllowOverrides = require('./combiningAlgorithms/AllowOverrides');\n\nvar _AllowOverrides2 = _interopRequireDefault(_AllowOverrides);\n\nvar _BlockOverrides = require('./combiningAlgorithms/BlockOverrides');\n\nvar _BlockOverrides2 = _interopRequireDefault(_BlockOverrides);\n\nvar _FirstApplicable = require('./combiningAlgorithms/FirstApplicable');\n\nvar _FirstApplicable2 = _interopRequireDefault(_FirstApplicable);\n\nvar _Rule = require('./Rule');\n\nvar _Rule2 = _interopRequireDefault(_Rule);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Policy = function () {\n  function Policy(key, rules, actions, combiningAlgorithm) {\n    (0, _classCallCheck3.default)(this, Policy);\n\n    if (!key) throw new Error('key is not defined');\n    if (!actions) throw new Error('actions are not defined');\n\n    this.actions = actions;\n    this.key = key;\n    this._setRules(rules);\n    this._setCombiningAlgorithm(combiningAlgorithm);\n  }\n\n  (0, _createClass3.default)(Policy, [{\n    key: 'addAction',\n    value: function addAction(method, param) {\n      this.actions.push({ method: method, param: param });\n    }\n  }, {\n    key: 'createRule',\n    value: function createRule(decision, condition, scope, target, priority) {\n      if (priority === undefined) {\n        priority = this.getLastPriority() + 1;\n      }\n      var rule = new _Rule2.default(decision, condition, scope, target, priority);\n      this.rules.push(rule);\n    }\n  }, {\n    key: 'deleteRule',\n    value: function deleteRule(rule) {\n      var indexToRemove = this.rules.indexOf(rule);\n      this.rules.splice(indexToRemove, 1);\n    }\n  }, {\n    key: 'enforceActions',\n    value: function enforceActions(context, message) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n        var results = [];\n        if (_this.actions.length !== 0) {\n          for (var i in _this.actions) {\n            var result = context.pep.actionsService[_this.actions[i].method](message, _this.actions[i].param);\n            results.push(result);\n          }\n          _promise2.default.all(results).then(function (messages) {\n            resolve(messages);\n          }, function (error) {\n            reject(error);\n          });\n        } else {\n          resolve([message]);\n        }\n      });\n    }\n  }, {\n    key: 'evaluateRules',\n    value: function evaluateRules(context, message, isIncoming) {\n      var results = [];\n      for (var i in this.rules) {\n        results.push(this.rules[i].evaluate(context, message, isIncoming));\n      }\n\n      return this.combiningAlgorithm.combine(results);\n    }\n  }, {\n    key: 'getLastPriority',\n    value: function getLastPriority() {\n      var priorities = [];\n\n      if (this.rules.length !== 0) {\n        for (var i in this.rules) {\n          priorities.push(this.rules[i].priority);\n        }\n        return Math.max.apply(Math, priorities);\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: 'getRuleByPriority',\n    value: function getRuleByPriority(priority) {\n      for (var i in this.rules) {\n        if (String(this.rules[i].priority) === String(priority)) {\n          return this.rules[i];\n        }\n      }\n      throw Error('Rule with priority ' + priority + ' does not exist!');\n    }\n  }, {\n    key: '_setCombiningAlgorithm',\n    value: function _setCombiningAlgorithm(combiningAlgorithm) {\n      if (!combiningAlgorithm) {\n        combiningAlgorithm = 'blockOverrides';\n      }\n      switch (combiningAlgorithm) {\n        case 'blockOverrides':\n          this.combiningAlgorithm = new _BlockOverrides2.default();\n          break;\n        case 'allowOverrides':\n          this.combiningAlgorithm = new _AllowOverrides2.default();\n          break;\n        case 'firstApplicable':\n          this.combiningAlgorithm = new _FirstApplicable2.default();\n          break;\n        default:\n          throw Error('Unknown algorithm: ' + combiningAlgorithm);\n      }\n    }\n  }, {\n    key: '_setRules',\n    value: function _setRules(rules) {\n      this.rules = [];\n\n      for (var i in rules) {\n        var rule = rules[i];\n        if (rule.priority === undefined) {\n          rule.priority = this.getLastPriority() + 1;\n        }\n        if (!(rule instanceof _Rule2.default)) {\n          rule = new _Rule2.default(rule.decision, rule.condition, rule.scope, rule.target, rule.priority);\n        }\n        this.rules.push(rule);\n      }\n    }\n  }, {\n    key: 'sortRules',\n    value: function sortRules() {\n      return this.rules.sort(function (a, b) {\n        var x = a.priority;var y = b.priority;\n        return x < y ? -1 : x > y ? 1 : 0;\n      });\n    }\n  }]);\n  return Policy;\n}();\n\nexports.default = Policy;\nmodule.exports = exports['default'];\n\n},{\"./Rule\":435,\"./combiningAlgorithms/AllowOverrides\":436,\"./combiningAlgorithms/BlockOverrides\":437,\"./combiningAlgorithms/FirstApplicable\":438,\"babel-runtime/core-js/promise\":12,\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16}],434:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _utils = require('../utils/utils');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ReThinkCtx = function () {\n  function ReThinkCtx() {\n    (0, _classCallCheck3.default)(this, ReThinkCtx);\n\n    this.defaultBehaviour = true;\n    this.groups = {};\n  }\n\n  (0, _createClass3.default)(ReThinkCtx, [{\n    key: 'scheme',\n    get: function get() {\n      return this._scheme;\n    },\n    set: function set(params) {\n      var from = params.message.from;\n      if ((0, _utils.isDataObjectURL)(from)) {\n        this._scheme = (0, _utils.divideURL)(from).type;\n      } else {\n        this._scheme = undefined;\n      }\n    }\n  }, {\n    key: 'date',\n    get: function get() {\n      return this._date;\n    },\n    set: function set(now) {\n      var date = new Date();\n      var day = String(date.getDate());\n      if (day.length === 1) {\n        day = '0' + day;\n      }\n      var month = String(date.getMonth() + 1);\n      if (month.length === 1) {\n        month = '0' + month;\n      }\n      this._date = day + '/' + month + '/' + date.getFullYear();\n    }\n  }, {\n    key: 'domain',\n    get: function get() {\n      return this._domain;\n    },\n    set: function set(params) {\n      if (params.message.body.identity !== undefined) {\n        this._domain = (0, _utils.divideEmail)(params.message.body.identity.userProfile.username).domain;\n      }\n    }\n  }, {\n    key: 'type',\n    get: function get() {\n      return this._type;\n    },\n    set: function set(params) {\n      var message = params.message;\n      if (message.body.value !== undefined) {\n        this._type = message.body.value.resourceType;\n      }\n    }\n  }, {\n    key: 'source',\n    get: function get() {\n      return this._source;\n    },\n    set: function set(params) {\n      if (params.message.body.identity !== undefined) {\n        this._source = params.message.body.identity.userProfile.username;\n      }\n    }\n  }, {\n    key: 'time',\n    get: function get() {\n      return this._time;\n    },\n    set: function set(now) {\n      now = new Date();\n      var minutes = String(now.getMinutes());\n      if (minutes.length === 1) {\n        minutes = '0' + minutes;\n      }\n      this._time = parseInt(String(now.getHours()) + minutes);\n    }\n  }, {\n    key: 'weekday',\n    get: function get() {\n      return this._weekday;\n    },\n    set: function set(now) {\n      this._weekday = String(new Date().getDay());\n    }\n  }]);\n  return ReThinkCtx;\n}();\n\nexports.default = ReThinkCtx;\nmodule.exports = exports['default'];\n\n},{\"../utils/utils\":457,\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16}],435:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _AdvancedCondition = require('./conditions/AdvancedCondition');\n\nvar _AdvancedCondition2 = _interopRequireDefault(_AdvancedCondition);\n\nvar _Condition = require('./conditions/Condition');\n\nvar _Condition2 = _interopRequireDefault(_Condition);\n\nvar _utils = require('../utils/utils');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Rule = function () {\n  function Rule(decision, condition, scope, target, priority) {\n    (0, _classCallCheck3.default)(this, Rule);\n\n    this.decision = decision;\n    this.setCondition(condition);\n    this.priority = priority;\n    this.scope = scope;\n    this.target = target;\n  }\n\n  (0, _createClass3.default)(Rule, [{\n    key: 'setCondition',\n    value: function setCondition(condition) {\n      if (!(condition instanceof _Condition2.default || condition instanceof _AdvancedCondition2.default || condition instanceof _AdvancedCondition2.default)) {\n        var attribute = condition.attribute;\n        switch (attribute) {\n          case 'subscription':\n            this.condition = new _AdvancedCondition2.default(condition.attribute, condition.operator, condition.params);\n            break;\n          case undefined:\n            this.condition = new _AdvancedCondition2.default(condition);\n            break;\n          default:\n            this.condition = new _Condition2.default(condition.attribute, condition.operator, condition.params);\n        }\n      } else {\n        this.condition = condition;\n      }\n    }\n  }, {\n    key: 'evaluate',\n    value: function evaluate(context, message, isIncoming) {\n      var field = isIncoming ? message.to : message.from;\n      var hypertyName = void 0;\n      switch (this.scope) {\n        case 'global':\n          break;\n\n        case 'hyperty':\n          if ((0, _utils.isDataObjectURL)(field)) {\n            var reporter = context.runtimeRegistry.getReporterURLSynchonous((0, _utils.removePathFromURL)(field));\n            if (reporter !== undefined) {\n              hypertyName = context.runtimeRegistry.getHypertyName(reporter);\n            }\n          } else {\n            if (field.split('://')[0] === 'hyperty') {\n              hypertyName = context.runtimeRegistry.getHypertyName((0, _utils.removePathFromURL)(field));\n            }\n          }\n          if (hypertyName === this.target) {\n            break;\n          }\n\n          return 'Not Applicable';\n\n        case 'identity':\n          var owner = void 0;\n\n          if ((0, _utils.isDataObjectURL)(field)) {\n            var _reporter = context.runtimeRegistry.getReporterURLSynchonous((0, _utils.removePathFromURL)(field));\n            owner = context.runtimeRegistry.getHypertyOwner(_reporter);\n          } else {\n            if (field.split('://')[0] === 'hyperty') {\n              owner = context.runtimeRegistry.getHypertyOwner((0, _utils.removePathFromURL)(field));\n            }\n          }\n          if (owner !== undefined) {\n            owner = (0, _utils.getUserEmailFromURL)(owner);\n          }\n          if (owner === this.target) {\n            break;\n          }\n\n          return 'Not Applicable';\n      }\n\n      if (this.condition.isApplicable(context, message, this.scope, this.target)) {\n        return this.decision;\n      } else {\n        return 'Not Applicable';\n      }\n    }\n  }]);\n  return Rule;\n}();\n\nexports.default = Rule;\nmodule.exports = exports['default'];\n\n},{\"../utils/utils\":457,\"./conditions/AdvancedCondition\":439,\"./conditions/Condition\":440,\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16}],436:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n* Copyright 2016 PT Inovao e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n\n/**\n* @author Ana Caldeira <ana.caldeira@tecnico.ulisboa.pt>\n* @classdesc Class to combine the authorization decisions that result from rules evaluation.\n*/\nvar AllowOverrides = function () {\n  function AllowOverrides() {\n    (0, _classCallCheck3.default)(this, AllowOverrides);\n  }\n\n  (0, _createClass3.default)(AllowOverrides, [{\n    key: 'combine',\n\n\n    /**\n    * Given an array of individual authorization decisions, prioritizes a positive one.\n    * @param    {boolean[]}   decisions\n    * @returns  {boolean}\n    */\n    value: function combine(decisions) {\n      if (decisions.indexOf(true) !== -1) {\n        return true;\n      } else {\n        if (decisions.indexOf(false) !== -1) {\n          return false;\n        } else {\n          return 'Not Applicable';\n        }\n      }\n    }\n  }]);\n  return AllowOverrides;\n}();\n\nexports.default = AllowOverrides;\nmodule.exports = exports['default'];\n\n},{\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16}],437:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n* Copyright 2016 PT Inovao e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n\n/**\n* @author Ana Caldeira <ana.caldeira@tecnico.ulisboa.pt>\n* @classdesc Class to combine the authorization decisions that result from rules evaluation.\n*/\nvar BlockOverrides = function () {\n  function BlockOverrides() {\n    (0, _classCallCheck3.default)(this, BlockOverrides);\n  }\n\n  (0, _createClass3.default)(BlockOverrides, [{\n    key: 'combine',\n\n\n    /**\n    * Given an array of individual authorisation decisions, prioritises a negative one.\n    * @param    {boolean[]}   decisions\n    * @returns  {boolean}\n    */\n    value: function combine(decisions) {\n      if (decisions.indexOf(false) !== -1) {\n        return false;\n      } else {\n        if (decisions.indexOf(true) !== -1) {\n          return true;\n        } else {\n          return 'Not Applicable';\n        }\n      }\n    }\n  }]);\n  return BlockOverrides;\n}();\n\nexports.default = BlockOverrides;\nmodule.exports = exports['default'];\n\n},{\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16}],438:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n* Copyright 2016 PT Inovao e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n\n/**\n* @author Ana Caldeira <ana.caldeira@tecnico.ulisboa.pt>\n* @classdesc Class to combine the authorization decisions that result from rules evaluation.\n*/\nvar FirstApplicable = function () {\n  function FirstApplicable() {\n    (0, _classCallCheck3.default)(this, FirstApplicable);\n  }\n\n  (0, _createClass3.default)(FirstApplicable, [{\n    key: 'combine',\n\n\n    /**\n    * Given an array of individual authorisation decisions, returns the first one different from 'Not Applicable', either positive or negative.\n    * @param    {boolean[]}     decisions\n    * @returns  {boolean}\n    */\n    value: function combine(decisions) {\n      for (var i in decisions) {\n        if (decisions[i] !== 'Not Applicable') {\n          return decisions[i];\n        }\n      }\n      return 'Not Applicable';\n    }\n  }]);\n  return FirstApplicable;\n}();\n\nexports.default = FirstApplicable;\nmodule.exports = exports['default'];\n\n},{\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16}],439:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _Condition = require('./Condition');\n\nvar _Condition2 = _interopRequireDefault(_Condition);\n\nvar _Operators = require('../Operators');\n\nvar _Operators2 = _interopRequireDefault(_Operators);\n\nvar _SubscriptionCondition = require('./SubscriptionCondition');\n\nvar _SubscriptionCondition2 = _interopRequireDefault(_SubscriptionCondition);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar AdvancedCondition = function () {\n  function AdvancedCondition(condition) {\n    (0, _classCallCheck3.default)(this, AdvancedCondition);\n\n    this.operators = new _Operators2.default();\n    if (condition.operators !== undefined) {\n      condition = condition.condition;\n    }\n    condition = this.buildCondition(condition);\n    this.condition = condition;\n  }\n\n  (0, _createClass3.default)(AdvancedCondition, [{\n    key: 'buildCondition',\n    value: function buildCondition(condition) {\n      if (Array.isArray(condition[1])) {\n        condition[1] = this.buildCondition(condition[1]);\n      } else {\n        if (condition[1].attribute === 'subscription') {\n          condition[1] = new _SubscriptionCondition2.default(condition[1].attribute, condition[1].operator, condition[1].params);\n        } else {\n          condition[1] = new _Condition2.default(condition[1].attribute, condition[1].operator, condition[1].params);\n        }\n      }\n\n      if (condition[2] !== undefined) {\n        if (Array.isArray(condition[2])) {\n          condition[2] = this.buildCondition(condition[2]);\n        } else {\n          if (condition[2].attribute === 'subscription') {\n            condition[2] = new _SubscriptionCondition2.default(condition[2].attribute, condition[2].operator, condition[2].params);\n          } else {\n            condition[2] = new _Condition2.default(condition[2].attribute, condition[2].operator, condition[2].params);\n          }\n        }\n      }\n      return condition;\n    }\n  }, {\n    key: 'isApplicable',\n    value: function isApplicable(context, message, scope, target, operator, left, right) {\n      if (!operator) {\n        operator = this.condition[0];\n        left = this.condition[1];\n        right = this.condition[2];\n      }\n\n      while (!(left instanceof _Condition2.default) & !(left instanceof _SubscriptionCondition2.default) & typeof left !== 'boolean') {\n        left = this.isApplicable(context, message, scope, target, left[0], left[1], left[2]);\n      }\n      if (right !== undefined) {\n        while (!(right instanceof _Condition2.default) & !(right instanceof _SubscriptionCondition2.default) & typeof right !== 'boolean') {\n          right = this.isApplicable(context, message, scope, target, right[0], right[1], right[2]);\n        }\n      }\n\n      var resultLeft = typeof left === 'boolean' ? left : left.isApplicable(context, message, scope, target);\n      var resultRight = void 0;\n      if (right !== undefined) {\n        resultRight = typeof right === 'boolean' ? right : right.isApplicable(context, message, scope, target);\n      }\n      return this.operators[operator]([resultLeft, resultRight]);\n    }\n  }]);\n  return AdvancedCondition;\n}();\n\nexports.default = AdvancedCondition;\nmodule.exports = exports['default'];\n\n},{\"../Operators\":430,\"./Condition\":440,\"./SubscriptionCondition\":441,\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16}],440:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _Operators = require('../Operators');\n\nvar _Operators2 = _interopRequireDefault(_Operators);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n* @author Ana Caldeira <ana.caldeira@tecnico.ulisboa.pt>\n* @classdesc Class to represent a condition and evaluate its applicability.\n*/\nvar Condition = function () {\n\n  /**\n  * Creates a new Condition.\n  * @class\n  * @param  {string}  attribute\n  * @param  {string}  operator\n  * @param  {*}       params\n  */\n  function Condition(attribute, operator, params) {\n    (0, _classCallCheck3.default)(this, Condition);\n\n    this.attribute = attribute;\n    this.operator = operator;\n    this.params = params;\n    this.operators = new _Operators2.default();\n  }\n\n  /**\n  * Verifies if the condition is applicable to the message. First, the system value that corresponds to the attribute is retrieved; then, that value is compared with the parameter specified in the condition by executing the operator implementation. If the operator is 'in' and the name of a group is given, then the array holding the members of the group is retrieved before the comparison.\n  * @param  {Object}    context   environment where the Policy Engine is being used\n  * @param  {Object}    message\n  */\n\n\n  (0, _createClass3.default)(Condition, [{\n    key: 'isApplicable',\n    value: function isApplicable(context, message) {\n      context[this.attribute] = { message: message };\n      var value = context[this.attribute];\n      var tempParam = void 0;\n\n      if (this.operator === 'in') {\n        if (!Array.isArray(this.params)) {\n          tempParam = context.getGroup(this.params, message.to);\n          return this.operators[this.operator]([tempParam, value]);\n        }\n      }\n\n      return this.operators[this.operator]([this.params, value]);\n    }\n  }]);\n  return Condition;\n}(); /**\n     * Copyright 2016 PT Inovao e Sistemas SA\n     * Copyright 2016 INESC-ID\n     * Copyright 2016 QUOBIS NETWORKS SL\n     * Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n     * Copyright 2016 ORANGE SA\n     * Copyright 2016 Deutsche Telekom AG\n     * Copyright 2016 Apizee\n     * Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *   http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     **/\n\nexports.default = Condition;\nmodule.exports = exports['default'];\n\n},{\"../Operators\":430,\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16}],441:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _get2 = require('babel-runtime/helpers/get');\n\nvar _get3 = _interopRequireDefault(_get2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _Condition2 = require('./Condition');\n\nvar _Condition3 = _interopRequireDefault(_Condition2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n* @author Ana Caldeira <ana.caldeira@tecnico.ulisboa.pt>\n* @classdesc Class to represent a subscription condition and evaluate its applicability.\n*/\nvar SubscriptionCondition = function (_Condition) {\n  (0, _inherits3.default)(SubscriptionCondition, _Condition);\n\n  /**\n  * Creates a new SubscriptionCondition.\n  * @class\n  * @param  {string}  attribute\n  * @param  {string}  operator\n  * @param  {*}       params\n  */\n  function SubscriptionCondition(attribute, operator, params) {\n    (0, _classCallCheck3.default)(this, SubscriptionCondition);\n    return (0, _possibleConstructorReturn3.default)(this, (SubscriptionCondition.__proto__ || (0, _getPrototypeOf2.default)(SubscriptionCondition)).call(this, attribute, operator, params));\n  }\n\n  /**\n  * Verifies if the subscription condition is applicable to the message. First, verifies if the message is of the subscription type; second, verifies if the message is from a remote runtime to guarantee that the subscription is being validated in the destination runtime; third, verifies if the subscription preference is met.\n  * @param  {Object}    context   environment where the Policy Engine is being used\n  * @param  {Object}    message\n  */\n\n\n  (0, _createClass3.default)(SubscriptionCondition, [{\n    key: 'isApplicable',\n    value: function isApplicable(context, message) {\n      var isSubscription = message.type === 'subscribe';\n      var isFromRemoteSM = context.isFromRemoteSM(message.from);\n      if (isSubscription & isFromRemoteSM) {\n        return (0, _get3.default)(SubscriptionCondition.prototype.__proto__ || (0, _getPrototypeOf2.default)(SubscriptionCondition.prototype), 'isApplicable', this).call(this, context, message);\n      } else {\n        return false;\n      }\n    }\n  }]);\n  return SubscriptionCondition;\n}(_Condition3.default); /**\n                        * Copyright 2016 PT Inovao e Sistemas SA\n                        * Copyright 2016 INESC-ID\n                        * Copyright 2016 QUOBIS NETWORKS SL\n                        * Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n                        * Copyright 2016 ORANGE SA\n                        * Copyright 2016 Deutsche Telekom AG\n                        * Copyright 2016 Apizee\n                        * Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n                        *\n                        * Licensed under the Apache License, Version 2.0 (the \"License\");\n                        * you may not use this file except in compliance with the License.\n                        * You may obtain a copy of the License at\n                        *\n                        *   http://www.apache.org/licenses/LICENSE-2.0\n                        *\n                        * Unless required by applicable law or agreed to in writing, software\n                        * distributed under the License is distributed on an \"AS IS\" BASIS,\n                        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n                        * See the License for the specific language governing permissions and\n                        * limitations under the License.\n                        **/\n\nexports.default = SubscriptionCondition;\nmodule.exports = exports['default'];\n\n},{\"./Condition\":440,\"babel-runtime/core-js/object/get-prototype-of\":8,\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16,\"babel-runtime/helpers/get\":17,\"babel-runtime/helpers/inherits\":18,\"babel-runtime/helpers/possibleConstructorReturn\":19}],442:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _stringify = require('babel-runtime/core-js/json/stringify');\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _AllowOverrides = require('../combiningAlgorithms/AllowOverrides');\n\nvar _AllowOverrides2 = _interopRequireDefault(_AllowOverrides);\n\nvar _BlockOverrides = require('../combiningAlgorithms/BlockOverrides');\n\nvar _BlockOverrides2 = _interopRequireDefault(_BlockOverrides);\n\nvar _utils = require('../../utils/utils');\n\nvar _FirstApplicable = require('../combiningAlgorithms/FirstApplicable');\n\nvar _FirstApplicable2 = _interopRequireDefault(_FirstApplicable);\n\nvar _ReThinkCtx2 = require('../ReThinkCtx');\n\nvar _ReThinkCtx3 = _interopRequireDefault(_ReThinkCtx2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar RuntimeCoreCtx = function (_ReThinkCtx) {\n  (0, _inherits3.default)(RuntimeCoreCtx, _ReThinkCtx);\n\n  function RuntimeCoreCtx(idModule, runtimeRegistry, storageManager) {\n    (0, _classCallCheck3.default)(this, RuntimeCoreCtx);\n\n    var _this2 = (0, _possibleConstructorReturn3.default)(this, (RuntimeCoreCtx.__proto__ || (0, _getPrototypeOf2.default)(RuntimeCoreCtx)).call(this));\n\n    _this2.idModule = idModule;\n    _this2.runtimeRegistry = runtimeRegistry;\n    _this2.activeUserPolicy = undefined;\n    _this2.serviceProviderPolicy = {};\n    _this2.userPolicies = {};\n    _this2.storageManager = storageManager;\n    return _this2;\n  }\n\n  (0, _createClass3.default)(RuntimeCoreCtx, [{\n    key: 'loadConfigurations',\n    value: function loadConfigurations() {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n\n        _this.storageManager.get('rethink:activePolicy').then(function (value) {\n          _this.activeUserPolicy = value;\n\n          return _this.storageManager.get('rethink:groups');\n        }).then(function (groupInfo) {\n          var groups = groupInfo;\n          _this.groups = groups === undefined ? {} : groups;\n\n          return _this.storageManager.get('rethink:spPolicies');\n        }).then(function (policiesInfo) {\n          var spPolicies = policiesInfo;\n          _this.serviceProviderPolicy = spPolicies === undefined ? {} : spPolicies;\n\n          _this._loadUserPolicies().then(function () {\n            resolve();\n          });\n        });\n      });\n    }\n  }, {\n    key: 'prepareForEvaluation',\n    value: function prepareForEvaluation(message, isIncoming) {\n      var _this3 = this;\n\n      return new _promise2.default(function (resolve, reject) {\n\n        var _this = _this3;\n        if (isIncoming) {\n          if (_this._isToCypherModule(message)) {\n            _this.idModule.decryptMessage(message).then(function (message) {\n              /*if (message.type === 'update') {\n                _this._isValidUpdate(message).then(message => {*/\n              resolve(message);\n            }, function (error) {\n              reject(error);\n              /*});\n              } else {\n                resolve(message);\n              }*/\n            });\n          } else {\n            resolve(message);\n          }\n        } else {\n          if (_this._isToSetID(message)) {\n            _this._getIdentity(message).then(function (identity) {\n              message.body.identity = identity;\n              resolve(message);\n            }, function (error) {\n              reject(error);\n            });\n          } else {\n            resolve(message);\n          }\n        }\n      });\n    }\n  }, {\n    key: 'getPolicies',\n    value: function getPolicies(message, isIncomingMessage) {\n      var policies = {};\n\n      if (this.activeUserPolicy !== undefined) {\n        policies.userPolicy = this.userPolicies[this.activeUserPolicy];\n      }\n\n      policies.serviceProviderPolicy = this.getServiceProviderPolicy(message, isIncomingMessage);\n\n      return policies;\n    }\n  }, {\n    key: '_isValidUpdate',\n    value: function _isValidUpdate(message) {\n      var _this = this;\n      return new _promise2.default(function (resolve, reject) {\n        if (message.from.split('://').length > 1) {\n          _this.idModule._getHypertyFromDataObject(message.from).then(function (hypertyURL) {\n            if (hypertyURL === message.body.source) {\n              resolve(message);\n            } else {\n              reject('The source of the message is not valid.');\n            }\n          }, function (error) {\n            reject(error);\n          });\n        } else {\n          resolve(message);\n        }\n      });\n    }\n  }, {\n    key: 'prepareToForward',\n    value: function prepareToForward(message, isIncoming, result) {\n      var _this = this;\n      return new _promise2.default(function (resolve, reject) {\n        if (isIncoming & result) {\n          var isSubscription = message.type === 'subscribe';\n          var isFromRemoteSM = _this.isFromRemoteSM(message.from);\n          if (isSubscription & isFromRemoteSM) {\n            _this.doMutualAuthentication(message).then(function () {\n              resolve(message);\n            }, function (error) {\n              reject(error);\n            });\n          } else {\n            resolve(message);\n          }\n        } else {\n          if (_this._isToCypherModule(message)) {\n            _this.idModule.encryptMessage(message).then(function (message) {\n              resolve(message);\n            }, function (error) {\n              reject(error);\n            });\n          } else {\n            resolve(message);\n          }\n        }\n      });\n    }\n  }, {\n    key: 'doMutualAuthentication',\n    value: function doMutualAuthentication(message) {\n      var _this = this;\n      return new _promise2.default(function (resolve, reject) {\n        var to = message.to.split('/');\n        var subsIndex = to.indexOf('subscription');\n        var isDataObjectSubscription = subsIndex !== -1;\n        var isFromRemoteSM = _this.isFromRemoteSM(message.from);\n        if (isDataObjectSubscription & isFromRemoteSM) {\n          (function () {\n            to.pop();\n            var dataObjectURL = to[0] + '//' + to[2] + '/' + to[3];\n            _this.idModule.doMutualAuthentication(dataObjectURL, message.body.subscriber).then(function () {\n              _this.runtimeRegistry.registerSubscriber(dataObjectURL, message.body.subscriber);\n              resolve();\n            }, function (error) {\n              reject(error);\n            });\n          })();\n        }\n      });\n    }\n  }, {\n    key: 'getMyEmails',\n    value: function getMyEmails() {\n      var identities = this.idModule.getIdentities();\n      var emails = [];\n\n      for (var i in identities) {\n        emails.push((0, _utils.getUserEmailFromURL)(identities[i].identity));\n      }\n\n      return emails;\n    }\n  }, {\n    key: 'getMyHyperties',\n    value: function getMyHyperties() {\n      var hyperties = this.runtimeRegistry.hypertiesList;\n      var hypertiesNames = [];\n\n      for (var i in hyperties) {\n        var hypertyName = hyperties[i].objectName;\n        if (hypertiesNames.indexOf(hypertyName) === -1) {\n          hypertiesNames.push(hypertyName);\n        }\n      }\n\n      return hypertiesNames;\n    }\n  }, {\n    key: 'getServiceProviderPolicy',\n    value: function getServiceProviderPolicy(message, isIncoming) {\n      var policy = void 0;\n\n      if (isIncoming) {\n        var toHyperty = this.runtimeRegistry.getHypertyName(message.to);\n        policy = this.serviceProviderPolicy[toHyperty];\n      } else {\n        var fromHyperty = this.runtimeRegistry.getHypertyName(message.from);\n        policy = this.serviceProviderPolicy[fromHyperty];\n      }\n      return policy;\n    }\n  }, {\n    key: 'isFromRemoteSM',\n    value: function isFromRemoteSM(from) {\n      var splitFrom = from.split('://');\n      return splitFrom[0] === 'runtime' && from !== this.runtimeRegistry.runtimeURL + '/sm';\n    }\n  }, {\n    key: '_isToSetID',\n    value: function _isToSetID(message) {\n      var schemasToIgnore = ['domain-idp', 'runtime', 'domain'];\n      var splitFrom = message.from.split('://');\n      var fromSchema = splitFrom[0];\n\n      return schemasToIgnore.indexOf(fromSchema) === -1;\n    }\n  }, {\n    key: 'getURL',\n    value: function getURL(url) {\n      var splitURL = url.split('/');\n      return splitURL[0] + '//' + splitURL[2] + '/' + splitURL[3];\n    }\n  }, {\n    key: '_getIdentity',\n    value: function _getIdentity(message) {\n      if (message.type === 'update') {\n        return this.idModule.getIdentityOfHyperty(message.body.source);\n      }\n\n      if (message.type === 'response' && message.body.source !== undefined) {\n        return this.idModule.getIdentityOfHyperty(message.body.source);\n      }\n\n      if ((0, _utils.divideURL)(message.from).type === 'hyperty') {\n        return this.idModule.getIdentityOfHyperty(message.from);\n      } else {\n        return this.idModule.getIdentityOfHyperty(this.getURL(message.from));\n      }\n    }\n\n    /**\n    * Identifies the messages to be forwarded to the Identity Module for\n    * encryption/decryption and integrity validation.\n    * @param {Message}    message\n    * @returns {boolean}  returns true if the message requires encryption/decryption\n    *                     or if its type equals 'handshake'; false otherwise\n    */\n\n  }, {\n    key: '_isToCypherModule',\n    value: function _isToCypherModule(message) {\n      var isCreate = message.type === 'create';\n      var isFromHyperty = (0, _utils.divideURL)(message.from).type === 'hyperty';\n      var isToHyperty = (0, _utils.divideURL)(message.to).type === 'hyperty';\n      var isToDataObject = (0, _utils.isDataObjectURL)(message.to);\n\n      return isCreate && isFromHyperty && isToHyperty || isCreate && isFromHyperty && isToDataObject || message.type === 'handshake' || message.type === 'update';\n    }\n\n    /**\n    * Creates a group with the given name.\n    * @param  {String}  groupName\n    */\n\n  }, {\n    key: '_loadUserPolicies',\n    value: function _loadUserPolicies() {\n      var _this4 = this;\n\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n\n        _this.storageManager.get('rethink:userPolicies').then(function (value) {\n          var policies = value;\n          if (policies !== undefined) {\n            for (var i in policies) {\n              _this4.pep.addPolicy('USER', i, policies[i]);\n            }\n          }\n          resolve();\n        });\n      });\n    }\n  }, {\n    key: '_getLastComponentOfURL',\n    value: function _getLastComponentOfURL(url) {\n      var split = url.split('/');\n      return split[split.length - 1];\n    }\n  }, {\n    key: '_getPoliciesJSON',\n    value: function _getPoliciesJSON(policies) {\n      for (var i in policies) {\n        var combiningAlgorithm = policies[i].combiningAlgorithm;\n        if (combiningAlgorithm instanceof _BlockOverrides2.default) {\n          policies[i].combiningAlgorithm = 'blockOverrides';\n        } else {\n          if (combiningAlgorithm instanceof _AllowOverrides2.default) {\n            policies[i].combiningAlgorithm = 'allowOverrides';\n          } else {\n            if (combiningAlgorithm instanceof _FirstApplicable2.default) {\n              policies[i].combiningAlgorithm = 'firstApplicable';\n            } else {\n              policies[i].combiningAlgorithm = undefined;\n            }\n          }\n        }\n      }\n\n      return policies;\n    }\n  }, {\n    key: 'saveActivePolicy',\n    value: function saveActivePolicy() {\n      var _this5 = this;\n\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n        _this.storageManager.set('rethink:activePolicy', 0, _this5.activeUserPolicy).then(function () {\n          resolve();\n        });\n      });\n    }\n  }, {\n    key: 'saveGroups',\n    value: function saveGroups() {\n      var _this6 = this;\n\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n        _this.storageManager.set('rethink:groups', 0, _this6.groups).then(function () {\n          resolve();\n        });\n      });\n    }\n  }, {\n    key: 'savePolicies',\n    value: function savePolicies(source, policy, key) {\n      var policiesJson = void 0;\n\n      switch (source) {\n        case 'USER':\n          policiesJson = (0, _stringify2.default)(this.userPolicies);\n          policiesJson = this._getPoliciesJSON(JSON.parse(policiesJson));\n          this.storageManager.set('rethink:userPolicies', 0, policiesJson);\n          break;\n        case 'SERVICE_PROVIDER':\n          if (policy !== undefined & key !== undefined) {\n            this.serviceProviderPolicy[key] = policy;\n          }\n          policiesJson = (0, _stringify2.default)(this.serviceProviderPolicy);\n          policiesJson = this._getPoliciesJSON(JSON.parse(policiesJson));\n          this.storageManager.set('rethink:spPolicies', 0, policiesJson);\n          break;\n        default:\n          throw Error('Unknown policy source: ' + source);\n      }\n    }\n  }, {\n    key: 'getGroupsNames',\n    value: function getGroupsNames() {\n      var myGroups = this.groups;\n      var groupsNames = [];\n      if (myGroups !== undefined) {\n        for (var groupName in myGroups) {\n          groupsNames.push(groupName);\n        }\n      }\n      return groupsNames;\n    }\n  }, {\n    key: 'getGroup',\n    value: function getGroup(groupName, destination) {\n      var members = [];\n\n      if (groupName === 'preauthorised') {\n        var dataObjectURL = destination.split('/');\n        dataObjectURL.pop();\n        dataObjectURL = dataObjectURL[0] + '//' + dataObjectURL[2];\n        members = this.runtimeRegistry.getPreAuthSubscribers(dataObjectURL);\n      } else {\n        if (this.groups[groupName] !== undefined) {\n          members = this.groups[groupName];\n        }\n      }\n\n      return members;\n    }\n\n    /**\n    * Creates a group with the given name.\n    * @param  {String}  groupName\n    */\n\n  }, {\n    key: 'createGroup',\n    value: function createGroup(groupName) {\n      this.groups[groupName] = [];\n      this.saveGroups();\n    }\n  }, {\n    key: 'deleteGroup',\n    value: function deleteGroup(groupName) {\n      delete this.groups[groupName];\n      this.saveGroups();\n    }\n\n    /**\n    * Adds the given user email to the group with the given name.\n    * @param  {String}  userEmail\n    * @param  {String}  groupName\n    */\n\n  }, {\n    key: 'addToGroup',\n    value: function addToGroup(groupName, userEmail) {\n      var myGroups = this.groups;\n      if (myGroups[groupName] !== undefined) {\n        if (myGroups[groupName].indexOf(userEmail) === -1) {\n          myGroups[groupName].push(userEmail);\n          this.saveGroups();\n        }\n      } else {\n        throw Error('Group \"' + groupName + '\" does not exist!');\n      }\n    }\n  }, {\n    key: 'removeFromGroup',\n    value: function removeFromGroup(groupName, userEmail) {\n      var group = this.groups[groupName];\n\n      group.splice(group.indexOf(userEmail), 1);\n      this.saveGroups();\n    }\n  }, {\n    key: 'subscription',\n    get: function get() {\n      return this._subscription;\n    },\n    set: function set(params) {\n      this._subscription = params.message.body.subscriber;\n    }\n  }]);\n  return RuntimeCoreCtx;\n}(_ReThinkCtx3.default);\n\nexports.default = RuntimeCoreCtx;\nmodule.exports = exports['default'];\n\n},{\"../../utils/utils\":457,\"../ReThinkCtx\":434,\"../combiningAlgorithms/AllowOverrides\":436,\"../combiningAlgorithms/BlockOverrides\":437,\"../combiningAlgorithms/FirstApplicable\":438,\"babel-runtime/core-js/json/stringify\":3,\"babel-runtime/core-js/object/get-prototype-of\":8,\"babel-runtime/core-js/promise\":12,\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16,\"babel-runtime/helpers/inherits\":18,\"babel-runtime/helpers/possibleConstructorReturn\":19}],443:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _RegistryDataModel2 = require('./RegistryDataModel');\n\nvar _RegistryDataModel3 = _interopRequireDefault(_RegistryDataModel2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n*   @author: Gil Dias (gil.dias@tecnico.ulisboa.pt)\n*   HypertyInstance Data Model used to model instances of Hyperties running in devices and servers.\n*/\nvar HypertyInstance = function (_RegistryDataModel) {\n  (0, _inherits3.default)(HypertyInstance, _RegistryDataModel);\n\n  function HypertyInstance(id, url, descriptorURL, descriptor, hypertyURL, user, guid, runtime, context) {\n    (0, _classCallCheck3.default)(this, HypertyInstance);\n\n    var _this2 = (0, _possibleConstructorReturn3.default)(this, (HypertyInstance.__proto__ || (0, _getPrototypeOf2.default)(HypertyInstance)).call(this, id, url, descriptorURL));\n\n    var _this = _this2;\n    _this._descriptor = descriptor;\n    _this._hypertyURL = hypertyURL;\n    _this._user = user;\n    _this._guid = guid;\n    _this._runtime = runtime;\n    _this._context = context;\n    return _this2;\n  }\n\n  (0, _createClass3.default)(HypertyInstance, [{\n    key: 'user',\n    set: function set(identity) {\n      var _this = this;\n      _this.user = identity;\n    },\n    get: function get() {\n      var _this = this;\n      return _this._user;\n    }\n  }, {\n    key: 'hypertyURL',\n    get: function get() {\n      var _this = this;\n      return _this._hypertyURL;\n    }\n  }, {\n    key: 'descriptor',\n    get: function get() {\n      var _this = this;\n      return _this._descriptor;\n    }\n  }, {\n    key: 'objectName',\n    get: function get() {\n      var _this = this;\n      return _this._descriptor._objectName;\n    }\n  }]);\n  return HypertyInstance;\n}(_RegistryDataModel3.default); /**\n                                * Copyright 2016 PT Inovao e Sistemas SA\n                                * Copyright 2016 INESC-ID\n                                * Copyright 2016 QUOBIS NETWORKS SL\n                                * Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n                                * Copyright 2016 ORANGE SA\n                                * Copyright 2016 Deutsche Telekom AG\n                                * Copyright 2016 Apizee\n                                * Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n                                *\n                                * Licensed under the Apache License, Version 2.0 (the \"License\");\n                                * you may not use this file except in compliance with the License.\n                                * You may obtain a copy of the License at\n                                *\n                                *   http://www.apache.org/licenses/LICENSE-2.0\n                                *\n                                * Unless required by applicable law or agreed to in writing, software\n                                * distributed under the License is distributed on an \"AS IS\" BASIS,\n                                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n                                * See the License for the specific language governing permissions and\n                                * limitations under the License.\n                                **/\n\n\nexports.default = HypertyInstance;\nmodule.exports = exports['default'];\n\n},{\"./RegistryDataModel\":445,\"babel-runtime/core-js/object/get-prototype-of\":8,\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16,\"babel-runtime/helpers/inherits\":18,\"babel-runtime/helpers/possibleConstructorReturn\":19}],444:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _AddressAllocation = require('../allocation/AddressAllocation');\n\nvar _AddressAllocation2 = _interopRequireDefault(_AddressAllocation);\n\nvar _HypertyInstance = require('./HypertyInstance');\n\nvar _HypertyInstance2 = _interopRequireDefault(_HypertyInstance);\n\nvar _MessageFactory = require('service-framework/dist/MessageFactory');\n\nvar _utils = require('../utils/utils.js');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n* Copyright 2016 PT Inovao e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\nvar STATUS = { DEPLOYED: 'deployed', PROGRESS: 'in-progress' };\n\n/*import IdentityManager from './IdentityManager';\nimport Discovery from './Discovery';*/\n\n/**\n* Runtime Registry Interface\n*/\n\nvar Registry = function () {\n\n  /**\n  * To initialise the Runtime Registry with the RuntimeURL that will be the basis to derive the internal runtime addresses when allocating addresses to internal runtime component. In addition, the Registry domain back-end to be used to remotely register Runtime components, is also passed as input parameter.\n  * @param  {MessageBus}          msgbus                msgbus\n  * @param  {HypertyRuntimeURL}   runtimeURL            runtimeURL\n  * @param  {AppSandbox}          appSandbox            appSandbox\n  * @param  {runtimeCatalogue}    runtimeCatalogue      runtimeCatalogue\n  * @param  {DomainURL}           remoteRegistry        remoteRegistry\n  * @param  {storageManager}      storageManager\n  */\n  function Registry(runtimeURL, appSandbox, identityModule, runtimeCatalogue, runtimeCapabilities, storageManager, remoteRegistry) {\n    (0, _classCallCheck3.default)(this, Registry);\n\n\n    // how some functions receive the parameters for example:\n    // new Registry('hyperty-runtime://sp1/123', appSandbox, idModule, remoteRegistry);\n    // registry.registerStub(sandbox, 'sp1');\n    // registry.registerHyperty(sandBox, 'hyperty-runtime://sp1/123');\n    // registry.resolve('hyperty-runtime://sp1/123');\n\n    if (!runtimeURL) throw new Error('runtimeURL is missing.');\n    if (!storageManager) throw new Error('storageManager is missing.');\n    /*if (!remoteRegistry) throw new Error('remoteRegistry is missing');*/\n\n    var _this = this;\n\n    _this.registryURL = runtimeURL + '/registry/';\n    _this.appSandbox = appSandbox;\n    _this.runtimeURL = runtimeURL;\n    _this.runtimeCatalogue = runtimeCatalogue;\n    _this.remoteRegistry = remoteRegistry;\n    _this.idModule = identityModule;\n    _this.storageManager = storageManager;\n    _this.runtimeCapabilities = runtimeCapabilities;\n    _this.identifier = Math.floor(Math.random() * 10000 + 1);\n\n    // the expires in 3600, represents 1 hour\n    //the expires is in seconds, unit of measure received by the domain registry\n    _this.expiresTime = 3600;\n\n    _this.hypertiesListToRemove = {};\n    _this.hypertiesList = [];\n    _this.protostubsList = {};\n    _this.idpProxyList = {};\n    _this.dataObjectList = {};\n    _this.subscribedDataObjectList = {};\n    _this.sandboxesList = { sandbox: {}, appSandbox: {} };\n    _this.pepList = {};\n\n    _this._domain = (0, _utils.divideURL)(_this.registryURL).domain;\n    _this.sandboxesList.appSandbox[runtimeURL] = appSandbox;\n    var msgFactory = new _MessageFactory.MessageFactory('false', '{}');\n    _this.messageFactory = msgFactory;\n  }\n\n  (0, _createClass3.default)(Registry, [{\n    key: 'discoverHypertyPerUser',\n\n\n    /**\n    * function to request about users registered in domain registry, and\n    * return the last hyperty instance registered by the user.\n    * @param  {email}              email\n    * @param  {domain}            domain (Optional)\n    * @return {Promise}          Promise\n    */\n\n    // TODO: implement a cache system\n    value: function discoverHypertyPerUser(email, domain) {\n      var _this = this;\n      var activeDomain = void 0;\n\n      if (!domain) {\n        activeDomain = _this._domain;\n      } else {\n        activeDomain = domain;\n      }\n\n      var identityURL = 'user://' + email.substring(email.indexOf('@') + 1, email.length) + '/' + email.substring(0, email.indexOf('@'));\n\n      // message to query domain registry, asking for a user hyperty.\n      var message = {\n        type: 'read', from: _this.registryURL, to: 'domain://registry.' + activeDomain + '/', body: { resource: identityURL }\n      };\n\n      console.log('Message: ', message, activeDomain, identityURL);\n\n      //console.log('message READ', message);\n      return new _promise2.default(function (resolve, reject) {\n\n        _this._messageBus.postMessage(message, function (reply) {\n          console.log('message reply', reply);\n\n          var hyperty = void 0;\n          var mostRecent = void 0;\n          var lastHyperty = void 0;\n          var value = reply.body.value;\n\n          for (hyperty in value) {\n            if (value[hyperty].lastModified !== undefined) {\n              if (mostRecent === undefined) {\n                mostRecent = new Date(value[hyperty].lastModified);\n                lastHyperty = hyperty;\n              } else {\n                var hypertyDate = new Date(value[hyperty].lastModified);\n                if (mostRecent.getTime() < hypertyDate.getTime()) {\n                  mostRecent = hypertyDate;\n                  lastHyperty = hyperty;\n                }\n              }\n            }\n          }\n\n          console.log('Last Hyperty: ', lastHyperty, mostRecent);\n\n          var hypertyURL = lastHyperty;\n\n          if (hypertyURL === undefined) {\n            return reject('User Hyperty not found');\n          }\n\n          var idPackage = {\n            id: email,\n            descriptor: value[hypertyURL].descriptor,\n            hypertyURL: hypertyURL\n          };\n\n          console.log('===> hypertyDiscovery messageBundle: ', idPackage);\n          resolve(idPackage);\n        });\n      });\n    }\n  }, {\n    key: '_getIdentityAssociated',\n    value: function _getIdentityAssociated(type, hypertyURL) {\n      var _this = this;\n\n      for (var hyperty in _this.hypertiesList) {\n        var value = _this.hypertiesList[hyperty];\n        if (value._hypertyURL === hypertyURL) {\n          switch (type) {\n            case 'username':\n              return value._user.username;\n            case 'cn':\n              return value._user.cn;\n            case 'locale':\n              return value._user.locale;\n            case 'avatar':\n              return value._user.avatar;\n            case 'userURL':\n              return value._user.userURL;\n            case '.':\n              return value._user;\n            default:\n              return '';\n          }\n        }\n      }\n      return '';\n    }\n\n    /**\n    * query the domain registry for information from a dataObject URL\n    * @param  {String}   url            dataObject URL\n    * @return {JSON}     dataObject     data object\n    */\n\n  }, {\n    key: 'discoverDataObjectPerURL',\n    value: function discoverDataObjectPerURL(url, domain) {\n\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n\n        var activeDomain = void 0;\n\n        if (!domain) {\n          activeDomain = _this._domain;\n        } else {\n          activeDomain = domain;\n        }\n\n        var msg = {\n          type: 'read', from: _this.registryURL, to: 'domain://registry.' + activeDomain + '/', body: { resource: url }\n        };\n\n        _this._messageBus.postMessage(msg, function (reply) {\n\n          var dataObject = reply.body.value;\n\n          if (dataObject) {\n            resolve(dataObject);\n          } else {\n            reject('DataObject not found');\n          }\n        });\n      });\n    }\n\n    /**\n    * This function is used to return the sandbox instance where the Application is executing. It is assumed there is just one App per Runtime instance.\n    */\n\n  }, {\n    key: 'getAppSandbox',\n    value: function getAppSandbox() {\n      var _this = this;\n      return _this.appSandbox;\n    }\n\n    /**\n    * This function returns the user associated to the hyperty URL\n    * @param    {String}    hypertyURL      hyperty URL\n    * @return   {String}    userURL         user URL\n    */\n\n  }, {\n    key: 'getHypertyOwner',\n    value: function getHypertyOwner(hypertyURL) {\n\n      var _this = this;\n      var userURL = void 0;\n\n      for (var index in _this.hypertiesList) {\n        var hyperty = _this.hypertiesList[index];\n        if (hyperty.hypertyURL === hypertyURL) {\n          userURL = hyperty.user.userURL;\n        }\n      }\n      return userURL;\n    }\n\n    /**\n    * returns the hyperty Name from a given url. This url could be from a dataObject or hyperty\n    * @param    {String}    url      hyperty or dataObject URL\n    * @return   {String}    hypertyName     hyperty Name\n    */\n\n  }, {\n    key: 'getHypertyName',\n    value: function getHypertyName(url) {\n      var _this = this;\n\n      var isHypertyURL = (0, _utils.divideURL)(url).type === 'hyperty';\n\n      //value to be returned in the end\n      var hypertyName = void 0;\n\n      //if is not an hyperty, check if is a dataObject and obtain his reporter\n      var hypertyURL = isHypertyURL ? hypertyURL = url : _this.getReporterURLSynchonous(url);\n\n      for (var index in _this.hypertiesList) {\n        var hyperty = _this.hypertiesList[index];\n        if (hyperty.hypertyURL === hypertyURL) {\n          hypertyName = hyperty.objectName;\n          break;\n        }\n      }\n      return hypertyName;\n    }\n\n    /**\n    * function to return the reporterURL associated with the dataobject URL\n    * @param    {String}     dataObjectURL    dataObjectURL\n    * @return   {String}     reporterURL      reporterURL\n    */\n\n  }, {\n    key: 'getReporterURL',\n    value: function getReporterURL(dataObjectURL) {\n      var _this = this;\n\n      var dataObject = _this.dataObjectList[dataObjectURL];\n\n      return new _promise2.default(function (resolve, reject) {\n        if (dataObject) {\n          resolve(dataObject.reporter);\n        } else {\n          reject('No reporter was found');\n        }\n      });\n    }\n\n    /**\n    * function to return the reporterURL associated with the dataobject URL. no promise returned\n    * @param    {String}     dataObjectURL    dataObjectURL\n    * @return   {String}     reporterURL      reporterURL\n    */\n\n  }, {\n    key: 'getReporterURLSynchonous',\n    value: function getReporterURLSynchonous(dataObjectURL) {\n      var _this = this;\n\n      var dataObject = _this.dataObjectList[dataObjectURL];\n\n      return dataObject ? dataObject.reporter : undefined;\n    }\n\n    /**\n    * returns the hyperty URL that subscribed the dataObject\n    * @param    {String}     url            url format\n    * @return   {String}    Hyperty URL subscribed to the URL\n    */\n\n  }, {\n    key: 'getDataObjectSubscriberHyperty',\n    value: function getDataObjectSubscriberHyperty(url) {\n      var _this = this;\n\n      return _this.subscribedDataObjectList[url];\n    }\n\n    /**\n    * register a desired dataObject to subscribe\n    * @param    {String}    dataObjectURL      dataObject URL\n    */\n\n  }, {\n    key: 'registerSubscribedDataObject',\n    value: function registerSubscribedDataObject(dataObjectURL, hypertyURL) {\n      var _this = this;\n      if (_this.subscribedDataObjectList[dataObjectURL] === undefined) {\n        _this.subscribedDataObjectList[dataObjectURL] = hypertyURL;\n      }\n    }\n\n    /**\n    * Function to return the list of pre authorised users received in the creation of a data object\n    * @param    {String}            dataObjectURL    dataObjectURL\n    * @return   {Array<String>}     preAuth         List of pre authorised users\n    */\n\n  }, {\n    key: 'getPreAuthSubscribers',\n    value: function getPreAuthSubscribers(dataObjectURL) {\n      var _this = this;\n      var dataObject = _this.dataObjectList[dataObjectURL];\n      var preAuth = [];\n\n      if (dataObject) {\n        preAuth = dataObject.preAuth;\n      }\n      return preAuth;\n    }\n\n    /**\n    * send requests to unregister all hyperties registered in domain registry\n    * @return   {Promise}     return a promise if the result of unregistration all hyperties\n    */\n\n  }, {\n    key: 'unregisterAllHyperties',\n    value: function unregisterAllHyperties() {\n      var _this = this;\n\n      var unregisterResults = [];\n\n      return new _promise2.default(function (resolve, reject) {\n\n        for (var index in _this.hypertiesList) {\n          var hyperty = _this.hypertiesList[index];\n          var result = _this.unregisterHypertyInstance(hyperty.user.userURL, hyperty.hypertyURL);\n          unregisterResults.push(result);\n        }\n\n        _promise2.default.all(unregisterResults).then(function () {\n\n          resolve('successfully unregistered all hyperties');\n        }, function (error) {\n          reject(error);\n        });\n      });\n    }\n\n    /**\n    *  function to unregister an hypertyInstance in the Domain Registry\n    *  @param   {String}      user        user url\n    *  @param   {String}      hypertyInstance   HypertyInsntance url\n    *\n    */\n\n  }, {\n    key: 'unregisterHypertyInstance',\n    value: function unregisterHypertyInstance(user, hypertyInstance) {\n      //TODO working but the user\n      var _this = this;\n\n      var message = { type: 'delete', from: _this.registryURL,\n        to: 'domain://registry.' + _this._domain + '/',\n        body: { value: { user: user, url: hypertyInstance } } };\n\n      _this._messageBus.postMessage(message, function (reply) {\n        console.log('unregister hyperty Reply', reply);\n      });\n    }\n\n    /**\n    *  function to delete an dataObjectInstance in the Domain Registry\n    *  @param   {String}    name      DataObjectName\n    */\n\n  }, {\n    key: 'deleteDataObjectInstance',\n    value: function deleteDataObjectInstance(name) {\n      var _this = this;\n\n      var message = { type: 'delete', from: _this.registryURL,\n        to: 'domain://registry.' + _this._domain + '/',\n        body: { value: { name: name } } };\n\n      _this._messageBus.postMessage(message, function (reply) {\n        console.log('unregister dataObject Reply', reply);\n      });\n    }\n\n    /**\n    * Function to update an Hyperty\n    */\n\n  }, {\n    key: 'updateHypertyInstance',\n    value: function updateHypertyInstance(resource, value) {\n      var _this = this;\n\n      var message = { type: 'UPDATE', from: _this.registryURL,\n        to: 'domain://registry.' + _this._domain + '/',\n        body: { resource: resource, value: value } };\n\n      _this._messageBus.post.postMessage(message, function (reply) {\n        console.log('Updated hyperty reply', reply);\n      });\n    }\n\n    /**\n    * register a new subscriber in the dataObject registered\n    * @param  {String}   dataObjectURL    dataObject URL\n    * @param  {String}   subscriberURL    subscriber URL\n    */\n\n  }, {\n    key: 'registerSubscriber',\n    value: function registerSubscriber(dataObjectURL, subscriberURL) {\n      var _this = this;\n      var dataObject = _this.dataObjectList[dataObjectURL];\n\n      if (dataObject) {\n        dataObject.subscribers.push(subscriberURL);\n        _this.dataObjectList[dataObjectURL] = dataObject;\n      }\n    }\n\n    /**\n    * get the subscribers registered within a dataObject\n    * @param  {String}          dataObjectURL    dataObject URL\n    * @param  {Array<String>}   Substribers List\n    */\n\n  }, {\n    key: 'getDataObjectSubscribers',\n    value: function getDataObjectSubscribers(dataObjectURL) {\n      var _this = this;\n      var dataObject = _this.dataObjectList[dataObjectURL];\n\n      if (dataObject) {\n        return dataObject.subscribers;\n      } else {\n        throw 'No dataObject was found';\n      }\n    }\n\n    /**\n    * To register a new Data Object in the runtime which returns the dataObjectURL allocated to the new Data Object.\n    * @param  {String}      identifier                  identifier\n    * @param  {String}      dataObjectschema            dataObjectschema\n    * @param  {String}      dataObjectUrl               dataObjectUrl\n    * @param {String}      dataObjectReporter           dataObjectReporter\n    * @param  {Array}     resources                     dataObject resources\n    * @param  {Array}     authorise                     list of pre authorised authorised IDs\n    */\n\n  }, {\n    key: 'registerDataObject',\n    value: function registerDataObject(identifier, dataObjectschema, dataObjectUrl, dataObjectReporter, resources, addressURL, authorise) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n\n        var dataScheme = [];\n        var filteredDataScheme = dataObjectUrl.split(':');\n        dataScheme.push(filteredDataScheme[0]);\n\n        _this.storageManager.get('registry:DataObjectURLs').then(function (urlsList) {\n\n          if (!urlsList) {\n            urlsList = {};\n          }\n\n          //update the list with the new elements\n          urlsList[identifier + dataObjectschema + resources + dataObjectReporter] = addressURL.address;\n\n          //message to register the new hyperty, within the domain registry\n          var messageValue = { name: identifier, resources: resources, dataSchemes: dataScheme, schema: dataObjectschema, url: dataObjectUrl, expires: _this.expiresTime, reporter: dataObjectReporter, preAuth: authorise, subscribers: [] };\n\n          var message = void 0;\n\n          if (addressURL.newAddress) {\n\n            console.log('registering new data object URL', dataObjectUrl);\n\n            message = { type: 'create', from: _this.registryURL, to: 'domain://registry.' + _this.registryDomain + '/', body: { value: messageValue, policy: 'policy' } };\n          } else {\n\n            console.log('registering previously registered data object URL', dataObjectUrl);\n\n            /*messageValue = {name: identifier, resources: resources, dataSchemes: dataScheme, schema: dataObjectschema, url: dataObjectUrl, expires: _this.expiresTime, reporter: dataObjectReporter, preAuth: authorise, subscribers: []};\n             message = {type:'create', from: _this.registryURL, to: 'domain://registry.' + _this.registryDomain + '/', body: {value: messageValue, policy: 'policy'}};*/\n\n            message = {\n              type: 'update',\n              to: 'domain://registry.' + _this.registryDomain + '/',\n              from: _this.registryURL,\n              body: { resource: dataObjectUrl, value: 'live', attribute: 'status' }\n            };\n          }\n\n          _this.dataObjectList[dataObjectUrl] = messageValue;\n\n          // step to obtain the list of all URL registered to updated with the new one.\n          _this.storageManager.set('registry:DataObjectURLs', 0, urlsList).then(function () {\n\n            /*let message = _this.messageFactory.createCreateMessageRequest(\n              _this.registryURL,\n              'domain://registry.' + _this.registryDomain + '/',\n              messageValue,\n              'policy'\n            );*/\n\n            _this._messageBus.postMessage(message, function (reply) {\n              console.log('===> registerDataObject Reply: ', reply);\n              if (reply.body.code === 200) {\n                resolve('ok');\n              } else {\n                reject('error on register DataObject');\n              }\n            });\n          });\n        });\n      });\n    }\n  }, {\n    key: '_getResourcesAndSchemes',\n    value: function _getResourcesAndSchemes(descriptor) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n\n        var resources = void 0;\n\n        // check if the hyperty resources is a vector or a string\n        // TODO delete later when catalogue is fixed\n        if (typeof descriptor.hypertyType === 'string') {\n          resources = [];\n          resources.push(descriptor.hypertyType);\n        } else {\n          resources = descriptor.hypertyType;\n        }\n\n        var descriptorDataSchema = descriptor.dataObjects;\n        var dataSchemasArray = [];\n\n        //this will create a array with a Promise in each position\n        for (var index in descriptorDataSchema) {\n          dataSchemasArray.push(_this.runtimeCatalogue.getDataSchemaDescriptor(descriptorDataSchema[index]));\n        }\n\n        // as soon as the previous array is completed, this will wait for the resolve of all promises in the array\n        _promise2.default.all(dataSchemasArray).then(function (dataSchemas) {\n\n          var filteredDataSchemas = [];\n          for (var _index in dataSchemas) {\n            var dataSchema = dataSchemas[_index];\n            filteredDataSchemas.push(dataSchema.sourcePackage.sourceCode.properties.scheme.constant);\n          }\n\n          console.log('Hyperty Schemas', filteredDataSchemas);\n          console.log('Hyperty resources', resources);\n\n          resolve({ resources: resources, dataSchema: filteredDataSchemas });\n        });\n      });\n    }\n\n    /**\n    * method that returns previously registered Hyperty or DataObjects URLS, for given characteristics\n    * @param  {JSON}        info           object or hyperty charateristics info\n    * @return {addressURL}  addressURL     return the URL if there is any previousy registered URL, return undefined otherwise\n    */\n\n  }, {\n    key: 'checkRegisteredURLs',\n    value: function checkRegisteredURLs(info) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n\n        var objectType = info.reporter ? 'registry:DataObjectURLs' : 'registry:HypertyURLs';\n\n        _this.storageManager.get(objectType).then(function (urlsList) {\n\n          if (!urlsList) {\n            urlsList = {};\n          }\n\n          if (objectType === 'registry:HypertyURLs') {\n            _this._getResourcesAndSchemes(info).then(function (value) {\n              if (urlsList[value.resources + value.dataSchema]) {\n                console.log('reusage of hyperty URL');\n                return resolve(urlsList[value.resources + value.dataSchema]);\n              } else {\n                console.log('no hyperty URL was previously registered ');\n                return resolve(undefined);\n              }\n            });\n          } else {\n\n            var characteristics = info.name + info.schema + info.resources + info.reporter;\n\n            if (urlsList[characteristics]) {\n              console.log('reusage of dataObject URL');\n              return resolve(urlsList[characteristics]);\n            } else {\n              console.log('no dataObject URL was previously registered');\n              return resolve(undefined);\n            }\n          }\n        });\n      });\n    }\n\n    /**\n    * To register a new Hyperty in the runtime which returns the HypertyURL allocated to the new Hyperty.\n    * @param  {Sandbox}             sandbox               sandbox\n    * @param  {HypertyCatalogueURL} HypertyCatalogueURL   descriptor\n    * @return {HypertyURL}          HypertyURL\n    */\n\n  }, {\n    key: 'registerHyperty',\n    value: function registerHyperty(sandbox, descriptorURL, descriptor, addressURL) {\n      var _this = this;\n\n      var hypertyCapabilities = void 0;\n\n      return new _promise2.default(function (resolve, reject) {\n\n        //assuming descriptor come in this format, the service-provider-domain url is retrieved by a split instruction\n        //hyperty-catalogue://<service-provider-domain>/<catalogue-object-identifier>\n        var domainUrl = (0, _utils.divideURL)(descriptorURL).domain;\n\n        if (domainUrl.includes('catalogue')) {\n          domainUrl = domainUrl.replace('catalogue.', '');\n        }\n\n        _this.idModule.getIdentityAssertion().then(function (result) {\n          var userProfile = result.userProfile;\n          var identityURL = userProfile.userURL;\n\n          if (_this._messageBus === undefined) {\n            reject('MessageBus not found on registerStub');\n          } else {\n            //call check if the protostub exist\n            _this.resolve('hyperty-runtime://' + domainUrl).then(function () {\n\n              return _this.storageManager.get('registry:HypertyURLs');\n            }).then(function (urlsList) {\n\n              _this._getResourcesAndSchemes(descriptor).then(function (value) {\n\n                hypertyCapabilities = value;\n\n                if (!urlsList) {\n                  urlsList = {};\n                }\n\n                urlsList[hypertyCapabilities.resources + hypertyCapabilities.dataSchema] = addressURL.address;\n                _this.storageManager.set('registry:HypertyURLs', 0, urlsList).then(function () {\n\n                  _this.registryDomain = domainUrl;\n\n                  //check whether the received sanbox e ApplicationSandbox or a normal sandbox\n                  if (sandbox.type === 'app') {\n                    _this.sandboxesList.appSandbox[addressURL.address[0]] = sandbox;\n                  } else if (sandbox.type === 'normal') {\n                    _this.sandboxesList.sandbox[addressURL.address[0]] = sandbox;\n                  } else {\n                    reject('Wrong SandboxType');\n                  }\n\n                  var hyperty = new _HypertyInstance2.default(_this.identifier, _this.registryURL, descriptorURL, descriptor, addressURL.address[0], userProfile);\n\n                  hyperty._resources = hypertyCapabilities.resources;\n                  hyperty._dataSchemes = hypertyCapabilities.dataSchema;\n                  _this.hypertiesList.push(hyperty);\n\n                  //message to register the new hyperty, within the domain registry\n                  var messageValue = void 0;\n                  var message = void 0;\n\n                  if (addressURL.newAddress) {\n                    console.log('registering new Hyperty URL', addressURL.address[0]);\n\n                    messageValue = { user: identityURL, descriptor: descriptorURL, url: addressURL.address[0], expires: _this.expiresTime, resources: hypertyCapabilities.resources, dataSchemes: hypertyCapabilities.dataSchema };\n\n                    message = { type: 'create', from: _this.registryURL, to: 'domain://registry.' + _this.registryDomain + '/', body: { value: messageValue, policy: 'policy' } };\n                  } else {\n                    console.log('registering previously registered Hyperty URL', addressURL.address[0]);\n\n                    message = { type: 'update',\n                      to: 'domain://registry.' + _this.registryDomain + '/',\n                      from: _this.registryURL,\n                      body: { resource: addressURL.address[0] /*, value: 'live', attribute: 'status'*/ }\n                    };\n                  }\n\n                  /*let message = _this.messageFactory.createCreateMessageRequest(\n                    _this.registryURL,\n                    'domain://registry.' + _this.registryDomain + '/',\n                    messageValue,\n                    'policy'\n                  );*/\n\n                  _this._messageBus.postMessage(message, function (reply) {\n                    console.log('===> RegisterHyperty Reply: ', reply);\n\n                    if (reply.body.code === 200) {\n                      resolve(addressURL.address[0]);\n                    } else {\n                      reject('Failed to register an Hyperty');\n                    }\n                  });\n\n                  //timer to keep the registration alive\n                  // the time is defined by a little less than half of the expires time defined\n                  var keepAliveTimer = setInterval(function () {\n\n                    /*let message = _this.messageFactory.createCreateMessageRequest(\n                      _this.registryURL,\n                      'domain://registry.' + _this.registryDomain + '/',\n                      messageValue,\n                      'policy'\n                    );*/\n\n                    var message = { type: 'update', from: _this.registryURL, to: 'domain://registry.' + _this.registryDomain + '/', body: { resource: addressURL.address[0] } };\n\n                    _this._messageBus.postMessage(message, function (reply) {\n                      console.log('===> KeepAlive Reply: ', reply);\n                    });\n                  }, _this.expiresTime / 1.1 / 2 * 1000);\n                }).catch(function (reason) {\n                  console.log('Address Reason: ', reason);\n                  reject(reason);\n                });\n              });\n            });\n          }\n        }, function (err) {\n          reject('Failed to obtain an identity', err);\n        });\n      });\n    }\n\n    /**\n    * To unregister a previously registered Hyperty\n    * @param  {HypertyURL}          HypertyURL url        url\n    */\n\n  }, {\n    key: 'unregisterHyperty',\n    value: function unregisterHyperty(url) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n\n        var found = false;\n        var index = 0;\n\n        for (index = 0; index < _this.hypertiesList.length; index++) {\n          var hyperty = _this.hypertiesList[index];\n          if (hyperty !== undefined) {\n            if (hyperty.hypertyURL === url) {\n              found = true;\n              break;\n            }\n          }\n        }\n\n        if (found === false) {\n          reject('Hyperty not found');\n        } else {\n          delete _this.hypertiesList[index];\n          resolve('Hyperty successfully deleted');\n        }\n      });\n    }\n\n    /**\n    * To discover protocol stubs available in the runtime for a certain domain. If available, it returns the runtime url for the protocol stub that connects to the requested domain. Required by the runtime BUS to route messages to remote servers or peers (do we need something similar for Hyperties?).\n    * @param  {DomainURL}           DomainURL            url\n    * @return {RuntimeURL}           RuntimeURL\n    */\n\n  }, {\n    key: 'discoverProtostub',\n    value: function discoverProtostub(url) {\n      if (!url) throw new Error('Parameter url needed');\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n\n        var dividedURL = (0, _utils.divideURL)(url);\n        var domainURL = dividedURL.domain;\n\n        if (_this.protostubsList.hasOwnProperty(domainURL) && _this.protostubsList[domainURL].status === STATUS.DEPLOYED) {\n          resolve(_this.protostubsList[domainURL]);\n        } else {\n          _this.protostubsList[domainURL] = {\n            status: STATUS.PROGRESS\n          };\n\n          reject('requestUpdate couldn\\'t get the ProtostubURL');\n        }\n      });\n    }\n\n    /**\n     * To register a new Protocol Stub in the runtime including as input parameters the function to postMessage, the DomainURL that is connected with the stub, which returns the RuntimeURL allocated to the new ProtocolStub.\n     * @param {Sandbox}        Sandbox\n     * @param  {DomainURL}     DomainURL service provider domain\n     * @return {RuntimeProtoStubURL}\n     */\n\n  }, {\n    key: 'registerStub',\n    value: function registerStub(sandbox, domainURL) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n\n        var runtimeProtoStubURL = void 0;\n\n        //check if messageBus is registered in registry or not\n        if (_this._messageBus === undefined) {\n          reject('MessageBus not found on registerStub');\n        }\n\n        //TODO implement a unique number for the protostubURL\n        if (!domainURL.indexOf('msg-node.')) {\n          domainURL = domainURL.substring(domainURL.indexOf('.') + 1);\n        }\n\n        runtimeProtoStubURL = 'msg-node.' + domainURL + '/protostub/' + Math.floor(Math.random() * 10000 + 1);\n\n        // TODO: Optimize this\n        // Proxy;\n        _this.protostubsList[domainURL] = {\n          url: runtimeProtoStubURL,\n          status: STATUS.DEPLOYED\n        };\n\n        // _this.protostubsList[domainURL] = runtimeProtoStubURL;\n        _this.sandboxesList.sandbox[runtimeProtoStubURL] = sandbox;\n\n        // sandbox.addListener('*', function(msg) {\n        //   _this._messageBus.postMessage(msg);\n        // });\n\n        resolve(runtimeProtoStubURL);\n\n        _this._messageBus.addListener(runtimeProtoStubURL + '/status', function (msg) {\n          if (msg.resource === msg.to + '/status') {\n            console.log('RuntimeProtostubURL/status message: ', msg.body.value);\n          }\n        });\n      });\n    }\n\n    /**\n    * To unregister a previously registered protocol stub\n    * @param  {HypertyRuntimeURL}   HypertyRuntimeURL     hypertyRuntimeURL\n    */\n\n  }, {\n    key: 'unregisterStub',\n    value: function unregisterStub(hypertyRuntimeURL) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n\n        if (_this.protostubsList.hasOwnProperty(hypertyRuntimeURL)) {\n          delete _this.protostubsList[hypertyRuntimeURL];\n          resolve('ProtostubURL removed');\n        } else {\n          reject('Error on unregisterStub: Hyperty not found');\n        }\n      });\n    }\n\n    /**\n     * To register a new Identity Provider proxy in the runtime including as input parameters the function to postMessage, the DomainURL that is connected with the stub, which returns the RuntimeURL allocated to the new ProtocolStub.\n     * @param {Sandbox}        Sandbox\n     * @param  {DomainURL}     DomainURL service provider domain\n     * @return {RuntimeIdpProxyURL}\n     */\n\n  }, {\n    key: 'registerIdpProxy',\n    value: function registerIdpProxy(sandbox, domainURL) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n\n        var idpProxyStubURL = void 0;\n\n        //check if messageBus is registered in registry or not\n        if (_this._messageBus === undefined) {\n          reject('MessageBus not found on registerStub');\n        }\n\n        idpProxyStubURL = 'domain-idp://' + domainURL + '/stub/' + Math.floor(Math.random() * 10000 + 1);\n\n        // TODO: Optimize this\n        _this.idpProxyList[domainURL] = {\n          url: idpProxyStubURL,\n          status: STATUS.PROGRESS\n        };\n\n        _this.sandboxesList.sandbox[idpProxyStubURL] = sandbox;\n\n        // sandbox.addListener('*', function(msg) {\n        //   _this._messageBus.postMessage(msg);\n        // });\n\n        resolve(idpProxyStubURL);\n\n        _this._messageBus.addListener(idpProxyStubURL + '/status', function (msg) {\n          if (msg.resource === msg.to + '/status') {\n            console.log('idpProxyStubURL/status message: ', msg.body.value);\n          }\n        });\n      });\n    }\n\n    /**\n    * To discover idpProxy stubs available in the runtime for a certain domain. If available, it returns the runtime url for the idpProxy stub that connects to the requested domain. Required by the runtime BUS to route messages to remote servers or peers\n    * @param  {DomainURL}           DomainURL            url\n    * @return {RuntimeURL}           RuntimeURL         idpProxyUrl\n    */\n\n  }, {\n    key: 'discoverIdpProxy',\n    value: function discoverIdpProxy(url) {\n      if (!url) throw new Error('Parameter url needed');\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n\n        var dividedURL = (0, _utils.divideURL)(url);\n        var domainURL = dividedURL.domain;\n\n        if (_this.idpProxyList.hasOwnProperty(domainURL) && _this.idpProxyList[domainURL].status === STATUS.DEPLOYED) {\n          resolve(_this.idpProxyList[domainURL]);\n        } else {\n          // TODO: Optimize this\n          _this.idpProxyList[domainURL] = {\n            status: STATUS.PROGRESS\n          };\n          reject('requestUpdate couldn\\'t get the idpProxyURL');\n        }\n      });\n    }\n\n    /**\n    * To register a new Policy Enforcer in the runtime including as input parameters the function to postMessage, the HypertyURL associated with the PEP, which returns the RuntimeURL allocated to the new Policy Enforcer component.\n    * @param  {Message.Message} postMessage postMessage\n    * @param  {HypertyURL}          HypertyURL            hyperty\n    * @return {HypertyRuntimeURL}   HypertyRuntimeURL\n    */\n\n  }, {\n    key: 'registerPEP',\n    value: function registerPEP(postMessage, hyperty) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n        //TODO check what parameter in the postMessage the pep is.\n        _this.pepList[hyperty] = postMessage;\n        resolve('PEP registered with success');\n      });\n    }\n\n    /**\n    * To unregister a previously registered protocol stub\n    * @param  {HypertyRuntimeURL}   HypertyRuntimeURL     HypertyRuntimeURL\n    */\n\n  }, {\n    key: 'unregisterPEP',\n    value: function unregisterPEP(HypertyRuntimeURL) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n\n        var result = _this.pepList[HypertyRuntimeURL];\n\n        if (result === undefined) {\n          reject('Pep Not found.');\n        } else {\n          resolve('PEP successfully removed.');\n        }\n      });\n    }\n\n    /**\n    * To receive status events from components registered in the Registry.\n    * @param  {Message.Message}     Message.Message       event\n    */\n\n  }, {\n    key: 'onEvent',\n    value: function onEvent(event) {\n      // TODO body...\n      console.log('onEvent');\n    }\n\n    /**\n    * To discover sandboxes available in the runtime for a certain domain. Required by the runtime UA to avoid more than one sandbox for the same domain.\n    * @param  {DomainURL} DomainURL url\n    * @return {RuntimeSandbox}           RuntimeSandbox\n    */\n\n  }, {\n    key: 'getSandbox',\n    value: function getSandbox(url) {\n      if (!url) throw new Error('Parameter url needed');\n      console.log('getSandbox: ', url);\n\n      var _this = this;\n      return new _promise2.default(function (resolve, reject) {\n\n        var request = void 0;\n\n        //first try to find the url in the appSandbox list\n        request = _this.sandboxesList.appSandbox[url];\n\n        //if no appSandbox was found, try to search in the normal sandboxes list\n        if (!request) {\n          request = _this.sandboxesList.sandbox[url];\n\n          if (!request) {\n\n            var domain = (0, _utils.divideURL)(url).domain;\n\n            // search in the sandboxes list for a entry containing the domain given\n            for (var sandbox in _this.sandboxesList.sandbox) {\n              if (sandbox.includes(domain)) {\n                request = _this.sandboxesList.sandbox[sandbox];\n                break;\n              }\n            }\n          }\n        }\n\n        if (!request) {\n          reject('no sandbox found for: ' + url);\n        } else {\n          resolve(request);\n        }\n      });\n    }\n\n    /**\n    * To verify if source is valid and to resolve target runtime url address if needed (eg protostub runtime url in case the message is to be dispatched to a remote endpoint).\n    * @param  {URL.URL}  url       url\n    * @return {Promise<URL.URL>}                 Promise <URL.URL>\n    */\n\n  }, {\n    key: 'resolve',\n    value: function resolve(url) {\n      console.log('resolve ' + url);\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n\n        //split the url to find the domainURL. deals with the url for example as:\n        //\"hyperty-runtime://sp1/protostub/123\",\n        var dividedURL = (0, _utils.divideURL)(url);\n        var domainUrl = dividedURL.domain;\n        var type = dividedURL.type;\n\n        // resolve the domain protostub in case of a message to global registry\n        if (url.includes('global://registry')) {\n          domainUrl = _this._domain;\n        }\n\n        if (!domainUrl.indexOf('msg-node.') || !domainUrl.indexOf('registry.')) {\n          domainUrl = domainUrl.substring(domainUrl.indexOf('.') + 1);\n        }\n\n        var registredComponent = void 0;\n        if (type === 'domain-idp') {\n          registredComponent = _this.idpProxyList.hasOwnProperty(domainUrl) ? _this.idpProxyList[domainUrl] : false;\n        } else {\n          registredComponent = _this.protostubsList.hasOwnProperty(domainUrl) ? _this.protostubsList[domainUrl] : false;\n        }\n\n        if (registredComponent && registredComponent.hasOwnProperty('status') && registredComponent.status === STATUS.DEPLOYED) {\n          console.info('Resolved: ', registredComponent.url);\n          resolve(registredComponent.url);\n        } else {\n          if (type === 'domain-idp') {\n            // _this.trigger('runtime:loadIdpProxy', domainUrl);\n\n            _this._loader.loadIdpProxy(domainUrl).then(function (result) {\n              registredComponent = _this.idpProxyList[domainUrl];\n              console.info('Resolved IDPProxy: ', registredComponent, result);\n              _this.idpProxyList[domainUrl].status = STATUS.DEPLOYED;\n              resolve(registredComponent.url);\n            }).catch(function (reason) {\n              console.error('Error resolving IDPProxy: ', reason);\n              reject(reason);\n            });\n          } else {\n            // _this.trigger('runtime:loadStub', domainUrl);\n\n            _this._loader.loadStub(domainUrl).then(function (result) {\n              registredComponent = _this.protostubsList[domainUrl];\n              console.info('Resolved Protostub: ', registredComponent, result);\n              _this.protostubsList[domainUrl].status = STATUS.DEPLOYED;\n              resolve(registredComponent.url);\n            }).catch(function (reason) {\n              console.error('Error resolving Protostub: ', reason);\n              reject(reason);\n            });\n          }\n        }\n      });\n    }\n  }, {\n    key: 'loader',\n    set: function set(loader) {\n      var _this = this;\n      _this._loader = loader;\n    },\n    get: function get() {\n      var _this = this;\n      return _this._loader;\n    }\n\n    /**\n    * return the messageBus in this Registry\n    * @param {MessageBus}           messageBus\n    */\n\n  }, {\n    key: 'messageBus',\n    get: function get() {\n      var _this = this;\n      return _this._messageBus;\n    }\n\n    /**\n    * Set the messageBus in this Registry\n    * @param {MessageBus}           messageBus\n    */\n    ,\n    set: function set(messageBus) {\n      var _this = this;\n      _this._messageBus = messageBus;\n\n      _this._messageBus.addListener(_this.registryURL, function (msg) {\n\n        var userUrl = _this._getIdentityAssociated(msg.body.resource, msg.body.criteria);\n\n        var reply = { id: msg.id, type: 'response', to: msg.from, from: msg.to, body: { resource: userUrl } };\n        reply.body.code = userUrl ? 200 : 404;\n\n        _this._messageBus.postMessage(reply);\n      });\n\n      // also set up messageBus in the IdentityModule component\n      // TODO redefine a better way to add the messageBus in the IdModule\n      _this.idModule.messageBus = messageBus;\n\n      // Install AddressAllocation\n      var addressAllocation = new _AddressAllocation2.default(_this.registryURL, messageBus, _this);\n      _this.addressAllocation = addressAllocation;\n    }\n  }]);\n  return Registry;\n}();\n\nexports.default = Registry;\nmodule.exports = exports['default'];\n\n},{\"../allocation/AddressAllocation\":421,\"../utils/utils.js\":457,\"./HypertyInstance\":443,\"babel-runtime/core-js/promise\":12,\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16,\"service-framework/dist/MessageFactory\":420}],445:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require(\"babel-runtime/helpers/createClass\");\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n* Copyright 2016 PT Inovao e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n/**\n*   @author: Gil Dias (gil.dias@tecnico.ulisboa.pt)\n*   Registry Data Model includes all Objects to be handled by the Registry functionality including\n*/\nvar RegistryDataModel = function () {\n  function RegistryDataModel(id, url, descriptorURL, startingTime, lastModified, status, stubs, stubsConfiguration) {\n    (0, _classCallCheck3.default)(this, RegistryDataModel);\n\n    var _this = this;\n\n    _this._id = id;\n    _this._url = url;\n    _this._descriptorURL = descriptorURL;\n    _this._startingTime = startingTime;\n    _this._lastModified = lastModified;\n    _this._status = status;\n    _this._stubs = stubs;\n    _this._stubsConfiguration = stubsConfiguration;\n  }\n\n  (0, _createClass3.default)(RegistryDataModel, [{\n    key: \"id\",\n    get: function get() {\n      var _this = this;\n      return _this._id;\n    }\n  }, {\n    key: \"url\",\n    get: function get() {\n      var _this = this;\n      return _this._url;\n    }\n  }, {\n    key: \"descriptor\",\n    get: function get() {\n      var _this = this;\n      return _this._descriptorURL;\n    }\n  }]);\n  return RegistryDataModel;\n}();\n\nexports.default = RegistryDataModel;\nmodule.exports = exports[\"default\"];\n\n},{\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16}],446:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _utils = require('../utils/utils');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Descriptors = function () {\n  function Descriptors(runtimeURL, catalogue, runtimeConfiguration) {\n    (0, _classCallCheck3.default)(this, Descriptors);\n\n    if (!runtimeURL) throw Error('The descriptor need to know the runtime url to be used');\n    if (!catalogue) throw Error('The descriptor needs the catalogue instance');\n    if (!runtimeConfiguration) throw Error('The descriptor needs the runtime configuration');\n\n    this.runtimeConfiguration = runtimeConfiguration;\n    this.runtimeURL = runtimeURL;\n    this.catalogue = catalogue;\n  }\n\n  (0, _createClass3.default)(Descriptors, [{\n    key: 'getHypertyDescriptor',\n    value: function getHypertyDescriptor(hypertyURL) {\n      return this.catalogue.getHypertyDescriptor(hypertyURL);\n    }\n  }, {\n    key: 'getStubDescriptor',\n    value: function getStubDescriptor(stubURL) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n\n        var dividedURL = (0, _utils.divideURL)(stubURL);\n        var domain = dividedURL.domain;\n        var protostub = dividedURL.identity;\n        var protoStubURL = void 0;\n\n        var originDividedURL = (0, _utils.divideURL)(_this.runtimeURL);\n        var originDomain = originDividedURL.domain;\n\n        if (!domain) {\n          domain = idpProxyURL;\n        }\n\n        if (!protostub) {\n          protostub = 'default';\n        } else {\n          protostub = protostub.substring(protostub.lastIndexOf('/') + 1);\n        }\n\n        protoStubURL = (0, _utils.buildURL)(_this.runtimeConfiguration, 'catalogueURLs', 'protocolstub', protostub);\n        if (domain !== _this.runtimeConfiguration.domain) {\n          if (!stubURL.indexOf('https') || !stubURL.indexOf('hyperty-catalogue')) {\n            protoStubURL = stubURL;\n          } else {\n\n            // TODO: check how to load form different configuration domain\n            var resource = (0, _utils.getConfigurationResources)(_this.runtimeConfiguration, 'catalogueURLs', 'protocolstub');\n            protoStubURL = resource.prefix + domain + resource.suffix + protostub;\n          }\n        }\n\n        console.log('Load ProtocolStub for domain, ' + domain + ' : ', protoStubURL);\n        return _this.catalogue.getStubDescriptor(protoStubURL).then(function (result) {\n\n          resolve(result);\n        }).catch(function (error) {\n\n          console.log('Error: ', error);\n\n          protostub = domain;\n          domain = originDomain;\n\n          var resource = (0, _utils.getConfigurationResources)(_this.runtimeConfiguration, 'catalogueURLs', 'protocolstub');\n          protoStubURL = resource.prefix + domain + resource.suffix + protostub;\n\n          console.log('Fallback -> Load Protocolstub for domain, ' + domain + ' : ', protostub);\n          return _this.catalogue.getStubDescriptor(protoStubURL);\n        }).then(function (result) {\n          resolve(result);\n        }).catch(function (reason) {\n          reject(reason);\n        });\n      });\n    }\n  }, {\n    key: 'getIdpProxyDescriptor',\n    value: function getIdpProxyDescriptor(idpProxyURL) {\n      var _this2 = this;\n\n      return new _promise2.default(function (resolve, reject) {\n\n        var dividedURL = (0, _utils.divideURL)(idpProxyURL);\n        var domain = dividedURL.domain;\n        var idpproxy = dividedURL.identity;\n\n        var originDividedURL = (0, _utils.divideURL)(_this2.runtimeURL);\n        var originDomain = originDividedURL.domain;\n\n        if (!domain) {\n          domain = idpProxyURL;\n        }\n\n        if (domain === originDomain || !idpproxy) {\n          idpproxy = 'default';\n        } else {\n          idpproxy = idpproxy.substring(idpproxy.lastIndexOf('/') + 1);\n        }\n\n        var resource = (0, _utils.getConfigurationResources)(_this2.runtimeConfiguration, 'catalogueURLs', 'idpProxy');\n\n        idpProxyURL = resource.prefix + domain + resource.suffix + idpproxy;\n        console.log('Load Idp Proxy for domain, ' + domain + ' : ', idpProxyURL);\n        return _this2.catalogue.getIdpProxyDescriptor(idpProxyURL).then(function (result) {\n\n          resolve(result);\n        }).catch(function () {\n\n          idpproxy = domain;\n          domain = originDomain;\n\n          idpProxyURL = (0, _utils.buildURL)(_this2.runtimeConfiguration, 'catalogueURLs', 'idpProxy', idpproxy);\n\n          console.log('Load Idp Proxy for domain, ' + domain + ' : ', idpProxyURL);\n          return _this2.catalogue.getIdpProxyDescriptor(idpProxyURL);\n        }).then(function (result) {\n          resolve(result);\n        }).catch(function (reason) {\n          reject(reason);\n        });\n      });\n    }\n  }]);\n  return Descriptors;\n}();\n\nexports.default = Descriptors;\nmodule.exports = exports['default'];\n\n},{\"../utils/utils\":457,\"babel-runtime/core-js/promise\":12,\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16}],447:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _utils = require('../utils/utils');\n\nvar _Descriptors = require('./Descriptors');\n\nvar _Descriptors2 = _interopRequireDefault(_Descriptors);\n\nvar _AddressAllocation = require('../allocation/AddressAllocation');\n\nvar _AddressAllocation2 = _interopRequireDefault(_AddressAllocation);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Loader = function () {\n  function Loader(runtimeConfiguration) {\n    (0, _classCallCheck3.default)(this, Loader);\n\n    if (!runtimeConfiguration) throw Error('The descriptor need to know the runtime configuration');\n    this.runtimeConfiguration = runtimeConfiguration;\n  }\n\n  /**\n   * Set runtime url\n   * @param  {string} value runtimeURL\n   */\n\n\n  (0, _createClass3.default)(Loader, [{\n    key: 'loadHyperty',\n\n\n    /**\n    * Deploy Hyperty from Catalogue URL\n    * @param  {URL.HypertyCatalogueURL}    hyperty hypertyDescriptor url;\n    */\n    value: function loadHyperty(hypertyDescriptorURL) {\n      var _this = this;\n\n      if (!this._readyToUse()) return false;\n      if (!hypertyDescriptorURL) throw new Error('Hyperty descriptor url parameter is needed');\n\n      return new _promise2.default(function (resolve, reject) {\n\n        var _hypertyURL = void 0;\n        var _hypertySandbox = void 0;\n        var _hypertyDescriptor = void 0;\n        var _hypertySourcePackage = void 0;\n        var haveError = false;\n\n        var errorReason = function errorReason(reason) {\n          console.error('Something failed on the deploy hyperty: ', reason);\n          reject(reason);\n        };\n\n        var handleError = function handleError(reason) {\n          haveError = true;\n          reject(reason);\n        };\n\n        // Get Hyperty descriptor\n        // TODO: the request Module should be changed,\n        // because at this moment it is incompatible with nodejs;\n        // Probably we need to pass a factory like we do for sandboxes;\n        console.info('------------------ Hyperty ------------------------');\n        console.info('Get hyperty descriptor for :', hypertyDescriptorURL);\n        return _this.descriptors.getHypertyDescriptor(hypertyDescriptorURL).then(function (hypertyDescriptor) {\n          // at this point, we have completed \"step 2 and 3\" as shown in https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-hyperty.md\n          console.info('1: return hyperty descriptor');\n\n          // hyperty contains the full path of the catalogue URL, e.g.\n          // catalogue.rethink.eu/.well-known/..........\n          _hypertyDescriptor = hypertyDescriptor;\n\n          var sourcePackageURL = hypertyDescriptor.sourcePackageURL;\n\n          if (sourcePackageURL === '/sourcePackage') {\n            return hypertyDescriptor.sourcePackage;\n          }\n\n          // Get the hyperty source code\n          return _this.runtimeCatalogue.getSourcePackageFromURL(sourcePackageURL);\n        }, handleError).then(function (sourcePackage) {\n          if (haveError) return false;\n\n          console.info('2: return hyperty source code');\n\n          // at this point, we have completed \"step 4 and 5\" as shown in https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-hyperty.md\n\n          _hypertySourcePackage = sourcePackage;\n\n          //\n          // steps 6 -- 9 are skipped.\n          // TODO: on release of core 0.2;\n          // TODO: Promise to check the policy engine\n\n          // mock-up code;\n          // temporary code, only\n          var policy = true;\n\n          return policy;\n        }, handleError).then(function (policyResult) {\n          if (haveError) return false;\n          console.info('3: return policy engine result' + policyResult);\n\n          // we have completed step 6 to 9 of https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-hyperty.md right now.\n          //\n          // Steps 6 -- 9\n          // As a result of the sipped steps, we know at this point if we execute\n          // inSameSandbox or not.\n          //\n\n          // For testing, just assume we execute in same Sandbox.\n          var inSameSandbox = true;\n          var sandbox = void 0;\n\n          if (inSameSandbox) {\n\n            // this don't need be a Promise;\n            sandbox = _this.registry.getAppSandbox();\n\n            // we have completed step 11 here.\n          } else {\n\n            var domain = (0, _utils.divideURL)(hypertyDescriptorURL).domain;\n\n            // getSandbox, this will return a promise;\n            sandbox = _this.registry.getSandbox(domain);\n          }\n\n          // this will return the sandbox or one promise to getSandbox;\n          return sandbox;\n        }, handleError).then(function (sandbox) {\n          if (haveError) return false;\n          console.info('4: return the sandbox', sandbox);\n\n          // Return the sandbox indepentely if it running in the same sandbox or not\n          // we have completed step 14 here.\n          return sandbox;\n        }, function (reason) {\n          if (haveError) return false;\n          console.error('4.1: Try to register a new sandbox');\n\n          // check if the sandbox is registed for this hyperty descriptor url;\n          // Make Steps xxx --- xxx\n          // Instantiate the Sandbox\n          var sandbox = _this._runtimeFactory.createSandbox();\n\n          sandbox.addListener('*', function (msg) {\n            _this.messageBus.postMessage(msg);\n          });\n\n          return sandbox;\n        }, handleError).then(function (sandbox) {\n          if (haveError) return false;\n          console.info('5: return sandbox and register');\n\n          _hypertySandbox = sandbox;\n\n          var numberOfAddresses = 1;\n          return _this._addressAllocation.create(_this._registry._domain, numberOfAddresses, _hypertyDescriptor, 'hyperty');\n        }, handleError).then(function (addresses) {\n          if (haveError) return false;\n          console.info('6: return the addresses for the hyperty');\n\n          // Register hyperty\n          return _this.registry.registerHyperty(_hypertySandbox, hypertyDescriptorURL, _hypertyDescriptor, addresses);\n        }, handleError).then(function (hypertyURL) {\n          if (haveError) return false;\n          console.info('7: Hyperty url, after register hyperty', hypertyURL);\n\n          // we have completed step 16 of https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-hyperty.md right now.\n          _hypertyURL = hypertyURL;\n\n          // Extend original hyperty configuration;\n          var configuration = {};\n          if (!(0, _utils.emptyObject)(_hypertyDescriptor.configuration)) {\n            try {\n              configuration = (0, _assign2.default)({}, JSON.parse(_hypertyDescriptor.configuration));\n            } catch (e) {\n              configuration = _hypertyDescriptor.configuration;\n            }\n          }\n          configuration.runtimeURL = _this._runtimeURL;\n\n          // We will deploy the component - step 17 of https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-hyperty.md right now.\n\n          try {\n            return _hypertySandbox.deployComponent(_hypertySourcePackage.sourceCode, _hypertyURL, configuration);\n          } catch (e) {\n            console.error('Error on deploy component:', e);\n            reject(e);\n          }\n        }, handleError).then(function (deployComponentStatus) {\n          if (haveError) return false;\n          console.info('8: Deploy component status for hyperty: ', deployComponentStatus);\n\n          // we have completed step 19 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-hyperty.md right now.\n\n          // Add the message bus listener to the appSandbox or hypertSandbox;\n          _this.messageBus.addListener(_hypertyURL, function (msg) {\n            _hypertySandbox.postMessage(msg);\n          });\n\n          // we have completed step 20 of https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-hyperty.md right now.\n          var hyperty = {\n            runtimeHypertyURL: _hypertyURL,\n            status: deployComponentStatus\n          };\n\n          resolve(hyperty);\n\n          // we have completed step 21 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-hyperty.md right now.\n          console.info('------------------ END ------------------------');\n        }, handleError).catch(errorReason);\n      });\n    }\n\n    /**\n    * Deploy Stub from Catalogue URL or domain url\n    * @param  {URL.URL}     domain          domain\n    */\n\n  }, {\n    key: 'loadStub',\n    value: function loadStub(protostubURL) {\n      var _this2 = this;\n\n      if (!this._readyToUse()) return false;\n      if (!protostubURL) throw new Error('ProtoStub descriptor url parameter is needed');\n\n      return new _promise2.default(function (resolve, reject) {\n\n        var domain = (0, _utils.divideURL)(protostubURL).domain;\n\n        if (!domain) {\n          domain = protostubURL;\n        }\n\n        var _stubSandbox = void 0;\n        var _stubDescriptor = void 0;\n        var _runtimeProtoStubURL = void 0;\n        var _stubSourcePackage = void 0;\n        var haveError = false;\n\n        var errorReason = function errorReason(reason) {\n          console.error('Something failed on the deploy of protocolstub: ', reason);\n          reject(reason);\n        };\n\n        var handleError = function handleError(reason) {\n          haveError = true;\n          reject(reason);\n        };\n\n        // Discover Protocol Stub\n        console.info('------------------- ProtoStub ---------------------------\\n');\n        console.info('Discover or Create a new ProtoStub for domain: ', domain);\n        _this2.registry.discoverProtostub(domain).then(function (runtimeProtoStubURL) {\n          // Is registed?\n          console.info('1. Proto Stub Discovered for ', domain, ': ', runtimeProtoStubURL);\n\n          // we have completed step 2 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\n\n          // TODO: Check if the status is saved in the status of sandbox;\n          // let stub = {\n          //   runtimeProtoStubURL: runtimeProtoStubURL,\n          //   status: 'deployed'\n          // };\n          var stub = _this2.registry.protostubsList[domain];\n          resolve(stub);\n          console.info('------------------- END ---------------------------\\n');\n        }).catch(function (reason) {\n\n          // is not registed?\n          console.info('1. Proto Stub not found ' + reason);\n\n          // we have completed step 3 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\n\n          // we need to get ProtoStub descriptor step 4 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\n          _this2.descriptors.getStubDescriptor(protostubURL).then(function (stubDescriptor) {\n            if (haveError) return false;\n            console.info('2. return the ProtoStub descriptor');\n\n            // we have completed step 5 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\n            _stubDescriptor = stubDescriptor;\n\n            var sourcePackageURL = stubDescriptor.sourcePackageURL;\n\n            if (sourcePackageURL === '/sourcePackage') {\n              return stubDescriptor.sourcePackage;\n            }\n\n            // we need to get ProtoStub Source code from descriptor - step 6 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\n            return _this2.runtimeCatalogue.getSourcePackageFromURL(sourcePackageURL);\n          }, handleError).catch(errorReason).then(function (stubSourcePackage) {\n            if (haveError) return false;\n            console.info('3. return the ProtoStub Source Code');\n\n            // we have completed step 7 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\n\n            _stubSourcePackage = stubSourcePackage;\n\n            // TODO: Check on PEP (policy Engine) if we need the sandbox and check if the Sandbox Factory have the context sandbox;\n            var policy = true;\n            return policy;\n          }, handleError).then(function (policy) {\n            if (haveError) return false;\n\n            // this will return the sandbox or one promise to getSandbox;\n            return _this2.registry.getSandbox(domain);\n          }).then(function (stubSandbox) {\n            if (haveError) return false;\n            console.info('4. if the sandbox is registered then return the sandbox ', stubSandbox);\n\n            // we have completed step xxx https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\n\n            _stubSandbox = stubSandbox;\n            return stubSandbox;\n          }).catch(function (reason) {\n            if (haveError) return false;\n            console.info('5. Sandbox was not found, creating a new one ', reason);\n\n            // check if the sandbox is registed for this stub descriptor url;\n            // Make Steps xxx --- xxx\n            // Instantiate the Sandbox\n            var sandbox = _this2._runtimeFactory.createSandbox();\n            sandbox.addListener('*', function (msg) {\n              _this2.messageBus.postMessage(msg);\n            });\n\n            return sandbox;\n          }).then(function (sandbox) {\n            if (haveError) return false;\n            console.info('6. return the sandbox instance and register', sandbox, 'to domain ', domain);\n\n            _stubSandbox = sandbox;\n\n            // we need register stub on registry - step xxx https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\n            return _this2.registry.registerStub(_stubSandbox, domain);\n          }, handleError).then(function (runtimeProtoStubURL) {\n            if (haveError) return false;\n            console.info('7. return the runtime protostub url: ', runtimeProtoStubURL);\n\n            // we have completed step xxx https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\n\n            _runtimeProtoStubURL = runtimeProtoStubURL;\n\n            // Extend original hyperty configuration;\n            var configuration = {};\n            if (!(0, _utils.emptyObject)(_stubDescriptor.configuration)) {\n              try {\n                configuration = (0, _assign2.default)({}, JSON.parse(_stubDescriptor.configuration));\n              } catch (e) {\n                configuration = _stubDescriptor.configuration;\n              }\n            }\n\n            configuration.runtimeURL = _this2._runtimeURL;\n\n            // Deploy Component step xxx\n            try {\n              return _stubSandbox.deployComponent(_stubSourcePackage.sourceCode, runtimeProtoStubURL, configuration);\n            } catch (e) {\n              console.error('Error on deploy component:', e);\n              reject(e);\n            }\n          }, handleError).then(function (deployComponentStatus) {\n            if (haveError) return false;\n            console.info('8: return deploy component for sandbox status: ', deployComponentStatus);\n\n            // we have completed step xxx https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\n\n            // Add the message bus listener\n            _this2.messageBus.addListener(_runtimeProtoStubURL, function (msg) {\n              _stubSandbox.postMessage(msg);\n            });\n\n            // we have completed step xxx https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\n            var stub = _this2.registry.protostubsList[domain];\n\n            // // Load Stub function resolved with success;\n            // let stub = {\n            //   runtimeProtoStubURL: _runtimeProtoStubURL,\n            //   status: deployComponentStatus\n            // };\n\n            console.log('Deployed: ', stub, domain, _this2.registry.protostubsList);\n\n            resolve(stub);\n            console.info('------------------- END ---------------------------\\n');\n          }, handleError).catch(errorReason);\n        });\n      });\n    }\n\n    /**\n    * Deploy idpProxy from Catalogue URL or domain url\n    * @param  {URL.URL}     domain          domain\n    */\n\n  }, {\n    key: 'loadIdpProxy',\n    value: function loadIdpProxy(idpProxyURL) {\n      var _this3 = this;\n\n      if (!this._readyToUse()) return false;\n      if (!idpProxyURL) throw new Error('IdpProxy descriptor url parameter is needed');\n\n      return new _promise2.default(function (resolve, reject) {\n\n        var domain = (0, _utils.divideURL)(idpProxyURL).domain;\n\n        if (!domain) {\n          domain = idpProxyURL;\n        }\n\n        var _proxySandbox = void 0;\n        var _proxyDescriptor = void 0;\n        var _runtimeIdpProxyURL = void 0;\n        var _proxySourcePackage = void 0;\n        var haveError = false;\n\n        var errorReason = function errorReason(reason) {\n          console.error('Something failed on the deploy of IdpProxy: ', reason);\n          reject(reason);\n        };\n\n        var handleError = function handleError(reason) {\n          haveError = true;\n          reject(reason);\n        };\n\n        // Discover IDPProxy\n        console.info('------------------- IDP Proxy Deploy ---------------------------\\n');\n        console.info('Discover or Create a new IdpProxy for domain/URL: ', domain);\n        return _this3.registry.discoverIdpProxy(domain).then(function (runtimeIdpProxyURL) {\n          // Is registed?\n          console.info('1. IDPProxy Discovered: ', runtimeIdpProxyURL);\n\n          // we have completed step 2 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\n\n          var idpProxy = _this3.registry.idpProxyList[domain];\n          console.log('Deployed: ', idpProxy);\n\n          resolve(idpProxy);\n          console.info('------------------- END ---------------------------\\n');\n        }).catch(function (reason) {\n\n          // is not registed?\n          console.info('1. IdpProxy not found:', reason);\n\n          // we have completed step 3 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\n\n          // we need to get ProtoStub descriptor step 4 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\n          _this3.descriptors.getIdpProxyDescriptor(idpProxyURL).then(function (proxyDescriptor) {\n\n            console.info('2. Return the IDPProxy descriptor');\n\n            // we have completed step 5 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\n            _proxyDescriptor = proxyDescriptor;\n\n            var sourcePackageURL = proxyDescriptor.sourcePackageURL;\n\n            if (sourcePackageURL === '/sourcePackage') {\n              return proxyDescriptor.sourcePackage;\n            }\n\n            // we need to get ProtoStub Source code from descriptor - step 6 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\n            return _this3.runtimeCatalogue.getSourcePackageFromURL(sourcePackageURL);\n          }, handleError).then(function (sourcePackage) {\n            if (haveError) return false;\n            console.info('3. return the IDPProxy source package');\n\n            // we have completed step 7 https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\n\n            _proxySourcePackage = sourcePackage;\n\n            // TODO: Check on PEP (policy Engine) if we need the sandbox and check if the Sandbox Factory have the context sandbox;\n            var policy = true;\n            return policy;\n          }, handleError).then(function (policy) {\n            if (haveError) return false;\n\n            // this will return the sandbox or one promise to getSandbox;\n            return _this3.registry.getSandbox(domain);\n          }).then(function (proxySandbox) {\n            if (haveError) return false;\n            console.info('4. if the sandbox is registered then return the sandbox', proxySandbox);\n\n            _proxySandbox = proxySandbox;\n            return proxySandbox;\n          }).catch(function (reason) {\n            if (haveError) return false;\n            console.info('5. Sandbox was not found, creating a new one', reason);\n\n            // check if the sandbox is registed for this proxy descriptor url;\n            // Make Steps xxx --- xxx\n            // Instantiate the Sandbox\n            var sandbox = _this3._runtimeFactory.createSandbox();\n            sandbox.addListener('*', function (msg) {\n              _this3.messageBus.postMessage(msg);\n            });\n\n            return sandbox;\n          }).then(function (sandbox) {\n            if (haveError) return false;\n            console.info('6. return the sandbox instance and register', sandbox, 'to domain ', domain);\n\n            _proxySandbox = sandbox;\n\n            // we need register stub on registry - step xxx https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\n            return _this3.registry.registerIdpProxy(sandbox, domain);\n          }, handleError).then(function (runtimeIdpProxyURL) {\n            if (haveError) return false;\n            console.info('7. Return the runtime Idp Proxy URL: ', runtimeIdpProxyURL);\n\n            // we have completed step xxx https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\n\n            _runtimeIdpProxyURL = runtimeIdpProxyURL;\n\n            // Extend original hyperty configuration;\n            var configuration = {};\n            if (!(0, _utils.emptyObject)(_proxyDescriptor.configuration)) {\n              try {\n                configuration = (0, _assign2.default)({}, JSON.parse(_proxyDescriptor.configuration));\n              } catch (e) {\n                configuration = _proxyDescriptor.configuration;\n              }\n            }\n            configuration.runtimeURL = _this3._runtimeURL;\n\n            // Deploy Component step xxx\n            try {\n              return _proxySandbox.deployComponent(_proxySourcePackage.sourceCode, runtimeIdpProxyURL, configuration);\n            } catch (e) {\n              console.error('Error on deploy component:', e);\n              reject(e);\n            }\n          }, handleError).then(function (deployComponentStatus) {\n            if (haveError) return false;\n            console.info('8: return deploy component for sandbox status: ', deployComponentStatus);\n\n            // we have completed step xxx https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\n\n            // Add the message bus listener\n            _this3.messageBus.addListener(_runtimeIdpProxyURL, function (msg) {\n              _proxySandbox.postMessage(msg);\n            });\n\n            // we have completed step xxx https://github.com/reTHINK-project/core-framework/blob/master/docs/specs/runtime/dynamic-view/basics/deploy-protostub.md\n\n            // Load Stub function resolved with success;\n            // let idpProxy = {\n            //   runtimeIdpProxyURL: _runtimeIdpProxyURL,\n            //   status: deployComponentStatus\n            // };\n\n            _this3.registry.idpProxyList[domain].status = 'deployed';\n            var idpProxy = _this3.registry.idpProxyList[domain];\n\n            console.log('Deployed: ', idpProxy);\n\n            resolve(idpProxy);\n            console.info('------------------- END ---------------------------\\n');\n          }, handleError).catch(errorReason);\n        });\n      });\n    }\n\n    // Check if the loader is ready to load all components\n\n  }, {\n    key: '_readyToUse',\n    value: function _readyToUse() {\n\n      var status = false;\n\n      if (!this._runtimeURL) throw new Error('The loader need the runtime url address');\n      if (!this._messagesBus) throw new Error('The loader need the messageBus component');\n      if (!this._runtimeCatalogue) throw new Error('The loader need the runtimeCatalogue component');\n      if (!this._registry) throw new Error('The loader need the registry component');\n      if (!this._runtimeFactory) throw new Error('The loader need the runtime factory component');\n\n      status = true;\n      return status;\n    }\n  }, {\n    key: 'runtimeURL',\n    set: function set(value) {\n      this._runtimeURL = value;\n    }\n\n    /**\n     * Get runtime url\n     * @return {string} value runtimeURL\n     */\n    ,\n    get: function get() {\n      return this._runtimeURL;\n    }\n\n    /**\n     * Set Registry component\n     * @param  {Registry} value Registry Component\n     */\n\n  }, {\n    key: 'registry',\n    set: function set(value) {\n      this._registry = value;\n\n      // Install AddressAllocation\n      var addressAllocation = new _AddressAllocation2.default(this._runtimeURL, this._messagesBus, this._registry);\n      this._addressAllocation = addressAllocation;\n    }\n\n    /**\n     * Get Registry component\n     * @return {Registry} Registry component\n     */\n    ,\n    get: function get() {\n      return this._registry;\n    }\n\n    /**\n     * Set Runtime Catalogue Component\n     * @param  {RuntimeCatalogue} value runtime catalogue component\n     */\n\n  }, {\n    key: 'runtimeCatalogue',\n    set: function set(value) {\n      this._runtimeCatalogue = value;\n\n      this.descriptors = new _Descriptors2.default(this._runtimeURL, value, this.runtimeConfiguration);\n    }\n\n    /**\n     * Get Runtime Catalogue component\n     * @return {RuntimeCatalogue} Runtime Catalogue component\n     */\n    ,\n    get: function get() {\n      return this._runtimeCatalogue;\n    }\n\n    /**\n     * Set Message Bus component\n     * @param  {MessageBus} value Message bus component\n     */\n\n  }, {\n    key: 'messageBus',\n    set: function set(value) {\n      this._messagesBus = value;\n    }\n\n    /**\n     * Get Message Bus component\n     * @return {MessageBus} Message Bus component\n     */\n    ,\n    get: function get() {\n      return this._messagesBus;\n    }\n\n    /**\n     * Set Runtime Factory component\n     * @param  {runtimeFactory} value Factory includes the specific implementations for each environment\n     */\n\n  }, {\n    key: 'runtimeFactory',\n    set: function set(value) {\n      this._runtimeFactory = value;\n    }\n\n    /**\n     * Get Runtime Factory component\n     * @return {runtimeFactory} Runtime Factory component\n     */\n    ,\n    get: function get() {\n      return this._runtimeFactory;\n    }\n  }]);\n  return Loader;\n}();\n\nexports.default = Loader;\nmodule.exports = exports['default'];\n\n},{\"../allocation/AddressAllocation\":421,\"../utils/utils\":457,\"./Descriptors\":446,\"babel-runtime/core-js/object/assign\":4,\"babel-runtime/core-js/promise\":12,\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16}],448:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nrequire('babel-polyfill');\n\nvar _Registry = require('../registry/Registry');\n\nvar _Registry2 = _interopRequireDefault(_Registry);\n\nvar _IdentityModule = require('../identity/IdentityModule');\n\nvar _IdentityModule2 = _interopRequireDefault(_IdentityModule);\n\nvar _PEP = require('../policy/PEP');\n\nvar _PEP2 = _interopRequireDefault(_PEP);\n\nvar _MessageBus = require('../bus/MessageBus');\n\nvar _MessageBus2 = _interopRequireDefault(_MessageBus);\n\nvar _utils = require('../utils/utils');\n\nvar _Loader = require('./Loader');\n\nvar _Loader2 = _interopRequireDefault(_Loader);\n\nvar _runtimeConfiguration = require('./runtimeConfiguration');\n\nvar _SyncherManager = require('../syncher/SyncherManager');\n\nvar _SyncherManager2 = _interopRequireDefault(_SyncherManager);\n\nvar _RuntimeCoreCtx = require('../policy/context/RuntimeCoreCtx');\n\nvar _RuntimeCoreCtx2 = _interopRequireDefault(_RuntimeCoreCtx);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Runtime User Agent Interface will process all the dependecies of the core runtime;\n * @author Vitor Silva [vitor-t-silva@telecom.pt]\n * @version 0.4.0\n *\n * @property {runtimeFactory} runtimeFactory - Specific implementation for all environments;\n * @property {RuntimeCatalogue} runtimeCatalogue - Catalogue of components can be installed;\n * @property {runtimeURL} runtimeURL - This identify the core runtime, should be unique;\n * @property {IdentityModule} identityModule - Identity Module;\n * @property {PEP} policyEngine - Policy Engine Module;\n * @property {Registry} registry - Registry Module;\n * @property {MessageBus} messageBus - Message Bus is used like a router to redirect the messages from one component to other(s)\n * @property {GraphConnector} graphConnector - Graph Connector handling GUID and contacts\n */\n\n// import GraphConnector from '../graphconnector/GraphConnector';\n\n/**\n* Copyright 2016 PT Inovao e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n\nvar RuntimeUA = function () {\n\n  /**\n   * Create a new instance of Runtime User Agent\n   * @param {runtimeFactory} runtimeFactory - Specific implementation for the environment where the core runtime will run;\n   * @param {domain} domainURL - specify the domain base for the runtime;\n   */\n  function RuntimeUA(runtimeFactory, domain) {\n    (0, _classCallCheck3.default)(this, RuntimeUA);\n\n\n    if (!runtimeFactory) throw new Error('The sandbox factory is a needed parameter');\n    if (!domain) throw new Error('You need the domain of runtime');\n\n    // Configuration object with information related with servers\n    this.runtimeConfiguration = (0, _assign2.default)({ domain: domain }, _runtimeConfiguration.runtimeConfiguration);\n\n    this.runtimeFactory = runtimeFactory;\n    this.runtimeCatalogue = runtimeFactory.createRuntimeCatalogue();\n\n    if (typeof runtimeFactory.createRuntimeCatalogue === 'function') {\n      this.persistenceManager = runtimeFactory.createRuntimeCatalogue();\n    } else {\n      throw new Error('Check your Runtime Factory because it need the Runtime Catalogue implementation');\n    }\n\n    if (typeof runtimeFactory.persistenceManager === 'function') {\n      this.persistenceManager = runtimeFactory.persistenceManager();\n    } else {\n      throw new Error('Check your Runtime Factory because it need the Persistence Manager implementation');\n    }\n\n    if (typeof runtimeFactory.storageManager === 'function') {\n      this.storageManager = runtimeFactory.storageManager();\n    } else {\n      throw new Error('Check your Runtime Factory because it need the Storage Manager implementation');\n    }\n    if (typeof runtimeFactory.runtimeCapabilities === 'function') {\n      this.runtimeCapabilities = runtimeFactory.runtimeCapabilities(this.storageManager);\n    } else {\n      console.info('Check your RuntimeFactory because it need the Runtime Capabilities implementation');\n    }\n  }\n\n  (0, _createClass3.default)(RuntimeUA, [{\n    key: 'init',\n    value: function init() {\n      var _this2 = this;\n\n      return new _promise2.default(function (resolve, reject) {\n\n        _this2.domain = _this2.runtimeConfiguration.domain;\n\n        try {\n          var getCapabilities = _this2.runtimeCapabilities.getRuntimeCapabilities();\n          var getRuntimeURL = _this2.storageManager.get('runtime:URL');\n\n          _promise2.default.all([getRuntimeURL, getCapabilities]).then(function (results) {\n\n            _this2.runtimeURL = results[0] ? results[0].runtimeURL : results[0];\n            if (!_this2.runtimeURL) {\n              _this2.runtimeURL = 'runtime://' + _this2.domain + '/' + (0, _utils.generateGUID)();\n              _this2.storageManager.set('runtime:URL', 1, { runtimeURL: _this2.runtimeURL });\n            }\n\n            _this2.capabilities = results[1];\n\n            return _this2._loadComponents();\n          }).then(function (status) {\n            resolve(status);\n          }).catch(function (error) {\n            console.error('ERROR: ', error);\n            reject(error);\n          });\n        } catch (e) {\n          reject(e);\n        }\n      });\n    }\n  }, {\n    key: '_loadComponents',\n    value: function _loadComponents() {\n      var _this3 = this;\n\n      return new _promise2.default(function (resolve, reject) {\n\n        try {\n\n          // Prepare the loader to load the hyperties, protostubs and idpproxy;\n          _this3.loader = new _Loader2.default(_this3.runtimeConfiguration);\n\n          // Instantiate the identity Module\n          _this3.identityModule = new _IdentityModule2.default(_this3.runtimeURL, _this3.runtimeCapabilities, _this3.storageManager);\n\n          // Use the sandbox factory to create an AppSandbox;\n          // In the future can be decided by policyEngine if we need\n          // create a AppSandbox or not;\n          var appSandbox = _this3.runtimeFactory.createAppSandbox();\n\n          // Instantiate the Registry Module\n          _this3.registry = new _Registry2.default(_this3.runtimeURL, appSandbox, _this3.identityModule, _this3.runtimeCatalogue, _this3.runtimeCapabilities, _this3.storageManager);\n\n          // Set the loader to load Hyperties, Stubs and IdpProxies\n          _this3.registry.loader = _this3.loader;\n\n          // Instantiate the Message Bus\n          _this3.messageBus = new _MessageBus2.default(_this3.registry);\n\n          // Instantiate the Policy Engine\n          _this3.policyEngine = new _PEP2.default(new _RuntimeCoreCtx2.default(_this3.identityModule, _this3.registry, _this3.storageManager));\n\n          _this3.messageBus.pipeline.handlers = [\n\n          // Policy message authorise\n          function (ctx) {\n            _this3.policyEngine.authorise(ctx.msg).then(function (changedMgs) {\n              ctx.msg = changedMgs;\n              ctx.next();\n            }).catch(function (reason) {\n              console.error(reason);\n              ctx.fail(reason);\n            });\n          }];\n\n          // Add to App Sandbox the listener;\n          appSandbox.addListener('*', function (msg) {\n            _this3.messageBus.postMessage(msg);\n          });\n\n          // Register messageBus on Registry\n          _this3.registry.messageBus = _this3.messageBus;\n\n          // Register registry on IdentityModule\n          _this3.identityModule.registry = _this3.registry;\n\n          // Use sandbox factory to use specific methods\n          // and set the message bus to the factory\n          _this3.runtimeFactory.messageBus = _this3.messageBus;\n\n          // Instanciate the SyncherManager;\n          _this3.syncherManager = new _SyncherManager2.default(_this3.runtimeURL, _this3.messageBus, _this3.registry, _this3.runtimeCatalogue, _this3.storageManager);\n\n          // Set into loader the needed components;\n          _this3.loader.runtimeURL = _this3.runtimeURL;\n          _this3.loader.messageBus = _this3.messageBus;\n          _this3.loader.registry = _this3.registry;\n          _this3.loader.runtimeCatalogue = _this3.runtimeCatalogue;\n          _this3.loader.runtimeFactory = _this3.runtimeFactory;\n\n          // Instantiate the Graph Connector\n          // _this.graphConnector = new GraphConnector(_this.runtimeURL, _this.messageBus);\n\n          resolve(true);\n        } catch (e) {\n          reject(e);\n        }\n      });\n    }\n\n    /**\n    * Deploy Hyperty from Catalogue URL\n    * @param  {URL.HypertyCatalogueURL}    hyperty hypertyDescriptor url;\n    */\n\n  }, {\n    key: 'loadHyperty',\n    value: function loadHyperty(hypertyDescriptorURL) {\n      var _this4 = this;\n\n      if (!hypertyDescriptorURL) throw new Error('Hyperty descriptor url parameter is needed');\n\n      return new _promise2.default(function (resolve, reject) {\n\n        _this4.loader.loadHyperty(hypertyDescriptorURL).then(function (result) {\n          resolve(result);\n        }).catch(function (reason) {\n          reject(reason);\n        });\n      });\n    }\n\n    /**\n    * Deploy Stub from Catalogue URL or domain url\n    * @param  {URL.URL}     domain          domain\n    */\n\n  }, {\n    key: 'loadStub',\n    value: function loadStub(protostubURL) {\n      var _this5 = this;\n\n      if (!protostubURL) throw new Error('ProtoStub descriptor url parameter is needed');\n\n      return new _promise2.default(function (resolve, reject) {\n\n        _this5.loader.loadStub(protostubURL).then(function (result) {\n          resolve(result);\n        }).catch(function (reason) {\n          reject(reason);\n        });\n      });\n    }\n\n    /**\n    * Deploy idpProxy from Catalogue URL or domain url\n    * @param  {URL.URL}     domain          domain\n    */\n\n  }, {\n    key: 'loadIdpProxy',\n    value: function loadIdpProxy(idpProxyURL) {\n      var _this6 = this;\n\n      if (!idpProxyURL) throw new Error('The IDP Proxy URL is a needed parameter, could be a DOMAIN or a URL');\n\n      return new _promise2.default(function (resolve, reject) {\n        _this6.loader.loadIdpProxy(idpProxyURL).then(function (result) {\n          resolve(result);\n        }).catch(function (reason) {\n          reject(reason);\n        });\n      });\n    }\n\n    /**\n     * Used to close all the runtime; Unregister all hyperties;\n     * @return {Promise<Boolean>} result of the close method, with true or false to the operation success;\n     */\n\n  }, {\n    key: 'close',\n    value: function close() {\n      var _this = this;\n\n      console.info('Unregister all hyperties');\n      return new _promise2.default(function (resolve, reject) {\n\n        _this.registry.unregisterAllHyperties().then(function (result) {\n          console.info('All the hyperties are unregisted with Success:', result);\n          resolve(true);\n        }).catch(function (reason) {\n          console.error('Failed to unregister the hyperties', reason);\n          reject(false);\n        });\n      });\n    }\n  }]);\n  return RuntimeUA;\n}();\n\n//Main dependecies\n\n\nexports.default = RuntimeUA;\nmodule.exports = exports['default'];\n\n},{\"../bus/MessageBus\":423,\"../identity/IdentityModule\":428,\"../policy/PEP\":432,\"../policy/context/RuntimeCoreCtx\":442,\"../registry/Registry\":444,\"../syncher/SyncherManager\":454,\"../utils/utils\":457,\"./Loader\":447,\"./runtimeConfiguration\":449,\"babel-polyfill\":1,\"babel-runtime/core-js/object/assign\":4,\"babel-runtime/core-js/promise\":12,\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16}],449:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar runtimeConfiguration = exports.runtimeConfiguration = {\n\n  runtimeURLS: {\n    registry: {\n      prefix: 'hyperty-runtime://',\n      suffix: 'registry'\n    },\n    identityModule: {\n      prefix: 'hyperty-runtime://',\n      suffix: '/idm'\n    },\n    runtimeUA: {\n      prefix: 'hyperty-runtime://',\n      suffix: '/ua'\n    },\n    catalogue: {\n      prefix: 'hyperty-runtime://',\n      suffix: '/catalogue'\n    },\n    graphConnector: {\n      prefix: 'hyperty-runtime://',\n      suffix: '/graph'\n    },\n    syncManager: {\n      prefix: 'hyperty-runtime://',\n      suffix: '/sm'\n    }\n  },\n  catalogueURLs: {\n    protocolstub: {\n      prefix: 'hyperty-catalogue://catalogue.',\n      suffix: '/.well-known/protocolstub/',\n      fallback: 'hyperty-catalogue://catalogue.%domain%/.well-known/protocolstub/'\n    },\n    idpProxy: {\n      prefix: 'hyperty-catalogue://catalogue.',\n      suffix: '/.well-known/idp-proxy/',\n      fallback: 'hyperty-catalogue://catalogue.%domain%/.well-known/idp-proxy/'\n    }\n  },\n  msgNodeURL: {\n    prefix: 'domain://msg-node.',\n    suffix: '',\n    hypertyAddressAllocation: '/hyperty-address-allocation',\n    objectAddressAllocation: '/object-address-allocation',\n    subscriptionManagement: '/sm'\n  },\n  domainRegistryURL: {\n    prefix: 'domain://registry.',\n    suffix: ''\n  },\n  globalRegistryURL: 'global://registry.'\n};\n\n},{}],450:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _utils = require('../utils/utils');\n\nvar _Subscription = require('./Subscription');\n\nvar _Subscription2 = _interopRequireDefault(_Subscription);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ObserverObject = function () {\n  function ObserverObject(parent, url, childrens) {\n    (0, _classCallCheck3.default)(this, ObserverObject);\n\n    var _this = this;\n\n    _this._parent = parent;\n    _this._url = url;\n    _this._childrens = childrens;\n\n    _this._storageManager = parent._storageManager;\n\n    _this._bus = parent._bus;\n\n    _this._subscriptions = {};\n    _this._storageSubscriptions = {};\n  }\n\n  (0, _createClass3.default)(ObserverObject, [{\n    key: '_newSubscription',\n    value: function _newSubscription(hyperty) {\n      var _this = this;\n\n      _this._subscriptions[hyperty] = new _Subscription2.default(_this._bus, hyperty, _this._url, _this._childrens, false);\n    }\n  }, {\n    key: 'addSubscription',\n    value: function addSubscription(hyperty) {\n      var _this = this;\n\n      _this._newSubscription(hyperty);\n    }\n  }, {\n    key: 'removeSubscription',\n    value: function removeSubscription(hyperty) {\n      var _this = this;\n\n      var domain = (0, _utils.divideURL)(hyperty).domain;\n      var objURLSubscription = _this._url + '/subscription';\n\n      var subscription = _this._subscriptions[hyperty];\n      if (subscription) {\n        //FLOW-OUT: message sent to remote ReporterObject -> _onRemoteUnSubscribe\n        _this._bus.postMessage({\n          type: 'unsubscribe', from: _this._parent._url, to: objURLSubscription,\n          body: { resource: _this._url }\n        });\n\n        //TODO: should I wait for response before unsubscribe on msg-node\n        //FLOW-OUT: message sent to msg-node SubscriptionManager component\n        _this._bus.postMessage({\n          type: 'unsubscribe', from: _this._parent._url, to: 'domain://msg-node.' + domain + '/sm',\n          body: { resource: _this._url, childrenResources: _this._childrens }\n        });\n\n        subscription._releaseListeners();\n        delete _this._subscriptions[hyperty];\n      }\n    }\n  }]);\n  return ObserverObject;\n}();\n\nexports.default = ObserverObject;\nmodule.exports = exports['default'];\n\n},{\"../utils/utils\":457,\"./Subscription\":453,\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16}],451:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _utils = require('../utils/utils');\n\nvar _Subscription = require('./Subscription');\n\nvar _Subscription2 = _interopRequireDefault(_Subscription);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ReporterObject = function () {\n  function ReporterObject(parent, owner, url) {\n    (0, _classCallCheck3.default)(this, ReporterObject);\n\n    var _this = this;\n\n    _this._parent = parent;\n    _this._owner = owner;\n    _this._url = url;\n\n    _this._bus = parent._bus;\n    _this._storageManager = parent._storageManager;\n\n    _this._domain = (0, _utils.divideURL)(owner).domain;\n    _this._objSubscriptorURL = _this._url + '/subscription';\n\n    _this._subscriptions = {};\n    _this._childrens = [];\n    _this._childrenListeners = [];\n\n    _this._forwards = {};\n\n    _this._allocateListeners();\n  }\n\n  (0, _createClass3.default)(ReporterObject, [{\n    key: '_allocateListeners',\n    value: function _allocateListeners() {\n      var _this = this;\n\n      //add subscription listener...\n      _this._subscriptionListener = _this._bus.addListener(_this._objSubscriptorURL, function (msg) {\n        console.log(_this._objSubscriptorURL + '-RCV: ', msg);\n        switch (msg.type) {\n          case 'subscribe':\n            _this._onRemoteSubscribe(msg);break;\n          case 'unsubscribe':\n            _this._onRemoteUnSubscribe(msg);break;\n          case 'response':\n            _this._onRemoteResponse(msg);break;\n        }\n      });\n\n      var changeURL = _this._url + '/changes';\n      _this._changeListener = _this._bus.addListener(changeURL, function (msg) {\n        //TODO: what todo here? Save changes?\n        if (msg.body.attribute) {\n          _this._parent._storeDataObjects.updateData(_this._url, 'data', msg.body.attribute, msg.body.value, true);\n        }\n        console.log('SyncherManager-' + changeURL + '-RCV: ', msg);\n      });\n    }\n  }, {\n    key: 'resumeSubscriptions',\n    value: function resumeSubscriptions(subscriptions) {\n      var _this = this;\n\n      (0, _keys2.default)(subscriptions).forEach(function (key) {\n        var hypertyURL = subscriptions[key];\n        // console.log('RESUME: ', hypertyURL, _this._subscriptions[hypertyURL]);\n        if (!_this._subscriptions[hypertyURL]) {\n          _this._subscriptions[hypertyURL] = new _Subscription2.default(_this._bus, _this._owner, _this._url, _this._childrens, true);\n        }\n      });\n    }\n  }, {\n    key: '_releaseListeners',\n    value: function _releaseListeners() {\n      var _this = this;\n\n      _this._subscriptionListener.remove();\n\n      _this._changeListener.remove();\n\n      _this._childrenListeners.forEach(function (cl) {\n        cl.remove();\n      });\n\n      (0, _keys2.default)(_this._forwards).forEach(function (key) {\n        _this.forwardUnSubscribe(key);\n      });\n\n      //remove all subscriptions\n      (0, _keys2.default)(_this._subscriptions).forEach(function (key) {\n        _this._subscriptions[key]._releaseListeners();\n      });\n    }\n\n    /**\n     * Register a listener in the msg-node and in the local MessageBus, so that messages on this address are forwarded to the reporter object\n     * @param  {string} address - URL to register the listeners\n     * @return {Promise} Return Promise OK or error\n     */\n\n  }, {\n    key: 'forwardSubscribe',\n    value: function forwardSubscribe(addresses) {\n      var _this = this;\n\n      //FLOW-OUT: message sent to the msg-node SubscriptionManager component\n      var nodeSubscribeMsg = {\n        type: 'subscribe', from: _this._parent._url, to: 'domain://msg-node.' + _this._domain + '/sm',\n        body: { subscribe: addresses, source: _this._owner }\n      };\n\n      return new _promise2.default(function (resolve, reject) {\n        _this._bus.postMessage(nodeSubscribeMsg, function (reply) {\n          console.log('forward-subscribe-response(reporter): ', reply);\n          if (reply.body.code === 200) {\n            var newForward = _this._bus.addForward(_this._url, _this._owner);\n            _this._forwards[addresses[0]] = newForward;\n            resolve();\n          } else {\n            reject('Error on msg-node subscription: ' + reply.body.desc);\n          }\n        });\n      });\n    }\n\n    /**\n     * UnRegister a listener in the msg-node and in the local MessageBus, so that messages on this address are removed from forward\n     * @param  {string} address - URL to un-register the listeners\n     */\n\n  }, {\n    key: 'forwardUnSubscribe',\n    value: function forwardUnSubscribe(address) {\n      var _this = this;\n\n      _this._forwards[address].remove();\n      delete _this._forwards[address];\n\n      //FLOW-OUT: message sent to the msg-node SubscriptionManager component\n      var nodeUnSubscribeMsg = {\n        type: 'unsubscribe', from: _this._parent._url, to: 'domain://msg-node.' + _this._domain + '/sm',\n        body: { subscribe: [address], source: _this._owner }\n      };\n\n      _this._bus.postMessage(nodeUnSubscribeMsg);\n    }\n\n    /**\n     * Register listeners for a list of childrens. Public channels used to transmit messages.\n     * @param  {string[]} childrens - channels to register\n     * @return {Promise} Return Promise OK or error\n     */\n\n  }, {\n    key: 'addChildrens',\n    value: function addChildrens(childrens) {\n      var _this = this;\n\n      return new _promise2.default(function (resolve, reject) {\n        if (childrens.length === 0) {\n          resolve();\n          return;\n        }\n\n        var childBaseURL = _this._url + '/children/';\n        _this._childrens.push(childrens);\n\n        /*\n        _this._childrens.forEach((child) => {\n          let childId = childBaseURL + child;\n           let selfForward = _this._bus.addForward(childId, owner);\n          _this._childrenListeners.push(selfForward);\n        });*/\n\n        var subscriptions = [];\n        childrens.forEach(function (child) {\n          return subscriptions.push(childBaseURL + child);\n        });\n\n        //_this._storageSubscriptions[_this._objSubscriptorURL] = {url: _this._url, owner: _this._owner, childrens: _this._childrens};\n\n        //FLOW-OUT: message sent to the msg-node SubscriptionManager component\n        var nodeSubscribeMsg = {\n          type: 'subscribe', from: _this._parent._url, to: 'domain://msg-node.' + _this._domain + '/sm',\n          body: { subscribe: subscriptions, source: _this._owner }\n        };\n\n        _this._bus.postMessage(nodeSubscribeMsg, function (reply) {\n          console.log('node-subscribe-response(reporter): ', reply);\n          if (reply.body.code === 200) {\n\n            //add children listeners on local ...\n            subscriptions.forEach(function (childURL) {\n              var childListener = _this._bus.addListener(childURL, function (msg) {\n                //TODO: what todo here? Save childrens?\n                console.log('SyncherManager-' + childURL + '-RCV: ', msg);\n              });\n              _this._childrenListeners.push(childListener);\n\n              var selfForward = _this._bus.addForward(childURL, _this._owner);\n              _this._childrenListeners.push(selfForward);\n            });\n\n            resolve();\n          } else {\n            reject('Error on msg-node subscription: ' + reply.body.desc);\n          }\n        });\n      });\n    }\n  }, {\n    key: 'delete',\n    value: function _delete() {\n      var _this = this;\n      var domain = (0, _utils.divideURL)(_this._owner).domain;\n\n      //FLOW-OUT: message sent directly to all subscribers of the reporter\n      _this._bus.postMessage({\n        type: 'delete', from: _this._objSubscriptorURL, to: _this._url + '/changes'\n      });\n\n      //FLOW-OUT: message sent to the msg-node ObjectAllocationManager component\n      _this._bus.postMessage({\n        type: 'delete', from: _this._parent._url, to: 'domain://msg-node.' + domain + '/object-address-allocation',\n        body: { resource: _this._url, childrenResources: _this._childrens }\n      });\n\n      _this._releaseListeners();\n      delete _this._parent._reporters[_this._url];\n    }\n  }, {\n    key: '_onRemoteResponse',\n    value: function _onRemoteResponse(msg) {\n      var _this = this;\n\n      _this._bus.postMessage({\n        id: msg.id, type: 'response', from: msg.to, to: _this._url,\n        body: { code: msg.body.code, identity: msg.body.identity, source: msg.from }\n      });\n    }\n\n    //FLOW-IN: message received from Syncher -> subscribe\n\n  }, {\n    key: '_onRemoteSubscribe',\n    value: function _onRemoteSubscribe(msg) {\n      var _this = this;\n      var hypertyURL = msg.body.subscriber;\n\n      //validate if subscription already exists?\n      if (_this._subscriptions[hypertyURL]) {\n        // let errorMsg = {\n        //   id: msg.id, type: 'response', from: msg.to, to: hypertyURL,\n        //   body: { code: 500, desc: 'Subscription for (' + _this._url + ' : ' +  hypertyURL + ') already exists!' }\n        // };\n        //\n        // _this._bus.postMessage(errorMsg);\n        // return;\n\n        // new version because of reusage\n        _this._subscriptions[hypertyURL]._releaseListeners();\n      }\n\n      //ask to subscribe to Syncher? (depends on the operation mode)\n      //TODO: get mode from object!\n      var mode = 'sub/pub';\n\n      if (mode === 'sub/pub') {\n        //FLOW-OUT: message sent to local hyperty address Syncher -> _onForward\n        var forwardMsg = {\n          type: 'forward', from: _this._url, to: _this._owner,\n          body: { type: msg.type, from: hypertyURL, to: _this._url, identity: msg.body.identity }\n        };\n\n        _this._bus.postMessage(forwardMsg, function (reply) {\n          console.log('forward-reply: ', reply);\n          if (reply.body.code === 200) {\n            if (!_this._subscriptions[hypertyURL]) {\n              _this._subscriptions[hypertyURL] = new _Subscription2.default(_this._bus, _this._owner, _this._url, _this._childrens, true);\n            }\n          }\n\n          // Store for each reporter hyperty the dataObject\n          var userURL = void 0;\n          if (msg.body.identity && msg.body.identity.userProfile.userURL) {\n            userURL = msg.body.identity.userProfile.userURL;\n            _this._parent._storeDataObjects.update(_this._url, 'subscriberUsers', userURL);\n          }\n\n          _this._parent._storeDataObjects.update(_this._url, 'subscriptions', hypertyURL);\n\n          //FLOW-OUT: subscription response sent (forward from internal Hyperty)\n          _this._bus.postMessage({\n            id: msg.id, type: 'response', from: msg.to, to: msg.from,\n            body: reply.body\n          });\n        });\n      }\n    }\n\n    //FLOW-IN: message received from remote ObserverObject -> removeSubscription\n\n  }, {\n    key: '_onRemoteUnSubscribe',\n    value: function _onRemoteUnSubscribe(msg) {\n      var _this = this;\n      var hypertyURL = msg.body.subscriber;\n\n      var subscription = _this._subscriptions[hypertyURL];\n      if (subscription) {\n        subscription._releaseListeners();\n        delete _this._subscriptions[hypertyURL];\n\n        //TODO: send un-subscribe message to Syncher? (depends on the operation mode)\n      }\n    }\n  }]);\n  return ReporterObject;\n}();\n\nexports.default = ReporterObject;\nmodule.exports = exports['default'];\n\n},{\"../utils/utils\":457,\"./Subscription\":453,\"babel-runtime/core-js/object/keys\":10,\"babel-runtime/core-js/promise\":12,\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16}],452:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _from = require('babel-runtime/core-js/array/from');\n\nvar _from2 = _interopRequireDefault(_from);\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar StoreDataObjects = function () {\n  function StoreDataObjects(storageManager) {\n    (0, _classCallCheck3.default)(this, StoreDataObjects);\n\n    if (!storageManager) throw new Error('[Store Data Objects] - Needs the storageManager component');\n\n    this._storageManager = storageManager;\n    this._storeDataObject = {};\n  }\n\n  (0, _createClass3.default)(StoreDataObjects, [{\n    key: 'set',\n    value: function set(resource, isReporter, schema, status, data, subscription, children, childrenResources, subscriberUser) {\n\n      var type = this._getTypeOfObject(isReporter);\n      if (!this._storeDataObject.hasOwnProperty(type)) this._storeDataObject[type] = {};\n\n      if (!this._storeDataObject[type].hasOwnProperty(resource)) {\n        this._storeDataObject[type][resource] = {\n          resource: resource,\n          isReporter: isReporter,\n          subscriptions: [],\n          subscriberUsers: []\n        };\n      }\n\n      if (isReporter) this._storeDataObject[type][resource].owner = subscription;\n\n      if (data) this._storeDataObject[type][resource].data = data;\n      if (schema) this._storeDataObject[type][resource].schema = schema;\n      if (status) this._storeDataObject[type][resource].status = status;\n      if (children) this._storeDataObject[type][resource].children = children;\n      if (childrenResources) this._storeDataObject[type][resource].childrenResources = childrenResources;\n\n      console.log('SET:', subscription, !isReporter);\n      if (subscription && !isReporter) {\n        if (this._storeDataObject[type][resource].subscriptions.indexOf(subscription)) this._storeDataObject[type][resource].subscriptions.push(subscription);\n      }\n\n      if (subscriberUser) {\n        if (this._storeDataObject[type][resource].subscriberUsers.indexOf(subscriberUser)) this._storeDataObject[type][resource].subscriberUsers.push(subscriberUser);\n      }\n\n      console.log('SET: ', this._storeDataObject[type][resource], subscription);\n\n      return this._storageManager.set('syncherManager:ObjectURLs', 1, this._storeDataObject);\n    }\n  }, {\n    key: 'updateData',\n    value: function updateData(resource, key, attribute, value) {\n      var isReporter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n\n      var type = this._getTypeOfObject(isReporter);\n\n      if (this._storeDataObject.hasOwnProperty(type) && this._storeDataObject[type][resource] && resource && key && value) {\n\n        if (key === 'subscriptions' || key === 'subscriberUsers') {\n          this._updateToArray(resource, key, value, type);\n        } else {\n          this._storeDataObject[type][resource][key][attribute] = value;\n        }\n\n        return this._storageManager.set('syncherManager:ObjectURLs', 1, this._storeDataObject);\n      } else {\n        //throw new Error('[StoreDataObjects] - Can\\'t update this ' + resource + ' to the key ' + key + ' with value: ' + value);\n      }\n    }\n  }, {\n    key: 'update',\n    value: function update(resource, key, value) {\n      var isReporter = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n      var type = this._getTypeOfObject(isReporter);\n\n      if (this._storeDataObject.hasOwnProperty(type) && this._storeDataObject[type][resource] && resource && key && value) {\n\n        if (key === 'subscriptions' || key === 'subscriberUsers') {\n          this._updateToArray(resource, key, value, type);\n        } else {\n          this._storeDataObject[type][resource][key] = value;\n        }\n\n        return this._storageManager.set('syncherManager:ObjectURLs', 1, this._storeDataObject);\n      } else {\n        //throw new Error('[StoreDataObjects] - Can\\'t update this ' + resource + ' to the key ' + key + ' with value: ' + value);\n      }\n    }\n  }, {\n    key: 'delete',\n    value: function _delete(resource, key, value) {\n      if (this._storeDataObject[resource] && resource && key && value) {\n\n        if (key === 'subscriptions' || key === 'subscriberUsers') {\n          this._removeFromArray(resource, key);\n        } else {\n          delete this._storeDataObject[resource][key];\n        }\n\n        return this._storageManager.set('syncherManager:ObjectURLs', 1, this._storeDataObject);\n      } else {\n        throw new Error('[StoreDataObjects] - Can\\'t delete this ' + resource + ' to the key ' + key + ' with value: ' + value);\n      }\n    }\n\n    /**\n     * TODO: check if this process is viable because the storage manager ability to delete\n     * now the storageManager only can delete an specific key, but not the specific value inside that key;\n     */\n\n  }, {\n    key: 'deleteResource',\n    value: function deleteResource(resource) {\n      var _this = this;\n\n      if (resource) {\n\n        return this.getAll().then(function (storedDataObjects) {\n          var tmp = storedDataObjects;\n\n          if (tmp.hasOwnProperty(resource)) {\n            delete tmp.observers[resource];\n            delete tmp.reporters[resource];\n            return _this._storageManager.set('syncherManager:ObjectURLs', 1, tmp);\n          }\n        });\n      } else {\n        throw new Error('[StoreDataObjects] - Can\\'t delete this ' + resource);\n      }\n    }\n  }, {\n    key: 'getAll',\n    value: function getAll() {\n      return this._storageManager.get('syncherManager:ObjectURLs');\n    }\n  }, {\n    key: 'get',\n    value: function get(resource) {\n      if (this._storeDataObject[resource]) {\n        return this._storeDataObject[resource];\n      } else {\n        throw new Error('[StoreDataObjects] - Can\\'t find this ' + resource);\n      }\n    }\n\n    /**\n     *\n     */\n\n  }, {\n    key: 'getResourcesByCriteria',\n    value: function getResourcesByCriteria(msg, isReporter) {\n      var _this2 = this;\n\n      console.log('MSG:', msg);\n\n      return new _promise2.default(function (resolve) {\n\n        var type = _this2._getTypeOfObject(isReporter);\n\n        _this2.getAll().then(function (storedDataObjects) {\n\n          if (!storedDataObjects) {\n            console.log('don\\'t have stored data objects');\n            return resolve(null);\n          }\n\n          if (msg.body.hasOwnProperty('resume') && !msg.body.resume) {\n            return resolve(null);\n          }\n\n          // check if the message have other criteria\n          // if not search for on the 'from' of the message.\n          var result = [];\n          var hasSubscription = _this2._hasSubscription(storedDataObjects[type], msg.from);\n          var isOwner = _this2._isOwner(storedDataObjects[type], msg.from);\n\n          if (msg.hasOwnProperty('from') && hasSubscription || isOwner) {\n            var resource = _this2._getResourcesBySubscription(storedDataObjects[type], msg.from);\n            var identityFoundData = _this2._getResourcesByIdentity(storedDataObjects[type], msg.body.identity);\n            var schemaFoundData = _this2._getResourcesBySchema(storedDataObjects[type], msg.body.schema);\n            var dataFound = _this2._getResourcesByData(storedDataObjects[type], msg.body.value);\n\n            // you can pass as arrays as you want.. it will be merged in on place\n            // removed duplicates;\n            result = _this2._intersection(identityFoundData, schemaFoundData, dataFound, resource);\n          } else {\n            return resolve(null);\n          }\n\n          var init = {};\n          result.forEach(function (key) {\n            var currentIsReporter = storedDataObjects[type][key];\n            init[key] = currentIsReporter;\n            return init;\n          });\n\n          console.log('[Store Data Objects] - ', init);\n\n          resolve(init);\n        });\n      });\n    }\n  }, {\n    key: '_getResourcesByIdentity',\n    value: function _getResourcesByIdentity(storedData, userURL) {\n      return (0, _keys2.default)(storedData).filter(function (objectURL) {\n        return storedData[objectURL].subscriberUsers.filter(function (current) {\n          return current === userURL;\n        }).length;\n      });\n    }\n  }, {\n    key: '_getResourcesBySubscription',\n    value: function _getResourcesBySubscription(storedData, subscription) {\n      return (0, _keys2.default)(storedData).filter(function (objectURL) {\n        return storedData[objectURL].subscriptions.filter(function (current) {\n          console.log('Cuurent:', current, subscription);\n          return current === subscription;\n        }).length;\n      });\n    }\n  }, {\n    key: '_getResourcesBySchema',\n    value: function _getResourcesBySchema(storedData, schema) {\n      return (0, _keys2.default)(storedData).filter(function (objectURL) {\n        var currentObject = storedData[objectURL];\n        return (0, _keys2.default)(currentObject).filter(function (key) {\n          return key === 'schema' && currentObject[key] === schema;\n        }).length;\n      });\n    }\n  }, {\n    key: '_getResourcesByData',\n    value: function _getResourcesByData(storedData, data) {\n      if (!data) return [];\n\n      return (0, _keys2.default)(storedData).filter(function (objectURL) {\n        var currentObject = storedData[objectURL].data;\n        return (0, _keys2.default)(currentObject).filter(function (key) {\n          // search on storeDataObjects for specific key provided from data;\n          return (0, _keys2.default)(data).filter(function (searchFor) {\n            return key === searchFor && currentObject[key] === data[searchFor];\n          }).length;\n        }).length;\n      });\n    }\n  }, {\n    key: '_hasSubscription',\n    value: function _hasSubscription(storedData, subscription) {\n      if (!storedData) return false;\n\n      return (0, _keys2.default)(storedData).filter(function (objectURL) {\n        return storedData[objectURL].subscriptions.filter(function (current) {\n          return current === subscription;\n        }).length;\n      }).length > 0 ? true : false;\n    }\n  }, {\n    key: '_isOwner',\n    value: function _isOwner(storedData, url) {\n      if (!storedData) return false;\n\n      return (0, _keys2.default)(storedData).filter(function (objectURL) {\n        return storedData[objectURL].owner === url;\n      }).length > 0 ? true : false;\n    }\n  }, {\n    key: '_intersection',\n    value: function _intersection() {\n      var args = (0, _from2.default)(arguments);\n\n      var result = args.reduce(function (first, second) {\n        return first.concat(second);\n      }).filter(function (value, index, self) {\n        return self.indexOf(value) === index;\n      });\n      console.log('Result an unique array of strings: ', result);\n      return result;\n    }\n  }, {\n    key: '_updateToArray',\n    value: function _updateToArray(resource, key, value, type) {\n      if (this._storeDataObject[type][resource][key].indexOf(value)) this._storeDataObject[type][resource][key].push(value);\n    }\n  }, {\n    key: '_removeFromArray',\n    value: function _removeFromArray(resource, key, value) {\n      var indexOfValue = this._storeDataObject[resource][key].indexOf(value);\n      if (indexOfValue) this._storeDataObject[resource][key].splice(indexOfValue, 1);\n    }\n  }, {\n    key: '_hasValue',\n    value: function _hasValue(obj, key, value) {\n      return obj.hasOwnProperty(key) && obj[key] === value;\n    }\n  }, {\n    key: '_getTypeOfObject',\n    value: function _getTypeOfObject(isReporter) {\n      return isReporter ? 'reporters' : 'observers';\n    }\n  }]);\n  return StoreDataObjects;\n}();\n\nexports.default = StoreDataObjects;\nmodule.exports = exports['default'];\n\n},{\"babel-runtime/core-js/array/from\":2,\"babel-runtime/core-js/object/keys\":10,\"babel-runtime/core-js/promise\":12,\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16}],453:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Subscription = function () {\n  function Subscription(bus, owner, url, childrens, isReporter) {\n    (0, _classCallCheck3.default)(this, Subscription);\n\n    var _this = this;\n    var childBaseURL = url + '/children/';\n    var changeURL = url + '/changes';\n\n    //process delete message\n    _this._deleteListener = bus.addListener(changeURL, function (msg) {\n      if (msg.type === 'delete') {\n        console.log('Subscription-DELETE: ', msg);\n\n        //FLOW-OUT: message sent to all subscribers\n        var deleteMessageToHyperty = {\n          type: 'delete', from: msg.from, to: owner,\n          body: { identity: msg.body.identity, resource: url }\n        };\n\n        //send delete to hyperty\n        bus.postMessage(deleteMessageToHyperty, function (reply) {\n          console.log('Subscription-DELETE-REPLY: ', reply);\n          if (reply.body.code === 200) {\n            _this._releaseListeners();\n          }\n        });\n      }\n    });\n\n    //add change publish address or forward\n    if (isReporter) {\n      _this._changeListener = bus.addPublish(changeURL);\n    } else {\n      _this._changeListener = bus.addForward(changeURL, owner);\n    }\n\n    _this._childrenListeners = [];\n    childrens.forEach(function (child) {\n      var childId = childBaseURL + child;\n\n      //add children publish address\n      var childrenForward = bus.addPublish(childId);\n      _this._childrenListeners.push(childrenForward);\n\n      //add self forward if an observer\n      if (!isReporter) {\n        var selfForward = bus.addForward(childId, owner);\n        _this._childrenListeners.push(selfForward);\n      }\n    });\n  }\n\n  (0, _createClass3.default)(Subscription, [{\n    key: '_releaseListeners',\n    value: function _releaseListeners() {\n      var _this = this;\n\n      _this._deleteListener.remove();\n\n      _this._changeListener.remove();\n\n      _this._childrenListeners.forEach(function (forward) {\n        forward.remove();\n      });\n    }\n  }]);\n  return Subscription;\n}();\n\nexports.default = Subscription;\nmodule.exports = exports['default'];\n\n},{\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16}],454:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _utils = require('../utils/utils');\n\nvar _schemaValidation = require('../utils/schemaValidation');\n\nvar _AddressAllocation = require('../allocation/AddressAllocation');\n\nvar _AddressAllocation2 = _interopRequireDefault(_AddressAllocation);\n\nvar _ReporterObject = require('./ReporterObject');\n\nvar _ReporterObject2 = _interopRequireDefault(_ReporterObject);\n\nvar _ObserverObject = require('./ObserverObject');\n\nvar _ObserverObject2 = _interopRequireDefault(_ObserverObject);\n\nvar _MessageFactory = require('service-framework/dist/MessageFactory');\n\nvar _StoreDataObjects = require('./StoreDataObjects');\n\nvar _StoreDataObjects2 = _interopRequireDefault(_StoreDataObjects);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @author micaelpedrosa@gmail.com\n * Core Syncronization system.\n */\nvar SyncherManager = function () {\n  /* private\n  _url: URL\n  _bus: MiniBus\n  _registry: Registry\n  _allocator: AddressAllocation\n   _reporters: { ObjectURL: ReporterObject }\n  _observers: { ObjectURL: ObserverObject }\n  */\n\n  function SyncherManager(runtimeURL, bus, registry, catalog, storageManager, allocator) {\n    (0, _classCallCheck3.default)(this, SyncherManager);\n\n    if (!runtimeURL) throw new Error('[Syncher Manager] - needs the runtimeURL parameter');\n    if (!bus) throw new Error('[Syncher Manager] - needs the MessageBus instance');\n    if (!registry) throw new Error('[Syncher Manager] - needs the Registry instance');\n    if (!catalog) throw new Error('[Syncher Manager] - needs the RuntimeCatalogue instance');\n    if (!storageManager) throw new Error('[Syncher Manager] - need the storageManager instance');\n\n    var _this = this;\n\n    _this._bus = bus;\n    _this._registry = registry;\n    _this._catalog = catalog;\n    _this._storageManager = storageManager;\n\n    //TODO: these should be saved in persistence engine?\n    _this._url = runtimeURL + '/sm';\n    _this._objectURL = runtimeURL + '/object-allocation';\n\n    _this._reporters = {};\n    _this._observers = {};\n\n    _this._storeDataObjects = new _StoreDataObjects2.default(storageManager);\n\n    //TODO: this should not be hardcoded!\n    _this._domain = (0, _utils.divideURL)(runtimeURL).domain;\n\n    _this._mf = new _MessageFactory.MessageFactory(false, {});\n\n    if (allocator) {\n      _this._allocator = allocator;\n    } else {\n      _this._allocator = new _AddressAllocation2.default(_this._objectURL, bus, _this._registry);\n    }\n\n    bus.addListener(_this._url, function (msg) {\n      console.log('SyncherManager-RCV: ', msg);\n      switch (msg.type) {\n        case 'create':\n          _this._onCreate(msg);break;\n        case 'delete':\n          _this._onDelete(msg);break;\n        case 'subscribe':\n          _this._onLocalSubscribe(msg);break;\n        case 'unsubscribe':\n          _this._onLocalUnSubscribe(msg);break;\n      }\n    });\n  }\n\n  (0, _createClass3.default)(SyncherManager, [{\n    key: '_onCreate',\n\n\n    //FLOW-IN: message received from Syncher -> create\n    value: function _onCreate(msg) {\n      var _this2 = this;\n\n      if (msg.body.hasOwnProperty('resume') && !msg.body.resume || !msg.body.resume) {\n        this._newCreate(msg);\n      } else {\n        this._storeDataObjects.getResourcesByCriteria(msg, true).then(function (result) {\n\n          console.log('[SyncherManager - Create] - filter result', result, msg);\n\n          if (result && (0, _keys2.default)(result).length > 0) {\n\n            // TODO: should reuse the storaged information\n            (0, _keys2.default)(result).forEach(function (objURL) {\n              console.log('[SyncherManager - resume Create] - reuse current object url: ', result[objURL]);\n              _this2._resumeCreate(msg, result[objURL]);\n            });\n          } else {\n            //forward to hyperty:\n            var reply = {};\n            reply.id = msg.id;\n            reply.from = msg.to;\n            reply.to = msg.from;\n            reply.type = 'response';\n            reply.body = {\n              code: 404,\n              desc: 'No data objects to be resumed'\n            };\n            _this2._bus.postMessage(reply);\n          }\n        });\n      }\n    }\n  }, {\n    key: '_newCreate',\n    value: function _newCreate(msg) {\n      var _this3 = this;\n\n      var _this = this;\n\n      var owner = msg.from;\n      var domain = (0, _utils.divideURL)(msg.from).domain;\n\n      if (msg.body.resource) {\n        _this._authorise(msg, msg.body.resource);\n        return;\n      }\n\n      //get schema from catalogue and parse -> (scheme, children)\n      _this._catalog.getDataSchemaDescriptor(msg.body.schema).then(function (descriptor) {\n\n        var properties = descriptor.sourcePackage.sourceCode.properties;\n        var scheme = properties.scheme ? properties.scheme.constant : 'resource';\n        var childrens = properties.children ? properties.children.constant : [];\n\n        // Do schema validation\n        // TODO: check if is need to handle with the result of validation\n        (0, _schemaValidation.schemaValidation)(scheme, descriptor, msg.body.value);\n\n        var objectInfo = {\n          name: msg.body.value.name,\n          schema: msg.body.value.schema,\n          reporter: msg.body.value.reporter,\n          resources: msg.body.value.resources\n        };\n\n        // should resuse data object url if it passed\n        var reuseDataObject = msg.body.value.resource;\n\n        //request address allocation of a new object from the msg-node\n        _this._allocator.create(domain, 1, objectInfo, scheme, reuseDataObject).then(function (allocated) {\n          var objURL = allocated.address[0];\n\n          console.log('ALLOCATOR CREATE:', allocated);\n\n          var subscriptionURL = objURL + '/subscription';\n\n          console.log('Subscription URL', subscriptionURL);\n\n          //To register the dataObject in the runtimeRegistry\n          console.info('Register Object: ', msg.body.value.name, msg.body.value.schema, objURL, msg.body.value.reporter, msg.body.value.resources);\n          _this._registry.registerDataObject(msg.body.value.name, msg.body.value.schema, objURL, msg.body.value.reporter, msg.body.value.resources, allocated, msg.body.authorise).then(function (resolve) {\n            console.log('DataObject successfully registered', resolve);\n\n            //all OK -> create reporter and register listeners\n            var reporter = void 0;\n\n            if (!_this3._reporters[objURL]) {\n              reporter = new _ReporterObject2.default(_this, owner, objURL);\n            } else {\n              reporter = _this3._reporters[objURL];\n            }\n\n            console.log('[SyncherManager - new Create] - ', msg);\n\n            if (msg.body.hasOwnProperty('store') && msg.body.store) {\n              // Store for each reporter hyperty the dataObject\n              var userURL = void 0;\n              if (msg.body.hasOwnProperty('identity') && msg.body.identity.userProfile.userURL) {\n                userURL = msg.body.identity.userProfile.userURL;\n              }\n\n              _this._storeDataObjects.set(objURL, true, msg.body.schema, 'on', msg.body.value, owner, null, childrens, userURL);\n            }\n\n            reporter.forwardSubscribe([objURL, subscriptionURL]).then(function () {\n              reporter.addChildrens(childrens).then(function () {\n                _this._reporters[objURL] = reporter;\n\n                //FLOW-OUT: message response to Syncher -> create\n                _this._bus.postMessage({\n                  id: msg.id, type: 'response', from: msg.to, to: owner,\n                  body: { code: 200, resource: objURL, childrenResources: childrens }\n                });\n\n                //send create to all observers, responses will be deliver to the Hyperty owner?\n                //schedule for next cycle needed, because the Reporter should be available.\n                setTimeout(function () {\n                  //will invite other hyperties\n                  _this._authorise(msg, objURL);\n                });\n              });\n            });\n          }, function (error) {\n            console.error(error);\n          });\n        });\n      }).catch(function (reason) {\n        //FLOW-OUT: error message response to Syncher -> create\n        var responseMsg = {\n          id: msg.id, type: 'response', from: msg.to, to: owner,\n          body: { code: 500, desc: reason }\n        };\n\n        _this._bus.postMessage(responseMsg);\n      });\n    }\n  }, {\n    key: '_resumeCreate',\n    value: function _resumeCreate(msg, storedObject) {\n      var _this4 = this;\n\n      var _this = this;\n\n      var owner = msg.from;\n      var schema = storedObject.schema;\n      var resource = storedObject.resource;\n      var initialData = storedObject.data;\n\n      console.log('[SyncherManager] - resumeCreate', msg);\n\n      var authMsg = msg;\n      authMsg.body.authorise = storedObject.subscriptions;\n\n      // // TODO: Check why the _authorise is called;\n      // if (resource) {\n      //   _this._authorise(authMsg, resource);\n      //   return;\n      // }\n\n      //get schema from catalogue and parse -> (scheme, children)\n      _this._catalog.getDataSchemaDescriptor(schema).then(function (descriptor) {\n\n        var properties = descriptor.sourcePackage.sourceCode.properties;\n        var scheme = properties.scheme ? properties.scheme.constant : 'resource';\n        var childrens = properties.children ? properties.children.constant : [];\n\n        // Do schema validation\n        // TODO: check if is need to handle with the result of validation\n        (0, _schemaValidation.schemaValidation)(scheme, descriptor, initialData);\n\n        //all OK -> create reporter and register listeners\n        var reporter = void 0;\n\n        if (!_this4._reporters[resource]) {\n          reporter = new _ReporterObject2.default(_this, owner, resource);\n        } else {\n          reporter = _this4._reporters[resource];\n        }\n\n        _this._reporters[resource] = reporter;\n\n        reporter.resumeSubscriptions(storedObject.subscriptions);\n\n        //FLOW-OUT: message response to Syncher -> create\n        _this._bus.postMessage({\n          id: msg.id, type: 'response', from: msg.to, to: owner,\n          body: { code: 200, resource: resource, childrenResources: childrens, schema: schema, value: storedObject.data }\n        });\n\n        // //send create to all observers, responses will be deliver to the Hyperty owner?\n        // //schedule for next cycle needed, because the Reporter should be available.\n        // setTimeout(() => {\n        //   //will invite other hyperties\n        //   _this._authorise(authMsg, resource);\n        // });\n      });\n    }\n  }, {\n    key: '_authorise',\n    value: function _authorise(msg, objURL) {\n      var _this = this;\n      var objSubscriptorURL = objURL + '/subscription';\n\n      msg.body.authorise.forEach(function (hypertyURL) {\n        //FLOW-OUT: send invites to list of remote Syncher -> _onRemoteCreate -> onNotification\n        _this._bus.postMessage({\n          type: 'create', from: objSubscriptorURL, to: hypertyURL,\n          body: { identity: msg.body.identity, source: msg.from, value: msg.body.value, schema: msg.body.schema }\n        });\n      });\n    }\n\n    //FLOW-IN: message received from DataObjectReporter -> delete\n\n  }, {\n    key: '_onDelete',\n    value: function _onDelete(msg) {\n      var _this = this;\n\n      var objURL = msg.body.resource;\n\n      var object = _this._reporters[objURL];\n      if (object) {\n        //TODO: is there any policy verification before delete?\n        object.delete();\n\n        this._storeDataObjects.deleteResource(objURL);\n\n        //TODO: unregister object?\n        _this._bus.postMessage({\n          id: msg.id, type: 'response', from: msg.to, to: msg.from,\n          body: { code: 200 }\n        });\n      }\n    }\n\n    //FLOW-IN: message received from local Syncher -> subscribe\n\n  }, {\n    key: '_onLocalSubscribe',\n    value: function _onLocalSubscribe(msg) {\n      var _this5 = this;\n\n      this._storeDataObjects.getResourcesByCriteria(msg, false).then(function (result) {\n\n        console.log('[SyncherManager - Subscribe] - filter result', result);\n\n        if (result && (0, _keys2.default)(result).length > 0) {\n\n          // TODO: should reuse the storaged information\n          (0, _keys2.default)(result).forEach(function (objURL) {\n            console.log('[SyncherManager - resume Subscribe] - reuse current object url: ', result[objURL]);\n            _this5._resumeSubscription(msg, result[objURL]);\n          });\n        } else if (msg.body.schema && msg.body.resource) {\n          console.log('[SyncherManager - new Subscribe] - ', msg.body.schema, msg.body.resource);\n          _this5._newSubscription(msg);\n        } else {\n          //forward to hyperty:\n          var reply = {};\n          reply.id = msg.id;\n          reply.from = msg.to;\n          reply.to = msg.from;\n          reply.type = 'response';\n          reply.body = {\n            code: 404,\n            desc: 'No data objects to be resumed'\n          };\n          _this5._bus.postMessage(reply);\n        }\n      });\n    }\n  }, {\n    key: '_newSubscription',\n    value: function _newSubscription(msg) {\n      var _this6 = this;\n\n      var _this = this;\n\n      var objURL = msg.body.resource;\n\n      var hypertyURL = msg.from;\n      var domain = (0, _utils.divideURL)(objURL).domain;\n      var objURLSubscription = objURL + '/subscription';\n\n      var childBaseURL = objURL + '/children/';\n\n      //get schema from catalogue and parse -> (children)\n      _this._catalog.getDataSchemaDescriptor(msg.body.schema).then(function (descriptor) {\n        var properties = descriptor.sourcePackage.sourceCode.properties;\n        var childrens = properties.children ? properties.children.constant : [];\n\n        //children addresses\n        var subscriptions = [];\n        subscriptions.push(objURL + '/changes');\n        childrens.forEach(function (child) {\n          return subscriptions.push(childBaseURL + child);\n        });\n\n        //FLOW-OUT: subscribe message to the msg-node, registering listeners on the broker\n        var nodeSubscribeMsg = {\n          type: 'subscribe', from: _this._url, to: 'domain://msg-node.' + domain + '/sm',\n          body: { identity: msg.body.identity, subscribe: subscriptions, source: hypertyURL }\n        };\n\n        //subscribe in msg-node\n        _this._bus.postMessage(nodeSubscribeMsg, function (reply) {\n          console.log('node-subscribe-response(observer): ', reply);\n          if (reply.body.code === 200) {\n\n            //FLOW-OUT: reply with provisional response\n            _this._bus.postMessage({\n              id: msg.id, type: 'response', from: msg.to, to: hypertyURL,\n              body: { code: 100, childrenResources: childrens, schema: msg.body.schema, resource: msg.body.resource }\n            });\n\n            //FLOW-OUT: subscribe message to remote ReporterObject -> _onRemoteSubscribe\n            var objSubscribeMsg = {\n              type: 'subscribe', from: _this._url, to: objURLSubscription,\n              body: { identity: nodeSubscribeMsg.body.identity, subscriber: hypertyURL }\n            };\n\n            //subscribe to reporter SM\n            _this._bus.postMessage(objSubscribeMsg, function (reply) {\n              console.log('reporter-subscribe-response-new: ', reply);\n              if (reply.body.code === 200) {\n\n                var observer = _this._observers[objURL];\n                if (!observer) {\n                  observer = new _ObserverObject2.default(_this, objURL, childrens);\n                  _this._observers[objURL] = observer;\n                }\n\n                if (msg.body.hasOwnProperty('store') && msg.body.store) {\n                  // Store for each reporter hyperty the dataObject\n                  var userURL = void 0;\n                  if (msg.body.hasOwnProperty('identity') && msg.body.identity.userProfile.userURL) {\n                    userURL = msg.body.identity.userProfile.userURL;\n                  }\n\n                  _this._storeDataObjects.set(objURL, false, msg.body.schema, 'on', {}, hypertyURL, null, childrens, userURL);\n                }\n\n                //register new hyperty subscription\n                observer.addSubscription(hypertyURL);\n\n                //forward to hyperty:\n                reply.id = msg.id;\n                reply.from = _this._url;\n                reply.to = hypertyURL;\n                reply.body.schema = msg.body.schema;\n                reply.body.resource = msg.body.resource;\n\n                console.log('[subscribe] - new subscription: ', msg, reply, observer);\n\n                _this6._bus.postMessage(reply);\n              }\n            });\n          } else {\n            //listener rejected\n            _this._bus.postMessage({\n              id: msg.id, type: 'response', from: msg.to, to: hypertyURL,\n              body: reply.body\n            });\n          }\n        });\n      });\n    }\n  }, {\n    key: '_resumeSubscription',\n    value: function _resumeSubscription(msg, storedObject) {\n      var _this7 = this;\n\n      var objURL = storedObject.resource;\n      var schema = storedObject.schema;\n\n      var hypertyURL = msg.from;\n      var objURLSubscription = objURL + '/subscription';\n\n      var childBaseURL = objURL + '/children/';\n\n      console.log('[SyncherManager ReuseSubscription] - objURL: ', objURL, ' - schema:', schema);\n\n      //get schema from catalogue and parse -> (children)\n      this._catalog.getDataSchemaDescriptor(schema).then(function (descriptor) {\n        var properties = descriptor.sourcePackage.sourceCode.properties;\n        var childrens = properties.children ? properties.children.constant : [];\n\n        //children addresses\n        var subscriptions = [];\n        subscriptions.push(objURL + '/changes');\n        childrens.forEach(function (child) {\n          return subscriptions.push(childBaseURL + child);\n        });\n\n        //FLOW-OUT: subscribe message to remote ReporterObject -> _onRemoteSubscribe\n        var objSubscribeMsg = {\n          type: 'subscribe', from: _this7._url, to: objURLSubscription,\n          body: { subscriber: hypertyURL }\n        };\n\n        //subscribe to reporter SM\n        _this7._bus.postMessage(objSubscribeMsg, function (reply) {\n\n          var observer = _this7._observers[objURL];\n          if (!observer) {\n            observer = new _ObserverObject2.default(_this7, objURL, childrens);\n            _this7._observers[objURL] = observer;\n          }\n\n          //register new hyperty subscription\n          observer.addSubscription(hypertyURL);\n\n          //forward to hyperty:\n          var response = {\n            id: msg.id, from: _this7._url, to: hypertyURL, type: 'response',\n            body: reply.body\n          };\n\n          response.body.schema = schema;\n          response.body.resource = objURL;\n\n          console.log('[subscribe] - resume subscription: ', msg, reply, response, observer);\n\n          _this7._bus.postMessage(response);\n        });\n      });\n    }\n\n    //FLOW-IN: message received from local DataObjectObserver -> unsubscribe\n\n  }, {\n    key: '_onLocalUnSubscribe',\n    value: function _onLocalUnSubscribe(msg) {\n      var _this = this;\n\n      var hypertyURL = msg.from;\n      var objURL = msg.body.resource;\n\n      var observer = _this._observers[objURL];\n      if (observer) {\n        //TODO: is there any policy verification before delete?\n        observer.removeSubscription(hypertyURL);\n\n        //TODO: destroy object in the registry?\n        _this._bus.postMessage({\n          id: msg.id, type: 'response', from: msg.to, to: msg.from,\n          body: { code: 200 }\n        });\n\n        this._storeDataObjects.delete(objURL, 'subscriptions', hypertyURL);\n\n        //TODO: remove Object if no more subscription?\n        //delete _this._observers[objURL];\n      }\n    }\n  }, {\n    key: 'url',\n    get: function get() {\n      return this._url;\n    }\n  }]);\n  return SyncherManager;\n}(); /**\n     * Copyright 2016 PT Inovao e Sistemas SA\n     * Copyright 2016 INESC-ID\n     * Copyright 2016 QUOBIS NETWORKS SL\n     * Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n     * Copyright 2016 ORANGE SA\n     * Copyright 2016 Deutsche Telekom AG\n     * Copyright 2016 Apizee\n     * Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *   http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     **/\n\n\nexports.default = SyncherManager;\nmodule.exports = exports['default'];\n\n},{\"../allocation/AddressAllocation\":421,\"../utils/schemaValidation\":455,\"../utils/utils\":457,\"./ObserverObject\":450,\"./ReporterObject\":451,\"./StoreDataObjects\":452,\"babel-runtime/core-js/object/keys\":10,\"babel-runtime/helpers/classCallCheck\":15,\"babel-runtime/helpers/createClass\":16,\"service-framework/dist/MessageFactory\":420}],455:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _stringify = require('babel-runtime/core-js/json/stringify');\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nexports.schemaValidation = schemaValidation;\n\nvar _tv = require('./tv4');\n\nvar _tv2 = _interopRequireDefault(_tv);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction schemaValidation(scheme, descriptor, value) {\n\n  console.log('Scheme: ', scheme);\n\n  // schema validation\n  console.log('Running object validation...');\n  try {\n    var obj = value;\n    var schema = descriptor.sourcePackage.sourceCode;\n\n    // add support for schema referencing itself\n    _tv2.default.addSchema(schema.id, schema);\n\n    // validate\n    var result = _tv2.default.validateMultiple(obj, schema);\n\n    // delete error stacks to improve logging\n    result.errors.forEach(function (error) {\n      delete error.stack;\n    });\n\n    // print more details about validation if it fails or schema contains $refs\n    if (!result.valid || result.missing.length > 0) {\n      console.warn('Object validation ' + (result.valid ? 'succeeded, but schema contained references:' : 'failed:'), (0, _stringify2.default)(result, null, 2));\n      console.debug('Object:', (0, _stringify2.default)(obj, null, 2), '\\r\\nSchema:', (0, _stringify2.default)(schema, null, 2));\n    } else {\n      console.log('Object validation succeeded');\n    }\n  } catch (e) {\n    console.warn('Error during object validation:', e);\n  }\n}\n\n},{\"./tv4\":456,\"babel-runtime/core-js/json/stringify\":3}],456:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _stringify = require('babel-runtime/core-js/json/stringify');\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _defineProperty = require('babel-runtime/core-js/object/define-property');\n\nvar _defineProperty2 = _interopRequireDefault(_defineProperty);\n\nvar _isFrozen = require('babel-runtime/core-js/object/is-frozen');\n\nvar _isFrozen2 = _interopRequireDefault(_isFrozen);\n\nvar _create = require('babel-runtime/core-js/object/create');\n\nvar _create2 = _interopRequireDefault(_create);\n\nvar _typeof2 = require('babel-runtime/helpers/typeof');\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n Author: Geraint Luff and others\n Year: 2013\n\n This code is released into the \"public domain\" by its author(s).  Anybody may use, alter and distribute the code without restriction.  The author makes no guarantees, and takes no liability of any kind for use of this code.\n\n If you find a bug or make an improvement, it would be courteous to let the author know, but it is not compulsory.\n */\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FObject%2Fkeys\nif (!_keys2.default) {\n    Object.keys = function () {\n        var hasOwnProperty = Object.prototype.hasOwnProperty,\n            hasDontEnumBug = !{ toString: null }.propertyIsEnumerable('toString'),\n            dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'],\n            dontEnumsLength = dontEnums.length;\n\n        return function (obj) {\n            if ((typeof obj === 'undefined' ? 'undefined' : (0, _typeof3.default)(obj)) !== 'object' && typeof obj !== 'function' || obj === null) {\n                throw new TypeError('Object.keys called on non-object');\n            }\n\n            var result = [];\n\n            for (var prop in obj) {\n                if (hasOwnProperty.call(obj, prop)) {\n                    result.push(prop);\n                }\n            }\n\n            if (hasDontEnumBug) {\n                for (var i = 0; i < dontEnumsLength; i++) {\n                    if (hasOwnProperty.call(obj, dontEnums[i])) {\n                        result.push(dontEnums[i]);\n                    }\n                }\n            }\n            return result;\n        };\n    }();\n}\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create\nif (!_create2.default) {\n    Object.create = function () {\n        function F() {}\n\n        return function (o) {\n            if (arguments.length !== 1) {\n                throw new Error('Object.create implementation only accepts one parameter.');\n            }\n            F.prototype = o;\n            return new F();\n        };\n    }();\n}\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FisArray\nif (!Array.isArray) {\n    Array.isArray = function (vArg) {\n        return Object.prototype.toString.call(vArg) === \"[object Array]\";\n    };\n}\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FindexOf\nif (!Array.prototype.indexOf) {\n    Array.prototype.indexOf = function (searchElement /*, fromIndex */) {\n        if (this === null) {\n            throw new TypeError();\n        }\n        var t = Object(this);\n        var len = t.length >>> 0;\n\n        if (len === 0) {\n            return -1;\n        }\n        var n = 0;\n        if (arguments.length > 1) {\n            n = Number(arguments[1]);\n            if (n !== n) {\n                // shortcut for verifying if it's NaN\n                n = 0;\n            } else if (n !== 0 && n !== Infinity && n !== -Infinity) {\n                n = (n > 0 || -1) * Math.floor(Math.abs(n));\n            }\n        }\n        if (n >= len) {\n            return -1;\n        }\n        var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);\n        for (; k < len; k++) {\n            if (k in t && t[k] === searchElement) {\n                return k;\n            }\n        }\n        return -1;\n    };\n}\n\n// Grungey Object.isFrozen hack\nif (!_isFrozen2.default) {\n    Object.isFrozen = function (obj) {\n        var key = \"tv4_test_frozen_key\";\n        while (obj.hasOwnProperty(key)) {\n            key += Math.random();\n        }\n        try {\n            obj[key] = true;\n            delete obj[key];\n            return false;\n        } catch (e) {\n            return true;\n        }\n    };\n}\n// Based on: https://github.com/geraintluff/uri-templates, but with all the de-substitution stuff removed\n\nvar uriTemplateGlobalModifiers = {\n    \"+\": true,\n    \"#\": true,\n    \".\": true,\n    \"/\": true,\n    \";\": true,\n    \"?\": true,\n    \"&\": true\n};\nvar uriTemplateSuffices = {\n    \"*\": true\n};\n\nfunction notReallyPercentEncode(string) {\n    return encodeURI(string).replace(/%25[0-9][0-9]/g, function (doubleEncoded) {\n        return \"%\" + doubleEncoded.substring(3);\n    });\n}\n\nfunction uriTemplateSubstitution(spec) {\n    var modifier = \"\";\n    if (uriTemplateGlobalModifiers[spec.charAt(0)]) {\n        modifier = spec.charAt(0);\n        spec = spec.substring(1);\n    }\n    var separator = \"\";\n    var prefix = \"\";\n    var shouldEscape = true;\n    var showVariables = false;\n    var trimEmptyString = false;\n    if (modifier === '+') {\n        shouldEscape = false;\n    } else if (modifier === \".\") {\n        prefix = \".\";\n        separator = \".\";\n    } else if (modifier === \"/\") {\n        prefix = \"/\";\n        separator = \"/\";\n    } else if (modifier === '#') {\n        prefix = \"#\";\n        shouldEscape = false;\n    } else if (modifier === ';') {\n        prefix = \";\";\n        separator = \";\";\n        showVariables = true;\n        trimEmptyString = true;\n    } else if (modifier === '?') {\n        prefix = \"?\";\n        separator = \"&\";\n        showVariables = true;\n    } else if (modifier === '&') {\n        prefix = \"&\";\n        separator = \"&\";\n        showVariables = true;\n    }\n\n    var varNames = [];\n    var varList = spec.split(\",\");\n    var varSpecs = [];\n    var varSpecMap = {};\n    for (var i = 0; i < varList.length; i++) {\n        var varName = varList[i];\n        var truncate = null;\n        if (varName.indexOf(\":\") !== -1) {\n            var parts = varName.split(\":\");\n            varName = parts[0];\n            truncate = parseInt(parts[1], 10);\n        }\n        var suffices = {};\n        while (uriTemplateSuffices[varName.charAt(varName.length - 1)]) {\n            suffices[varName.charAt(varName.length - 1)] = true;\n            varName = varName.substring(0, varName.length - 1);\n        }\n        var varSpec = {\n            truncate: truncate,\n            name: varName,\n            suffices: suffices\n        };\n        varSpecs.push(varSpec);\n        varSpecMap[varName] = varSpec;\n        varNames.push(varName);\n    }\n    var subFunction = function subFunction(valueFunction) {\n        var result = \"\";\n        var startIndex = 0;\n        for (var i = 0; i < varSpecs.length; i++) {\n            var varSpec = varSpecs[i];\n            var value = valueFunction(varSpec.name);\n            if (value === null || value === undefined || Array.isArray(value) && value.length === 0 || (typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) === 'object' && (0, _keys2.default)(value).length === 0) {\n                startIndex++;\n                continue;\n            }\n            if (i === startIndex) {\n                result += prefix;\n            } else {\n                result += separator || \",\";\n            }\n            if (Array.isArray(value)) {\n                if (showVariables) {\n                    result += varSpec.name + \"=\";\n                }\n                for (var j = 0; j < value.length; j++) {\n                    if (j > 0) {\n                        result += varSpec.suffices['*'] ? separator || \",\" : \",\";\n                        if (varSpec.suffices['*'] && showVariables) {\n                            result += varSpec.name + \"=\";\n                        }\n                    }\n                    result += shouldEscape ? encodeURIComponent(value[j]).replace(/!/g, \"%21\") : notReallyPercentEncode(value[j]);\n                }\n            } else if ((typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) === \"object\") {\n                if (showVariables && !varSpec.suffices['*']) {\n                    result += varSpec.name + \"=\";\n                }\n                var first = true;\n                for (var key in value) {\n                    if (!first) {\n                        result += varSpec.suffices['*'] ? separator || \",\" : \",\";\n                    }\n                    first = false;\n                    result += shouldEscape ? encodeURIComponent(key).replace(/!/g, \"%21\") : notReallyPercentEncode(key);\n                    result += varSpec.suffices['*'] ? '=' : \",\";\n                    result += shouldEscape ? encodeURIComponent(value[key]).replace(/!/g, \"%21\") : notReallyPercentEncode(value[key]);\n                }\n            } else {\n                if (showVariables) {\n                    result += varSpec.name;\n                    if (!trimEmptyString || value !== \"\") {\n                        result += \"=\";\n                    }\n                }\n                if (varSpec.truncate != null) {\n                    value = value.substring(0, varSpec.truncate);\n                }\n                result += shouldEscape ? encodeURIComponent(value).replace(/!/g, \"%21\") : notReallyPercentEncode(value);\n            }\n        }\n        return result;\n    };\n    subFunction.varNames = varNames;\n    return {\n        prefix: prefix,\n        substitution: subFunction\n    };\n}\n\nfunction UriTemplate(template) {\n    if (!(this instanceof UriTemplate)) {\n        return new UriTemplate(template);\n    }\n    var parts = template.split(\"{\");\n    var textParts = [parts.shift()];\n    var prefixes = [];\n    var substitutions = [];\n    var varNames = [];\n    while (parts.length > 0) {\n        var part = parts.shift();\n        var spec = part.split(\"}\")[0];\n        var remainder = part.substring(spec.length + 1);\n        var funcs = uriTemplateSubstitution(spec);\n        substitutions.push(funcs.substitution);\n        prefixes.push(funcs.prefix);\n        textParts.push(remainder);\n        varNames = varNames.concat(funcs.substitution.varNames);\n    }\n    this.fill = function (valueFunction) {\n        var result = textParts[0];\n        for (var i = 0; i < substitutions.length; i++) {\n            var substitution = substitutions[i];\n            result += substitution(valueFunction);\n            result += textParts[i + 1];\n        }\n        return result;\n    };\n    this.varNames = varNames;\n    this.template = template;\n}\n\nUriTemplate.prototype = {\n    toString: function toString() {\n        return this.template;\n    },\n    fillFromObject: function fillFromObject(obj) {\n        return this.fill(function (varName) {\n            return obj[varName];\n        });\n    }\n};\nvar ValidatorContext = function ValidatorContext(parent, collectMultiple, errorReporter, checkRecursive, trackUnknownProperties) {\n    this.missing = [];\n    this.missingMap = {};\n    this.formatValidators = parent ? (0, _create2.default)(parent.formatValidators) : {};\n    this.schemas = parent ? (0, _create2.default)(parent.schemas) : {};\n    this.collectMultiple = collectMultiple;\n    this.errors = [];\n    this.handleError = collectMultiple ? this.collectError : this.returnError;\n    if (checkRecursive) {\n        this.checkRecursive = true;\n        this.scanned = [];\n        this.scannedFrozen = [];\n        this.scannedFrozenSchemas = [];\n        this.scannedFrozenValidationErrors = [];\n        this.validatedSchemasKey = 'tv4_validation_id';\n        this.validationErrorsKey = 'tv4_validation_errors_id';\n    }\n    if (trackUnknownProperties) {\n        this.trackUnknownProperties = true;\n        this.knownPropertyPaths = {};\n        this.unknownPropertyPaths = {};\n    }\n    this.errorReporter = errorReporter || defaultErrorReporter('en');\n    if (typeof this.errorReporter === 'string') {\n        throw new Error('debug');\n    }\n    this.definedKeywords = {};\n    if (parent) {\n        for (var key in parent.definedKeywords) {\n            this.definedKeywords[key] = parent.definedKeywords[key].slice(0);\n        }\n    }\n};\nValidatorContext.prototype.defineKeyword = function (keyword, keywordFunction) {\n    this.definedKeywords[keyword] = this.definedKeywords[keyword] || [];\n    this.definedKeywords[keyword].push(keywordFunction);\n};\nValidatorContext.prototype.createError = function (code, messageParams, dataPath, schemaPath, subErrors, data, schema) {\n    var error = new ValidationError(code, messageParams, dataPath, schemaPath, subErrors);\n    error.message = this.errorReporter(error, data, schema);\n    return error;\n};\nValidatorContext.prototype.returnError = function (error) {\n    return error;\n};\nValidatorContext.prototype.collectError = function (error) {\n    if (error) {\n        this.errors.push(error);\n    }\n    return null;\n};\nValidatorContext.prototype.prefixErrors = function (startIndex, dataPath, schemaPath) {\n    for (var i = startIndex; i < this.errors.length; i++) {\n        this.errors[i] = this.errors[i].prefixWith(dataPath, schemaPath);\n    }\n    return this;\n};\nValidatorContext.prototype.banUnknownProperties = function (data, schema) {\n    for (var unknownPath in this.unknownPropertyPaths) {\n        var error = this.createError(ErrorCodes.UNKNOWN_PROPERTY, { path: unknownPath }, unknownPath, \"\", null, data, schema);\n        var result = this.handleError(error);\n        if (result) {\n            return result;\n        }\n    }\n    return null;\n};\n\nValidatorContext.prototype.addFormat = function (format, validator) {\n    if ((typeof format === 'undefined' ? 'undefined' : (0, _typeof3.default)(format)) === 'object') {\n        for (var key in format) {\n            this.addFormat(key, format[key]);\n        }\n        return this;\n    }\n    this.formatValidators[format] = validator;\n};\nValidatorContext.prototype.resolveRefs = function (schema, urlHistory) {\n    if (schema['$ref'] !== undefined) {\n        urlHistory = urlHistory || {};\n        if (urlHistory[schema['$ref']]) {\n            return this.createError(ErrorCodes.CIRCULAR_REFERENCE, { urls: (0, _keys2.default)(urlHistory).join(', ') }, '', '', null, undefined, schema);\n        }\n        urlHistory[schema['$ref']] = true;\n        schema = this.getSchema(schema['$ref'], urlHistory);\n    }\n    return schema;\n};\nValidatorContext.prototype.getSchema = function (url, urlHistory) {\n    var schema;\n    if (this.schemas[url] !== undefined) {\n        schema = this.schemas[url];\n        return this.resolveRefs(schema, urlHistory);\n    }\n    var baseUrl = url;\n    var fragment = \"\";\n    if (url.indexOf('#') !== -1) {\n        fragment = url.substring(url.indexOf(\"#\") + 1);\n        baseUrl = url.substring(0, url.indexOf(\"#\"));\n    }\n    if ((0, _typeof3.default)(this.schemas[baseUrl]) === 'object') {\n        schema = this.schemas[baseUrl];\n        var pointerPath = decodeURIComponent(fragment);\n        if (pointerPath === \"\") {\n            return this.resolveRefs(schema, urlHistory);\n        } else if (pointerPath.charAt(0) !== \"/\") {\n            return undefined;\n        }\n        var parts = pointerPath.split(\"/\").slice(1);\n        for (var i = 0; i < parts.length; i++) {\n            var component = parts[i].replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n            if (schema[component] === undefined) {\n                schema = undefined;\n                break;\n            }\n            schema = schema[component];\n        }\n        if (schema !== undefined) {\n            return this.resolveRefs(schema, urlHistory);\n        }\n    }\n    if (this.missing[baseUrl] === undefined) {\n        this.missing.push(baseUrl);\n        this.missing[baseUrl] = baseUrl;\n        this.missingMap[baseUrl] = baseUrl;\n    }\n};\nValidatorContext.prototype.searchSchemas = function (schema, url) {\n    if (Array.isArray(schema)) {\n        for (var i = 0; i < schema.length; i++) {\n            this.searchSchemas(schema[i], url);\n        }\n    } else if (schema && (typeof schema === 'undefined' ? 'undefined' : (0, _typeof3.default)(schema)) === \"object\") {\n        if (typeof schema.id === \"string\") {\n            if (isTrustedUrl(url, schema.id)) {\n                if (this.schemas[schema.id] === undefined) {\n                    this.schemas[schema.id] = schema;\n                }\n            }\n        }\n        for (var key in schema) {\n            if (key !== \"enum\") {\n                if ((0, _typeof3.default)(schema[key]) === \"object\") {\n                    this.searchSchemas(schema[key], url);\n                } else if (key === \"$ref\") {\n                    var uri = getDocumentUri(schema[key]);\n                    if (uri && this.schemas[uri] === undefined && this.missingMap[uri] === undefined) {\n                        this.missingMap[uri] = uri;\n                    }\n                }\n            }\n        }\n    }\n};\nValidatorContext.prototype.addSchema = function (url, schema) {\n    //overload\n    if (typeof url !== 'string' || typeof schema === 'undefined') {\n        if ((typeof url === 'undefined' ? 'undefined' : (0, _typeof3.default)(url)) === 'object' && typeof url.id === 'string') {\n            schema = url;\n            url = schema.id;\n        } else {\n            return;\n        }\n    }\n    if (url === getDocumentUri(url) + \"#\") {\n        // Remove empty fragment\n        url = getDocumentUri(url);\n    }\n    this.schemas[url] = schema;\n    delete this.missingMap[url];\n    normSchema(schema, url);\n    this.searchSchemas(schema, url);\n};\n\nValidatorContext.prototype.getSchemaMap = function () {\n    var map = {};\n    for (var key in this.schemas) {\n        map[key] = this.schemas[key];\n    }\n    return map;\n};\n\nValidatorContext.prototype.getSchemaUris = function (filterRegExp) {\n    var list = [];\n    for (var key in this.schemas) {\n        if (!filterRegExp || filterRegExp.test(key)) {\n            list.push(key);\n        }\n    }\n    return list;\n};\n\nValidatorContext.prototype.getMissingUris = function (filterRegExp) {\n    var list = [];\n    for (var key in this.missingMap) {\n        if (!filterRegExp || filterRegExp.test(key)) {\n            list.push(key);\n        }\n    }\n    return list;\n};\n\nValidatorContext.prototype.dropSchemas = function () {\n    this.schemas = {};\n    this.reset();\n};\nValidatorContext.prototype.reset = function () {\n    this.missing = [];\n    this.missingMap = {};\n    this.errors = [];\n};\n\nValidatorContext.prototype.validateAll = function (data, schema, dataPathParts, schemaPathParts, dataPointerPath) {\n    var topLevel;\n    schema = this.resolveRefs(schema);\n    if (!schema) {\n        return null;\n    } else if (schema instanceof ValidationError) {\n        this.errors.push(schema);\n        return schema;\n    }\n\n    var startErrorCount = this.errors.length;\n    var frozenIndex,\n        scannedFrozenSchemaIndex = null,\n        scannedSchemasIndex = null;\n    if (this.checkRecursive && data && (typeof data === 'undefined' ? 'undefined' : (0, _typeof3.default)(data)) === 'object') {\n        topLevel = !this.scanned.length;\n        if (data[this.validatedSchemasKey]) {\n            var schemaIndex = data[this.validatedSchemasKey].indexOf(schema);\n            if (schemaIndex !== -1) {\n                this.errors = this.errors.concat(data[this.validationErrorsKey][schemaIndex]);\n                return null;\n            }\n        }\n        if ((0, _isFrozen2.default)(data)) {\n            frozenIndex = this.scannedFrozen.indexOf(data);\n            if (frozenIndex !== -1) {\n                var frozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].indexOf(schema);\n                if (frozenSchemaIndex !== -1) {\n                    this.errors = this.errors.concat(this.scannedFrozenValidationErrors[frozenIndex][frozenSchemaIndex]);\n                    return null;\n                }\n            }\n        }\n        this.scanned.push(data);\n        if ((0, _isFrozen2.default)(data)) {\n            if (frozenIndex === -1) {\n                frozenIndex = this.scannedFrozen.length;\n                this.scannedFrozen.push(data);\n                this.scannedFrozenSchemas.push([]);\n            }\n            scannedFrozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].length;\n            this.scannedFrozenSchemas[frozenIndex][scannedFrozenSchemaIndex] = schema;\n            this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = [];\n        } else {\n            if (!data[this.validatedSchemasKey]) {\n                try {\n                    (0, _defineProperty2.default)(data, this.validatedSchemasKey, {\n                        value: [],\n                        configurable: true\n                    });\n                    (0, _defineProperty2.default)(data, this.validationErrorsKey, {\n                        value: [],\n                        configurable: true\n                    });\n                } catch (e) {\n                    //IE 7/8 workaround\n                    data[this.validatedSchemasKey] = [];\n                    data[this.validationErrorsKey] = [];\n                }\n            }\n            scannedSchemasIndex = data[this.validatedSchemasKey].length;\n            data[this.validatedSchemasKey][scannedSchemasIndex] = schema;\n            data[this.validationErrorsKey][scannedSchemasIndex] = [];\n        }\n    }\n\n    var errorCount = this.errors.length;\n    var error = this.validateBasic(data, schema, dataPointerPath) || this.validateNumeric(data, schema, dataPointerPath) || this.validateString(data, schema, dataPointerPath) || this.validateArray(data, schema, dataPointerPath) || this.validateObject(data, schema, dataPointerPath) || this.validateCombinations(data, schema, dataPointerPath) || this.validateHypermedia(data, schema, dataPointerPath) || this.validateFormat(data, schema, dataPointerPath) || this.validateDefinedKeywords(data, schema, dataPointerPath) || null;\n\n    if (topLevel) {\n        while (this.scanned.length) {\n            var item = this.scanned.pop();\n            delete item[this.validatedSchemasKey];\n        }\n        this.scannedFrozen = [];\n        this.scannedFrozenSchemas = [];\n    }\n\n    if (error || errorCount !== this.errors.length) {\n        while (dataPathParts && dataPathParts.length || schemaPathParts && schemaPathParts.length) {\n            var dataPart = dataPathParts && dataPathParts.length ? \"\" + dataPathParts.pop() : null;\n            var schemaPart = schemaPathParts && schemaPathParts.length ? \"\" + schemaPathParts.pop() : null;\n            if (error) {\n                error = error.prefixWith(dataPart, schemaPart);\n            }\n            this.prefixErrors(errorCount, dataPart, schemaPart);\n        }\n    }\n\n    if (scannedFrozenSchemaIndex !== null) {\n        this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = this.errors.slice(startErrorCount);\n    } else if (scannedSchemasIndex !== null) {\n        data[this.validationErrorsKey][scannedSchemasIndex] = this.errors.slice(startErrorCount);\n    }\n\n    return this.handleError(error);\n};\nValidatorContext.prototype.validateFormat = function (data, schema) {\n    if (typeof schema.format !== 'string' || !this.formatValidators[schema.format]) {\n        return null;\n    }\n    var errorMessage = this.formatValidators[schema.format].call(null, data, schema);\n    if (typeof errorMessage === 'string' || typeof errorMessage === 'number') {\n        return this.createError(ErrorCodes.FORMAT_CUSTOM, { message: errorMessage }, '', '/format', null, data, schema);\n    } else if (errorMessage && (typeof errorMessage === 'undefined' ? 'undefined' : (0, _typeof3.default)(errorMessage)) === 'object') {\n        return this.createError(ErrorCodes.FORMAT_CUSTOM, { message: errorMessage.message || \"?\" }, errorMessage.dataPath || '', errorMessage.schemaPath || \"/format\", null, data, schema);\n    }\n    return null;\n};\nValidatorContext.prototype.validateDefinedKeywords = function (data, schema, dataPointerPath) {\n    for (var key in this.definedKeywords) {\n        if (typeof schema[key] === 'undefined') {\n            continue;\n        }\n        var validationFunctions = this.definedKeywords[key];\n        for (var i = 0; i < validationFunctions.length; i++) {\n            var func = validationFunctions[i];\n            var result = func(data, schema[key], schema, dataPointerPath);\n            if (typeof result === 'string' || typeof result === 'number') {\n                return this.createError(ErrorCodes.KEYWORD_CUSTOM, {\n                    key: key,\n                    message: result\n                }, '', '', null, data, schema).prefixWith(null, key);\n            } else if (result && (typeof result === 'undefined' ? 'undefined' : (0, _typeof3.default)(result)) === 'object') {\n                var code = result.code;\n                if (typeof code === 'string') {\n                    if (!ErrorCodes[code]) {\n                        throw new Error('Undefined error code (use defineError): ' + code);\n                    }\n                    code = ErrorCodes[code];\n                } else if (typeof code !== 'number') {\n                    code = ErrorCodes.KEYWORD_CUSTOM;\n                }\n                var messageParams = (0, _typeof3.default)(result.message) === 'object' ? result.message : {\n                    key: key,\n                    message: result.message || \"?\"\n                };\n                var schemaPath = result.schemaPath || \"/\" + key.replace(/~/g, '~0').replace(/\\//g, '~1');\n                return this.createError(code, messageParams, result.dataPath || null, schemaPath, null, data, schema);\n            }\n        }\n    }\n    return null;\n};\n\nfunction recursiveCompare(A, B) {\n    if (A === B) {\n        return true;\n    }\n    if (A && B && (typeof A === 'undefined' ? 'undefined' : (0, _typeof3.default)(A)) === \"object\" && (typeof B === 'undefined' ? 'undefined' : (0, _typeof3.default)(B)) === \"object\") {\n        if (Array.isArray(A) !== Array.isArray(B)) {\n            return false;\n        } else if (Array.isArray(A)) {\n            if (A.length !== B.length) {\n                return false;\n            }\n            for (var i = 0; i < A.length; i++) {\n                if (!recursiveCompare(A[i], B[i])) {\n                    return false;\n                }\n            }\n        } else {\n            var key;\n            for (key in A) {\n                if (B[key] === undefined && A[key] !== undefined) {\n                    return false;\n                }\n            }\n            for (key in B) {\n                if (A[key] === undefined && B[key] !== undefined) {\n                    return false;\n                }\n            }\n            for (key in A) {\n                if (!recursiveCompare(A[key], B[key])) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    return false;\n}\n\nValidatorContext.prototype.validateBasic = function validateBasic(data, schema, dataPointerPath) {\n    var error;\n    if (error = this.validateType(data, schema, dataPointerPath)) {\n        return error.prefixWith(null, \"type\");\n    }\n    if (error = this.validateEnum(data, schema, dataPointerPath)) {\n        return error.prefixWith(null, \"type\");\n    }\n    return null;\n};\n\nValidatorContext.prototype.validateType = function validateType(data, schema) {\n    if (schema.type === undefined) {\n        return null;\n    }\n    var dataType = typeof data === 'undefined' ? 'undefined' : (0, _typeof3.default)(data);\n    if (data === null) {\n        dataType = \"null\";\n    } else if (Array.isArray(data)) {\n        dataType = \"array\";\n    }\n    var allowedTypes = schema.type;\n    if (!Array.isArray(allowedTypes)) {\n        allowedTypes = [allowedTypes];\n    }\n\n    for (var i = 0; i < allowedTypes.length; i++) {\n        var type = allowedTypes[i];\n        if (type === dataType || type === \"integer\" && dataType === \"number\" && data % 1 === 0) {\n            return null;\n        }\n    }\n    return this.createError(ErrorCodes.INVALID_TYPE, {\n        type: dataType,\n        expected: allowedTypes.join(\"/\")\n    }, '', '', null, data, schema);\n};\n\nValidatorContext.prototype.validateEnum = function validateEnum(data, schema) {\n    if (schema[\"enum\"] === undefined) {\n        return null;\n    }\n    for (var i = 0; i < schema[\"enum\"].length; i++) {\n        var enumVal = schema[\"enum\"][i];\n        if (recursiveCompare(data, enumVal)) {\n            return null;\n        }\n    }\n    return this.createError(ErrorCodes.ENUM_MISMATCH, { value: typeof JSON !== 'undefined' ? (0, _stringify2.default)(data) : data }, '', '', null, data, schema);\n};\n\nValidatorContext.prototype.validateNumeric = function validateNumeric(data, schema, dataPointerPath) {\n    return this.validateMultipleOf(data, schema, dataPointerPath) || this.validateMinMax(data, schema, dataPointerPath) || this.validateNaN(data, schema, dataPointerPath) || null;\n};\n\nvar CLOSE_ENOUGH_LOW = Math.pow(2, -51);\nvar CLOSE_ENOUGH_HIGH = 1 - CLOSE_ENOUGH_LOW;\nValidatorContext.prototype.validateMultipleOf = function validateMultipleOf(data, schema) {\n    var multipleOf = schema.multipleOf || schema.divisibleBy;\n    if (multipleOf === undefined) {\n        return null;\n    }\n    if (typeof data === \"number\") {\n        var remainder = data / multipleOf % 1;\n        if (remainder >= CLOSE_ENOUGH_LOW && remainder < CLOSE_ENOUGH_HIGH) {\n            return this.createError(ErrorCodes.NUMBER_MULTIPLE_OF, {\n                value: data,\n                multipleOf: multipleOf\n            }, '', '', null, data, schema);\n        }\n    }\n    return null;\n};\n\nValidatorContext.prototype.validateMinMax = function validateMinMax(data, schema) {\n    if (typeof data !== \"number\") {\n        return null;\n    }\n    if (schema.minimum !== undefined) {\n        if (data < schema.minimum) {\n            return this.createError(ErrorCodes.NUMBER_MINIMUM, {\n                value: data,\n                minimum: schema.minimum\n            }, '', '/minimum', null, data, schema);\n        }\n        if (schema.exclusiveMinimum && data === schema.minimum) {\n            return this.createError(ErrorCodes.NUMBER_MINIMUM_EXCLUSIVE, {\n                value: data,\n                minimum: schema.minimum\n            }, '', '/exclusiveMinimum', null, data, schema);\n        }\n    }\n    if (schema.maximum !== undefined) {\n        if (data > schema.maximum) {\n            return this.createError(ErrorCodes.NUMBER_MAXIMUM, {\n                value: data,\n                maximum: schema.maximum\n            }, '', '/maximum', null, data, schema);\n        }\n        if (schema.exclusiveMaximum && data === schema.maximum) {\n            return this.createError(ErrorCodes.NUMBER_MAXIMUM_EXCLUSIVE, {\n                value: data,\n                maximum: schema.maximum\n            }, '', '/exclusiveMaximum', null, data, schema);\n        }\n    }\n    return null;\n};\n\nValidatorContext.prototype.validateNaN = function validateNaN(data, schema) {\n    if (typeof data !== \"number\") {\n        return null;\n    }\n    if (isNaN(data) === true || data === Infinity || data === -Infinity) {\n        return this.createError(ErrorCodes.NUMBER_NOT_A_NUMBER, { value: data }, '', '/type', null, data, schema);\n    }\n    return null;\n};\n\nValidatorContext.prototype.validateString = function validateString(data, schema, dataPointerPath) {\n    return this.validateStringLength(data, schema, dataPointerPath) || this.validateStringPattern(data, schema, dataPointerPath) || null;\n};\n\nValidatorContext.prototype.validateStringLength = function validateStringLength(data, schema) {\n    if (typeof data !== \"string\") {\n        return null;\n    }\n    if (schema.minLength !== undefined) {\n        if (data.length < schema.minLength) {\n            return this.createError(ErrorCodes.STRING_LENGTH_SHORT, {\n                length: data.length,\n                minimum: schema.minLength\n            }, '', '/minLength', null, data, schema);\n        }\n    }\n    if (schema.maxLength !== undefined) {\n        if (data.length > schema.maxLength) {\n            return this.createError(ErrorCodes.STRING_LENGTH_LONG, {\n                length: data.length,\n                maximum: schema.maxLength\n            }, '', '/maxLength', null, data, schema);\n        }\n    }\n    return null;\n};\n\nValidatorContext.prototype.validateStringPattern = function validateStringPattern(data, schema) {\n    if (typeof data !== \"string\" || typeof schema.pattern !== \"string\" && !(schema.pattern instanceof RegExp)) {\n        return null;\n    }\n    var regexp;\n    if (schema.pattern instanceof RegExp) {\n        regexp = schema.pattern;\n    } else {\n        var body,\n            flags = '';\n        // Check for regular expression literals\n        // @see http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.5\n        var literal = schema.pattern.match(/^\\/(.+)\\/([img]*)$/);\n        if (literal) {\n            body = literal[1];\n            flags = literal[2];\n        } else {\n            body = schema.pattern;\n        }\n        regexp = new RegExp(body, flags);\n    }\n    if (!regexp.test(data)) {\n        return this.createError(ErrorCodes.STRING_PATTERN, { pattern: schema.pattern }, '', '/pattern', null, data, schema);\n    }\n    return null;\n};\n\nValidatorContext.prototype.validateArray = function validateArray(data, schema, dataPointerPath) {\n    if (!Array.isArray(data)) {\n        return null;\n    }\n    return this.validateArrayLength(data, schema, dataPointerPath) || this.validateArrayUniqueItems(data, schema, dataPointerPath) || this.validateArrayItems(data, schema, dataPointerPath) || null;\n};\n\nValidatorContext.prototype.validateArrayLength = function validateArrayLength(data, schema) {\n    var error;\n    if (schema.minItems !== undefined) {\n        if (data.length < schema.minItems) {\n            error = this.createError(ErrorCodes.ARRAY_LENGTH_SHORT, {\n                length: data.length,\n                minimum: schema.minItems\n            }, '', '/minItems', null, data, schema);\n            if (this.handleError(error)) {\n                return error;\n            }\n        }\n    }\n    if (schema.maxItems !== undefined) {\n        if (data.length > schema.maxItems) {\n            error = this.createError(ErrorCodes.ARRAY_LENGTH_LONG, {\n                length: data.length,\n                maximum: schema.maxItems\n            }, '', '/maxItems', null, data, schema);\n            if (this.handleError(error)) {\n                return error;\n            }\n        }\n    }\n    return null;\n};\n\nValidatorContext.prototype.validateArrayUniqueItems = function validateArrayUniqueItems(data, schema) {\n    if (schema.uniqueItems) {\n        for (var i = 0; i < data.length; i++) {\n            for (var j = i + 1; j < data.length; j++) {\n                if (recursiveCompare(data[i], data[j])) {\n                    var error = this.createError(ErrorCodes.ARRAY_UNIQUE, {\n                        match1: i,\n                        match2: j\n                    }, '', '/uniqueItems', null, data, schema);\n                    if (this.handleError(error)) {\n                        return error;\n                    }\n                }\n            }\n        }\n    }\n    return null;\n};\n\nValidatorContext.prototype.validateArrayItems = function validateArrayItems(data, schema, dataPointerPath) {\n    if (schema.items === undefined) {\n        return null;\n    }\n    var error, i;\n    if (Array.isArray(schema.items)) {\n        for (i = 0; i < data.length; i++) {\n            if (i < schema.items.length) {\n                if (error = this.validateAll(data[i], schema.items[i], [i], [\"items\", i], dataPointerPath + \"/\" + i)) {\n                    return error;\n                }\n            } else if (schema.additionalItems !== undefined) {\n                if (typeof schema.additionalItems === \"boolean\") {\n                    if (!schema.additionalItems) {\n                        error = this.createError(ErrorCodes.ARRAY_ADDITIONAL_ITEMS, {}, '/' + i, '/additionalItems', null, data, schema);\n                        if (this.handleError(error)) {\n                            return error;\n                        }\n                    }\n                } else if (error = this.validateAll(data[i], schema.additionalItems, [i], [\"additionalItems\"], dataPointerPath + \"/\" + i)) {\n                    return error;\n                }\n            }\n        }\n    } else {\n        for (i = 0; i < data.length; i++) {\n            if (error = this.validateAll(data[i], schema.items, [i], [\"items\"], dataPointerPath + \"/\" + i)) {\n                return error;\n            }\n        }\n    }\n    return null;\n};\n\nValidatorContext.prototype.validateObject = function validateObject(data, schema, dataPointerPath) {\n    if ((typeof data === 'undefined' ? 'undefined' : (0, _typeof3.default)(data)) !== \"object\" || data === null || Array.isArray(data)) {\n        return null;\n    }\n    return this.validateObjectMinMaxProperties(data, schema, dataPointerPath) || this.validateObjectRequiredProperties(data, schema, dataPointerPath) || this.validateObjectProperties(data, schema, dataPointerPath) || this.validateObjectDependencies(data, schema, dataPointerPath) || null;\n};\n\nValidatorContext.prototype.validateObjectMinMaxProperties = function validateObjectMinMaxProperties(data, schema) {\n    var keys = (0, _keys2.default)(data);\n    var error;\n    if (schema.minProperties !== undefined) {\n        if (keys.length < schema.minProperties) {\n            error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MINIMUM, {\n                propertyCount: keys.length,\n                minimum: schema.minProperties\n            }, '', '/minProperties', null, data, schema);\n            if (this.handleError(error)) {\n                return error;\n            }\n        }\n    }\n    if (schema.maxProperties !== undefined) {\n        if (keys.length > schema.maxProperties) {\n            error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MAXIMUM, {\n                propertyCount: keys.length,\n                maximum: schema.maxProperties\n            }, '', '/maxProperties', null, data, schema);\n            if (this.handleError(error)) {\n                return error;\n            }\n        }\n    }\n    return null;\n};\n\nValidatorContext.prototype.validateObjectRequiredProperties = function validateObjectRequiredProperties(data, schema) {\n    if (schema.required !== undefined) {\n        for (var i = 0; i < schema.required.length; i++) {\n            var key = schema.required[i];\n            if (data[key] === undefined) {\n                var error = this.createError(ErrorCodes.OBJECT_REQUIRED, { key: key }, '', '/required/' + i, null, data, schema);\n                if (this.handleError(error)) {\n                    return error;\n                }\n            }\n        }\n    }\n    return null;\n};\n\nValidatorContext.prototype.validateObjectProperties = function validateObjectProperties(data, schema, dataPointerPath) {\n    var error;\n    for (var key in data) {\n        var keyPointerPath = dataPointerPath + \"/\" + key.replace(/~/g, '~0').replace(/\\//g, '~1');\n        var foundMatch = false;\n        if (schema.properties !== undefined && schema.properties[key] !== undefined) {\n            foundMatch = true;\n            if (error = this.validateAll(data[key], schema.properties[key], [key], [\"properties\", key], keyPointerPath)) {\n                return error;\n            }\n        }\n        if (schema.patternProperties !== undefined) {\n            for (var patternKey in schema.patternProperties) {\n                var regexp = new RegExp(patternKey);\n                if (regexp.test(key)) {\n                    foundMatch = true;\n                    if (error = this.validateAll(data[key], schema.patternProperties[patternKey], [key], [\"patternProperties\", patternKey], keyPointerPath)) {\n                        return error;\n                    }\n                }\n            }\n        }\n        if (!foundMatch) {\n            if (schema.additionalProperties !== undefined) {\n                if (this.trackUnknownProperties) {\n                    this.knownPropertyPaths[keyPointerPath] = true;\n                    delete this.unknownPropertyPaths[keyPointerPath];\n                }\n                if (typeof schema.additionalProperties === \"boolean\") {\n                    if (!schema.additionalProperties) {\n                        error = this.createError(ErrorCodes.OBJECT_ADDITIONAL_PROPERTIES, { key: key }, '', '/additionalProperties', null, data, schema).prefixWith(key, null);\n                        if (this.handleError(error)) {\n                            return error;\n                        }\n                    }\n                } else {\n                    if (error = this.validateAll(data[key], schema.additionalProperties, [key], [\"additionalProperties\"], keyPointerPath)) {\n                        return error;\n                    }\n                }\n            } else if (this.trackUnknownProperties && !this.knownPropertyPaths[keyPointerPath]) {\n                this.unknownPropertyPaths[keyPointerPath] = true;\n            }\n        } else if (this.trackUnknownProperties) {\n            this.knownPropertyPaths[keyPointerPath] = true;\n            delete this.unknownPropertyPaths[keyPointerPath];\n        }\n    }\n    return null;\n};\n\nValidatorContext.prototype.validateObjectDependencies = function validateObjectDependencies(data, schema, dataPointerPath) {\n    var error;\n    if (schema.dependencies !== undefined) {\n        for (var depKey in schema.dependencies) {\n            if (data[depKey] !== undefined) {\n                var dep = schema.dependencies[depKey];\n                if (typeof dep === \"string\") {\n                    if (data[dep] === undefined) {\n                        error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {\n                            key: depKey,\n                            missing: dep\n                        }, '', '', null, data, schema).prefixWith(null, depKey).prefixWith(null, \"dependencies\");\n                        if (this.handleError(error)) {\n                            return error;\n                        }\n                    }\n                } else if (Array.isArray(dep)) {\n                    for (var i = 0; i < dep.length; i++) {\n                        var requiredKey = dep[i];\n                        if (data[requiredKey] === undefined) {\n                            error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {\n                                key: depKey,\n                                missing: requiredKey\n                            }, '', '/' + i, null, data, schema).prefixWith(null, depKey).prefixWith(null, \"dependencies\");\n                            if (this.handleError(error)) {\n                                return error;\n                            }\n                        }\n                    }\n                } else {\n                    if (error = this.validateAll(data, dep, [], [\"dependencies\", depKey], dataPointerPath)) {\n                        return error;\n                    }\n                }\n            }\n        }\n    }\n    return null;\n};\n\nValidatorContext.prototype.validateCombinations = function validateCombinations(data, schema, dataPointerPath) {\n    return this.validateAllOf(data, schema, dataPointerPath) || this.validateAnyOf(data, schema, dataPointerPath) || this.validateOneOf(data, schema, dataPointerPath) || this.validateNot(data, schema, dataPointerPath) || null;\n};\n\nValidatorContext.prototype.validateAllOf = function validateAllOf(data, schema, dataPointerPath) {\n    if (schema.allOf === undefined) {\n        return null;\n    }\n    var error;\n    for (var i = 0; i < schema.allOf.length; i++) {\n        var subSchema = schema.allOf[i];\n        if (error = this.validateAll(data, subSchema, [], [\"allOf\", i], dataPointerPath)) {\n            return error;\n        }\n    }\n    return null;\n};\n\nValidatorContext.prototype.validateAnyOf = function validateAnyOf(data, schema, dataPointerPath) {\n    if (schema.anyOf === undefined) {\n        return null;\n    }\n    var errors = [];\n    var startErrorCount = this.errors.length;\n    var oldUnknownPropertyPaths, oldKnownPropertyPaths;\n    if (this.trackUnknownProperties) {\n        oldUnknownPropertyPaths = this.unknownPropertyPaths;\n        oldKnownPropertyPaths = this.knownPropertyPaths;\n    }\n    var errorAtEnd = true;\n    for (var i = 0; i < schema.anyOf.length; i++) {\n        if (this.trackUnknownProperties) {\n            this.unknownPropertyPaths = {};\n            this.knownPropertyPaths = {};\n        }\n        var subSchema = schema.anyOf[i];\n\n        var errorCount = this.errors.length;\n        var error = this.validateAll(data, subSchema, [], [\"anyOf\", i], dataPointerPath);\n\n        if (error === null && errorCount === this.errors.length) {\n            this.errors = this.errors.slice(0, startErrorCount);\n\n            if (this.trackUnknownProperties) {\n                for (var knownKey in this.knownPropertyPaths) {\n                    oldKnownPropertyPaths[knownKey] = true;\n                    delete oldUnknownPropertyPaths[knownKey];\n                }\n                for (var unknownKey in this.unknownPropertyPaths) {\n                    if (!oldKnownPropertyPaths[unknownKey]) {\n                        oldUnknownPropertyPaths[unknownKey] = true;\n                    }\n                }\n                // We need to continue looping so we catch all the property definitions, but we don't want to return an error\n                errorAtEnd = false;\n                continue;\n            }\n\n            return null;\n        }\n        if (error) {\n            errors.push(error.prefixWith(null, \"\" + i).prefixWith(null, \"anyOf\"));\n        }\n    }\n    if (this.trackUnknownProperties) {\n        this.unknownPropertyPaths = oldUnknownPropertyPaths;\n        this.knownPropertyPaths = oldKnownPropertyPaths;\n    }\n    if (errorAtEnd) {\n        errors = errors.concat(this.errors.slice(startErrorCount));\n        this.errors = this.errors.slice(0, startErrorCount);\n        return this.createError(ErrorCodes.ANY_OF_MISSING, {}, \"\", \"/anyOf\", errors, data, schema);\n    }\n};\n\nValidatorContext.prototype.validateOneOf = function validateOneOf(data, schema, dataPointerPath) {\n    if (schema.oneOf === undefined) {\n        return null;\n    }\n    var validIndex = null;\n    var errors = [];\n    var startErrorCount = this.errors.length;\n    var oldUnknownPropertyPaths, oldKnownPropertyPaths;\n    if (this.trackUnknownProperties) {\n        oldUnknownPropertyPaths = this.unknownPropertyPaths;\n        oldKnownPropertyPaths = this.knownPropertyPaths;\n    }\n    for (var i = 0; i < schema.oneOf.length; i++) {\n        if (this.trackUnknownProperties) {\n            this.unknownPropertyPaths = {};\n            this.knownPropertyPaths = {};\n        }\n        var subSchema = schema.oneOf[i];\n\n        var errorCount = this.errors.length;\n        var error = this.validateAll(data, subSchema, [], [\"oneOf\", i], dataPointerPath);\n\n        if (error === null && errorCount === this.errors.length) {\n            if (validIndex === null) {\n                validIndex = i;\n            } else {\n                this.errors = this.errors.slice(0, startErrorCount);\n                return this.createError(ErrorCodes.ONE_OF_MULTIPLE, {\n                    index1: validIndex,\n                    index2: i\n                }, \"\", \"/oneOf\", null, data, schema);\n            }\n            if (this.trackUnknownProperties) {\n                for (var knownKey in this.knownPropertyPaths) {\n                    oldKnownPropertyPaths[knownKey] = true;\n                    delete oldUnknownPropertyPaths[knownKey];\n                }\n                for (var unknownKey in this.unknownPropertyPaths) {\n                    if (!oldKnownPropertyPaths[unknownKey]) {\n                        oldUnknownPropertyPaths[unknownKey] = true;\n                    }\n                }\n            }\n        } else if (error) {\n            errors.push(error);\n        }\n    }\n    if (this.trackUnknownProperties) {\n        this.unknownPropertyPaths = oldUnknownPropertyPaths;\n        this.knownPropertyPaths = oldKnownPropertyPaths;\n    }\n    if (validIndex === null) {\n        errors = errors.concat(this.errors.slice(startErrorCount));\n        this.errors = this.errors.slice(0, startErrorCount);\n        return this.createError(ErrorCodes.ONE_OF_MISSING, {}, \"\", \"/oneOf\", errors, data, schema);\n    } else {\n        this.errors = this.errors.slice(0, startErrorCount);\n    }\n    return null;\n};\n\nValidatorContext.prototype.validateNot = function validateNot(data, schema, dataPointerPath) {\n    if (schema.not === undefined) {\n        return null;\n    }\n    var oldErrorCount = this.errors.length;\n    var oldUnknownPropertyPaths, oldKnownPropertyPaths;\n    if (this.trackUnknownProperties) {\n        oldUnknownPropertyPaths = this.unknownPropertyPaths;\n        oldKnownPropertyPaths = this.knownPropertyPaths;\n        this.unknownPropertyPaths = {};\n        this.knownPropertyPaths = {};\n    }\n    var error = this.validateAll(data, schema.not, null, null, dataPointerPath);\n    var notErrors = this.errors.slice(oldErrorCount);\n    this.errors = this.errors.slice(0, oldErrorCount);\n    if (this.trackUnknownProperties) {\n        this.unknownPropertyPaths = oldUnknownPropertyPaths;\n        this.knownPropertyPaths = oldKnownPropertyPaths;\n    }\n    if (error === null && notErrors.length === 0) {\n        return this.createError(ErrorCodes.NOT_PASSED, {}, \"\", \"/not\", null, data, schema);\n    }\n    return null;\n};\n\nValidatorContext.prototype.validateHypermedia = function validateCombinations(data, schema, dataPointerPath) {\n    if (!schema.links) {\n        return null;\n    }\n    var error;\n    for (var i = 0; i < schema.links.length; i++) {\n        var ldo = schema.links[i];\n        if (ldo.rel === \"describedby\") {\n            var template = new UriTemplate(ldo.href);\n            var allPresent = true;\n            for (var j = 0; j < template.varNames.length; j++) {\n                if (!(template.varNames[j] in data)) {\n                    allPresent = false;\n                    break;\n                }\n            }\n            if (allPresent) {\n                var schemaUrl = template.fillFromObject(data);\n                var subSchema = { \"$ref\": schemaUrl };\n                if (error = this.validateAll(data, subSchema, [], [\"links\", i], dataPointerPath)) {\n                    return error;\n                }\n            }\n        }\n    }\n};\n\n// parseURI() and resolveUrl() are from https://gist.github.com/1088850\n//   -  released as public domain by author (\"Yaffle\") - see comments on gist\n\nfunction parseURI(url) {\n    var m = String(url).replace(/^\\s+|\\s+$/g, '').match(/^([^:\\/?#]+:)?(\\/\\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\\/?#]*)(?::(\\d*))?))?([^?#]*)(\\?[^#]*)?(#[\\s\\S]*)?/);\n    // authority = '//' + user + ':' + pass '@' + hostname + ':' port\n    return m ? {\n        href: m[0] || '',\n        protocol: m[1] || '',\n        authority: m[2] || '',\n        host: m[3] || '',\n        hostname: m[4] || '',\n        port: m[5] || '',\n        pathname: m[6] || '',\n        search: m[7] || '',\n        hash: m[8] || ''\n    } : null;\n}\n\nfunction resolveUrl(base, href) {\n    // RFC 3986\n\n    function removeDotSegments(input) {\n        var output = [];\n        input.replace(/^(\\.\\.?(\\/|$))+/, '').replace(/\\/(\\.(\\/|$))+/g, '/').replace(/\\/\\.\\.$/, '/../').replace(/\\/?[^\\/]*/g, function (p) {\n            if (p === '/..') {\n                output.pop();\n            } else {\n                output.push(p);\n            }\n        });\n        return output.join('').replace(/^\\//, input.charAt(0) === '/' ? '/' : '');\n    }\n\n    href = parseURI(href || '');\n    base = parseURI(base || '');\n\n    return !href || !base ? null : (href.protocol || base.protocol) + (href.protocol || href.authority ? href.authority : base.authority) + removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : href.pathname ? (base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname : base.pathname) + (href.protocol || href.authority || href.pathname ? href.search : href.search || base.search) + href.hash;\n}\n\nfunction getDocumentUri(uri) {\n    return uri.split('#')[0];\n}\n\nfunction normSchema(schema, baseUri) {\n    if (schema && (typeof schema === 'undefined' ? 'undefined' : (0, _typeof3.default)(schema)) === \"object\") {\n        if (baseUri === undefined) {\n            baseUri = schema.id;\n        } else if (typeof schema.id === \"string\") {\n            baseUri = resolveUrl(baseUri, schema.id);\n            schema.id = baseUri;\n        }\n        if (Array.isArray(schema)) {\n            for (var i = 0; i < schema.length; i++) {\n                normSchema(schema[i], baseUri);\n            }\n        } else {\n            if (typeof schema['$ref'] === \"string\") {\n                schema['$ref'] = resolveUrl(baseUri, schema['$ref']);\n            }\n            for (var key in schema) {\n                if (key !== \"enum\") {\n                    normSchema(schema[key], baseUri);\n                }\n            }\n        }\n    }\n}\n\nfunction defaultErrorReporter(language) {\n    language = language || 'en';\n\n    var errorMessages = languages[language];\n\n    return function (error) {\n        var messageTemplate = errorMessages[error.code] || ErrorMessagesDefault[error.code];\n        if (typeof messageTemplate !== 'string') {\n            return \"Unknown error code \" + error.code + \": \" + (0, _stringify2.default)(error.messageParams);\n        }\n        var messageParams = error.params;\n        // Adapted from Crockford's supplant()\n        return messageTemplate.replace(/\\{([^{}]*)\\}/g, function (whole, varName) {\n            var subValue = messageParams[varName];\n            return typeof subValue === 'string' || typeof subValue === 'number' ? subValue : whole;\n        });\n    };\n}\n\nvar ErrorCodes = {\n    INVALID_TYPE: 0,\n    ENUM_MISMATCH: 1,\n    ANY_OF_MISSING: 10,\n    ONE_OF_MISSING: 11,\n    ONE_OF_MULTIPLE: 12,\n    NOT_PASSED: 13,\n    // Numeric errors\n    NUMBER_MULTIPLE_OF: 100,\n    NUMBER_MINIMUM: 101,\n    NUMBER_MINIMUM_EXCLUSIVE: 102,\n    NUMBER_MAXIMUM: 103,\n    NUMBER_MAXIMUM_EXCLUSIVE: 104,\n    NUMBER_NOT_A_NUMBER: 105,\n    // String errors\n    STRING_LENGTH_SHORT: 200,\n    STRING_LENGTH_LONG: 201,\n    STRING_PATTERN: 202,\n    // Object errors\n    OBJECT_PROPERTIES_MINIMUM: 300,\n    OBJECT_PROPERTIES_MAXIMUM: 301,\n    OBJECT_REQUIRED: 302,\n    OBJECT_ADDITIONAL_PROPERTIES: 303,\n    OBJECT_DEPENDENCY_KEY: 304,\n    // Array errors\n    ARRAY_LENGTH_SHORT: 400,\n    ARRAY_LENGTH_LONG: 401,\n    ARRAY_UNIQUE: 402,\n    ARRAY_ADDITIONAL_ITEMS: 403,\n    // Custom/user-defined errors\n    FORMAT_CUSTOM: 500,\n    KEYWORD_CUSTOM: 501,\n    // Schema structure\n    CIRCULAR_REFERENCE: 600,\n    // Non-standard validation options\n    UNKNOWN_PROPERTY: 1000\n};\nvar ErrorCodeLookup = {};\nfor (var key in ErrorCodes) {\n    ErrorCodeLookup[ErrorCodes[key]] = key;\n}\nvar ErrorMessagesDefault = {\n    INVALID_TYPE: \"Invalid type: {type} (expected {expected})\",\n    ENUM_MISMATCH: \"No enum match for: {value}\",\n    ANY_OF_MISSING: \"Data does not match any schemas from \\\"anyOf\\\"\",\n    ONE_OF_MISSING: \"Data does not match any schemas from \\\"oneOf\\\"\",\n    ONE_OF_MULTIPLE: \"Data is valid against more than one schema from \\\"oneOf\\\": indices {index1} and {index2}\",\n    NOT_PASSED: \"Data matches schema from \\\"not\\\"\",\n    // Numeric errors\n    NUMBER_MULTIPLE_OF: \"Value {value} is not a multiple of {multipleOf}\",\n    NUMBER_MINIMUM: \"Value {value} is less than minimum {minimum}\",\n    NUMBER_MINIMUM_EXCLUSIVE: \"Value {value} is equal to exclusive minimum {minimum}\",\n    NUMBER_MAXIMUM: \"Value {value} is greater than maximum {maximum}\",\n    NUMBER_MAXIMUM_EXCLUSIVE: \"Value {value} is equal to exclusive maximum {maximum}\",\n    NUMBER_NOT_A_NUMBER: \"Value {value} is not a valid number\",\n    // String errors\n    STRING_LENGTH_SHORT: \"String is too short ({length} chars), minimum {minimum}\",\n    STRING_LENGTH_LONG: \"String is too long ({length} chars), maximum {maximum}\",\n    STRING_PATTERN: \"String does not match pattern: {pattern}\",\n    // Object errors\n    OBJECT_PROPERTIES_MINIMUM: \"Too few properties defined ({propertyCount}), minimum {minimum}\",\n    OBJECT_PROPERTIES_MAXIMUM: \"Too many properties defined ({propertyCount}), maximum {maximum}\",\n    OBJECT_REQUIRED: \"Missing required property: {key}\",\n    OBJECT_ADDITIONAL_PROPERTIES: \"Additional properties not allowed\",\n    OBJECT_DEPENDENCY_KEY: \"Dependency failed - key must exist: {missing} (due to key: {key})\",\n    // Array errors\n    ARRAY_LENGTH_SHORT: \"Array is too short ({length}), minimum {minimum}\",\n    ARRAY_LENGTH_LONG: \"Array is too long ({length}), maximum {maximum}\",\n    ARRAY_UNIQUE: \"Array items are not unique (indices {match1} and {match2})\",\n    ARRAY_ADDITIONAL_ITEMS: \"Additional items not allowed\",\n    // Format errors\n    FORMAT_CUSTOM: \"Format validation failed ({message})\",\n    KEYWORD_CUSTOM: \"Keyword failed: {key} ({message})\",\n    // Schema structure\n    CIRCULAR_REFERENCE: \"Circular $refs: {urls}\",\n    // Non-standard validation options\n    UNKNOWN_PROPERTY: \"Unknown property (not in schema)\"\n};\n\nfunction ValidationError(code, params, dataPath, schemaPath, subErrors) {\n    Error.call(this);\n    if (code === undefined) {\n        throw new Error(\"No error code supplied: \" + schemaPath);\n    }\n    this.message = '';\n    this.params = params;\n    this.code = code;\n    this.dataPath = dataPath || \"\";\n    this.schemaPath = schemaPath || \"\";\n    this.subErrors = subErrors || null;\n\n    var err = new Error(this.message);\n    this.stack = err.stack || err.stacktrace;\n    if (!this.stack) {\n        try {\n            throw err;\n        } catch (err) {\n            this.stack = err.stack || err.stacktrace;\n        }\n    }\n}\n\nValidationError.prototype = (0, _create2.default)(Error.prototype);\nValidationError.prototype.constructor = ValidationError;\nValidationError.prototype.name = 'ValidationError';\n\nValidationError.prototype.prefixWith = function (dataPrefix, schemaPrefix) {\n    if (dataPrefix !== null) {\n        dataPrefix = dataPrefix.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n        this.dataPath = \"/\" + dataPrefix + this.dataPath;\n    }\n    if (schemaPrefix !== null) {\n        schemaPrefix = schemaPrefix.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n        this.schemaPath = \"/\" + schemaPrefix + this.schemaPath;\n    }\n    if (this.subErrors !== null) {\n        for (var i = 0; i < this.subErrors.length; i++) {\n            this.subErrors[i].prefixWith(dataPrefix, schemaPrefix);\n        }\n    }\n    return this;\n};\n\nfunction isTrustedUrl(baseUrl, testUrl) {\n    if (testUrl.substring(0, baseUrl.length) === baseUrl) {\n        var remainder = testUrl.substring(baseUrl.length);\n        if (testUrl.length > 0 && testUrl.charAt(baseUrl.length - 1) === \"/\" || remainder.charAt(0) === \"#\" || remainder.charAt(0) === \"?\") {\n            return true;\n        }\n    }\n    return false;\n}\n\nvar languages = {};\n\nfunction createApi(language) {\n    var globalContext = new ValidatorContext();\n    var currentLanguage;\n    var customErrorReporter;\n    var api = {\n        setErrorReporter: function setErrorReporter(reporter) {\n            if (typeof reporter === 'string') {\n                return this.language(reporter);\n            }\n            customErrorReporter = reporter;\n            return true;\n        },\n        addFormat: function addFormat() {\n            globalContext.addFormat.apply(globalContext, arguments);\n        },\n        language: function language(code) {\n            if (!code) {\n                return currentLanguage;\n            }\n            if (!languages[code]) {\n                code = code.split('-')[0]; // fall back to base language\n            }\n            if (languages[code]) {\n                currentLanguage = code;\n                return code; // so you can tell if fall-back has happened\n            }\n            return false;\n        },\n        addLanguage: function addLanguage(code, messageMap) {\n            var key;\n            for (key in ErrorCodes) {\n                if (messageMap[key] && !messageMap[ErrorCodes[key]]) {\n                    messageMap[ErrorCodes[key]] = messageMap[key];\n                }\n            }\n            var rootCode = code.split('-')[0];\n            if (!languages[rootCode]) {\n                // use for base language if not yet defined\n                languages[code] = messageMap;\n                languages[rootCode] = messageMap;\n            } else {\n                languages[code] = (0, _create2.default)(languages[rootCode]);\n                for (key in messageMap) {\n                    if (typeof languages[rootCode][key] === 'undefined') {\n                        languages[rootCode][key] = messageMap[key];\n                    }\n                    languages[code][key] = messageMap[key];\n                }\n            }\n            return this;\n        },\n        freshApi: function freshApi(language) {\n            var result = createApi();\n            if (language) {\n                result.language(language);\n            }\n            return result;\n        },\n        validate: function validate(data, schema, checkRecursive, banUnknownProperties) {\n            var def = defaultErrorReporter(currentLanguage);\n            var errorReporter = customErrorReporter ? function (error, data, schema) {\n                return customErrorReporter(error, data, schema) || def(error, data, schema);\n            } : def;\n            var context = new ValidatorContext(globalContext, false, errorReporter, checkRecursive, banUnknownProperties);\n            if (typeof schema === \"string\") {\n                schema = { \"$ref\": schema };\n            }\n            context.addSchema(\"\", schema);\n            var error = context.validateAll(data, schema, null, null, \"\");\n            if (!error && banUnknownProperties) {\n                error = context.banUnknownProperties(data, schema);\n            }\n            this.error = error;\n            this.missing = context.missing;\n            this.valid = error === null;\n            return this.valid;\n        },\n        validateResult: function validateResult() {\n            var result = {};\n            this.validate.apply(result, arguments);\n            return result;\n        },\n        validateMultiple: function validateMultiple(data, schema, checkRecursive, banUnknownProperties) {\n            var def = defaultErrorReporter(currentLanguage);\n            var errorReporter = customErrorReporter ? function (error, data, schema) {\n                return customErrorReporter(error, data, schema) || def(error, data, schema);\n            } : def;\n            var context = new ValidatorContext(globalContext, true, errorReporter, checkRecursive, banUnknownProperties);\n            if (typeof schema === \"string\") {\n                schema = { \"$ref\": schema };\n            }\n            context.addSchema(\"\", schema);\n            context.validateAll(data, schema, null, null, \"\");\n            if (banUnknownProperties) {\n                context.banUnknownProperties(data, schema);\n            }\n            var result = {};\n            result.errors = context.errors;\n            result.missing = context.missing;\n            result.valid = result.errors.length === 0;\n            return result;\n        },\n        addSchema: function addSchema() {\n            return globalContext.addSchema.apply(globalContext, arguments);\n        },\n        getSchema: function getSchema() {\n            return globalContext.getSchema.apply(globalContext, arguments);\n        },\n        getSchemaMap: function getSchemaMap() {\n            return globalContext.getSchemaMap.apply(globalContext, arguments);\n        },\n        getSchemaUris: function getSchemaUris() {\n            return globalContext.getSchemaUris.apply(globalContext, arguments);\n        },\n        getMissingUris: function getMissingUris() {\n            return globalContext.getMissingUris.apply(globalContext, arguments);\n        },\n        dropSchemas: function dropSchemas() {\n            globalContext.dropSchemas.apply(globalContext, arguments);\n        },\n        defineKeyword: function defineKeyword() {\n            globalContext.defineKeyword.apply(globalContext, arguments);\n        },\n        defineError: function defineError(codeName, codeNumber, defaultMessage) {\n            if (typeof codeName !== 'string' || !/^[A-Z]+(_[A-Z]+)*$/.test(codeName)) {\n                throw new Error('Code name must be a string in UPPER_CASE_WITH_UNDERSCORES');\n            }\n            if (typeof codeNumber !== 'number' || codeNumber % 1 !== 0 || codeNumber < 10000) {\n                throw new Error('Code number must be an integer > 10000');\n            }\n            if (typeof ErrorCodes[codeName] !== 'undefined') {\n                throw new Error('Error already defined: ' + codeName + ' as ' + ErrorCodes[codeName]);\n            }\n            if (typeof ErrorCodeLookup[codeNumber] !== 'undefined') {\n                throw new Error('Error code already used: ' + ErrorCodeLookup[codeNumber] + ' as ' + codeNumber);\n            }\n            ErrorCodes[codeName] = codeNumber;\n            ErrorCodeLookup[codeNumber] = codeName;\n            ErrorMessagesDefault[codeName] = ErrorMessagesDefault[codeNumber] = defaultMessage;\n            for (var langCode in languages) {\n                var language = languages[langCode];\n                if (language[codeName]) {\n                    language[codeNumber] = language[codeNumber] || language[codeName];\n                }\n            }\n        },\n        reset: function reset() {\n            globalContext.reset();\n            this.error = null;\n            this.missing = [];\n            this.valid = true;\n        },\n        missing: [],\n        error: null,\n        valid: true,\n        normSchema: normSchema,\n        resolveUrl: resolveUrl,\n        getDocumentUri: getDocumentUri,\n        errorCodes: ErrorCodes\n    };\n    api.language(language || 'en');\n    return api;\n}\n\n//export function validator() {\nvar tv4 = createApi();\ntv4.addLanguage('en-gb', ErrorMessagesDefault);\n\n//legacy property\ntv4.tv4 = tv4;\n//return tv4;\nexports.default = tv4;\n//}\n\nmodule.exports = exports['default'];\n\n},{\"babel-runtime/core-js/json/stringify\":3,\"babel-runtime/core-js/object/create\":5,\"babel-runtime/core-js/object/define-property\":6,\"babel-runtime/core-js/object/is-frozen\":9,\"babel-runtime/core-js/object/keys\":10,\"babel-runtime/helpers/typeof\":20}],457:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _stringify = require('babel-runtime/core-js/json/stringify');\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nexports.divideURL = divideURL;\nexports.divideEmail = divideEmail;\nexports.emptyObject = emptyObject;\nexports.deepClone = deepClone;\nexports.removePathFromURL = removePathFromURL;\nexports.getUserURLFromEmail = getUserURLFromEmail;\nexports.getUserEmailFromURL = getUserEmailFromURL;\nexports.convertToUserURL = convertToUserURL;\nexports.isDataObjectURL = isDataObjectURL;\nexports.getConfigurationResources = getConfigurationResources;\nexports.buildURL = buildURL;\nexports.generateGUID = generateGUID;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n* Copyright 2016 PT Inovao e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n/**\n * Support module with some functions will be useful\n * @module utils\n */\n\n/**\n * @typedef divideURL\n * @type Object\n * @property {string} type The type of URL\n * @property {string} domain The domain of URL\n * @property {string} identity The identity of URL\n */\n\n/**\n * Divide an url in type, domain and identity\n * @param  {URL.URL} url - url address\n * @return {divideURL} the result of divideURL\n */\nfunction divideURL(url) {\n\n  if (!url) throw Error('URL is needed to split');\n\n  // let re = /([a-zA-Z-]*)?:\\/\\/(?:\\.)?([-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.[a-z]{2,6}\\b)*(\\/[\\/\\d\\w\\.-]*)*(?:[\\?])*(.+)*/gi;\n  var re = /([a-zA-Z-]*):\\/\\/(?:\\.)?([-a-zA-Z0-9@:%._\\+~#=]{2,256})([-a-zA-Z0-9@:%._\\+~#=\\/]*)/gi;\n  var subst = '$1,$2,$3';\n  var parts = url.replace(re, subst).split(',');\n\n  // If the url has no protocol, the default protocol set is https\n  if (parts[0] === url) {\n    parts[0] = 'https';\n    parts[1] = url;\n  }\n\n  var result = {\n    type: parts[0],\n    domain: parts[1],\n    identity: parts[2]\n  };\n\n  return result;\n}\n\nfunction divideEmail(email) {\n  var indexOfAt = email.indexOf('@');\n\n  var result = {\n    username: email.substring(0, indexOfAt),\n    domain: email.substring(indexOfAt + 1, email.length)\n  };\n\n  return result;\n}\n\n/**\n * Check if an Object is empty\n * @param  {Object} object Object to be checked\n * @return {Boolean}       status of Object, empty or not (true|false);\n */\nfunction emptyObject(object) {\n  return (0, _keys2.default)(object).length > 0 ? false : true;\n}\n\n/**\n * Make a COPY of the original data\n * @param  {Object}  obj - object to be cloned\n * @return {Object}\n */\nfunction deepClone(obj) {\n  //TODO: simple but inefficient JSON deep clone...\n  if (obj) return JSON.parse((0, _stringify2.default)(obj));\n}\n\nfunction removePathFromURL(url) {\n  var splitURL = url.split('/');\n  return splitURL[0] + '//' + splitURL[2] + '/' + splitURL[3];\n}\n\n/**\n * Obtains the user URL that corresponds to a given email\n * @param  {string} userEmail The user email\n * @return {URL.URL} userURL The user URL\n */\nfunction getUserURLFromEmail(userEmail) {\n  var indexOfAt = userEmail.indexOf('@');\n  return 'user://' + userEmail.substring(indexOfAt + 1, userEmail.length) + '/' + userEmail.substring(0, indexOfAt);\n}\n\n/**\n * Obtains the user email that corresponds to a given URL\n * @param  {URL.URL} userURL The user URL\n * @return {string} userEmail The user email\n */\nfunction getUserEmailFromURL(userURL) {\n  var url = divideURL(userURL);\n  return url.identity.replace('/', '') + '@' + url.domain; // identity field has '/exampleID' instead of 'exampleID'\n}\n\n/**\n * Check if the user identifier is already in the URL format, if not, convert to URL format\n * @param  {string}   identifier  user identifier\n * @return {string}   userURL    the user URL\n */\nfunction convertToUserURL(identifier) {\n\n  // check if the identifier is already in the url format\n  if (identifier.substring(0, 7) === 'user://') {\n    var dividedURL = divideURL(identifier);\n\n    //check if the url is well formated\n    if (dividedURL.domain && dividedURL.identity) {\n      return identifier;\n    } else {\n      throw 'userURL with wrong format';\n    }\n\n    //if not, convert the user email to URL format\n  } else {\n    return getUserURLFromEmail(identifier);\n  }\n}\n\nfunction isDataObjectURL(url) {\n  var schemasToIgnore = ['domain-idp', 'runtime', 'domain', 'hyperty'];\n  var splitURL = url.split('://');\n  var urlSchema = splitURL[0];\n\n  return schemasToIgnore.indexOf(urlSchema) === -1;\n}\n\n/**\n * get information relative each component configured on runtime configuration;\n * @param  {object} configuration object with all configuration\n * @param  {string} component     string with the component to get the configuration, like, runtimeURLS, catalogueURLs, msgNodeURL, domainRegistryURL;\n * @param  {string} resource      type of resource to get, like, catalogue, runtimeUA, protocolstub, idpProxy\n * @return {object}               return an object with all configurations;\n */\nfunction getConfigurationResources(configuration, component, resource) {\n  var objectResource = configuration[component];\n  var resourceType = objectResource[resource];\n\n  return resourceType;\n}\n\n/**\n * Build a full url with the runtime configuration;\n * @param  {object} configuration object with all configuration\n * @param  {string} component     string with the component to get the configuration, like, runtimeURLS, catalogueURLs, msgNodeURL, domainRegistryURL;\n * @param  {string} resource      type of resource to get, like, catalogue, runtimeUA, protocolstub, idpProxy\n * @param  {string} type          resource to get, like a hyperty name or protocolstub name;\n * @param  {boolean} useFallback  if true the function will check if have a fallback url;\n * @return {string}               partial url to contact the resource;\n */\nfunction buildURL(configuration, component, resource, type) {\n  var useFallback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  var objectResource = configuration[component];\n  var url = void 0;\n\n  if (!objectResource.hasOwnProperty(resource)) {\n    throw Error('The configuration ' + (0, _stringify2.default)(objectResource, '', 2) + ' don\\'t have the ' + resource + ' resource you are looking for');\n  }\n\n  var resourceType = objectResource[resource];\n\n  if (type) {\n    url = resourceType.prefix + configuration.domain + resourceType.suffix + type;\n    if (resourceType.hasOwnProperty('fallback') && useFallback) {\n      if (resourceType.fallback.indexOf('%domain%')) {\n        url = resourceType.fallback.replace(/(%domain%)/g, configuration.domain) + type;\n      } else {\n        url = resourceType.fallback + type;\n      }\n    }\n  } else {\n    url = resourceType.prefix + configuration.domain + resourceType.suffix;\n  }\n\n  // console.log(url);\n\n  return url;\n}\n\nfunction generateGUID() {\n\n  function s4() {\n    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n  }\n\n  return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n}\n\n},{\"babel-runtime/core-js/json/stringify\":3,\"babel-runtime/core-js/object/keys\":10}]},{},[448])(448)\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcG9seWZpbGwvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9hcnJheS9mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9pcy1mcm96ZW4uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wvaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvZ2V0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvZm4vcmVnZXhwL2VzY2FwZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vYXJyYXkvZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvaXMtZnJvemVuLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qva2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jbGFzc29mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ZhaWxzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mb3Itb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19odG1sLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW52b2tlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZXRlY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19rZXlvZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWV0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWljcm90YXNrLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdwby5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qtc2FwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS1hbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtcHJvdG8uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1zcGVjaWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zdHJpbmctYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Rhc2suanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWluZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1leHQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5LmZyb20uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmlzLWZyb3plbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5wcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYS1udW1iZXItdmFsdWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1jb3B5LXdpdGhpbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWZpbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1mcm9tLWl0ZXJhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktbWV0aG9kcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXJlZHVjZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2JpbmQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXN0cm9uZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tdG8tanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24td2Vhay5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kYXRlLXRvLXByaW1pdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLWlzLXJlZ2V4cC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZpeC1yZS13a3MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mbGFncy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2luaGVyaXQtaWYtcmVxdWlyZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtcmVnZXhwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbGlicmFyeS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtZXhwbTEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLWxvZzFwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1zaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZm9yY2VkLXBhbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC10by1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX293bi1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcGFyc2UtZmxvYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wYXJzZS1pbnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wYXJ0aWFsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVwbGFjZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zYW1lLXZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpY3QtbWV0aG9kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWNvbnRleHQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctaHRtbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1wYWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctcmVwZWF0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXRyaW0uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctd3MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLWJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9jb3JlLnJlZ2V4cC5lc2NhcGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5jb3B5LXdpdGhpbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmV2ZXJ5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZm9yLWVhY2guanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pbmRleC1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmlzLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuam9pbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lmxhc3QtaW5kZXgtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5tYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS1yaWdodC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNsaWNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29tZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNvcnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zcGVjaWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS5ub3cuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWlzby1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWpzb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLXByaW1pdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmFjb3NoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hc2luaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXRhbmguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNicnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNsejMyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jb3NoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5leHBtMS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZnJvdW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5oeXBvdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaW11bC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMTAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzFwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaW5oLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50YW5oLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50cnVuYy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5lcHNpbG9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLW5hbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1zYWZlLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5taW4tc2FmZS1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWludC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1maXhlZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1wcmVjaXNpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnRpZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1zZWFsZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QucHJldmVudC1leHRlbnNpb25zLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNlYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucGFyc2UtZmxvYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5wYXJzZS1pbnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5lbnVtZXJhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5oYXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lm93bi1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5wcmV2ZW50LWV4dGVuc2lvbnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5tYXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC50by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zZXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYW5jaG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJpZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ibGluay5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ib2xkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmNvZGUtcG9pbnQtYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZW5kcy13aXRoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZpeGVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRjb2xvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250c2l6ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mcm9tLWNvZGUtcG9pbnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRhbGljcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5saW5rLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJhdy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5yZXBlYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc21hbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RyaWtlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1Yi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcudHJpbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmFycmF5LWJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmRhdGEtdmlldy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0MzItYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDY0LWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MTYtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDgtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MTYtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MzItYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWNsYW1wZWQtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLW1hcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstc2V0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5hc2FwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuZXJyb3IuaXMtZXJyb3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXAudG8tanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaWFkZGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmltdWxoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pc3ViaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGgudW11bGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLWdldHRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtc2V0dGVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmVudHJpZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtZ2V0dGVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1zZXR0ZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QudmFsdWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JzZXJ2YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVmaW5lLW1ldGFkYXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5kZWxldGUtbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YS1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW1ldGFkYXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtb3duLW1ldGFkYXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5tZXRhZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC50by1qc29uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLmF0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLm1hdGNoLWFsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtZW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1zdGFydC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy50cmltLWxlZnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1yaWdodC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5c3RlbS5nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5pbW1lZGlhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi50aW1lcnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9zaGltLmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJub2RlX21vZHVsZXMvc2VydmljZS1mcmFtZXdvcmsvZGlzdC9NZXNzYWdlRmFjdG9yeS5qcyIsInNyYy9hbGxvY2F0aW9uL0FkZHJlc3NBbGxvY2F0aW9uLmpzIiwic3JjL2J1cy9CdXMuanMiLCJzcmMvYnVzL01lc3NhZ2VCdXMuanMiLCJzcmMvYnVzL1BpcGVsaW5lLmpzIiwic3JjL2lkZW50aXR5L0NyeXB0by5qcyIsInNyYy9pZGVudGl0eS9HdWlGYWtlLmpzIiwic3JjL2lkZW50aXR5L0lkZW50aXR5LmpzIiwic3JjL2lkZW50aXR5L0lkZW50aXR5TW9kdWxlLmpzIiwic3JjL3BvbGljeS9BY3Rpb25zU2VydmljZS5qcyIsInNyYy9wb2xpY3kvT3BlcmF0b3JzLmpzIiwic3JjL3BvbGljeS9QRFAuanMiLCJzcmMvcG9saWN5L1BFUC5qcyIsInNyYy9wb2xpY3kvUG9saWN5LmpzIiwic3JjL3BvbGljeS9SZVRoaW5rQ3R4LmpzIiwic3JjL3BvbGljeS9SdWxlLmpzIiwic3JjL3BvbGljeS9jb21iaW5pbmdBbGdvcml0aG1zL0FsbG93T3ZlcnJpZGVzLmpzIiwic3JjL3BvbGljeS9jb21iaW5pbmdBbGdvcml0aG1zL0Jsb2NrT3ZlcnJpZGVzLmpzIiwic3JjL3BvbGljeS9jb21iaW5pbmdBbGdvcml0aG1zL0ZpcnN0QXBwbGljYWJsZS5qcyIsInNyYy9wb2xpY3kvY29uZGl0aW9ucy9BZHZhbmNlZENvbmRpdGlvbi5qcyIsInNyYy9wb2xpY3kvY29uZGl0aW9ucy9Db25kaXRpb24uanMiLCJzcmMvcG9saWN5L2NvbmRpdGlvbnMvU3Vic2NyaXB0aW9uQ29uZGl0aW9uLmpzIiwic3JjL3BvbGljeS9jb250ZXh0L1J1bnRpbWVDb3JlQ3R4LmpzIiwic3JjL3JlZ2lzdHJ5L0h5cGVydHlJbnN0YW5jZS5qcyIsInNyYy9yZWdpc3RyeS9SZWdpc3RyeS5qcyIsInNyYy9yZWdpc3RyeS9SZWdpc3RyeURhdGFNb2RlbC5qcyIsInNyYy9ydW50aW1lL0Rlc2NyaXB0b3JzLmpzIiwic3JjL3J1bnRpbWUvTG9hZGVyLmpzIiwic3JjL3J1bnRpbWUvUnVudGltZVVBLmpzIiwic3JjL3J1bnRpbWUvcnVudGltZUNvbmZpZ3VyYXRpb24uanMiLCJzcmMvc3luY2hlci9PYnNlcnZlck9iamVjdC5qcyIsInNyYy9zeW5jaGVyL1JlcG9ydGVyT2JqZWN0LmpzIiwic3JjL3N5bmNoZXIvU3RvcmVEYXRhT2JqZWN0cy5qcyIsInNyYy9zeW5jaGVyL1N1YnNjcmlwdGlvbi5qcyIsInNyYy9zeW5jaGVyL1N5bmNoZXJNYW5hZ2VyLmpzIiwic3JjL3V0aWxzL3NjaGVtYVZhbGlkYXRpb24uanMiLCJzcmMvdXRpbHMvdHY0LmpzIiwic3JjL3V0aWxzL3V0aWxzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0JBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTs7QUNBQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7O0FDRkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTs7QUNGQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxT0E7O0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDUEE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDakJBO0FBQ0E7QUFDQTs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBOzs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9CQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCQTs7QUFFQTs7O0lBR00saUI7QUFDSjs7Ozs7QUFLQTs7Ozs7QUFLQSw2QkFBWSxHQUFaLEVBQWlCLEdBQWpCLEVBQXNCLFFBQXRCLEVBQWdDO0FBQUE7O0FBQzlCLFFBQUksUUFBUSxJQUFaOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQU0sSUFBTixHQUFhLEdBQWI7QUFDQSxVQUFNLElBQU4sR0FBYSxHQUFiO0FBQ0EsVUFBTSxTQUFOLEdBQWtCLFFBQWxCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7QUFNQTs7Ozs7OzJCQU1PLE0sRUFBUSxNLEVBQVEsSSxFQUFNLE0sRUFBUSxRLEVBQVU7QUFDN0MsVUFBSSxRQUFRLElBQVo7O0FBRUEsYUFBTyxzQkFBWSxVQUFDLE9BQUQsRUFBVSxNQUFWLEVBQXFCOztBQUV0QyxZQUFJLFFBQUosRUFBYzs7QUFFWixnQkFBTSxTQUFOLENBQWdCLG1CQUFoQixDQUFvQyxJQUFwQyxFQUEwQyxJQUExQyxDQUErQyxVQUFDLElBQUQsRUFBVTs7QUFFdkQsZ0JBQUksSUFBSixFQUFVO0FBQ1Isc0JBQVEsSUFBUixDQUFhLDBCQUEwQixNQUExQixHQUFtQyxlQUFoRDtBQUNBLGtCQUFJLFFBQVEsRUFBQyxZQUFZLEtBQWIsRUFBb0IsU0FBUyxJQUE3QixFQUFaO0FBQ0Esc0JBQVEsS0FBUjtBQUNELGFBSkQsTUFJTztBQUNMLHNCQUFRLElBQVIsQ0FBYSw2Q0FBNkMsUUFBN0MsR0FBd0QsWUFBckU7QUFDQSxxQkFBTyxlQUFQO0FBQ0Q7QUFFRixXQVhELEVBV0csS0FYSCxDQVdTLFVBQUMsTUFBRCxFQUFZO0FBQ25CLG1CQUFPLE1BQVA7QUFDRCxXQWJEO0FBZUQsU0FqQkQsTUFpQk87O0FBRUwsZ0JBQU0sU0FBTixDQUFnQixtQkFBaEIsQ0FBb0MsSUFBcEMsRUFBMEMsSUFBMUMsQ0FBK0MsVUFBQyxJQUFELEVBQVU7O0FBRXZEO0FBQ0EsZ0JBQUksSUFBSixFQUFVOztBQUVSLHNCQUFRLElBQVIsQ0FBYSwwQkFBMEIsTUFBMUIsR0FBbUMsZUFBaEQ7QUFDQSxrQkFBSSxRQUFRLEVBQUMsWUFBWSxLQUFiLEVBQW9CLFNBQVMsSUFBN0IsRUFBWjtBQUNBLHNCQUFRLEtBQVI7QUFFRCxhQU5ELE1BTU87O0FBRUw7QUFDQSxvQkFBTSxtQkFBTixDQUEwQixNQUExQixFQUFrQyxNQUFsQyxFQUEwQyxNQUExQyxFQUFrRCxJQUFsRCxDQUF1RCxVQUFDLFNBQUQsRUFBZTtBQUNwRSx3QkFBUSxTQUFSO0FBQ0QsZUFGRCxFQUVHLEtBRkgsQ0FFUyxVQUFDLE1BQUQsRUFBWTtBQUNuQix1QkFBTyxNQUFQO0FBQ0QsZUFKRDtBQU1EO0FBQ0YsV0FuQkQsRUFtQkcsS0FuQkgsQ0FtQlMsVUFBQyxNQUFELEVBQVk7QUFDbkIsbUJBQU8sTUFBUDtBQUNELFdBckJEO0FBdUJEO0FBQ0YsT0E3Q00sQ0FBUDtBQStDRDs7O3dDQUVtQixNLEVBQVEsTSxFQUFRLE0sRUFBUTtBQUFBOztBQUUxQyxhQUFPLHNCQUFZLFVBQUMsT0FBRCxFQUFVLE1BQVYsRUFBcUI7O0FBRXRDLFlBQUksTUFBTTtBQUNSLGdCQUFNLFFBREUsRUFDUSxNQUFNLE9BQUssSUFEbkIsRUFDeUIsSUFBSSx1QkFBdUIsTUFBdkIsR0FBZ0MscUJBRDdEO0FBRVIsZ0JBQU0sRUFBQyxPQUFPLEVBQUUsUUFBUSxNQUFWLEVBQVI7QUFGRSxTQUFWOztBQUtBLFlBQUksV0FBVyxRQUFmLEVBQXlCLElBQUksSUFBSixDQUFTLE1BQVQsR0FBa0IsTUFBbEI7O0FBRXpCLGdCQUFRLElBQVIsQ0FBYSwwQkFBMEIsTUFBMUIsR0FBbUMscUJBQWhEOztBQUVBO0FBQ0EsZUFBSyxJQUFMLENBQVUsV0FBVixDQUFzQixHQUF0QixFQUEyQixVQUFDLEtBQUQsRUFBVztBQUNwQyxjQUFJLE1BQU0sSUFBTixDQUFXLElBQVgsS0FBb0IsR0FBeEIsRUFBNkI7QUFDM0IsZ0JBQUksU0FBUyxFQUFDLFlBQVksSUFBYixFQUFtQixTQUFTLE1BQU0sSUFBTixDQUFXLEtBQVgsQ0FBaUIsU0FBN0MsRUFBYjtBQUNBLG9CQUFRLE1BQVI7QUFDRCxXQUhELE1BR087QUFDTCxtQkFBTyxNQUFNLElBQU4sQ0FBVyxJQUFsQjtBQUNEO0FBQ0YsU0FQRDtBQVNELE9BckJNLENBQVA7QUF1QkQ7O0FBRUQ7Ozs7Ozs7Ozs0QkFNTyxNLEVBQVEsUyxFQUFXO0FBQ3hCLFVBQUksUUFBUSxJQUFaOztBQUVBLFVBQUksVUFBVTtBQUNaLGNBQU0sUUFETSxFQUNJLE1BQU0sTUFBTSxJQURoQixFQUNzQixJQUFJLHVCQUF1QixNQUF2QixHQUFnQyxxQkFEMUQ7QUFFWixjQUFNLEVBQUMsbUJBQW1CLFNBQXBCO0FBRk0sT0FBZDs7QUFLQSxhQUFPLHNCQUFZLFVBQUMsT0FBRCxFQUFVLE1BQVYsRUFBcUI7O0FBRXRDLGNBQU0sSUFBTixDQUFXLFdBQVgsQ0FBdUIsT0FBdkIsRUFBZ0MsVUFBQyxLQUFELEVBQVc7QUFDekMsa0JBQVEsR0FBUixDQUFZLE9BQVosRUFBcUIsS0FBckI7QUFDQSxjQUFJLE1BQU0sSUFBTixDQUFXLElBQVgsS0FBb0IsR0FBeEIsRUFBNkI7QUFDM0Isb0JBQVEsTUFBTSxJQUFOLENBQVcsSUFBbkI7QUFDRCxXQUZELE1BRU87QUFDTCxtQkFBTyxNQUFNLElBQU4sQ0FBVyxJQUFsQjtBQUNEO0FBQ0YsU0FQRDtBQVFELE9BVk0sQ0FBUDtBQVlEOzs7d0JBakhTO0FBQUUsYUFBTyxLQUFLLElBQVo7QUFBbUI7Ozs7O2tCQW9IbEIsaUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDektmOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQTs7Ozs7O0lBTU0sRztBQUNKOzs7Ozs7O0FBU0EsaUJBQWM7QUFBQTs7QUFDWixRQUFJLFFBQVEsSUFBWjtBQUNBLFVBQU0sTUFBTixHQUFlLENBQWY7QUFDQSxVQUFNLGNBQU4sR0FBdUIsRUFBdkI7O0FBRUEsVUFBTSxnQkFBTixHQUF5QixJQUF6QixDQUxZLENBS21CO0FBQy9CLFVBQU0sa0JBQU4sR0FBMkIsRUFBM0I7O0FBRUEsVUFBTSx5QkFBTjtBQUNEOztBQUVEOzs7Ozs7Ozs7OztnQ0FPWSxHLEVBQUssUSxFQUFVO0FBQ3pCLFVBQUksUUFBUSxJQUFaOztBQUVBLFVBQUksT0FBTyxJQUFJLFdBQUosQ0FBZ0IsTUFBTSxjQUF0QixFQUFzQyxHQUF0QyxFQUEyQyxRQUEzQyxDQUFYO0FBQ0EsVUFBSSxXQUFXLE1BQU0sY0FBTixDQUFxQixHQUFyQixDQUFmO0FBQ0EsVUFBSSxDQUFDLFFBQUwsRUFBZTtBQUNiLG1CQUFXLEVBQVg7QUFDQSxjQUFNLGNBQU4sQ0FBcUIsR0FBckIsSUFBNEIsUUFBNUI7QUFDRDs7QUFFRCxlQUFTLElBQVQsQ0FBYyxJQUFkO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7O3dDQVFvQixHLEVBQUssSyxFQUFPLGdCLEVBQWtCO0FBQ2hELFdBQUssa0JBQUwsQ0FBd0IsTUFBTSxLQUE5QixJQUF1QyxnQkFBdkM7QUFDRDs7QUFFRDs7Ozs7Ozs7MkNBS3VCLEcsRUFBSyxLLEVBQU87QUFDakMsYUFBTyxLQUFLLGtCQUFMLENBQXdCLE1BQU0sS0FBOUIsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7O3lDQUlxQixHLEVBQUs7QUFDeEIsYUFBTyxLQUFLLGNBQUwsQ0FBb0IsR0FBcEIsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7O3lCQU9LLE0sRUFBUSxLLEVBQU8sTSxFQUFRO0FBQUE7O0FBQzFCLFVBQUksUUFBUSxJQUFaOztBQUVBLFVBQUksWUFBWSxNQUFNLFdBQU4sQ0FBa0IsTUFBbEIsRUFBMEIsVUFBQyxHQUFELEVBQVM7QUFDakQsZUFBTyxXQUFQLENBQW1CLEdBQW5CO0FBQ0QsT0FGZSxDQUFoQjs7QUFJQSxVQUFJLGNBQWMsT0FBTyxXQUFQLENBQW1CLEtBQW5CLEVBQTBCLFVBQUMsR0FBRCxFQUFTO0FBQ25ELGNBQU0sV0FBTixDQUFrQixHQUFsQjtBQUNELE9BRmlCLENBQWxCOztBQUlBLGFBQU87QUFDTCxzQkFBYyxTQURUO0FBRUwsd0JBQWdCLFdBRlg7QUFHTCxnQkFBUSxrQkFBTTtBQUNaLGlCQUFLLFlBQUwsQ0FBa0IsTUFBbEI7QUFDQSxpQkFBSyxjQUFMLENBQW9CLE1BQXBCO0FBQ0Q7QUFOSSxPQUFQO0FBUUQ7O0FBRUQ7Ozs7c0NBQ2tCLEcsRUFBSztBQUNyQjtBQUNBLFVBQUksV0FBVyxLQUFLLGNBQUwsQ0FBb0IsR0FBcEIsQ0FBZjtBQUNBLFVBQUksUUFBSixFQUFjO0FBQ1osYUFBSyxVQUFMLENBQWdCLFFBQWhCLEVBQTBCLEdBQTFCO0FBQ0Q7QUFDRjs7QUFFRDs7OzsrQkFDVyxRLEVBQVUsRyxFQUFLO0FBQ3hCLGVBQVMsT0FBVCxDQUFpQixVQUFDLEdBQUQsRUFBUztBQUN4QixZQUFJLFNBQUosQ0FBYyxHQUFkO0FBQ0QsT0FGRDtBQUdEOzs7c0NBRWlCLEssRUFBTyxnQixFQUFrQjtBQUN6QyxVQUFJLFFBQVEsSUFBWjs7QUFFQTtBQUNBLFVBQUksZ0JBQUosRUFBc0I7QUFBQTtBQUNwQixjQUFJLGFBQWEsTUFBTSxJQUFOLEdBQWEsTUFBTSxFQUFwQztBQUNBLGdCQUFNLGtCQUFOLENBQXlCLFVBQXpCLElBQXVDLGdCQUF2Qzs7QUFFQSxxQkFBVyxZQUFNO0FBQ2YsZ0JBQUksY0FBYyxNQUFNLGtCQUFOLENBQXlCLFVBQXpCLENBQWxCO0FBQ0EsbUJBQU8sTUFBTSxrQkFBTixDQUF5QixVQUF6QixDQUFQOztBQUVBLGdCQUFJLFdBQUosRUFBaUI7QUFDZixrQkFBSSxXQUFXO0FBQ2Isb0JBQUksTUFBTSxFQURHLEVBQ0MsTUFBTSxVQURQO0FBRWIsc0JBQU0sRUFBRSxNQUFNLEdBQVIsRUFBYSxNQUFNLG1CQUFuQixFQUF3QyxPQUFPLEtBQS9DO0FBRk8sZUFBZjs7QUFLQSwwQkFBWSxRQUFaO0FBQ0Q7QUFDRixXQVpELEVBWUcsTUFBTSxnQkFaVDtBQUpvQjtBQWlCckI7QUFDRjs7O2dDQUVXLEcsRUFBSztBQUNmLFVBQUksUUFBUSxJQUFaOztBQUVBLFVBQUksSUFBSSxJQUFKLEtBQWEsVUFBakIsRUFBNkI7QUFDM0IsWUFBSSxhQUFhLElBQUksRUFBSixHQUFTLElBQUksRUFBOUI7QUFDQSxZQUFJLGNBQWMsTUFBTSxrQkFBTixDQUF5QixVQUF6QixDQUFsQjs7QUFFQTtBQUNBLFlBQUksSUFBSSxJQUFKLENBQVMsSUFBVCxJQUFpQixHQUFyQixFQUEwQjtBQUN4QixpQkFBTyxNQUFNLGtCQUFOLENBQXlCLFVBQXpCLENBQVA7QUFDRDs7QUFFRCxZQUFJLFdBQUosRUFBaUI7QUFDZixzQkFBWSxHQUFaO0FBQ0EsaUJBQU8sSUFBUDtBQUNEO0FBQ0Y7O0FBRUQsYUFBTyxLQUFQO0FBQ0Q7O0FBRUQ7Ozs7K0JBQ1csRyxFQUFLO0FBQ2QsVUFBSSxRQUFRLElBQVo7O0FBRUEsVUFBSSxDQUFDLE1BQU0sV0FBTixDQUFrQixHQUFsQixDQUFMLEVBQTZCO0FBQzNCLFlBQUksV0FBVyxNQUFNLGNBQU4sQ0FBcUIsSUFBSSxFQUF6QixDQUFmO0FBQ0EsWUFBSSxRQUFKLEVBQWM7QUFDWixnQkFBTSxVQUFOLENBQWlCLFFBQWpCLEVBQTJCLEdBQTNCO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsZ0JBQU0saUJBQU4sQ0FBd0IsR0FBeEI7QUFDRDtBQUNGO0FBQ0Y7OzsyQkFFTSxLLEVBQU87QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQUksQ0FBQyxNQUFNLEVBQVAsSUFBYSxNQUFNLEVBQU4sS0FBYSxDQUE5QixFQUFpQztBQUMvQixhQUFLLE1BQUw7QUFDQSxjQUFNLEVBQU4sR0FBVyxLQUFLLE1BQWhCO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7Z0NBUVksSyxFQUFPLGdCLEVBQWtCLENBQUc7O0FBRXhDOzs7Ozs7OzttQ0FLZSxHLEVBQUssQ0FBMkQsQyxDQUF6RDs7QUFFdEI7Ozs7Ozs7OztnREFNNEIsQ0FBRSxtRkFBcUY7Ozs7O0lBSS9HLFc7QUFDSjs7Ozs7O0FBTUEsdUJBQVksYUFBWixFQUEyQixHQUEzQixFQUFnQyxRQUFoQyxFQUEwQztBQUFBOztBQUN4QyxRQUFJLFFBQVEsSUFBWjs7QUFFQSxVQUFNLGNBQU4sR0FBdUIsYUFBdkI7QUFDQSxVQUFNLElBQU4sR0FBYSxHQUFiO0FBQ0EsVUFBTSxTQUFOLEdBQWtCLFFBQWxCO0FBQ0Q7Ozs7OztBQUlEOzs7NkJBR1M7QUFDUCxVQUFJLFFBQVEsSUFBWjs7QUFFQSxVQUFJLE9BQU8sTUFBTSxjQUFOLENBQXFCLE1BQU0sSUFBM0IsQ0FBWDtBQUNBLFVBQUksSUFBSixFQUFVO0FBQ1IsWUFBSSxRQUFRLEtBQUssT0FBTCxDQUFhLEtBQWIsQ0FBWjtBQUNBLGFBQUssTUFBTCxDQUFZLEtBQVosRUFBbUIsQ0FBbkI7O0FBRUE7QUFDQSxZQUFJLEtBQUssTUFBTCxLQUFnQixDQUFwQixFQUF1QjtBQUNyQixpQkFBTyxNQUFNLGNBQU4sQ0FBcUIsTUFBTSxJQUEzQixDQUFQO0FBQ0Q7QUFDRjtBQUNGOzs7d0JBbEJTO0FBQUUsYUFBTyxLQUFLLElBQVo7QUFBbUI7Ozs7O2tCQXFCbEIsRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9QZjs7OztBQUNBOzs7Ozs7QUFFQTs7Ozs7QUF6QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUE4Qk0sVTs7O0FBQ0o7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7QUFFQSxzQkFBWSxRQUFaLEVBQXNCO0FBQUE7O0FBQUE7O0FBRXBCLFdBQUssU0FBTCxHQUFpQixRQUFqQjtBQUNBLFdBQUssU0FBTCxHQUFpQixFQUFqQjs7QUFFQSxXQUFLLFNBQUwsR0FBaUIsdUJBQWEsVUFBQyxLQUFELEVBQVc7QUFDdkMsY0FBUSxHQUFSLENBQVksa0JBQVosRUFBZ0MseUJBQWUsS0FBZixDQUFoQztBQUNELEtBRmdCLENBQWpCO0FBTG9CO0FBUXJCOzs7Ozs7QUFJRDs7Ozs7OztnQ0FPWSxLLEVBQU8sZ0IsRUFBa0I7QUFDbkMsVUFBSSxRQUFRLElBQVo7O0FBRUEsWUFBTSxNQUFOLENBQWEsS0FBYjs7QUFFQSxZQUFNLFNBQU4sQ0FBZ0IsT0FBaEIsQ0FBd0IsS0FBeEIsRUFBK0IsVUFBQyxHQUFELEVBQVM7O0FBRXRDLGNBQU0saUJBQU4sQ0FBd0IsS0FBeEIsRUFBK0IsZ0JBQS9COztBQUVBLFlBQUksQ0FBQyxNQUFNLFdBQU4sQ0FBa0IsR0FBbEIsQ0FBTCxFQUE2QjtBQUMzQixjQUFJLFdBQVcsTUFBTSxjQUFOLENBQXFCLElBQUksRUFBekIsQ0FBZjtBQUNBLGNBQUksUUFBSixFQUFjO0FBQ1o7QUFDQSxrQkFBTSxVQUFOLENBQWlCLFFBQWpCLEVBQTJCLEdBQTNCO0FBQ0QsV0FIRCxNQUdPO0FBQ0w7QUFDQSxrQkFBTSxjQUFOLENBQXFCLEdBQXJCO0FBQ0Q7QUFDRjtBQUNGLE9BZEQ7O0FBZ0JBLGFBQU8sTUFBTSxFQUFiO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OytCQUtXLEksRUFBTTtBQUFBOztBQUNmLFVBQUksUUFBUSxJQUFaOztBQUVBO0FBQ0EsVUFBSSxXQUFXLE1BQU0sU0FBTixDQUFnQixJQUFoQixDQUFmO0FBQ0EsVUFBSSxDQUFDLFFBQUwsRUFBZTtBQUNiLFlBQUksa0JBQWtCLE1BQU0sV0FBTixDQUFrQixJQUFsQixFQUF3QixVQUFDLEdBQUQsRUFBUztBQUNyRCxrQkFBUSxHQUFSLENBQVksbUJBQW1CLElBQW5CLEdBQTBCLElBQXRDO0FBQ0EsZ0JBQU0sY0FBTixDQUFxQixHQUFyQjtBQUNELFNBSHFCLENBQXRCOztBQUtBLG1CQUFXO0FBQ1QsbUJBQVMsQ0FEQTtBQUVULGNBQUksZUFGSztBQUdULGtCQUFRLGtCQUFNO0FBQ1osbUJBQUssT0FBTDtBQUNBLGdCQUFJLE9BQUssT0FBTCxLQUFpQixDQUFyQixFQUF3QjtBQUN0QixxQkFBSyxFQUFMLENBQVEsTUFBUjtBQUNBLHFCQUFPLE1BQU0sU0FBTixDQUFnQixJQUFoQixDQUFQO0FBQ0Q7QUFDRjtBQVRRLFNBQVg7O0FBWUQsY0FBTSxTQUFOLENBQWdCLElBQWhCLElBQXdCLFFBQXhCO0FBQ0Q7O0FBRUQsZUFBUyxPQUFUO0FBQ0EsYUFBTyxRQUFQO0FBQ0E7O0FBRUQ7Ozs7Ozs7OytCQUtZLEksRUFBTSxFLEVBQUk7QUFDbkIsVUFBSSxRQUFRLElBQVo7O0FBRUEsYUFBTyxNQUFNLFdBQU4sQ0FBa0IsSUFBbEIsRUFBd0IsVUFBQyxHQUFELEVBQVM7QUFDdEMsZ0JBQVEsR0FBUixDQUFZLG1CQUFtQixJQUFuQixHQUEwQixNQUExQixHQUFtQyxFQUFuQyxHQUF3QyxJQUFwRDtBQUNBLGNBQU0sT0FBTixDQUFjLEVBQWQsRUFBa0IsR0FBbEI7QUFDRCxPQUhNLENBQVA7QUFJRDs7QUFFRDs7Ozs7Ozs7NEJBS1EsRyxFQUFLLEcsRUFBSztBQUNoQixVQUFJLFFBQVEsSUFBWjs7QUFFQSxVQUFJLFdBQVcsTUFBTSxjQUFOLENBQXFCLEdBQXJCLENBQWY7QUFDQSxVQUFJLFFBQUosRUFBYztBQUNaLGNBQU0sVUFBTixDQUFpQixRQUFqQixFQUEyQixHQUEzQjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7bUNBQ2UsRyxFQUFLO0FBQ2xCLFVBQUksUUFBUSxJQUFaOztBQUVBO0FBQ0EsWUFBTSxTQUFOLENBQWdCLE9BQWhCLENBQXdCLElBQUksRUFBNUIsRUFBZ0MsSUFBaEMsQ0FBcUMsVUFBQyxLQUFELEVBQVc7QUFDOUMsY0FBTSxPQUFOLENBQWMsS0FBZCxFQUFxQixHQUFyQjtBQUNELE9BRkQsRUFFRyxLQUZILENBRVMsVUFBUyxDQUFULEVBQVk7QUFDbkIsZ0JBQVEsR0FBUixDQUFZLGlCQUFaLEVBQStCLENBQS9CO0FBQ0QsT0FKRDtBQUtEOzs7d0JBMUdhO0FBQUUsYUFBTyxLQUFLLFNBQVo7QUFBd0I7Ozs7O2tCQTZHNUIsVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqS2Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBOzs7OztJQUtNLFE7QUFDSjs7Ozs7QUFLQSxvQkFBWSxPQUFaLEVBQXFCO0FBQUE7O0FBQ25CLFFBQUksUUFBUSxJQUFaOztBQUVBLFVBQU0sUUFBTixHQUFpQixFQUFqQjtBQUNBLFVBQU0sTUFBTixHQUFlLE9BQWY7QUFDRDs7QUFFRDs7Ozs7Ozs7OzRCQUtRLEcsRUFBSyxTLEVBQVc7QUFDdEIsVUFBSSxRQUFRLElBQVo7O0FBRUEsVUFBSSxNQUFNLFFBQU4sQ0FBZSxNQUFmLEdBQXdCLENBQTVCLEVBQStCO0FBQzdCLFlBQUksT0FBTyxJQUFJLFFBQUosQ0FBYSxNQUFNLFFBQW5CLENBQVg7QUFDQSxhQUFLLElBQUwsQ0FBVSxJQUFJLFdBQUosQ0FBZ0IsS0FBaEIsRUFBdUIsSUFBdkIsRUFBNkIsR0FBN0IsRUFBa0MsU0FBbEMsQ0FBVjtBQUNELE9BSEQsTUFHTztBQUNMLGtCQUFVLEdBQVY7QUFDRDtBQUNGOzs7OztBQUdIOzs7Ozs7O0lBS00sVztBQUNKOzs7Ozs7O0FBUUEsdUJBQVksUUFBWixFQUFzQixJQUF0QixFQUE0QixHQUE1QixFQUFpQyxTQUFqQyxFQUE0QztBQUFBOztBQUMxQyxRQUFJLFFBQVEsSUFBWjs7QUFFQSxVQUFNLE9BQU4sR0FBZ0IsS0FBaEI7O0FBRUEsVUFBTSxTQUFOLEdBQWtCLFFBQWxCO0FBQ0EsVUFBTSxLQUFOLEdBQWMsSUFBZDtBQUNBLFVBQU0sSUFBTixHQUFhLEdBQWI7QUFDQSxVQUFNLFVBQU4sR0FBbUIsU0FBbkI7QUFDRDs7Ozs7O0FBT0Q7OzsyQkFHTztBQUNMLFVBQUksUUFBUSxJQUFaOztBQUVBLFVBQUksQ0FBQyxNQUFNLE9BQVgsRUFBb0I7QUFDbEIsWUFBSSxNQUFNLEtBQU4sQ0FBWSxPQUFoQixFQUF5QjtBQUN2QixnQkFBTSxLQUFOLENBQVksSUFBWixDQUFpQixLQUFqQjtBQUNELFNBRkQsTUFFTztBQUNMLGdCQUFNLFVBQU4sQ0FBaUIsTUFBTSxJQUF2QjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7Ozs7OzhCQUdVO0FBQ1IsVUFBSSxRQUFRLElBQVo7QUFDQSxVQUFJLENBQUMsTUFBTSxPQUFYLEVBQW9CO0FBQ2xCLGNBQU0sT0FBTixHQUFnQixJQUFoQjtBQUNBLGNBQU0sVUFBTixDQUFpQixNQUFNLElBQXZCO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozt5QkFJSyxLLEVBQU87QUFDVixVQUFJLFFBQVEsSUFBWjs7QUFFQSxVQUFJLENBQUMsTUFBTSxPQUFYLEVBQW9CO0FBQ2xCLGNBQU0sT0FBTixHQUFnQixJQUFoQjtBQUNBLFlBQUksTUFBTSxTQUFOLENBQWdCLE1BQXBCLEVBQTRCO0FBQzFCLGdCQUFNLFNBQU4sQ0FBZ0IsTUFBaEIsQ0FBdUIsS0FBdkI7QUFDRDtBQUNGO0FBQ0Y7Ozt3QkE1Q2M7QUFBRSxhQUFPLEtBQUssU0FBWjtBQUF3Qjs7O3dCQUUvQjtBQUFFLGFBQU8sS0FBSyxJQUFaO0FBQW1CLEs7c0JBQ3ZCLEssRUFBTztBQUFFLFdBQUssSUFBTCxHQUFZLEtBQVo7QUFBb0I7Ozs7O0lBNENqQyxRO0FBQ0o7Ozs7O0FBS0Esb0JBQVksS0FBWixFQUFtQjtBQUFBOztBQUNqQixTQUFLLE1BQUwsR0FBYyxDQUFDLENBQWY7QUFDQSxTQUFLLE1BQUwsR0FBYyxLQUFkO0FBQ0Q7Ozs7d0JBRWE7QUFDWixhQUFPLEtBQUssTUFBTCxHQUFjLEtBQUssTUFBTCxDQUFZLE1BQVosR0FBcUIsQ0FBMUM7QUFDRDs7O3dCQUVVO0FBQ1QsV0FBSyxNQUFMO0FBQ0EsYUFBTyxLQUFLLE1BQUwsQ0FBWSxLQUFLLE1BQWpCLENBQVA7QUFDRDs7Ozs7a0JBR1ksUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdkpmOzs7O0lBSU0sTTtBQUVKLG9CQUFjO0FBQUE7O0FBQ1osUUFBSSxRQUFRLElBQVo7QUFFRDs7QUFFRDs7Ozs7Ozs7OzJCQUtPLEssRUFBTztBQUNaLGFBQU8sS0FBSyxLQUFMLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7MkJBS08sSyxFQUFPO0FBQ1osYUFBTyxJQUFJLFVBQUosQ0FBZSxLQUFLLEtBQUwsQ0FBVyxNQUFNLEtBQUssS0FBTCxDQUFOLEdBQW9CLEdBQS9CLENBQWYsQ0FBUDtBQUNEOzs7K0JBRVUsTSxFQUFRLEksRUFBTTtBQUN2QixVQUFJLFFBQVEsSUFBWjs7QUFFQSxhQUFPLHNCQUFZLFVBQVMsT0FBVCxFQUFrQixNQUFsQixFQUEwQjtBQUMzQyxjQUFNLG9CQUFOLENBQTJCLElBQUksVUFBSixDQUFlLE1BQWYsQ0FBM0IsRUFBbUQsSUFBbkQsQ0FBd0QsVUFBUyxTQUFULEVBQW9COztBQUUxRSxpQkFBTyxNQUFQLENBQWMsT0FBZCxDQUNJO0FBQ0Usa0JBQU07QUFEUixXQURKLEVBSUksU0FKSixFQUllO0FBQ1gsY0FMSixDQUtTO0FBTFQsWUFPQyxJQVBELENBT00sVUFBUyxTQUFULEVBQW9CO0FBQ3hCO0FBQ0E7QUFDQSxvQkFBUSxJQUFJLFVBQUosQ0FBZSxTQUFmLENBQVI7QUFFRCxXQVpELEVBWUcsS0FaSCxDQVlTLFVBQVMsR0FBVCxFQUFjO0FBQ3JCLG9CQUFRLEdBQVIsQ0FBWSxtQkFBWixFQUFpQyxHQUFqQztBQUNBLG1CQUFPLEdBQVA7QUFDRCxXQWZEO0FBaUJELFNBbkJEO0FBcUJELE9BdEJNLENBQVA7QUF3QkQ7OzsrQkFFVSxPLEVBQVMsSSxFQUFNO0FBQ3hCLFVBQUksUUFBUSxJQUFaOztBQUVBLGFBQU8sc0JBQVksVUFBUyxPQUFULEVBQWtCLE1BQWxCLEVBQTBCO0FBQzNDLGNBQU0sb0JBQU4sQ0FBMkIsT0FBM0IsRUFBb0MsSUFBcEMsQ0FBeUMsVUFBUyxVQUFULEVBQXFCOztBQUU1RCxpQkFBTyxNQUFQLENBQWMsT0FBZCxDQUNJO0FBQ0Usa0JBQU07QUFEUixXQURKLEVBSUksVUFKSixFQUlnQjtBQUNaLGNBTEosQ0FLUztBQUxULFlBT0MsSUFQRCxDQU9NLFVBQVMsU0FBVCxFQUFvQjs7QUFFeEIsZ0JBQUksZ0JBQWdCLElBQUksVUFBSixDQUFlLFNBQWYsQ0FBcEI7O0FBRUE7QUFDQSxvQkFBUSxhQUFSO0FBRUQsV0FkRCxFQWNHLEtBZEgsQ0FjUyxVQUFTLEdBQVQsRUFBYztBQUNyQixvQkFBUSxHQUFSLENBQVksbUJBQVosRUFBaUMsR0FBakM7QUFDQSxtQkFBTyxHQUFQO0FBQ0QsV0FqQkQ7QUFrQkQsU0FwQkQ7QUFzQkQsT0F2Qk0sQ0FBUDtBQXdCRDs7OzRCQUVPLE8sRUFBUyxJLEVBQU07QUFDckIsVUFBSSxRQUFRLElBQVo7O0FBRUEsYUFBTyxzQkFBWSxVQUFTLE9BQVQsRUFBa0IsTUFBbEIsRUFBMEI7QUFDM0MsY0FBTSxpQkFBTixDQUF3QixPQUF4QixFQUFpQyxJQUFqQyxDQUFzQyxVQUFTLFVBQVQsRUFBcUI7O0FBRXpELGlCQUFPLE1BQVAsQ0FBYyxJQUFkLENBQ0k7QUFDRSxrQkFBTTtBQURSLFdBREosRUFJSSxVQUpKLEVBSWdCO0FBQ1osZ0JBQU0sV0FBTixDQUFrQixJQUFsQixDQUxKLENBSzRCO0FBTDVCLFlBT0MsSUFQRCxDQU9NLFVBQVMsU0FBVCxFQUFvQjtBQUN4QjtBQUNBO0FBQ0Esb0JBQVEsSUFBSSxVQUFKLENBQWUsU0FBZixDQUFSO0FBRUQsV0FaRCxFQVlHLEtBWkgsQ0FZUyxVQUFTLEdBQVQsRUFBYztBQUNyQixvQkFBUSxHQUFSLENBQVksZ0JBQVosRUFBOEIsR0FBOUI7QUFDQSxtQkFBTyxHQUFQO0FBQ0QsV0FmRDtBQWlCRCxTQW5CRDtBQXFCRCxPQXRCTSxDQUFQO0FBdUJEOzs7OEJBRVMsTSxFQUFRLEksRUFBTSxTLEVBQVc7QUFDakMsVUFBSSxRQUFRLElBQVo7O0FBRUEsYUFBTyxzQkFBWSxVQUFTLE9BQVQsRUFBa0IsTUFBbEIsRUFBMEI7QUFDM0MsY0FBTSxtQkFBTixDQUEwQixNQUExQixFQUFrQyxJQUFsQyxDQUF1QyxVQUFTLFNBQVQsRUFBb0I7O0FBRXpELGlCQUFPLE1BQVAsQ0FBYyxNQUFkLENBQ0k7QUFDRSxrQkFBTTtBQURSLFdBREosRUFJSSxTQUpKLEVBSWU7QUFDWCxtQkFMSixFQUtlO0FBQ1gsZ0JBQU0sV0FBTixDQUFrQixJQUFsQixDQU5KLENBTTRCO0FBTjVCLFlBUUMsSUFSRCxDQVFNLFVBQVMsT0FBVCxFQUFrQjtBQUN0QjtBQUNBO0FBQ0Esb0JBQVEsT0FBUjtBQUVELFdBYkQsRUFhRyxLQWJILENBYVMsVUFBUyxHQUFULEVBQWM7QUFDckIsb0JBQVEsR0FBUixDQUFZLGtCQUFaLEVBQWdDLEdBQWhDO0FBQ0EsbUJBQU8sR0FBUDtBQUNELFdBaEJEO0FBa0JELFNBcEJEO0FBc0JELE9BdkJNLENBQVA7QUF3QkQ7OzsrQkFFVSxHLEVBQUssSSxFQUFNLEUsRUFBSTtBQUN4QixVQUFJLFFBQVEsSUFBWjs7QUFFQSxhQUFPLHNCQUFZLFVBQVMsT0FBVCxFQUFrQixNQUFsQixFQUEwQjtBQUMzQyxjQUFNLGFBQU4sQ0FBb0IsR0FBcEIsRUFBeUIsSUFBekIsQ0FBOEIsVUFBUyxNQUFULEVBQWlCOztBQUU3QyxpQkFBTyxNQUFQLENBQWMsT0FBZCxDQUNJO0FBQ0Usa0JBQU0sU0FEUjtBQUVFO0FBQ0E7QUFDQSxnQkFBSTtBQUpOLFdBREosRUFPSSxNQVBKLEVBT1k7QUFDUixnQkFBTSxXQUFOLENBQWtCLElBQWxCLENBUkosQ0FRNEI7QUFSNUIsWUFVQyxJQVZELENBVU0sVUFBUyxTQUFULEVBQW9CO0FBQ3hCO0FBQ0E7QUFDQSxvQkFBUSxJQUFJLFVBQUosQ0FBZSxTQUFmLENBQVI7QUFFRCxXQWZELEVBZUcsS0FmSCxDQWVTLFVBQVMsR0FBVCxFQUFjO0FBQ3JCLG9CQUFRLEdBQVIsQ0FBWSxtQkFBWixFQUFpQyxHQUFqQztBQUNBLG1CQUFPLEdBQVA7QUFDRCxXQWxCRDtBQW9CRCxTQXRCRDtBQXdCRCxPQXpCTSxDQUFQO0FBMEJEOzs7K0JBRVUsRyxFQUFLLEksRUFBTSxFLEVBQUk7QUFDeEIsVUFBSSxRQUFRLElBQVo7O0FBRUEsYUFBTyxzQkFBWSxVQUFTLE9BQVQsRUFBa0IsTUFBbEIsRUFBMEI7QUFDM0MsY0FBTSxhQUFOLENBQW9CLEdBQXBCLEVBQXlCLElBQXpCLENBQThCLFVBQVMsTUFBVCxFQUFpQjs7QUFFN0MsaUJBQU8sTUFBUCxDQUFjLE9BQWQsQ0FDSTtBQUNFLGtCQUFNLFNBRFI7QUFFRSxnQkFBSTtBQUZOLFdBREosRUFLSSxNQUxKLEVBS1k7QUFDUixjQU5KLENBTVM7QUFOVCxZQVFDLElBUkQsQ0FRTSxVQUFTLFNBQVQsRUFBb0I7O0FBRXhCLGdCQUFJLGNBQWMsTUFBTSxXQUFOLENBQWtCLElBQUksVUFBSixDQUFlLFNBQWYsQ0FBbEIsQ0FBbEI7QUFDQTtBQUNBLG9CQUFRLFdBQVI7QUFFRCxXQWRELEVBY0csS0FkSCxDQWNTLFVBQVMsR0FBVCxFQUFjO0FBQ3JCLG9CQUFRLEdBQVIsQ0FBWSxtQkFBWixFQUFpQyxHQUFqQztBQUNBLG1CQUFPLEdBQVA7QUFDRCxXQWpCRDtBQW1CRCxTQXJCRDtBQXVCRCxPQXhCTSxDQUFQO0FBeUJEOztBQUVEOzs7Ozs7Ozs7NkJBTVMsRyxFQUFLLEksRUFBTTtBQUNsQixVQUFJLFFBQVEsSUFBWjs7QUFFQSxhQUFPLHNCQUFZLFVBQVMsT0FBVCxFQUFpQixNQUFqQixFQUF5Qjs7QUFFMUMsY0FBTSxjQUFOLENBQXFCLEdBQXJCLEVBQTBCLElBQTFCLENBQStCLFVBQVMsT0FBVCxFQUFrQjs7QUFFL0MsaUJBQU8sTUFBUCxDQUFjLElBQWQsQ0FDQTtBQUNFLGtCQUFNO0FBRFIsV0FEQSxFQUlBLE9BSkEsRUFJUztBQUNULGdCQUFNLFdBQU4sQ0FBa0IsSUFBbEIsQ0FMQSxDQUt3QjtBQUx4QixZQU9DLElBUEQsQ0FPTSxVQUFTLFNBQVQsRUFBb0I7QUFDeEI7O0FBRUE7QUFDQSxvQkFBUSxJQUFJLFVBQUosQ0FBZSxTQUFmLENBQVI7QUFFRCxXQWJELEVBYUcsS0FiSCxDQWFTLFVBQVMsR0FBVCxFQUFjO0FBQ3JCLG9CQUFRLEdBQVIsQ0FBWSxpQkFBWixFQUErQixHQUEvQjtBQUNBLG1CQUFPLEdBQVA7QUFDRCxXQWhCRDtBQWlCRCxTQW5CRDtBQW9CRCxPQXRCTSxDQUFQO0FBdUJEOztBQUVEOzs7Ozs7Ozs7OytCQU9XLEcsRUFBSyxJLEVBQU0sUyxFQUFXO0FBQy9CLFVBQUksUUFBUSxJQUFaOztBQUVBLGFBQU8sc0JBQVksVUFBUyxPQUFULEVBQWlCLE1BQWpCLEVBQXlCOztBQUUxQyxjQUFNLGNBQU4sQ0FBcUIsR0FBckIsRUFBMEIsSUFBMUIsQ0FBK0IsVUFBUyxPQUFULEVBQWtCOztBQUUvQyxpQkFBTyxNQUFQLENBQWMsTUFBZCxDQUNFO0FBQ0Usa0JBQU07QUFEUixXQURGLEVBSUUsT0FKRixFQUlXO0FBQ1QsbUJBTEYsRUFLYTtBQUNYLGdCQUFNLFdBQU4sQ0FBa0IsSUFBbEIsQ0FORixDQU0wQjtBQU4xQixZQVFDLElBUkQsQ0FRTSxVQUFTLE9BQVQsRUFBa0I7QUFDdEI7QUFDQTtBQUNDLG1CQUFELEdBQVksUUFBUSxPQUFSLENBQVosR0FBK0IsT0FBTyxPQUFQLENBQS9CO0FBRUQsV0FiRCxFQWFHLEtBYkgsQ0FhUyxVQUFTLEdBQVQsRUFBYztBQUNyQixvQkFBUSxLQUFSLENBQWMsbUJBQWQsRUFBbUMsR0FBbkM7QUFDQSxtQkFBTyxHQUFQO0FBQ0QsV0FoQkQ7QUFrQkQsU0FwQkQ7QUFxQkQsT0F2Qk0sQ0FBUDtBQXdCRDs7QUFFRDs7Ozs7Ozt5Q0FJcUI7QUFDbkIsVUFBSSxRQUFRLElBQVo7QUFDQSxVQUFJLFVBQVUsRUFBZDs7QUFFQSxhQUFPLHNCQUFZLFVBQVMsT0FBVCxFQUFrQixNQUFsQixFQUEwQjtBQUMzQyxlQUFPLE1BQVAsQ0FBYyxXQUFkLENBQ0E7QUFDRSxnQkFBTSxTQURSO0FBRUUseUJBQWUsSUFGakIsRUFFdUI7QUFDckIsMEJBQWdCLElBQUksVUFBSixDQUFlLENBQUMsSUFBRCxFQUFPLElBQVAsRUFBYSxJQUFiLENBQWYsQ0FIbEI7QUFJRSxnQkFBTSxFQUFDLE1BQU0sU0FBUCxFQUpSLENBSTBCO0FBSjFCLFNBREEsRUFPQSxJQVBBLEVBT007QUFDTixTQUFDLE1BQUQsRUFBUyxRQUFULENBUkEsQ0FRbUI7O0FBUm5CLFVBVUUsSUFWRixDQVVPLFVBQVMsR0FBVCxFQUFjO0FBQ25CO0FBQ0E7O0FBRUEsaUJBQU8sTUFBUCxDQUFjLFNBQWQsQ0FDRSxNQURGLEVBQ1U7QUFDUixjQUFJLFNBRk4sQ0FFZ0I7QUFGaEIsWUFHRSxJQUhGLENBR08sVUFBUyxTQUFULEVBQW9CO0FBQ3pCO0FBQ0Esb0JBQVEsTUFBUixHQUFrQixJQUFJLFVBQUosQ0FBZSxTQUFmLENBQWxCO0FBQ0EsbUJBQU8sT0FBTyxNQUFQLENBQWMsU0FBZCxDQUNMLE9BREssRUFDSTtBQUNULGdCQUFJLFVBRkMsQ0FFVTtBQUZWLGFBQVA7QUFJRCxXQVZELEVBVUcsSUFWSCxDQVVRLFVBQVMsVUFBVCxFQUFxQjtBQUMzQixvQkFBUSxPQUFSLEdBQW1CLElBQUksVUFBSixDQUFlLFVBQWYsQ0FBbkI7QUFDQTs7QUFFQSxvQkFBUSxPQUFSO0FBRUQsV0FoQkQsRUFnQkcsS0FoQkgsQ0FnQlMsVUFBUyxHQUFULEVBQWM7QUFDckIsb0JBQVEsS0FBUixDQUFjLEdBQWQ7QUFDQSxtQkFBTyxHQUFQO0FBQ0QsV0FuQkQ7QUFxQkQsU0FuQ0QsRUFtQ0csS0FuQ0gsQ0FtQ1MsVUFBUyxHQUFULEVBQWM7QUFDckIsa0JBQVEsS0FBUixDQUFjLEdBQWQ7QUFDQSxpQkFBTyxHQUFQO0FBQ0QsU0F0Q0Q7QUF1Q0QsT0F4Q00sQ0FBUDtBQXlDRDs7QUFFRDs7Ozs7OztpQ0FJYTtBQUNYLFVBQUksUUFBUSxJQUFaOztBQUVBLFVBQUksUUFBUSxJQUFLLFVBQUwsQ0FBZ0IsRUFBaEIsQ0FBWjtBQUNBLGFBQU8sZUFBUCxDQUF1QixLQUF2Qjs7QUFFQSxhQUFPLEtBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7cUNBS2lCO0FBQ2YsVUFBSSxRQUFRLElBQVo7O0FBRUEsVUFBSSxRQUFRLElBQUssVUFBTCxDQUFnQixFQUFoQixDQUFaO0FBQ0EsYUFBTyxlQUFQLENBQXVCLEtBQXZCOztBQUVBLFVBQUksT0FBTyxLQUFLLEdBQUwsRUFBWDtBQUNBLFVBQUksY0FBYyxNQUFNLFdBQU4sQ0FBa0IsSUFBbEIsQ0FBbEI7O0FBRUE7QUFDQSxVQUFJLFlBQVksWUFBWSxLQUFaLENBQWtCLFlBQVksTUFBWixHQUFxQixDQUF2QyxFQUEwQyxZQUFZLE1BQXRELENBQWhCOztBQUVBO0FBQ0EsV0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEdBQXZCLEVBQTRCO0FBQUUsY0FBTSxDQUFOLElBQVcsVUFBVSxDQUFWLENBQVg7QUFBMEI7QUFDeEQsYUFBTyxLQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7a0NBSWM7QUFDWixVQUFJLFFBQVEsSUFBWjs7QUFFQSxVQUFJLFFBQVEsSUFBSSxVQUFKLENBQWUsRUFBZixDQUFaO0FBQ0EsYUFBTyxlQUFQLENBQXVCLEtBQXZCO0FBQ0EsYUFBTyxLQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O3lDQUtxQixPLEVBQVMsSSxFQUFNO0FBQ2xDLFVBQUksUUFBUSxJQUFaOztBQUVBLGFBQU8sc0JBQVksVUFBUyxPQUFULEVBQWtCLE1BQWxCLEVBQTBCO0FBQzNDLFlBQUksTUFBTSxJQUFJLFVBQUosQ0FBZSxFQUFmLENBQVY7QUFDQSxZQUFJLE9BQU8sSUFBWDs7QUFFQSxjQUFNLE9BQU4sQ0FBYyxPQUFkLEVBQXVCLElBQXZCLENBQTRCLFVBQUMsV0FBRCxFQUFpQjs7QUFFM0MsZ0JBQU0sUUFBTixDQUFlLFdBQWYsRUFBNEIsSUFBNUIsRUFBa0MsSUFBbEMsQ0FBdUMsVUFBUyxRQUFULEVBQW1COztBQUV4RDtBQUNBLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksRUFBcEIsRUFBd0IsR0FBeEIsRUFBNkI7QUFBRSxrQkFBSSxDQUFKLElBQVMsU0FBUyxDQUFULENBQVQ7QUFBdUI7QUFDdEQsbUJBQU8sTUFBTSxRQUFOLENBQWUsV0FBZixFQUE0QixPQUFPLFFBQW5DLENBQVA7QUFFRCxXQU5ELEVBTUcsSUFOSCxDQU1RLFVBQVMsUUFBVCxFQUFtQjs7QUFFekI7QUFDQSxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEVBQXBCLEVBQXdCLEdBQXhCLEVBQTZCO0FBQUUsa0JBQUksSUFBSSxFQUFSLElBQWMsU0FBUyxDQUFULENBQWQ7QUFBNEI7QUFDM0Q7QUFDQSxvQkFBUSxHQUFSO0FBRUQsV0FiRCxFQWFHLEtBYkgsQ0FhUyxVQUFTLEdBQVQsRUFBYztBQUNyQixvQkFBUSxHQUFSLENBQVksNkJBQVosRUFBMkMsR0FBM0M7QUFDQSxtQkFBTyxHQUFQO0FBQ0QsV0FoQkQ7QUFpQkQsU0FuQkQ7QUFxQkQsT0F6Qk0sQ0FBUDtBQTBCRDs7QUFFRDs7Ozs7Ozs7OztpQ0FPYSxPLEVBQVMsSSxFQUFNO0FBQzFCLFVBQUksUUFBUSxJQUFaOztBQUVBLGFBQU8sc0JBQVksVUFBUyxPQUFULEVBQWtCLE1BQWxCLEVBQTBCOztBQUUzQyxZQUFJLE1BQU0sRUFBVjtBQUNBLFlBQUksT0FBTyxJQUFYOztBQUVBO0FBQ0EsY0FBTSxRQUFOLENBQWUsT0FBZixFQUF3QixJQUF4QixFQUE4QixJQUE5QixDQUFtQyxVQUFTLFFBQVQsRUFBbUI7QUFDcEQsY0FBSSxJQUFKLENBQVMsUUFBVDtBQUNBLGlCQUFPLE1BQU0sUUFBTixDQUFlLE9BQWYsRUFBd0IsT0FBTyxRQUEvQixDQUFQO0FBRUQsU0FKRCxFQUlHLElBSkgsQ0FJUSxVQUFTLFFBQVQsRUFBbUI7QUFDekIsY0FBSSxJQUFKLENBQVMsUUFBVDtBQUNBLGlCQUFPLE1BQU0sUUFBTixDQUFlLE9BQWYsRUFBd0IsT0FBTyxRQUEvQixDQUFQO0FBRUQsU0FSRCxFQVFHLElBUkgsQ0FRUSxVQUFTLFFBQVQsRUFBbUI7QUFDekIsY0FBSSxJQUFKLENBQVMsUUFBVDtBQUNBLGlCQUFPLE1BQU0sUUFBTixDQUFlLE9BQWYsRUFBd0IsT0FBTyxRQUEvQixDQUFQO0FBRUQsU0FaRCxFQVlHLElBWkgsQ0FZUSxVQUFTLFFBQVQsRUFBbUI7QUFDekIsY0FBSSxJQUFKLENBQVMsUUFBVDs7QUFFQTtBQUNBLGtCQUFRLEdBQVI7QUFFRCxTQWxCRCxFQWtCRyxLQWxCSCxDQWtCUyxVQUFTLEdBQVQsRUFBYztBQUNyQjtBQUNBLGlCQUFPLEdBQVA7QUFDRCxTQXJCRDs7QUF1QkE7QUFDRCxPQTlCTSxDQUFQO0FBK0JEOzs7c0NBRWlCLE8sRUFBUztBQUN6QixVQUFJLFFBQVEsSUFBWjs7QUFFQSxhQUFPLHNCQUFZLFVBQVMsT0FBVCxFQUFrQixNQUFsQixFQUEwQjtBQUMzQyxlQUFPLE1BQVAsQ0FBYyxTQUFkLENBQ0ksT0FESixFQUNhO0FBQ1QsZUFGSixFQUdJLEVBQUk7QUFDRixnQkFBTSxtQkFEUjtBQUVFLGdCQUFNLEVBQUMsTUFBTSxTQUFQLEVBRlIsQ0FFMEI7QUFGMUIsU0FISixFQU9JLElBUEosRUFPVTtBQUNOLFNBQUMsTUFBRCxDQVJKLENBUWE7QUFSYixVQVVDLElBVkQsQ0FVTSxVQUFTLFVBQVQsRUFBcUI7QUFDekI7QUFDQTtBQUNBLGtCQUFRLFVBQVI7QUFFRCxTQWZELEVBZUcsS0FmSCxDQWVTLFVBQVMsR0FBVCxFQUFjO0FBQ3JCLGtCQUFRLEtBQVIsQ0FBYywwQkFBZCxFQUEwQyxHQUExQztBQUNBLGlCQUFPLEdBQVA7QUFDRCxTQWxCRDtBQW1CRCxPQXBCTSxDQUFQO0FBcUJEOzs7d0NBRW1CLE0sRUFBUTtBQUMxQixVQUFJLFFBQVEsSUFBWjs7QUFFQSxhQUFPLHNCQUFZLFVBQVMsT0FBVCxFQUFrQixNQUFsQixFQUEwQjtBQUMzQyxlQUFPLE1BQVAsQ0FBYyxTQUFkLENBQ0ksTUFESixFQUNZO0FBQ1IsY0FGSixFQUdJLEVBQUk7QUFDRixnQkFBTSxtQkFEUjtBQUVFLGdCQUFNLEVBQUMsTUFBTSxTQUFQLEVBRlIsQ0FFMEI7QUFGMUIsU0FISixFQU9JLElBUEosRUFPVTtBQUNOLFNBQUMsUUFBRCxDQVJKLENBUWU7QUFSZixVQVVDLElBVkQsQ0FVTSxVQUFTLFNBQVQsRUFBb0I7QUFDeEI7QUFDQTtBQUNBLGtCQUFRLFNBQVI7QUFFRCxTQWZELEVBZUcsS0FmSCxDQWVTLFVBQVMsR0FBVCxFQUFjO0FBQ3JCLGtCQUFRLEtBQVIsQ0FBYyw0QkFBZCxFQUE0QyxHQUE1QztBQUNBLGlCQUFPLEdBQVA7QUFDRCxTQWxCRDtBQW1CRCxPQXBCTSxDQUFQO0FBcUJEOzs7eUNBRW9CLE0sRUFBUTtBQUMzQixVQUFJLFFBQVEsSUFBWjs7QUFFQSxhQUFPLHNCQUFZLFVBQVMsT0FBVCxFQUFrQixNQUFsQixFQUEwQjtBQUMzQyxlQUFPLE1BQVAsQ0FBYyxTQUFkLENBQ0ksTUFESixFQUNZO0FBQ1IsY0FGSixFQUdJLEVBQUk7QUFDRixnQkFBTSxVQURSO0FBRUUsZ0JBQU0sRUFBQyxNQUFNLFNBQVAsRUFGUixDQUUwQjtBQUYxQixTQUhKLEVBT0ksSUFQSixFQU9VO0FBQ04sU0FBQyxTQUFELENBUkosQ0FRZ0I7QUFDQTtBQVRoQixVQVdDLElBWEQsQ0FXTSxVQUFTLFNBQVQsRUFBb0I7QUFDeEI7QUFDQTtBQUNBLGtCQUFRLFNBQVI7QUFFRCxTQWhCRCxFQWdCRyxLQWhCSCxDQWdCUyxVQUFTLEdBQVQsRUFBYztBQUNyQixrQkFBUSxLQUFSLENBQWMsNkJBQWQsRUFBNkMsR0FBN0M7QUFDQSxpQkFBTyxHQUFQO0FBQ0QsU0FuQkQ7QUFvQkQsT0FyQk0sQ0FBUDtBQXNCRDs7O3lDQUVvQixPLEVBQVM7QUFDNUIsVUFBSSxRQUFRLElBQVo7O0FBRUEsYUFBTyxzQkFBWSxVQUFTLE9BQVQsRUFBa0IsTUFBbEIsRUFBMEI7QUFDM0MsZUFBTyxNQUFQLENBQWMsU0FBZCxDQUNJLE9BREosRUFDYTtBQUNULGVBRkosRUFHSSxFQUFJO0FBQ0YsZ0JBQU0sVUFEUjtBQUVFLGdCQUFNLEVBQUMsTUFBTSxTQUFQLEVBRlIsQ0FFMEI7QUFGMUIsU0FISixFQU9JLElBUEosRUFPVTtBQUNOLFNBQUMsU0FBRCxDQVJKLENBUWdCO0FBQ0E7QUFUaEIsVUFXQyxJQVhELENBV00sVUFBUyxVQUFULEVBQXFCO0FBQ3pCO0FBQ0E7QUFDQSxrQkFBUSxVQUFSO0FBRUQsU0FoQkQsRUFnQkcsS0FoQkgsQ0FnQlMsVUFBUyxHQUFULEVBQWM7QUFDckIsa0JBQVEsS0FBUixDQUFjLDZCQUFkLEVBQTZDLEdBQTdDO0FBQ0EsaUJBQU8sR0FBUDtBQUNELFNBbkJEO0FBb0JELE9BckJNLENBQVA7QUFzQkQ7Ozt5Q0FFb0IsRyxFQUFLLFEsRUFBVSxVLEVBQVk7QUFDOUMsVUFBSSxRQUFRLElBQVo7O0FBRUEsVUFBSSxXQUFXLElBQUksVUFBSixDQUFlLElBQUksTUFBSixHQUFhLFNBQVMsTUFBdEIsR0FBK0IsV0FBVyxNQUF6RCxDQUFmOztBQUVBO0FBQ0EsV0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLElBQUksTUFBeEIsRUFBZ0MsR0FBaEMsRUFBcUM7QUFDbkMsaUJBQVMsQ0FBVCxJQUFjLElBQUksQ0FBSixDQUFkO0FBQ0Q7O0FBRUQ7QUFDQSxXQUFLLElBQUksS0FBSSxDQUFiLEVBQWdCLEtBQUksU0FBUyxNQUE3QixFQUFxQyxJQUFyQyxFQUEwQztBQUN4QyxpQkFBUyxLQUFJLElBQUksTUFBakIsSUFBMkIsSUFBSSxFQUFKLENBQTNCO0FBQ0Q7O0FBRUQ7QUFDQSxXQUFLLElBQUksTUFBSSxDQUFiLEVBQWdCLE1BQUksV0FBVyxNQUEvQixFQUF1QyxLQUF2QyxFQUE0QztBQUMxQyxpQkFBUyxNQUFJLElBQUksTUFBUixHQUFpQixTQUFTLE1BQW5DLElBQTZDLElBQUksR0FBSixDQUE3QztBQUNEOztBQUVELGFBQU8sUUFBUDtBQUNEOzs7eUNBRW9CO0FBQ25CLFVBQUksUUFBUSxJQUFLLFVBQUwsQ0FBZ0IsRUFBaEIsQ0FBWjtBQUNBLGFBQU8sZUFBUCxDQUF1QixLQUF2Qjs7QUFFQSxhQUFPLEtBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7bUNBS2UsVyxFQUFhO0FBQzFCLFVBQUksUUFBUSxJQUFaOztBQUVBLGFBQU8sc0JBQVksVUFBUyxPQUFULEVBQWtCLE1BQWxCLEVBQTBCOztBQUUzQyxjQUFNLE9BQU4sQ0FBYyxXQUFkLEVBQTJCLElBQTNCLENBQWdDLFVBQUMsR0FBRCxFQUFTOztBQUV2QyxpQkFBTyxNQUFQLENBQWMsU0FBZCxDQUNBLEtBREEsRUFDTztBQUNQLGFBRkEsRUFHQSxFQUFJO0FBQ0Ysa0JBQU0sTUFEUjtBQUVFLGtCQUFNLEVBQUMsTUFBTSxTQUFQLEVBRlIsRUFFMkI7QUFDekIsb0JBQVEsR0FIVixDQUdjO0FBSGQsV0FIQSxFQVFBLElBUkEsRUFRTTtBQUNOLFdBQUMsTUFBRCxFQUFTLFFBQVQsQ0FUQSxDQVNtQjtBQVRuQixZQVVFLElBVkYsQ0FVTyxVQUFTLEdBQVQsRUFBYztBQUNuQjtBQUNBO0FBQ0Esb0JBQVEsR0FBUjtBQUNELFdBZEQsRUFlQyxLQWZELENBZU8sVUFBUyxHQUFULEVBQWM7QUFDbkIsbUJBQU8sR0FBUDtBQUNELFdBakJEO0FBa0JELFNBcEJEO0FBcUJELE9BdkJNLENBQVA7QUF3QkQ7Ozs0QkFFTyxLLEVBQU87QUFDYixVQUFJLFFBQVEsSUFBWjs7QUFFQSxhQUFPLHNCQUFZLFVBQVMsT0FBVCxFQUFrQixNQUFsQixFQUEwQjtBQUMzQyxlQUFPLE1BQVAsQ0FBYyxNQUFkLENBQ0k7QUFDRSxnQkFBTTtBQURSLFNBREosRUFJSSxLQUpKLENBSVU7QUFKVixVQU1DLElBTkQsQ0FNTSxVQUFTLElBQVQsRUFBZTtBQUNuQjtBQUNBO0FBQ0Esa0JBQVEsSUFBSSxVQUFKLENBQWUsSUFBZixDQUFSO0FBQ0QsU0FWRCxFQVdDLEtBWEQsQ0FXTyxVQUFTLEdBQVQsRUFBYztBQUNuQixrQkFBUSxLQUFSLENBQWMsR0FBZDtBQUNBLGlCQUFPLEdBQVA7QUFDRCxTQWREO0FBZ0JELE9BakJNLENBQVA7QUFrQkQ7OztrQ0FFYSxXLEVBQWE7QUFDekIsYUFBTyxzQkFBWSxVQUFTLE9BQVQsRUFBa0IsTUFBbEIsRUFBMEI7QUFDM0MsZUFBTyxNQUFQLENBQWMsU0FBZCxDQUNJLEtBREosRUFDVztBQUNQLG1CQUZKLEVBR0ksRUFBSTtBQUNGLGdCQUFNO0FBRFIsU0FISixFQU1JLElBTkosRUFNVTtBQUNOLFNBQUMsU0FBRCxFQUFZLFNBQVosQ0FQSixDQU8yQjtBQVAzQixVQVNDLElBVEQsQ0FTTSxVQUFTLEdBQVQsRUFBYztBQUNsQjtBQUNBO0FBQ0Esa0JBQVEsR0FBUjtBQUNELFNBYkQsRUFjQyxLQWRELENBY08sVUFBUyxHQUFULEVBQWM7QUFDbkIsa0JBQVEsS0FBUixDQUFjLHFCQUFkLEVBQXFDLEdBQXJDO0FBQ0EsaUJBQU8sR0FBUDtBQUNELFNBakJEO0FBa0JELE9BbkJNLENBQVA7QUFvQkQ7OztnQ0FFVyxDLEVBQUc7QUFDYixhQUFPLElBQUksV0FBSixDQUFnQixPQUFoQixFQUF5QixNQUF6QixDQUFnQyxDQUFoQyxDQUFQO0FBQ0Q7OztnQ0FFVyxDLEVBQUc7QUFDYixhQUFPLElBQUksV0FBSixDQUFnQixPQUFoQixFQUF5QixNQUF6QixDQUFnQyxDQUFoQyxDQUFQO0FBQ0Q7Ozs7O2tCQUdZLE07Ozs7Ozs7Ozs7Ozs7Ozs7QUNycUJmOzs7OztJQUtNLE8sR0FFSixpQkFBWSxHQUFaLEVBQWlCLFVBQWpCLEVBQTZCO0FBQUE7O0FBQzNCLE1BQUksUUFBUSxJQUFaOztBQUVBLFFBQU0sSUFBTixHQUFhLEdBQWI7QUFDQSxRQUFNLFNBQU4sR0FBa0IsS0FBbEI7QUFDQSxRQUFNLFdBQU4sR0FBb0IsVUFBcEI7O0FBRUEsUUFBTSxXQUFOLENBQWtCLFdBQWxCLENBQThCLE1BQU0sSUFBcEMsRUFBMEMsZUFBTzs7QUFFL0MsUUFBSSxhQUFhLElBQUksSUFBSixDQUFTLEtBQVQsQ0FBZSxVQUFoQztBQUNBLFFBQUksT0FBTyxJQUFJLElBQUosQ0FBUyxLQUFULENBQWUsSUFBMUI7O0FBRUEsUUFBSSxjQUFKOztBQUVBLFFBQUksV0FBVyxDQUFYLE1BQWtCLFNBQXRCLEVBQWlDO0FBQy9CLGNBQVEsRUFBQyxNQUFNLFVBQVAsRUFBbUIsT0FBTyxXQUFXLENBQVgsQ0FBMUIsRUFBeUMsTUFBTSxHQUEvQyxFQUFSO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsY0FBUSxFQUFDLE1BQU0sS0FBUCxFQUFjLE9BQU8sS0FBSyxDQUFMLENBQXJCLEVBQThCLE1BQU0sR0FBcEMsRUFBUjtBQUNEOztBQUVELFFBQUksV0FBVyxFQUFDLElBQUksSUFBSSxFQUFULEVBQWEsTUFBTSxVQUFuQixFQUErQixJQUFJLElBQUksSUFBdkMsRUFBNkMsTUFBTSxJQUFJLEVBQXZELEVBQTJELE1BQU0sS0FBakUsRUFBZjs7QUFFQTtBQUNBO0FBQ0EsUUFBSSxJQUFJLElBQUosQ0FBUyxLQUFULEtBQW1CLE1BQXZCLEVBQStCOztBQUU3QixpQkFBVyxZQUFNO0FBQ2YsY0FBTSxXQUFOLENBQWtCLFdBQWxCLENBQThCLFFBQTlCO0FBQ0QsT0FGRCxFQUVHLE1BQU0sU0FGVDtBQUdELEtBTEQsTUFLTztBQUNMLFlBQU0sV0FBTixDQUFrQixXQUFsQixDQUE4QixRQUE5QjtBQUNEO0FBQ0YsR0F6QkQ7QUEwQkQsQzs7a0JBSVksTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1Q2Y7Ozs7SUFJTSxRO0FBRUosb0JBQVksSUFBWixFQUFrQixJQUFsQixFQUF3QjtBQUFBOztBQUN0QixRQUFJLFFBQVEsSUFBWjs7QUFFQSxVQUFNLElBQU4sR0FBYSxJQUFiO0FBQ0EsVUFBTSxJQUFOLEdBQWEsSUFBYjtBQUNBLFVBQU0sZUFBTixHQUF3QixFQUF4QjtBQUVEOzs7O2dDQUVXLFUsRUFBWTtBQUN0QixVQUFJLFFBQVEsSUFBWjtBQUNBLFVBQUksc0JBQXNCO0FBQ3hCLHFCQUFhLEVBRFc7QUFFeEIsd0JBQWdCLEVBRlE7QUFHeEIsNEJBQW9CLEVBSEk7QUFJeEIsMkJBQW1CLEVBSks7QUFLeEIscUJBQWE7QUFMVyxPQUExQjtBQU9BLFlBQU0sZUFBTixDQUFzQixVQUF0QixJQUFvQyxtQkFBcEM7QUFDRDs7O21DQUVjLFUsRUFBWSxTLEVBQVcsRyxFQUFLLEssRUFBTztBQUNoRCxVQUFJLFFBQVEsSUFBWjs7QUFFQSxVQUFJLGlCQUFpQixJQUFJLFdBQUosQ0FBZ0IsU0FBaEIsRUFBMkIsR0FBM0IsRUFBZ0MsS0FBaEMsQ0FBckI7O0FBRUEsWUFBTSxlQUFOLENBQXNCLElBQXRCLENBQTJCLGNBQTNCO0FBQ0Q7Ozs7O0lBR0csVyxHQUVKLHFCQUFZLFNBQVosRUFBdUIsR0FBdkIsRUFBNEIsS0FBNUIsRUFBbUM7QUFBQTs7QUFDakMsTUFBSSxRQUFRLElBQVo7O0FBRUEsUUFBTSxTQUFOLEdBQWtCLFNBQWxCO0FBQ0EsUUFBTSxHQUFOLEdBQVksR0FBWjtBQUNBLFFBQU0sS0FBTixHQUFjLEtBQWQ7QUFDRCxDOztJQUlHLFk7QUFFSix3QkFBWSxRQUFaLEVBQXNCLFFBQXRCLEVBQWdDO0FBQUE7O0FBQzlCLFFBQUksUUFBUSxJQUFaO0FBQ0EsVUFBTSxRQUFOLEdBQWlCLFFBQWpCO0FBQ0EsVUFBTSxRQUFOLEdBQWlCLFFBQWpCO0FBQ0Q7Ozs7OEJBRVMsUSxFQUFVLFEsRUFBVTtBQUM1Qjs7QUFFRDs7Ozs7a0JBR1ksUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3RGY7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQTRCTSxjOztBQUVKOzs7QUFHQSwwQkFBWSxVQUFaLEVBQXdCLG1CQUF4QixFQUE2QyxjQUE3QyxFQUE2RDtBQUFBOztBQUMzRCxRQUFJLFFBQVEsSUFBWjs7QUFFQSxRQUFJLENBQUMsVUFBTCxFQUFpQixNQUFNLElBQUksS0FBSixDQUFVLHdCQUFWLENBQU47QUFDakIsUUFBSSxDQUFDLGNBQUwsRUFBcUIsTUFBTSxJQUFJLEtBQUosQ0FBVSwyQkFBVixDQUFOOztBQUVyQixVQUFNLFdBQU4sR0FBb0IsVUFBcEI7QUFDQSxVQUFNLGNBQU4sR0FBdUIsY0FBdkI7QUFDQSxVQUFNLE9BQU4sR0FBZ0IsTUFBTSxXQUFOLEdBQW9CLE1BQXBDO0FBQ0EsVUFBTSxPQUFOLEdBQWdCLE1BQU0sV0FBTixHQUFvQixlQUFwQztBQUNBLFVBQU0sbUJBQU4sR0FBNEIsbUJBQTVCOztBQUVBLFVBQU0sT0FBTixHQUFnQixzQkFBVSxNQUFNLFdBQWhCLEVBQTZCLE1BQTdDOztBQUVBO0FBQ0EsVUFBTSxVQUFOLEdBQW1CLEVBQW5CO0FBQ0EsVUFBTSxVQUFOLEdBQW1CLEVBQW5CO0FBQ0EsUUFBSSxjQUFjLHVCQUFhLE1BQWIsRUFBb0IsT0FBcEIsQ0FBbEI7QUFDQSxVQUFNLFFBQU4sR0FBaUIsV0FBakI7QUFDQSxVQUFNLE1BQU4sR0FBZSxzQkFBZjs7QUFFQTtBQUNBLFVBQU0sbUJBQU4sR0FBNEIsRUFBNUI7O0FBRUE7QUFDQSxVQUFNLFFBQU4sR0FBaUIsRUFBakI7O0FBRUE7QUFDQSxVQUFNLHFCQUFOLEdBQThCLEVBQTlCOztBQUVBO0FBQ0EsVUFBTSxpQkFBTixHQUEwQixJQUExQjs7QUFFQTtBQUNBLFVBQU0sV0FBTixHQUFvQixLQUFwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBTSxlQUFOO0FBRUQ7O0FBRUQ7Ozs7Ozs7Ozs7QUFxQ0E7Ozs7O29DQUtnQjtBQUNkLFVBQUksUUFBUSxJQUFaO0FBQ0EsYUFBTyxNQUFNLFVBQWI7QUFDRDs7QUFFRDs7Ozs7Ozs7Z0NBS1ksTyxFQUFTO0FBQ25CLFVBQUksUUFBUSxJQUFaOztBQUVBLFdBQUssSUFBSSxLQUFULElBQWtCLE1BQU0sVUFBeEIsRUFBb0M7O0FBRWxDLFlBQUksV0FBVyxNQUFNLFVBQU4sQ0FBaUIsS0FBakIsQ0FBZjtBQUNBLFlBQUksU0FBUyxRQUFULEtBQXNCLE9BQTFCLEVBQW1DO0FBQ2pDLGlCQUFPLFFBQVA7QUFDRDtBQUNGOztBQUVELFlBQU0sb0JBQU47QUFDRDs7O3NDQUVpQjtBQUNoQixVQUFJLFFBQVEsSUFBWjtBQUNBLGFBQU8sc0JBQVksVUFBQyxPQUFELEVBQWE7O0FBRTlCLGNBQU0sY0FBTixDQUFxQixHQUFyQixDQUF5QixxQkFBekIsRUFBZ0QsSUFBaEQsQ0FBcUQsVUFBQyxVQUFELEVBQWdCOztBQUVuRSxjQUFJLFVBQUosRUFBZ0I7QUFDZCxrQkFBTSxVQUFOLEdBQW1CLFVBQW5CO0FBQ0Q7QUFDRDtBQUNELFNBTkQ7QUFPRCxPQVRNLENBQVA7QUFVRDs7O2dDQUVXO0FBQ1YsVUFBSSxRQUFRLElBQVo7QUFDQSxZQUFNLFdBQU4sR0FBb0IsSUFBcEI7QUFDRDs7O3lDQUVvQixVLEVBQVk7QUFDL0IsVUFBSSxRQUFRLElBQVo7O0FBRUEsYUFBTyxzQkFBWSxVQUFTLE9BQVQsRUFBa0IsTUFBbEIsRUFBMEI7QUFDM0MsWUFBSSxXQUFXLFdBQVcsS0FBWCxDQUFpQixLQUFqQixDQUFmO0FBQ0EsWUFBSSxTQUFTLENBQVQsTUFBZ0IsU0FBcEIsRUFBK0I7QUFDN0IsZ0JBQU0seUJBQU4sQ0FBZ0MsVUFBaEMsRUFBNEMsSUFBNUMsQ0FBaUQsVUFBQyxrQkFBRCxFQUF3QjtBQUN2RSxnQkFBSSxVQUFVLE1BQU0sUUFBTixDQUFlLGVBQWYsQ0FBK0Isa0JBQS9CLENBQWQ7QUFDQSxnQkFBSSxPQUFKLEVBQWE7O0FBRVgsbUJBQUssSUFBSSxLQUFULElBQWtCLE1BQU0sVUFBeEIsRUFBb0M7QUFDbEMsb0JBQUksV0FBVyxNQUFNLFVBQU4sQ0FBaUIsS0FBakIsQ0FBZjtBQUNBLG9CQUFJLFNBQVMsUUFBVCxLQUFzQixPQUExQixFQUFtQztBQUNqQyx5QkFBTyxRQUFRLFNBQVMsV0FBakIsQ0FBUDtBQUNEO0FBQ0Y7QUFDRixhQVJELE1BUU87QUFDTCxxQkFBTyxPQUFPLHdCQUFQLENBQVA7QUFDRDtBQUNGLFdBYkQ7QUFjRCxTQWZELE1BZU87QUFDTCxjQUFJLFVBQVUsTUFBTSxRQUFOLENBQWUsZUFBZixDQUErQixVQUEvQixDQUFkO0FBQ0EsY0FBSSxPQUFKLEVBQWE7O0FBRVgsaUJBQUssSUFBSSxLQUFULElBQWtCLE1BQU0sVUFBeEIsRUFBb0M7QUFDbEMsa0JBQUksV0FBVyxNQUFNLFVBQU4sQ0FBaUIsS0FBakIsQ0FBZjtBQUNBLGtCQUFJLFNBQVMsUUFBVCxLQUFzQixPQUExQixFQUFtQztBQUNqQyx1QkFBTyxRQUFRLFNBQVMsV0FBakIsQ0FBUDtBQUNEO0FBQ0Y7QUFDRixXQVJELE1BUU87QUFDTCxtQkFBTyxPQUFPLHdCQUFQLENBQVA7QUFDRDtBQUNGO0FBQ0YsT0EvQk0sQ0FBUDtBQWdDRDs7OzRDQUV1QjtBQUN0QixVQUFJLFFBQVEsSUFBWjtBQUNBLFVBQUksYUFBYSxNQUFNLFVBQXZCO0FBQ0EsVUFBSSxPQUFPLENBQUMsWUFBRCxFQUFlLGVBQWYsRUFBZ0MsV0FBaEMsQ0FBWDs7QUFFQSxhQUFPLEVBQUMsWUFBWSxVQUFiLEVBQXlCLE1BQU0sSUFBL0IsRUFBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7Z0NBTVksVyxFQUFhO0FBQ3ZCLFVBQUksUUFBUSxJQUFaO0FBQ0EsVUFBSSxRQUFRLEVBQVo7O0FBRUE7QUFDQSxVQUFJLFlBQWEsV0FBRCxnQ0FBc0MsVUFBQyxLQUFELEVBQVc7QUFBQyxlQUFPLEtBQVA7QUFBYyxPQUFoRjs7QUFFQSxXQUFLLElBQUksS0FBVCxJQUFrQixNQUFNLFVBQXhCLEVBQW9DO0FBQ2xDLFlBQUksV0FBVyxNQUFNLFVBQU4sQ0FBaUIsS0FBakIsQ0FBZjtBQUNBLGNBQU0sSUFBTixDQUFXLFVBQVUsU0FBUyxRQUFuQixDQUFYO0FBQ0Q7QUFDRCxhQUFPLEtBQVA7QUFDRDs7QUFFRDs7Ozs7Ozt5Q0FJcUI7QUFDbkIsVUFBSSxRQUFRLElBQVo7QUFDQSxhQUFPLE1BQU0sZUFBYjtBQUNEOztBQUVEOzs7Ozs7O3VDQUltQixRLEVBQVU7QUFDM0IsVUFBSSxRQUFRLElBQVo7QUFDQSxZQUFNLGVBQU4sR0FBd0IsUUFBeEI7QUFDRDs7QUFFRDs7Ozs7OzttQ0FJZSxNLEVBQVE7QUFDckIsVUFBSSxRQUFRLElBQVo7O0FBRUEsVUFBSSxVQUFVLDZCQUFpQixNQUFqQixDQUFkOztBQUVBLFdBQUssSUFBSSxRQUFULElBQXFCLE1BQU0sVUFBM0IsRUFBdUM7QUFDckMsWUFBSSxNQUFNLFVBQU4sQ0FBaUIsUUFBakIsRUFBMkIsUUFBM0IsS0FBd0MsT0FBNUMsRUFBcUQ7QUFDbkQsZ0JBQU0sVUFBTixDQUFpQixNQUFqQixDQUF3QixRQUF4QixFQUFrQyxDQUFsQztBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7Ozs7Ozt1Q0FJbUIsSyxFQUFPO0FBQ3hCLFVBQUksUUFBUSxJQUFaOztBQUVBLFdBQUssSUFBSSxDQUFULElBQWMsTUFBTSxVQUFwQixFQUFnQztBQUM5QixZQUFJLE1BQU0sVUFBTixDQUFpQixDQUFqQixNQUF3QixLQUE1QixFQUFtQztBQUNqQyxnQkFBTSxVQUFOLENBQWlCLE1BQWpCLENBQXdCLENBQXhCLEVBQTJCLENBQTNCO0FBQ0Q7QUFDRjtBQUNGOztBQUVEOzs7Ozs7O21DQUllLFMsRUFBVztBQUN4QixVQUFJLENBQUMsU0FBTCxFQUFnQjtBQUNkLGVBQU8seUJBQVA7QUFDRCxPQUZELE1BRU87QUFDTCxlQUFPLGtCQUFrQixTQUF6QjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7eUNBT3FCLFUsRUFBWSxJLEVBQU07QUFDckMsVUFBSSxRQUFRLElBQVo7O0FBRUEsYUFBTyxzQkFBWSxVQUFTLE9BQVQsRUFBaUIsTUFBakIsRUFBeUI7O0FBRTFDO0FBQ0EsWUFBSSxNQUFNLFdBQU4sS0FBc0IsS0FBMUIsRUFBaUM7O0FBRS9CLGNBQUksVUFBVSxzQkFBWSxNQUFNLE9BQWxCLEVBQTJCLE1BQU0sV0FBakMsQ0FBZDtBQUNBLGdCQUFNLE9BQU4sR0FBZ0IsT0FBaEI7QUFDQSxnQkFBTSxXQUFOLEdBQW9CLElBQXBCO0FBQ0Q7O0FBRUQsWUFBSSxVQUFVLEVBQUMsTUFBSyxRQUFOLEVBQWdCLElBQUksTUFBTSxPQUExQixFQUFtQyxNQUFNLE1BQU0sT0FBL0M7QUFDQSxnQkFBTSxFQUFDLE9BQU8sRUFBQyxZQUFZLFVBQWIsRUFBeUIsTUFBTSxJQUEvQixFQUFSLEVBRE4sRUFBZDs7QUFHQSxZQUFJLEtBQUssTUFBTSxXQUFOLENBQWtCLFdBQWxCLENBQThCLE9BQTlCLENBQVQ7O0FBRUE7QUFDQSxjQUFNLFdBQU4sQ0FBa0IsbUJBQWxCLENBQXNDLE1BQU0sT0FBNUMsRUFBcUQsRUFBckQsRUFBeUQsZUFBTztBQUM5RCxnQkFBTSxXQUFOLENBQWtCLHNCQUFsQixDQUF5QyxNQUFNLE9BQS9DLEVBQXdELEVBQXhEOztBQUVBLGNBQUksSUFBSSxJQUFKLENBQVMsSUFBVCxLQUFrQixHQUF0QixFQUEyQjtBQUN6QixnQkFBSSxtQkFBbUIsSUFBSSxJQUEzQjs7QUFFQSxvQkFBUSxHQUFSLENBQVksb0JBQVosRUFBa0MsaUJBQWlCLEtBQW5EO0FBQ0Esb0JBQVEsZ0JBQVI7QUFDRCxXQUxELE1BS087QUFDTCxtQkFBTyw0Q0FBUDtBQUNEO0FBQ0YsU0FYRDtBQVlELE9BNUJNLENBQVA7QUE2QkQ7Ozs4QkFFUyxXLEVBQWE7O0FBRXJCLGFBQU8sc0JBQVksVUFBQyxPQUFELEVBQVUsTUFBVixFQUFxQjs7QUFFdEMsWUFBSSxNQUFNLE9BQU8sSUFBUCxDQUFZLFdBQVosRUFBeUIsZUFBekIsRUFBMEMsdUJBQTFDLENBQVY7QUFDQSxZQUFJLE9BQU8sT0FBWCxFQUFvQjtBQUNsQixjQUFJLGdCQUFKLENBQXFCLFdBQXJCLEVBQWtDLFVBQVMsQ0FBVCxFQUFZO0FBQzVDLGdCQUFJLE1BQU0sRUFBRSxHQUFaO0FBQ0EsZ0JBQUksT0FBTyxlQUFlLElBQWYsQ0FBb0IsR0FBcEIsQ0FBWDtBQUNBLGdCQUFJLFFBQVEsZ0JBQWdCLElBQWhCLENBQXFCLEdBQXJCLENBQVo7O0FBRUEsZ0JBQUksUUFBUSxLQUFaLEVBQW1CO0FBQ2pCLGtCQUFJLEtBQUo7QUFDQSxzQkFBUSxHQUFSO0FBQ0Q7QUFDRixXQVREO0FBVUQsU0FYRCxNQVdPO0FBQUE7QUFDTCxnQkFBSSxZQUFZLFlBQVksWUFBVztBQUNyQyxrQkFBSTtBQUNGLG9CQUFJLElBQUksTUFBUixFQUFnQjtBQUNkLHlCQUFPLGlEQUFQO0FBQ0EsZ0NBQWMsU0FBZDtBQUNEOztBQUVELG9CQUFJLElBQUksUUFBSixDQUFhLEdBQWIsQ0FBaUIsT0FBakIsQ0FBeUIsVUFBekIsTUFBeUMsQ0FBQyxDQUExQyxJQUErQyxJQUFJLFFBQUosQ0FBYSxHQUFiLENBQWlCLE9BQWpCLENBQXlCLFNBQVMsTUFBbEMsTUFBOEMsQ0FBQyxDQUFsRyxFQUFxRztBQUNuRyx5QkFBTyxhQUFQLENBQXFCLFNBQXJCO0FBQ0Esc0JBQUksTUFBUSxJQUFJLFFBQUosQ0FBYSxHQUF6Qjs7QUFFQSxzQkFBSSxLQUFKO0FBQ0EsMEJBQVEsR0FBUjtBQUNEO0FBQ0YsZUFiRCxDQWFFLE9BQU8sQ0FBUCxFQUFVO0FBQ1Y7QUFDRDtBQUNGLGFBakJlLEVBaUJiLEdBakJhLENBQWhCO0FBREs7QUFtQk47QUFDRixPQWxDTSxDQUFQO0FBbUNEOztBQUVEOzs7Ozs7Ozt5Q0FLcUIsVSxFQUFZLE0sRUFBUSxZLEVBQWMsUyxFQUFXO0FBQ2hFLFVBQUksUUFBUSxJQUFaOztBQUVBLGFBQU8sc0JBQVksVUFBUyxPQUFULEVBQWlCLE1BQWpCLEVBQXlCOztBQUUxQztBQUNBOztBQUVBLGNBQU0sbUJBQU4sQ0FBMEIsV0FBMUIsQ0FBc0MsU0FBdEMsRUFBaUQsSUFBakQsQ0FBc0QsVUFBQyxNQUFELEVBQVk7QUFDaEUsa0JBQVEsR0FBUixDQUFZLHVDQUFaLEVBQXFELE1BQXJEOztBQUVBLGNBQUksQ0FBQyxNQUFMLEVBQWE7O0FBRWIsY0FBSSxpQkFBaUIsTUFBTSxxQkFBTixFQUFyQjs7QUFFQSxnQkFBTSxvQkFBTixDQUEyQixlQUFlLFVBQTFDLEVBQXNELGVBQWUsSUFBckUsRUFBMkUsSUFBM0UsQ0FBZ0YsaUJBQVM7O0FBRXZGLGdCQUFJLE1BQU0sSUFBTixLQUFlLFVBQW5CLEVBQStCOztBQUU3QixrQkFBSSxXQUFXLGdDQUFvQixNQUFNLEtBQTFCLENBQWY7O0FBRUE7QUFDQSxtQkFBSyxJQUFJLENBQVQsSUFBYyxNQUFNLFVBQXBCLEVBQWdDO0FBQzlCLG9CQUFJLE1BQU0sVUFBTixDQUFpQixDQUFqQixFQUFvQixRQUFwQixLQUFpQyxRQUFyQyxFQUErQztBQUM3Qyx5QkFBTyxRQUFRLE1BQU0sVUFBTixDQUFpQixDQUFqQixFQUFvQixXQUE1QixDQUFQO0FBQ0Q7QUFDRjtBQUNELHFCQUFPLHlCQUFQO0FBQ0QsYUFYRCxNQVdPLElBQUksTUFBTSxJQUFOLEtBQWUsS0FBbkIsRUFBMEI7O0FBRS9CLG9CQUFNLG1CQUFOLENBQTBCLE1BQU0sS0FBaEMsRUFBdUMsTUFBdkMsRUFBK0MsSUFBL0MsQ0FBb0QsVUFBQyxLQUFELEVBQVc7QUFDN0Qsd0JBQVEsS0FBUjtBQUNELGVBRkQsRUFFRyxVQUFDLEdBQUQsRUFBUztBQUNWLHVCQUFPLEdBQVA7QUFDRCxlQUpEO0FBTUQsYUFSTSxNQVFBO0FBQ0wscUJBQU8sZ0NBQVA7QUFDRDtBQUNGLFdBeEJEO0FBeUJELFNBaENELEVBZ0NHLEtBaENILENBZ0NTLGlCQUFTO0FBQ2hCLGtCQUFRLEdBQVIsQ0FBWSxnQ0FBWixFQUE4QyxLQUE5QztBQUNBLGlCQUFPLEtBQVA7QUFDRCxTQW5DRDs7QUFxQ0EsY0FBTSxtQkFBTixDQUEwQixXQUExQixDQUFzQyxNQUF0QyxFQUE4QyxJQUE5QyxDQUFtRCxVQUFDLE1BQUQsRUFBWTtBQUM3RCxrQkFBUSxHQUFSLENBQVksNEJBQVosRUFBMEMsTUFBMUM7O0FBRUEsY0FBSSxDQUFDLE1BQUwsRUFBYTs7QUFFYixjQUFJLE1BQU0sZUFBTixLQUEwQixTQUE5QixFQUF5QztBQUN2QztBQUNBO0FBQ0EsbUJBQU8sUUFBUSxNQUFNLGVBQWQsQ0FBUDtBQUNELFdBSkQsTUFJTztBQUFBO0FBQ0wsc0JBQVEsR0FBUixDQUFZLGlDQUFaO0FBQ0Esa0JBQUksZUFBZSxLQUFLLEtBQUwsQ0FBWSxLQUFLLE1BQUwsS0FBZ0IsS0FBakIsR0FBMEIsQ0FBckMsQ0FBbkI7QUFDQSxrQkFBSSxpQkFBaUI7QUFDbkIsMkJBQVcsV0FEUTtBQUVuQixxQkFBSSxRQUZlO0FBR25CLDZCQUFhO0FBQ1gsMEJBQVEsOEZBREc7QUFFWCxzQkFBSSxhQUZPO0FBR1gsNEJBQVUsWUFBWSxZQUFaLEdBQTJCLGFBSDFCO0FBSVgsMkJBQVMsOEJBQThCO0FBSjVCLGlCQUhNLEVBQXJCO0FBU0Esb0JBQU0sZUFBTixHQUF3QixjQUF4QjtBQUNBLG9CQUFNLFVBQU4sQ0FBaUIsSUFBakIsQ0FBc0IsY0FBdEI7QUFDQSxvQkFBTSxjQUFOLENBQXFCLEdBQXJCLENBQXlCLHFCQUF6QixFQUFnRCxDQUFoRCxFQUFtRCxNQUFNLFVBQXpELEVBQXFFLElBQXJFLENBQTBFLFlBQU07O0FBRTlFLHVCQUFPLFFBQVEsY0FBUixDQUFQO0FBQ0QsZUFIRDtBQWRLO0FBa0JOO0FBRUYsU0E3QkQsRUE2QkcsS0E3QkgsQ0E2QlMsaUJBQVM7QUFDaEIsa0JBQVEsR0FBUixDQUFZLGdDQUFaLEVBQThDLEtBQTlDO0FBQ0EsaUJBQU8sS0FBUDtBQUNELFNBaENEO0FBaUNELE9BM0VNLENBQVA7QUE0RUQ7Ozt3Q0FFbUIsRyxFQUFLLE0sRUFBUTtBQUMvQixVQUFJLFFBQVEsSUFBWjs7QUFFQSxhQUFPLHNCQUFZLFVBQUMsT0FBRCxFQUFVLE1BQVYsRUFBcUI7O0FBRXRDLFlBQUksa0JBQUo7QUFDQSxZQUFJLG9CQUFKOztBQUVBO0FBQ0EsY0FBTSxNQUFOLENBQWEsa0JBQWIsR0FBa0MsSUFBbEMsQ0FBdUMsVUFBUyxPQUFULEVBQWtCOztBQUV2RCxzQkFBWSxLQUFLLFFBQVEsTUFBYixDQUFaO0FBQ0Esd0JBQWMsT0FBZDtBQUNBLGlCQUFPLE1BQU0saUJBQU4sQ0FBd0IsU0FBeEIsRUFBbUMsTUFBbkMsRUFBMkMsRUFBM0MsRUFBK0MsV0FBL0MsRUFBNEQsR0FBNUQsQ0FBUDtBQUVELFNBTkQsRUFNRyxJQU5ILENBTVEsVUFBUyxHQUFULEVBQWM7QUFDcEIsaUJBQU8sTUFBTSxpQkFBTixDQUF3QixTQUF4QixFQUFtQyxNQUFuQyxFQUEyQyxHQUEzQyxFQUFnRCxXQUFoRCxFQUE2RCxHQUE3RCxDQUFQO0FBRUQsU0FURCxFQVNHLElBVEgsQ0FTUSxVQUFTLEtBQVQsRUFBZ0I7QUFDdEIsY0FBSSxLQUFKLEVBQVc7QUFDVCxvQkFBUSxLQUFSO0FBQ0QsV0FGRCxNQUVPO0FBQ0wsbUJBQU8sNkJBQVA7QUFDRDtBQUNGLFNBZkQsRUFlRyxLQWZILENBZVMsVUFBUyxHQUFULEVBQWM7QUFDckIsa0JBQVEsR0FBUixDQUFZLEdBQVo7QUFDQSxpQkFBTyxHQUFQO0FBQ0QsU0FsQkQ7QUFtQkQsT0F6Qk0sQ0FBUDtBQTBCRDs7O3dDQUVtQixRLEVBQVUsTSxFQUFRLFksRUFBYyxTLEVBQVc7QUFDN0QsVUFBSSxRQUFRLElBQVo7QUFDQSxVQUFJLFNBQVMsTUFBTSxjQUFOLENBQXFCLFNBQXJCLENBQWI7QUFDQSxVQUFJLGdCQUFKOztBQUVBLGFBQU8sc0JBQVksVUFBQyxPQUFELEVBQVUsTUFBVixFQUFxQjtBQUN0QyxrQkFBVSxFQUFDLE1BQUssU0FBTixFQUFpQixJQUFJLE1BQXJCLEVBQTZCLE1BQU0sTUFBTSxPQUF6QyxFQUFrRCxNQUFNLEVBQUMsVUFBVSxVQUFYLEVBQXVCLFFBQVEsbUJBQS9CLEVBQW9ELFFBQVEsRUFBQyxVQUFVLFFBQVgsRUFBcUIsUUFBUSxNQUE3QixFQUFxQyxjQUFjLFlBQW5ELEVBQTVELEVBQXhELEVBQVY7QUFDQSxjQUFNLFdBQU4sQ0FBa0IsV0FBbEIsQ0FBOEIsT0FBOUIsRUFBdUMsVUFBQyxHQUFELEVBQVM7QUFDOUMsY0FBSSxTQUFTLElBQUksSUFBSixDQUFTLEtBQXRCOztBQUVBLGtCQUFRLE1BQVI7QUFFRCxTQUxEO0FBTUQsT0FSTSxDQUFQO0FBU0Q7OztrQ0FFYSxNLEVBQVEsTyxFQUFTO0FBQzdCLFVBQUksUUFBUSxJQUFaOztBQUVBLGFBQU8sc0JBQVksVUFBQyxPQUFELEVBQVUsTUFBVixFQUFxQjs7QUFFdEMsWUFBSSxtQkFBbUIsT0FBTyxTQUFQLENBQWlCLEtBQWpCLENBQXVCLEdBQXZCLENBQXZCO0FBQ0EsWUFBSSx3QkFBSjs7QUFFQTtBQUNBLFlBQUksaUJBQWlCLENBQWpCLENBQUosRUFBeUI7QUFDdkIsNEJBQWtCLEtBQUssS0FBTCxDQUFXLEtBQUssaUJBQWlCLENBQWpCLENBQUwsQ0FBWCxDQUFsQjtBQUNELFNBRkQsTUFFTzs7QUFFTCw0QkFBa0IsS0FBSyxLQUFMLENBQVcsS0FBSyxPQUFPLFNBQVosQ0FBWCxDQUFsQjtBQUNEO0FBQ0QsWUFBSSxnQkFBSjs7QUFFQTtBQUNBLFlBQUksZ0JBQWdCLFdBQXBCLEVBQWlDO0FBQy9CLG9CQUFVLGdCQUFnQixXQUExQjtBQUNELFNBRkQsTUFFTztBQUNMLG9CQUFVLGVBQVY7QUFDRDs7QUFFRCxZQUFJLFFBQVEsUUFBUSxLQUFSLElBQWlCLFFBQVEsR0FBckM7O0FBRUEsWUFBSSxhQUFhLGdDQUFvQixLQUFwQixDQUFqQjs7QUFFQSxlQUFPLFFBQVAsR0FBa0IsVUFBbEI7O0FBRUEsY0FBTSxRQUFOLENBQWUsV0FBZixDQUEyQixNQUEzQjs7QUFFQTtBQUNBLFlBQUksWUFBYSxPQUFPLFNBQVIsR0FBcUIsT0FBTyxTQUE1QixHQUF3QyxFQUF4RDs7QUFFQSxZQUFJLGFBQWEsUUFBUSxJQUFSLElBQWdCLE1BQU0sU0FBTixDQUFnQixDQUFoQixFQUFtQixNQUFNLE9BQU4sQ0FBYyxHQUFkLENBQW5CLENBQWpDO0FBQ0EsWUFBSSxvQkFBb0IsRUFBQyxVQUFVLEtBQVgsRUFBa0IsSUFBSSxVQUF0QixFQUFrQyxRQUFRLFVBQVUsT0FBcEQsRUFBNkQsUUFBUSxVQUFVLE1BQS9FLEVBQXVGLFNBQVMsVUFBaEcsRUFBeEI7O0FBRUE7QUFDQSxZQUFJLGNBQWMsRUFBQyxhQUFhLGlCQUFkLEVBQWlDLEtBQUssT0FBTyxHQUFQLENBQVcsTUFBakQsRUFBeUQsV0FBVyxPQUFPLFNBQTNFLEVBQWxCO0FBQ0EsZUFBTyxXQUFQLEdBQXFCLFdBQXJCO0FBQ0EsZUFBTyxPQUFQLEdBQWlCLE9BQWpCOztBQUVBLGNBQU0sZUFBTixHQUF3QixXQUF4Qjs7QUFFQTtBQUNBLFlBQUksa0JBQWtCLEtBQXRCO0FBQ0EsWUFBSSxjQUFKO0FBQ0EsYUFBSyxJQUFJLFFBQVQsSUFBcUIsTUFBTSxVQUEzQixFQUF1QztBQUNyQyxjQUFJLE1BQU0sVUFBTixDQUFpQixRQUFqQixFQUEyQixRQUEzQixLQUF3QyxPQUFPLFFBQW5ELEVBQTZEO0FBQzNELDhCQUFrQixJQUFsQjtBQUNBLG9CQUFRLE1BQU0sVUFBTixDQUFpQixRQUFqQixFQUEyQixXQUFuQztBQUNEO0FBQ0Y7O0FBRUQsWUFBSSxlQUFKLEVBQXFCO0FBQ25CLGtCQUFRLEtBQVI7QUFDQSxjQUFJLFNBQVMsS0FBYjs7QUFFQTtBQUNBO0FBQ0EsZUFBSyxJQUFJLENBQVQsSUFBYyxNQUFNLFVBQXBCLEVBQWdDO0FBQzlCLGdCQUFJLE1BQU0sVUFBTixDQUFpQixDQUFqQixNQUF3QixLQUE1QixFQUFtQztBQUNqQyx1QkFBUyxJQUFUO0FBQ0E7QUFDRDtBQUNGO0FBQ0QsY0FBSSxDQUFDLE1BQUwsRUFBYTtBQUNYLGtCQUFNLFVBQU4sQ0FBaUIsSUFBakIsQ0FBc0IsS0FBdEI7QUFDRDtBQUVGLFNBaEJELE1BZ0JPO0FBQ0wsZ0JBQU0sVUFBTixDQUFpQixJQUFqQixDQUFzQixLQUF0QjtBQUNBLGdCQUFNLFVBQU4sQ0FBaUIsSUFBakIsQ0FBc0IsTUFBdEI7QUFDQSxnQkFBTSxjQUFOLENBQXFCLEdBQXJCLENBQXlCLHFCQUF6QixFQUFnRCxDQUFoRCxFQUFtRCxNQUFNLFVBQXpELEVBQXFFLElBQXJFLENBQTBFLFlBQU07O0FBRTlFLG9CQUFRLFdBQVI7QUFDRCxXQUhEO0FBSUQ7QUFFRixPQTdFTSxDQUFQO0FBOEVEOztBQUVEOzs7Ozs7Ozs7Ozs7c0NBU2tCLFEsRUFBVSxNLEVBQVEsWSxFQUFjLE8sRUFBUyxTLEVBQVc7QUFDcEUsVUFBSSxRQUFRLElBQVo7O0FBRUEsY0FBUSxHQUFSLENBQVksbUJBQVo7O0FBRUEsYUFBTyxzQkFBWSxVQUFTLE9BQVQsRUFBaUIsTUFBakIsRUFBeUI7O0FBRTFDLGNBQU0sbUJBQU4sQ0FBMEIsUUFBMUIsRUFBb0MsTUFBcEMsRUFBNEMsWUFBNUMsRUFBMEQsU0FBMUQsRUFBcUUsSUFBckUsQ0FBMEUsVUFBQyxNQUFELEVBQVk7O0FBRXBGLGNBQUksT0FBTyxRQUFYLEVBQXFCOztBQUVuQixrQkFBTSxTQUFOLENBQWdCLE9BQU8sUUFBdkIsRUFBaUMsSUFBakMsQ0FBc0MsVUFBQyxLQUFELEVBQVc7QUFDL0Msc0JBQVEsS0FBUjtBQUNELGFBRkQsRUFFRyxVQUFDLEdBQUQsRUFBUztBQUNWLHFCQUFPLEdBQVA7QUFDRCxhQUpEO0FBS0QsV0FQRCxNQU9PLElBQUksTUFBSixFQUFZOztBQUVqQixrQkFBTSxhQUFOLENBQW9CLE1BQXBCLEVBQTRCLE9BQTVCLEVBQXFDLElBQXJDLENBQTBDLFVBQUMsS0FBRCxFQUFXO0FBQ25ELHNCQUFRLEtBQVI7QUFDRCxhQUZELEVBRUcsVUFBQyxHQUFELEVBQVM7QUFDVixxQkFBTyxHQUFQO0FBQ0QsYUFKRDtBQU1ELFdBUk0sTUFRQTtBQUNMLG1CQUFPLHlDQUFQO0FBQ0Q7QUFFRixTQXJCRDtBQXNCRCxPQXhCTSxDQUFQO0FBeUJEOztBQUVEOzs7O0FBSUE7Ozs7Ozs7Ozs7c0NBT2tCLFMsRUFBVyxNLEVBQVEsUyxFQUFXO0FBQzlDLFVBQUksUUFBUSxJQUFaOztBQUVBLFVBQUksU0FBUyxNQUFNLGNBQU4sQ0FBcUIsU0FBckIsQ0FBYjs7QUFFQSxVQUFJLFVBQVUsRUFBQyxNQUFLLFNBQU4sRUFBaUIsSUFBSSxNQUFyQixFQUE2QixNQUFNLE1BQU0sT0FBekMsRUFBa0QsTUFBTSxFQUFDLFVBQVUsVUFBWCxFQUF1QixRQUFRLG1CQUEvQjtBQUM5RCxrQkFBUSxFQUFDLFdBQVcsU0FBWixFQUF1QixRQUFRLE1BQS9CLEVBRHNELEVBQXhELEVBQWQ7O0FBR0EsYUFBTyxzQkFBWSxVQUFTLE9BQVQsRUFBa0IsTUFBbEIsRUFBMEI7QUFDM0MsY0FBTSxXQUFOLENBQWtCLFdBQWxCLENBQThCLE9BQTlCLEVBQXVDLFVBQUMsTUFBRCxFQUFZO0FBQ2pELGNBQUksT0FBTyxJQUFQLENBQVksSUFBWixLQUFxQixHQUF6QixFQUE4QjtBQUM1QixvQkFBUSxPQUFPLElBQVAsQ0FBWSxLQUFwQjtBQUNELFdBRkQsTUFFTztBQUNMLG1CQUFPLE9BQVAsRUFBZ0IsT0FBTyxJQUFQLENBQVksSUFBNUI7QUFDRDtBQUNGLFNBTkQ7QUFPRCxPQVJNLENBQVA7QUFTRDs7O21DQUVjLE8sRUFBUztBQUN0QixVQUFJLFFBQVEsSUFBWjs7QUFFQSxjQUFRLEdBQVIsQ0FBWSxrQkFBWjs7QUFFQSxhQUFPLHNCQUFZLFVBQVMsT0FBVCxFQUFrQixNQUFsQixFQUEwQjtBQUMzQyxZQUFJLGtCQUFrQixRQUFRLElBQVIsS0FBaUIsV0FBdkM7O0FBRUE7QUFDQSxZQUFJLENBQUMsTUFBTSxpQkFBUCxJQUE0QixDQUFDLGVBQWpDLEVBQWtEO0FBQ2hELGtCQUFRLEdBQVIsQ0FBWSxxQkFBWjtBQUNBLGlCQUFPLFFBQVEsT0FBUixDQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxZQUFJLGVBQWUsUUFBUSxFQUFSLENBQVcsS0FBWCxDQUFpQixHQUFqQixDQUFuQjtBQUNBLFlBQUksZ0JBQWdCLGFBQWEsQ0FBYixJQUFrQixJQUFsQixHQUF5QixhQUFhLENBQWIsQ0FBekIsR0FBMkMsR0FBM0MsR0FBaUQsYUFBYSxDQUFiLENBQXJFO0FBQ0EsWUFBSSxhQUFhLE1BQWIsR0FBc0IsQ0FBMUIsRUFBNkI7QUFDM0IsMEJBQWdCLGFBQWEsQ0FBYixJQUFrQixJQUFsQixHQUF5QixhQUFhLENBQWIsQ0FBekIsR0FBMkMsR0FBM0MsR0FBaUQsYUFBYSxDQUFiLENBQWpELEdBQW1FLEdBQW5FLEdBQXlFLGFBQWEsQ0FBYixDQUF6RjtBQUNEOztBQUVELFlBQUksaUJBQWlCLDRCQUFnQixhQUFoQixDQUFyQjtBQUNBLFlBQUksZ0JBQWdCLHNCQUFVLFFBQVEsSUFBbEIsRUFBd0IsSUFBeEIsS0FBaUMsU0FBckQ7QUFDQSxZQUFJLGNBQWMsc0JBQVUsUUFBUSxFQUFsQixFQUFzQixJQUF0QixLQUErQixTQUFqRDs7QUFFQSxZQUFJLFFBQVEsSUFBUixLQUFpQixRQUFyQixFQUErQjtBQUM3QixrQkFBUSxPQUFSO0FBQ0Q7O0FBRUQsWUFBSSxpQkFBaUIsV0FBckIsRUFBa0M7QUFDaEMsY0FBSSxVQUFVLE1BQU0sU0FBTixDQUFnQixlQUFoQixDQUFnQyxRQUFRLElBQXhDLENBQWQ7QUFDQSxjQUFJLE9BQUosRUFBYTtBQUFBOztBQUVYO0FBQ0Esa0JBQUksV0FBVyxNQUFNLFFBQU4sQ0FBZSxRQUFRLElBQVIsR0FBZSxLQUFmLEdBQXVCLFFBQVEsRUFBOUMsQ0FBZjtBQUNBLGtCQUFJLENBQUMsUUFBTCxFQUFlO0FBQ2IsMkJBQVcsTUFBTSxjQUFOLENBQXFCLE9BQXJCLEVBQThCLE9BQTlCLENBQVg7QUFDQSx3QkFBUSxHQUFSLENBQVksdUJBQVosRUFBcUMsUUFBUSxJQUFSLEdBQWUsUUFBUSxFQUE1RDtBQUNBLHNCQUFNLFFBQU4sQ0FBZSxRQUFRLElBQVIsR0FBZSxLQUFmLEdBQXVCLFFBQVEsRUFBOUMsSUFBb0QsUUFBcEQ7QUFDQSx3QkFBUSxJQUFSLENBQWEsY0FBYixHQUE4QixnQkFBOUI7QUFDRDs7QUFFRCxrQkFBSSxTQUFTLGFBQVQsSUFBMEIsQ0FBQyxlQUEvQixFQUFnRDtBQUFBOztBQUU5QyxzQkFBSSxLQUFLLE1BQU0sTUFBTixDQUFhLFVBQWIsRUFBVDtBQUNBLHdCQUFNLE1BQU4sQ0FBYSxVQUFiLENBQXdCLFNBQVMsSUFBVCxDQUFjLHFCQUF0QyxFQUE2RCxRQUFRLElBQVIsQ0FBYSxLQUExRSxFQUFpRixFQUFqRixFQUFxRixJQUFyRixDQUEwRiwwQkFBa0I7O0FBRTFHLHdCQUFJLGtCQUFrQixNQUFNLG9CQUFOLENBQTJCLE9BQTNCLEVBQW9DLFFBQVEsSUFBUixDQUFhLEtBQWIsR0FBcUIsRUFBekQsRUFBNkQsU0FBUyxXQUFULENBQXFCLFdBQWxGLENBQXRCOztBQUVBLDBCQUFNLE1BQU4sQ0FBYSxRQUFiLENBQXNCLFNBQVMsSUFBVCxDQUFjLGtCQUFwQyxFQUF3RCxlQUF4RCxFQUF5RSxJQUF6RSxDQUE4RSxnQkFBUTtBQUNwRjtBQUNBLDBCQUFJLFFBQVEsRUFBQyxJQUFJLE1BQU0sTUFBTixDQUFhLE1BQWIsQ0FBb0IsRUFBcEIsQ0FBTCxFQUE4QixPQUFPLE1BQU0sTUFBTixDQUFhLE1BQWIsQ0FBb0IsY0FBcEIsQ0FBckMsRUFBMEUsTUFBTSxNQUFNLE1BQU4sQ0FBYSxNQUFiLENBQW9CLElBQXBCLENBQWhGLEVBQVo7QUFDQSw4QkFBUSxJQUFSLENBQWEsS0FBYixHQUFxQix5QkFBZSxLQUFmLENBQXJCOztBQUVBLDhCQUFRLE9BQVI7QUFDRCxxQkFORDtBQU9ELG1CQVhEOztBQWFBO0FBaEI4QztBQWlCL0MsZUFqQkQsTUFpQk8sSUFBSSxlQUFKLEVBQXFCO0FBQzFCLHdCQUFRLE9BQVI7O0FBRUE7QUFDRCxlQUpNLE1BSUE7QUFDTCxzQkFBTSxpQkFBTixDQUF3QixPQUF4QixFQUFpQyxRQUFqQyxFQUEyQyxJQUEzQyxDQUFnRCxVQUFTLEtBQVQsRUFBZ0I7QUFDOUQsd0JBQU0sUUFBTixDQUFlLFFBQVEsSUFBUixHQUFlLEtBQWYsR0FBdUIsUUFBUSxFQUE5QyxJQUFvRCxNQUFNLFFBQTFEOztBQUVBLHdCQUFNLFdBQU4sQ0FBa0IsV0FBbEIsQ0FBOEIsTUFBTSxPQUFwQztBQUNBLHlCQUFPLG1DQUFQO0FBQ0QsaUJBTEQ7QUFNRDtBQXZDVTtBQXdDWjs7QUFFSDtBQUNDLFNBN0NELE1BNkNPLElBQUksaUJBQWlCLGNBQXJCLEVBQXFDO0FBQUE7QUFDMUMsb0JBQVEsR0FBUixDQUFZLCtCQUFaLEVBQTZDLFFBQVEsSUFBUixDQUFhLEtBQTFEOztBQUVBLGdCQUFJLGdCQUFnQixNQUFNLHFCQUFOLENBQTRCLGFBQTVCLENBQXBCOztBQUVBO0FBQ0EsZ0JBQUksQ0FBQyxhQUFMLEVBQW9CO0FBQ2xCLGtCQUFJLG9CQUFvQixNQUFNLFFBQU4sQ0FBZSx3QkFBZixDQUF3QyxhQUF4QyxDQUF4Qjs7QUFFQTtBQUNBLGtCQUFJLHFCQUFxQixzQkFBc0IsUUFBUSxJQUF2RCxFQUE2RDs7QUFFM0Qsb0JBQUksYUFBYSxNQUFNLE1BQU4sQ0FBYSxjQUFiLEVBQWpCO0FBQ0Esc0JBQU0scUJBQU4sQ0FBNEIsYUFBNUIsSUFBNkMsRUFBQyxZQUFZLFVBQWIsRUFBeUIsYUFBYSxJQUF0QyxFQUE3Qzs7QUFFQSxnQ0FBZ0IsTUFBTSxxQkFBTixDQUE0QixhQUE1QixDQUFoQjtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQSxnQkFBSSxhQUFKLEVBQW1COztBQUVqQjtBQUNBLGtCQUFJLGNBQWMsV0FBbEIsRUFBK0I7QUFBQTtBQUM3QixzQkFBSSxLQUFLLE1BQU0sTUFBTixDQUFhLFVBQWIsRUFBVDs7QUFFQSx3QkFBTSxNQUFOLENBQWEsVUFBYixDQUF3QixjQUFjLFVBQXRDLEVBQWtELE1BQU0sTUFBTixDQUFhLE1BQWIsQ0FBb0IseUJBQWUsUUFBUSxJQUFSLENBQWEsS0FBNUIsQ0FBcEIsQ0FBbEQsRUFBMkcsRUFBM0csRUFBK0csSUFBL0csQ0FBb0gsMEJBQWtCOztBQUVwSSx3QkFBSSxrQkFBa0IsTUFBTSxvQkFBTixDQUEyQixPQUEzQixFQUFvQyxRQUFRLElBQVIsQ0FBYSxLQUFiLEdBQXFCLEVBQXpELEVBQTZELGNBQWMsVUFBM0UsQ0FBdEI7O0FBRUEsMEJBQU0sTUFBTixDQUFhLFFBQWIsQ0FBc0IsY0FBYyxVQUFwQyxFQUFnRCxlQUFoRCxFQUFpRSxJQUFqRSxDQUFzRSxnQkFBUTtBQUM1RTs7QUFFQSwwQkFBSSxXQUFXLEVBQUMsT0FBTyxNQUFNLE1BQU4sQ0FBYSxNQUFiLENBQW9CLGNBQXBCLENBQVIsRUFBNkMsSUFBSSxNQUFNLE1BQU4sQ0FBYSxNQUFiLENBQW9CLEVBQXBCLENBQWpELEVBQTBFLE1BQU0sTUFBTSxNQUFOLENBQWEsTUFBYixDQUFvQixJQUFwQixDQUFoRixFQUFmOztBQUVBLDhCQUFRLElBQVIsQ0FBYSxLQUFiLEdBQXFCLHlCQUFlLFFBQWYsQ0FBckI7QUFDQSw4QkFBUSxPQUFSO0FBQ0QscUJBUEQ7QUFRRCxtQkFaRDs7QUFjRjtBQWpCK0I7QUFrQjlCLGVBbEJELE1Ba0JPO0FBQ0wsd0JBQVEsT0FBUjtBQUNEOztBQUVEO0FBQ0QsYUExQkQsTUEwQk87QUFDTCxxQkFBTywyQkFBUDtBQUNEO0FBaER5QztBQWlEM0M7QUFDRixPQXZITSxDQUFQO0FBd0hEOzs7bUNBRWMsTyxFQUFTO0FBQ3RCLFVBQUksUUFBUSxJQUFaOztBQUVBLGNBQVEsR0FBUixDQUFZLGtCQUFaOztBQUVBLGFBQU8sc0JBQVksVUFBUyxPQUFULEVBQWtCLE1BQWxCLEVBQTBCO0FBQzNDLFlBQUksa0JBQWtCLFFBQVEsSUFBUixLQUFpQixXQUF2Qzs7QUFFQTtBQUNBLFlBQUksQ0FBQyxNQUFNLGlCQUFQLElBQTRCLENBQUMsZUFBakMsRUFBa0Q7QUFDaEQsa0JBQVEsR0FBUixDQUFZLHFCQUFaO0FBQ0EsaUJBQU8sUUFBUSxPQUFSLENBQVA7QUFDRDs7QUFFRDs7QUFFQSxZQUFJLGVBQWUsUUFBUSxFQUFSLENBQVcsS0FBWCxDQUFpQixHQUFqQixDQUFuQjtBQUNBLFlBQUksZ0JBQWdCLGFBQWEsQ0FBYixJQUFrQixJQUFsQixHQUF5QixhQUFhLENBQWIsQ0FBekIsR0FBMkMsR0FBM0MsR0FBaUQsYUFBYSxDQUFiLENBQXJFO0FBQ0EsWUFBSSxhQUFhLE1BQWIsR0FBc0IsQ0FBMUIsRUFBNkI7QUFDM0IsMEJBQWdCLGFBQWEsQ0FBYixJQUFrQixJQUFsQixHQUF5QixhQUFhLENBQWIsQ0FBekIsR0FBMkMsR0FBM0MsR0FBaUQsYUFBYSxDQUFiLENBQWpELEdBQW1FLEdBQW5FLEdBQXlFLGFBQWEsQ0FBYixDQUF6RjtBQUNEOztBQUVELFlBQUksaUJBQWlCLDRCQUFnQixhQUFoQixDQUFyQjtBQUNBLFlBQUksZ0JBQWdCLHNCQUFVLFFBQVEsSUFBbEIsRUFBd0IsSUFBeEIsS0FBaUMsU0FBckQ7QUFDQSxZQUFJLGNBQWMsc0JBQVUsUUFBUSxFQUFsQixFQUFzQixJQUF0QixLQUErQixTQUFqRDs7QUFFQSxZQUFJLFFBQVEsSUFBUixLQUFpQixRQUFyQixFQUErQjtBQUM3QixrQkFBUSxPQUFSO0FBQ0Q7O0FBRUQ7QUFDQSxZQUFJLGlCQUFpQixXQUFyQixFQUFrQztBQUNoQztBQUNBLGNBQUksVUFBVSxNQUFNLFNBQU4sQ0FBZ0IsZUFBaEIsQ0FBZ0MsUUFBUSxFQUF4QyxDQUFkO0FBQ0EsY0FBSSxPQUFKLEVBQWE7QUFBQTs7QUFFWCxrQkFBSSxXQUFXLE1BQU0sUUFBTixDQUFlLFFBQVEsRUFBUixHQUFhLEtBQWIsR0FBcUIsUUFBUSxJQUE1QyxDQUFmO0FBQ0Esa0JBQUksQ0FBQyxRQUFMLEVBQWU7QUFDYiwyQkFBVyxNQUFNLGNBQU4sQ0FBcUIsT0FBckIsRUFBOEIsT0FBOUIsRUFBdUMsU0FBdkMsQ0FBWDtBQUNBLHNCQUFNLFFBQU4sQ0FBZSxRQUFRLEVBQVIsR0FBYSxLQUFiLEdBQXFCLFFBQVEsSUFBNUMsSUFBb0QsUUFBcEQ7QUFDRDs7QUFFRCxrQkFBSSxTQUFTLGFBQVQsSUFBMEIsQ0FBQyxlQUEvQixFQUFnRDtBQUFBO0FBQzlDLHNCQUFJLFFBQVEsS0FBSyxLQUFMLENBQVcsUUFBUSxJQUFSLENBQWEsS0FBeEIsQ0FBWjtBQUNBLHNCQUFJLEtBQUssTUFBTSxNQUFOLENBQWEsTUFBYixDQUFvQixNQUFNLEVBQTFCLENBQVQ7QUFDQSxzQkFBSSxPQUFPLE1BQU0sTUFBTixDQUFhLE1BQWIsQ0FBb0IsTUFBTSxLQUExQixDQUFYO0FBQ0Esc0JBQUksT0FBTyxNQUFNLE1BQU4sQ0FBYSxNQUFiLENBQW9CLE1BQU0sSUFBMUIsQ0FBWDtBQUNBLHdCQUFNLE1BQU4sQ0FBYSxVQUFiLENBQXdCLFNBQVMsSUFBVCxDQUFjLG1CQUF0QyxFQUEyRCxJQUEzRCxFQUFpRSxFQUFqRSxFQUFxRSxJQUFyRSxDQUEwRSx5QkFBaUI7QUFDekYsNEJBQVEsR0FBUixDQUFZLGtCQUFaLEVBQWdDLGFBQWhDO0FBQ0EsNEJBQVEsSUFBUixDQUFhLEtBQWIsR0FBcUIsYUFBckI7O0FBRUEsd0JBQUksa0JBQWtCLE1BQU0sb0JBQU4sQ0FBMkIsT0FBM0IsRUFBb0MsZ0JBQWdCLEVBQXBELENBQXRCOztBQUVBLDBCQUFNLE1BQU4sQ0FBYSxVQUFiLENBQXdCLFNBQVMsSUFBVCxDQUFjLGdCQUF0QyxFQUF3RCxlQUF4RCxFQUF5RSxJQUF6RSxFQUErRSxJQUEvRSxDQUFvRixrQkFBVTtBQUM1RjtBQUNBLDhCQUFRLElBQVIsQ0FBYSxnQkFBYixHQUFnQyxJQUFoQztBQUNBLDhCQUFRLE9BQVI7QUFDRCxxQkFKRDtBQUtELG1CQVhEO0FBTDhDO0FBa0IvQyxlQWxCRCxNQWtCTyxJQUFJLGVBQUosRUFBcUI7QUFDMUIsc0JBQU0saUJBQU4sQ0FBd0IsT0FBeEIsRUFBaUMsUUFBakMsRUFBMkMsSUFBM0MsQ0FBZ0QsVUFBUyxLQUFULEVBQWdCOztBQUU5RDtBQUNBLHNCQUFJLFVBQVUsY0FBZCxFQUE4QjtBQUM1QiwyQkFBTyxtQ0FBUDs7QUFFRjtBQUNDLG1CQUpELE1BSU87QUFDTCwwQkFBTSxRQUFOLENBQWUsUUFBUSxFQUFSLEdBQWEsS0FBYixHQUFxQixRQUFRLElBQTVDLElBQW9ELE1BQU0sUUFBMUQ7QUFDQSwwQkFBTSxXQUFOLENBQWtCLFdBQWxCLENBQThCLE1BQU0sT0FBcEM7QUFDQSwyQkFBTyxtQ0FBUDtBQUNEO0FBQ0YsaUJBWkQ7QUFhRCxlQWRNLE1BY0E7QUFDTCx1QkFBTywwQkFBUDtBQUNEO0FBMUNVO0FBMkNaLFdBM0NELE1BMkNPO0FBQ0wsbUJBQU8sMEJBQVA7QUFDRDs7QUFFRDtBQUNELFNBbkRELE1BbURPLElBQUksaUJBQWlCLGNBQXJCLEVBQXFDO0FBQUE7QUFDMUMsb0JBQVEsR0FBUixDQUFZLCtCQUFaLEVBQTZDLFFBQVEsSUFBckQ7O0FBRUEsZ0JBQUksZ0JBQWdCLE1BQU0scUJBQU4sQ0FBNEIsYUFBNUIsQ0FBcEI7O0FBRUEsZ0JBQUksYUFBSixFQUFtQjs7QUFFakI7QUFDQSxrQkFBSSxjQUFjLFdBQWxCLEVBQStCO0FBQUE7QUFDN0Isc0JBQUksY0FBYyxLQUFLLEtBQUwsQ0FBVyxRQUFRLElBQVIsQ0FBYSxLQUF4QixDQUFsQjtBQUNBLHNCQUFJLEtBQUssTUFBTSxNQUFOLENBQWEsTUFBYixDQUFvQixZQUFZLEVBQWhDLENBQVQ7QUFDQSxzQkFBSSxpQkFBaUIsTUFBTSxNQUFOLENBQWEsTUFBYixDQUFvQixZQUFZLEtBQWhDLENBQXJCO0FBQ0Esc0JBQUksT0FBTyxNQUFNLE1BQU4sQ0FBYSxNQUFiLENBQW9CLFlBQVksSUFBaEMsQ0FBWDs7QUFFQSx3QkFBTSxNQUFOLENBQWEsVUFBYixDQUF3QixjQUFjLFVBQXRDLEVBQWtELGNBQWxELEVBQWtFLEVBQWxFLEVBQXNFLElBQXRFLENBQTJFLDBCQUFrQjtBQUMzRix3QkFBSSxjQUFjLEtBQUssS0FBTCxDQUFXLEtBQUssY0FBTCxDQUFYLENBQWxCO0FBQ0EsNEJBQVEsR0FBUixDQUFZLGtCQUFaLEVBQWdDLFdBQWhDO0FBQ0EsNEJBQVEsSUFBUixDQUFhLEtBQWIsR0FBcUIsV0FBckI7O0FBRUEsd0JBQUksa0JBQWtCLE1BQU0sb0JBQU4sQ0FBMkIsT0FBM0IsRUFBb0MsY0FBYyxFQUFsRCxDQUF0Qjs7QUFFQSwwQkFBTSxNQUFOLENBQWEsVUFBYixDQUF3QixjQUFjLFVBQXRDLEVBQWtELGVBQWxELEVBQW1FLElBQW5FLEVBQXlFLElBQXpFLENBQThFLGtCQUFVO0FBQ3RGOztBQUVBLDhCQUFRLElBQVIsQ0FBYSxnQkFBYixHQUFnQyxJQUFoQztBQUNBLDhCQUFRLE9BQVI7QUFDRCxxQkFMRDtBQU1ELG1CQWJEOztBQWVGO0FBckIrQjtBQXNCOUIsZUF0QkQsTUFzQk87QUFDTCx3QkFBUSxJQUFSLENBQWEsZ0JBQWIsR0FBZ0MsSUFBaEM7QUFDQSx3QkFBUSxPQUFSO0FBQ0Q7QUFFRixhQTlCRCxNQThCTztBQUNMLHNCQUFRLElBQVIsQ0FBYSxnQkFBYixHQUFnQyxJQUFoQztBQUNBLHNCQUFRLE9BQVI7O0FBRUE7QUFDRDtBQXhDeUM7QUEwQzNDLFNBMUNNLE1BMENBO0FBQ0wsaUJBQU8sMEJBQVA7QUFDRDtBQUVGLE9BM0hNLENBQVA7QUE0SEQ7OzsyQ0FFc0IsTSxFQUFRLFEsRUFBVTtBQUN2QyxjQUFRLEdBQVIsQ0FBWSwwQkFBWixFQUF3QyxNQUF4QyxFQUFnRCxRQUFoRDtBQUNBLFVBQUksUUFBUSxJQUFaO0FBQ0EsVUFBSSxzQkFBSjs7QUFFQTtBQUNBLFVBQUksY0FBYyxNQUFNLFFBQU4sQ0FBZSx3QkFBZixDQUF3QyxNQUF4QyxDQUFsQjtBQUNBLFVBQUksV0FBSixFQUFpQjtBQUNmLHdCQUFnQixNQUFoQjtBQUNBLGlCQUFTLFdBQVQ7QUFDRDs7QUFFRCxVQUFJLE1BQU07QUFDUixZQUFJLFFBREk7QUFFUixjQUFNLE1BRkU7QUFHUixrQkFBVSxTQUhGO0FBSVIsY0FBTSxFQUFDLGdCQUFnQixnQkFBakIsRUFBbUMsUUFBUSxlQUEzQztBQUpFLE9BQVY7O0FBT0EsYUFBTyxzQkFBWSxVQUFTLE9BQVQsRUFBa0IsTUFBbEIsRUFBMEI7O0FBRTNDLFlBQUksQ0FBQyxNQUFELElBQVcsQ0FBQyxRQUFoQixFQUEwQjtBQUN4QixpQkFBTyxPQUFPLHNEQUFQLENBQVA7QUFDRDs7QUFFRCxZQUFJLFdBQVcsTUFBTSxRQUFOLENBQWUsU0FBUyxLQUFULEdBQWlCLFFBQWhDLENBQWY7QUFDQSxZQUFJLFVBQVUsTUFBTSxTQUFOLENBQWdCLGVBQWhCLENBQWdDLE1BQWhDLENBQWQ7O0FBRUEsWUFBSSxPQUFKLEVBQWE7O0FBRVgsY0FBSSxDQUFDLFFBQUwsRUFBZTtBQUNiO0FBQ0EsZ0JBQUksV0FBVyxTQUFYLFFBQVcsQ0FBUyxLQUFULEVBQWdCO0FBQzdCLHNCQUFRLEdBQVIsQ0FBWSxpQkFBWixFQUErQixLQUEvQjtBQUNBLHNCQUFRLEtBQVI7QUFDRCxhQUhEO0FBSUEsZ0JBQUksUUFBSixHQUFlLFFBQWY7QUFDQSxnQkFBSSxhQUFKLEdBQW9CLGFBQXBCOztBQUVBLHVCQUFXLE1BQU0sY0FBTixDQUFxQixHQUFyQixFQUEwQixPQUExQixDQUFYO0FBQ0Esa0JBQU0sUUFBTixDQUFlLFNBQVMsS0FBVCxHQUFpQixRQUFoQyxJQUE0QyxRQUE1QztBQUNEOztBQUVELGNBQUksU0FBUyxhQUFiLEVBQTRCOztBQUUxQixnQkFBSSwwQkFBMEI7QUFDNUIsa0JBQUksTUFEd0I7QUFFNUIsb0JBQU07QUFGc0IsYUFBOUI7QUFJQSxxQkFBUyxhQUFULEdBQXlCLGFBQXpCO0FBQ0Esa0JBQU0sdUJBQU4sQ0FBOEIsdUJBQTlCLEVBQXVELFFBQXZELEVBQWlFLElBQWpFLENBQXNFLGlCQUFTOztBQUU3RSxvQkFBTSxXQUFOLENBQWtCLFdBQWxCLENBQThCLE1BQU0sT0FBcEM7QUFDQSxzQkFBUSx1Q0FBUjtBQUNELGFBSkQ7QUFLRCxXQVpELE1BWU87O0FBRUwsa0JBQU0saUJBQU4sQ0FBd0IsR0FBeEIsRUFBNkIsUUFBN0I7QUFDRDtBQUNGLFNBL0JELE1BK0JPO0FBQ0wsaUJBQU8saUNBQVA7QUFDRDtBQUNGLE9BM0NNLENBQVA7QUE2Q0Q7OztzQ0FFaUIsTyxFQUFTLFEsRUFBVTtBQUNuQyxVQUFJLFFBQVEsSUFBWjs7QUFFQTs7QUFFQSxhQUFPLHNCQUFZLFVBQVMsT0FBVCxFQUFpQixNQUFqQixFQUF5Qjs7QUFFMUMsWUFBSSxnQkFBZ0IsUUFBUSxJQUFSLENBQWEsY0FBakM7QUFDQSxZQUFJLFdBQUo7QUFDQSxZQUFJLGFBQUo7QUFDQSxZQUFJLFFBQVEsRUFBWjtBQUNBLFlBQUksd0JBQUo7O0FBTjBDO0FBTzFDLGtCQUFRLGFBQVI7O0FBRUUsaUJBQUssZ0JBQUw7QUFDRSx1QkFBUyxJQUFULENBQWMsVUFBZCxHQUEyQixNQUFNLE1BQU4sQ0FBYSxjQUFiLEVBQTNCOztBQUVBLGtCQUFJLG9CQUFvQjtBQUN0QixzQkFBTSxXQURnQjtBQUV0QixvQkFBSSxRQUFRLEVBRlU7QUFHdEIsc0JBQU0sUUFBUSxJQUhRO0FBSXRCLHNCQUFNO0FBQ0osa0NBQWdCLGFBRFo7QUFFSix5QkFBTyxNQUFNLE1BQU4sQ0FBYSxNQUFiLENBQW9CLFNBQVMsSUFBVCxDQUFjLFVBQWxDO0FBRkg7QUFKZ0IsZUFBeEI7QUFTQSx1QkFBUyxnQkFBVCxDQUEwQixXQUExQixHQUF3QyxNQUFNLG9CQUFOLENBQTJCLGlCQUEzQixFQUE4QyxTQUE5QyxFQUF5RCxTQUFTLFdBQVQsQ0FBcUIsV0FBOUUsQ0FBeEM7O0FBRUE7QUFDQTtBQUNBLGtCQUFJLFNBQVMsY0FBYixFQUE2QjtBQUFDLHdCQUFRLEVBQUMsU0FBUyxpQkFBVixFQUE2QixVQUFVLFFBQXZDLEVBQVI7QUFDN0IsZUFERCxNQUNPO0FBQ0wsc0JBQU0sUUFBTixDQUFlLFFBQVEsSUFBUixHQUFlLEtBQWYsR0FBdUIsUUFBUSxFQUE5QyxJQUFvRCxRQUFwRDtBQUNBLHNCQUFNLFdBQU4sQ0FBa0IsV0FBbEIsQ0FBOEIsaUJBQTlCO0FBQ0Q7O0FBRUg7QUFDQSxpQkFBSyxhQUFMOztBQUVFLHNCQUFRLEdBQVIsQ0FBWSxhQUFaO0FBQ0EsdUJBQVMsZ0JBQVQsQ0FBMEIsV0FBMUIsR0FBd0MsTUFBTSxvQkFBTixDQUEyQixPQUEzQixDQUF4QztBQUNBLHVCQUFTLElBQVQsQ0FBYyxVQUFkLEdBQTJCLE1BQU0sTUFBTixDQUFhLE1BQWIsQ0FBb0IsUUFBUSxJQUFSLENBQWEsS0FBakMsQ0FBM0I7QUFDQSx1QkFBUyxJQUFULENBQWMsUUFBZCxHQUF5QixNQUFNLE1BQU4sQ0FBYSxjQUFiLEVBQXpCOztBQUVBLGtCQUFJLGlCQUFpQjtBQUNuQixzQkFBTSxXQURhO0FBRW5CLG9CQUFJLFFBQVEsSUFGTztBQUduQixzQkFBTSxRQUFRLEVBSEs7QUFJbkIsc0JBQU07QUFDSixrQ0FBZ0IsZUFEWjtBQUVKLHlCQUFPLE1BQU0sTUFBTixDQUFhLE1BQWIsQ0FBb0IsU0FBUyxJQUFULENBQWMsUUFBbEM7QUFGSDtBQUphLGVBQXJCO0FBU0EsdUJBQVMsZ0JBQVQsQ0FBMEIsYUFBMUIsR0FBMEMsTUFBTSxvQkFBTixDQUEyQixjQUEzQixFQUEyQyxTQUEzQyxFQUFzRCxTQUFTLFdBQVQsQ0FBcUIsV0FBM0UsQ0FBMUM7QUFDQSxzQkFBUSxFQUFDLFNBQVMsY0FBVixFQUEwQixVQUFVLFFBQXBDLEVBQVI7O0FBRUY7QUFDQSxpQkFBSyxlQUFMOztBQUVFLHNCQUFRLEdBQVIsQ0FBWSxlQUFaO0FBQ0EsdUJBQVMsZ0JBQVQsQ0FBMEIsYUFBMUIsR0FBMEMsTUFBTSxvQkFBTixDQUEyQixPQUEzQixDQUExQzs7QUFFQSxvQkFBTSxpQkFBTixDQUF3QixRQUFRLElBQVIsQ0FBYSxRQUFiLENBQXNCLFNBQTlDLEVBQXlELFNBQXpELEVBQW9FLFFBQVEsSUFBUixDQUFhLFFBQWIsQ0FBc0IsR0FBMUYsRUFBK0YsSUFBL0YsQ0FBb0csVUFBQyxLQUFELEVBQVc7O0FBRTdHO0FBQ0Esb0JBQUksbUJBQW9CLE9BQU8sTUFBTSxRQUFiLEtBQTBCLFFBQTNCLEdBQXVDLE1BQU0sUUFBN0MsR0FBd0QsTUFBTSxRQUFOLENBQWUsS0FBOUY7O0FBRUEsb0JBQUksb0JBQW9CLE1BQU0sTUFBTixDQUFhLE1BQWIsQ0FBb0IsZ0JBQXBCLENBQXhCO0FBQ0Esb0JBQUksa0JBQWtCLE1BQU0sTUFBTixDQUFhLFdBQWIsRUFBdEI7QUFDQSxvQkFBSSxXQUFXLFFBQVEsSUFBUixDQUFhLEtBQTVCO0FBQ0EseUJBQVMsU0FBVCxDQUFtQixTQUFuQixHQUErQixRQUFRLElBQVIsQ0FBYSxRQUFiLENBQXNCLFNBQXJEO0FBQ0EseUJBQVMsU0FBVCxDQUFtQixTQUFuQixHQUErQixpQkFBL0I7QUFDQSx5QkFBUyxTQUFULENBQW1CLE1BQW5CLEdBQStCLE1BQU0sUUFBTixDQUFlLEtBQTlDO0FBQ0EseUJBQVMsSUFBVCxDQUFjLFFBQWQsR0FBMEIsTUFBTSxNQUFOLENBQWEsTUFBYixDQUFvQixRQUFwQixDQUExQjtBQUNBLHlCQUFTLElBQVQsQ0FBYyxZQUFkLEdBQTZCLGVBQTdCOztBQUVBLG9CQUFJLFlBQVksTUFBTSxNQUFOLENBQWEsb0JBQWIsQ0FBa0MsZUFBbEMsRUFBbUQsU0FBUyxJQUFULENBQWMsUUFBakUsRUFBMkUsU0FBUyxJQUFULENBQWMsVUFBekYsQ0FBaEI7O0FBRUEsdUJBQU8sTUFBTSxNQUFOLENBQWEsb0JBQWIsQ0FBa0MsU0FBbEMsRUFBNkMsb0JBQW9CLFNBQVMsSUFBVCxDQUFjLFFBQWxDLEdBQTZDLFNBQVMsSUFBVCxDQUFjLFVBQXhHLENBQVA7O0FBRUE7QUFDRCxlQW5CRCxFQW1CRyxJQW5CSCxDQW1CUSxVQUFDLFNBQUQsRUFBZTtBQUNyQix5QkFBUyxJQUFULENBQWMsU0FBZCxHQUEwQixTQUExQjs7QUFFQSx1QkFBTyxNQUFNLE1BQU4sQ0FBYSxZQUFiLENBQTBCLFNBQTFCLEVBQXFDLGtCQUFrQixTQUFTLElBQVQsQ0FBYyxRQUFoQyxHQUEyQyxTQUFTLElBQVQsQ0FBYyxVQUE5RixDQUFQOztBQUVBO0FBQ0QsZUF6QkQsRUF5QkcsSUF6QkgsQ0F5QlEsVUFBQyxJQUFELEVBQVU7O0FBRWhCLHlCQUFTLElBQVQsQ0FBYyxtQkFBZCxHQUFvQyxJQUFJLFVBQUosQ0FBZSxLQUFLLENBQUwsQ0FBZixDQUFwQztBQUNBLHlCQUFTLElBQVQsQ0FBYyxxQkFBZCxHQUFzQyxJQUFJLFVBQUosQ0FBZSxLQUFLLENBQUwsQ0FBZixDQUF0QztBQUNBLHlCQUFTLElBQVQsQ0FBYyxnQkFBZCxHQUFpQyxJQUFJLFVBQUosQ0FBZSxLQUFLLENBQUwsQ0FBZixDQUFqQztBQUNBLHlCQUFTLElBQVQsQ0FBYyxrQkFBZCxHQUFtQyxJQUFJLFVBQUosQ0FBZSxLQUFLLENBQUwsQ0FBZixDQUFuQztBQUNBLHFCQUFLLE1BQU0sTUFBTixDQUFhLFVBQWIsRUFBTDtBQUNBLHNCQUFNLEVBQU4sR0FBVyxNQUFNLE1BQU4sQ0FBYSxNQUFiLENBQW9CLEVBQXBCLENBQVg7O0FBRUEsb0JBQUksbUJBQW1CO0FBQ3JCLHdCQUFNLFdBRGU7QUFFckIsc0JBQUksUUFBUSxJQUZTO0FBR3JCLHdCQUFNLFFBQVEsRUFITztBQUlyQix3QkFBTTtBQUNKLG9DQUFnQjtBQURaO0FBSmUsaUJBQXZCOztBQVNBO0FBQ0Esa0NBQWtCLE1BQU0sb0JBQU4sQ0FBMkIsZ0JBQTNCLEVBQTZDLE9BQU8sRUFBcEQsRUFBd0QsU0FBUyxXQUFULENBQXFCLFdBQTdFLENBQWxCO0FBQ0EsdUJBQU8sTUFBTSxNQUFOLENBQWEsUUFBYixDQUFzQixTQUFTLElBQVQsQ0FBYyxrQkFBcEMsRUFBd0QsZUFBeEQsQ0FBUDtBQUNELGVBOUNELEVBOENHLElBOUNILENBOENRLFVBQUMsSUFBRCxFQUFVO0FBQ2hCLHNCQUFNLElBQU4sR0FBYSxNQUFNLE1BQU4sQ0FBYSxNQUFiLENBQW9CLElBQXBCLENBQWI7O0FBRUE7QUFDQSx1QkFBTyxNQUFNLE1BQU4sQ0FBYSxVQUFiLENBQXdCLFNBQVMsSUFBVCxDQUFjLHFCQUF0QyxFQUE2RCxJQUE3RCxFQUFtRSxFQUFuRSxDQUFQO0FBQ0QsZUFuREQsRUFtREcsSUFuREgsQ0FtRFEsVUFBQyxhQUFELEVBQW1CO0FBQ3pCLHNCQUFNLGtCQUFOLEdBQTJCLE1BQU0sTUFBTixDQUFhLE1BQWIsQ0FBb0IsYUFBcEIsQ0FBM0I7O0FBRUEsdUJBQU8sTUFBTSxNQUFOLENBQWEsVUFBYixDQUF3QixTQUFTLFNBQVQsQ0FBbUIsU0FBM0MsRUFBc0QsU0FBUyxJQUFULENBQWMsWUFBcEUsQ0FBUDtBQUVELGVBeERELEVBd0RHLElBeERILENBd0RRLFVBQUMsY0FBRCxFQUFvQjs7QUFFMUIsc0JBQU0sb0JBQU4sR0FBNkIsTUFBTSxNQUFOLENBQWEsTUFBYixDQUFvQixjQUFwQixDQUE3Qjs7QUFFQSxvQkFBSSxtQkFBbUI7QUFDckIsd0JBQU0sV0FEZTtBQUVyQixzQkFBSSxRQUFRLElBRlM7QUFHckIsd0JBQU0sUUFBUSxFQUhPO0FBSXJCLHdCQUFNO0FBQ0osb0NBQWdCO0FBRFo7QUFKZSxpQkFBdkI7O0FBU0Esb0JBQUksZ0JBQWdCLE1BQU0sb0JBQU4sQ0FBMkIsZ0JBQTNCLEVBQTZDLFNBQVMsSUFBVCxDQUFjLFlBQTNELEVBQXlFLFNBQVMsV0FBVCxDQUFxQixXQUE5RixDQUFwQjs7QUFFQSx1QkFBTyxNQUFNLE1BQU4sQ0FBYSxPQUFiLENBQXFCLFNBQVMsV0FBVCxDQUFxQixVQUExQyxFQUFzRCx5QkFBZSxTQUFTLGdCQUF4QixJQUE0Qyx5QkFBZSxhQUFmLENBQWxHLENBQVA7QUFFRCxlQXpFRCxFQXlFRyxJQXpFSCxDQXlFUSxxQkFBYTs7QUFFbkIsc0JBQU0sU0FBTixHQUFrQixNQUFNLE1BQU4sQ0FBYSxNQUFiLENBQW9CLFNBQXBCLENBQWxCOztBQUVBLG9CQUFJLG1CQUFtQjtBQUNyQix3QkFBTSxXQURlO0FBRXJCLHNCQUFJLFFBQVEsSUFGUztBQUdyQix3QkFBTSxRQUFRLEVBSE87QUFJckIsd0JBQU07QUFDSixvQ0FBZ0IsbUJBRFo7QUFFSiwyQkFBTyxLQUFLLHlCQUFlLEtBQWYsQ0FBTDtBQUZIO0FBSmUsaUJBQXZCO0FBU0EseUJBQVMsZ0JBQVQsQ0FBMEIsaUJBQTFCLEdBQThDLE1BQU0sb0JBQU4sQ0FBMkIsZ0JBQTNCLEVBQTZDLE9BQU8sRUFBcEQsRUFBd0QsU0FBUyxXQUFULENBQXFCLFdBQTdFLENBQTlDOztBQUVBLHdCQUFRLEVBQUMsU0FBUyxnQkFBVixFQUE0QixVQUFVLFFBQXRDLEVBQVI7QUFFRCxlQTFGRCxFQTBGRztBQUFBLHVCQUFTLE9BQU8sS0FBUCxDQUFUO0FBQUEsZUExRkg7O0FBNEZGO0FBQ0EsaUJBQUssbUJBQUw7O0FBRUUsc0JBQVEsR0FBUixDQUFZLG1CQUFaO0FBQ0Esa0JBQUksZ0JBQWdCLEtBQUssS0FBTCxDQUFXLEtBQUssUUFBUSxJQUFSLENBQWEsS0FBbEIsQ0FBWCxDQUFwQjs7QUFFQSxvQkFBTSxpQkFBTixDQUF3QixRQUFRLElBQVIsQ0FBYSxRQUFiLENBQXNCLFNBQTlDLEVBQXlELFNBQXpELEVBQW9FLFFBQVEsSUFBUixDQUFhLFFBQWIsQ0FBc0IsR0FBMUYsRUFBK0YsSUFBL0YsQ0FBb0csVUFBQyxLQUFELEVBQVc7QUFDN0csb0JBQUksZUFBZSxNQUFNLE1BQU4sQ0FBYSxNQUFiLENBQW9CLGNBQWMsb0JBQWxDLENBQW5COztBQUVBO0FBQ0Esb0JBQUksbUJBQW9CLE9BQU8sTUFBTSxRQUFiLEtBQTBCLFFBQTNCLEdBQXVDLE1BQU0sUUFBN0MsR0FBd0QsTUFBTSxRQUFOLENBQWUsS0FBOUY7O0FBRUEsb0JBQUksa0JBQWtCLE1BQU0sTUFBTixDQUFhLE1BQWIsQ0FBb0IsZ0JBQXBCLENBQXRCO0FBQ0EseUJBQVMsU0FBVCxDQUFtQixTQUFuQixHQUErQixRQUFRLElBQVIsQ0FBYSxRQUFiLENBQXNCLFNBQXJEO0FBQ0EseUJBQVMsU0FBVCxDQUFtQixTQUFuQixHQUErQixlQUEvQjtBQUNBLHlCQUFTLFNBQVQsQ0FBbUIsTUFBbkIsR0FBK0IsTUFBTSxRQUFOLENBQWUsS0FBOUM7O0FBRUEsdUJBQU8sTUFBTSxNQUFOLENBQWEsVUFBYixDQUF3QixTQUFTLFdBQVQsQ0FBcUIsVUFBN0MsRUFBeUQsWUFBekQsQ0FBUDtBQUVELGVBYkQsRUFhRyxVQUFDLEtBQUQsRUFBVztBQUNaLHdCQUFRLEdBQVIsQ0FBWSxLQUFaO0FBQ0EsdUJBQU8seUNBQVA7O0FBRUE7QUFDRCxlQWxCRCxFQWtCRyxJQWxCSCxDQWtCUSxlQUFPOztBQUViLHlCQUFTLElBQVQsQ0FBYyxZQUFkLEdBQTZCLElBQUksVUFBSixDQUFlLEdBQWYsQ0FBN0I7O0FBRUEsb0JBQUksWUFBWSxNQUFNLE1BQU4sQ0FBYSxNQUFiLENBQW9CLGNBQWMsU0FBbEMsQ0FBaEI7O0FBRUEsb0JBQUksb0JBQW9CLE1BQU0sb0JBQU4sQ0FBMkIsT0FBM0IsRUFBb0MsU0FBUyxJQUFULENBQWMsWUFBbEQsQ0FBeEI7O0FBRUEsdUJBQU8sTUFBTSxNQUFOLENBQWEsU0FBYixDQUF1QixTQUFTLFNBQVQsQ0FBbUIsU0FBMUMsRUFBcUQseUJBQWUsU0FBUyxnQkFBeEIsSUFBNEMseUJBQWUsaUJBQWYsQ0FBakcsRUFBb0ksU0FBcEksQ0FBUDs7QUFFQTtBQUNELGVBN0JELEVBNkJHLElBN0JILENBNkJRLGdDQUF3Qjs7QUFFOUIsd0JBQVEsR0FBUixDQUFZLDhCQUFaLEVBQTRDLG9CQUE1QztBQUNBLG9CQUFJLFlBQVksTUFBTSxNQUFOLENBQWEsb0JBQWIsQ0FBa0MsU0FBUyxJQUFULENBQWMsWUFBaEQsRUFBOEQsU0FBUyxJQUFULENBQWMsUUFBNUUsRUFBc0YsU0FBUyxJQUFULENBQWMsVUFBcEcsQ0FBaEI7O0FBRUEsdUJBQU8sTUFBTSxNQUFOLENBQWEsb0JBQWIsQ0FBa0MsU0FBbEMsRUFBNkMsb0JBQW9CLFNBQVMsSUFBVCxDQUFjLFFBQWxDLEdBQTZDLFNBQVMsSUFBVCxDQUFjLFVBQXhHLENBQVA7O0FBRUE7QUFDRCxlQXJDRCxFQXFDRyxJQXJDSCxDQXFDUSxxQkFBYTtBQUNuQix5QkFBUyxJQUFULENBQWMsU0FBZCxHQUEwQixTQUExQjs7QUFFQSx1QkFBTyxNQUFNLE1BQU4sQ0FBYSxZQUFiLENBQTBCLFNBQTFCLEVBQXFDLGtCQUFrQixTQUFTLElBQVQsQ0FBYyxRQUFoQyxHQUEyQyxTQUFTLElBQVQsQ0FBYyxVQUE5RixDQUFQOztBQUVBO0FBQ0QsZUEzQ0QsRUEyQ0csSUEzQ0gsQ0EyQ1EsZ0JBQVE7QUFDZCx5QkFBUyxJQUFULENBQWMscUJBQWQsR0FBc0MsSUFBSSxVQUFKLENBQWUsS0FBSyxDQUFMLENBQWYsQ0FBdEM7QUFDQSx5QkFBUyxJQUFULENBQWMsbUJBQWQsR0FBb0MsSUFBSSxVQUFKLENBQWUsS0FBSyxDQUFMLENBQWYsQ0FBcEM7QUFDQSx5QkFBUyxJQUFULENBQWMsa0JBQWQsR0FBbUMsSUFBSSxVQUFKLENBQWUsS0FBSyxDQUFMLENBQWYsQ0FBbkM7QUFDQSx5QkFBUyxJQUFULENBQWMsZ0JBQWQsR0FBaUMsSUFBSSxVQUFKLENBQWUsS0FBSyxDQUFMLENBQWYsQ0FBakM7QUFDQSxxQkFBSyxNQUFNLE1BQU4sQ0FBYSxNQUFiLENBQW9CLGNBQWMsRUFBbEMsQ0FBTDtBQUNBLG9CQUFJLE9BQU8sTUFBTSxNQUFOLENBQWEsTUFBYixDQUFvQixjQUFjLGtCQUFsQyxDQUFYOztBQUVBLHVCQUFPLE1BQU0sTUFBTixDQUFhLFVBQWIsQ0FBd0IsU0FBUyxJQUFULENBQWMsbUJBQXRDLEVBQTJELElBQTNELEVBQWlFLEVBQWpFLENBQVA7QUFFRCxlQXJERCxFQXFERyxJQXJESCxDQXFEUSx5QkFBaUI7QUFDdkI7O0FBRUEseUJBQVMsZ0JBQVQsQ0FBMEIsaUJBQTFCLEdBQThDLE1BQU0sb0JBQU4sQ0FBMkIsT0FBM0IsRUFBb0MsZ0JBQWdCLEVBQXBELENBQTlDOztBQUVBLG9CQUFJLGVBQWUsTUFBTSxNQUFOLENBQWEsTUFBYixDQUFvQixjQUFjLElBQWxDLENBQW5COztBQUVBLGtDQUFrQixNQUFNLG9CQUFOLENBQTJCLE9BQTNCLEVBQW9DLGdCQUFnQixFQUFwRCxDQUFsQjs7QUFFQSx1QkFBTyxNQUFNLE1BQU4sQ0FBYSxVQUFiLENBQXdCLFNBQVMsSUFBVCxDQUFjLGdCQUF0QyxFQUF3RCxlQUF4RCxFQUF5RSxZQUF6RSxDQUFQO0FBRUQsZUFoRUQsRUFnRUcsSUFoRUgsQ0FnRVEsd0JBQWlCOztBQUV2QjtBQUNBLG9CQUFJLDBCQUEwQjtBQUM1Qix3QkFBTSxXQURzQjtBQUU1QixzQkFBSSxRQUFRLElBRmdCO0FBRzVCLHdCQUFNLFFBQVEsRUFIYztBQUk1Qix3QkFBTTtBQUNKLG9DQUFnQjtBQURaO0FBSnNCLGlCQUE5QjtBQVFBLHFCQUFLLE1BQU0sTUFBTixDQUFhLFVBQWIsRUFBTDtBQUNBLHNCQUFNLEVBQU4sR0FBVyxNQUFNLE1BQU4sQ0FBYSxNQUFiLENBQW9CLEVBQXBCLENBQVg7O0FBRUEsa0NBQWtCLE1BQU0sb0JBQU4sQ0FBMkIsdUJBQTNCLEVBQW9ELFFBQVEsRUFBNUQsRUFBZ0UsU0FBUyxXQUFULENBQXFCLFdBQXJGLENBQWxCOztBQUVBLHVCQUFPLE1BQU0sTUFBTixDQUFhLFFBQWIsQ0FBc0IsU0FBUyxJQUFULENBQWMsa0JBQXBDLEVBQXdELHVCQUF4RCxDQUFQO0FBQ0QsZUFqRkQsRUFpRkcsSUFqRkgsQ0FpRlEsZ0JBQVE7O0FBRWQsc0JBQU0sSUFBTixHQUFhLE1BQU0sTUFBTixDQUFhLE1BQWIsQ0FBb0IsSUFBcEIsQ0FBYjtBQUNBLHVCQUFPLE1BQU0sTUFBTixDQUFhLFVBQWIsQ0FBd0IsU0FBUyxJQUFULENBQWMscUJBQXRDLEVBQTZELEtBQTdELEVBQW9FLEVBQXBFLENBQVA7QUFFRCxlQXRGRCxFQXNGRyxJQXRGSCxDQXNGUSwwQkFBa0I7QUFDeEIsc0JBQU0sS0FBTixHQUFjLE1BQU0sTUFBTixDQUFhLE1BQWIsQ0FBb0IsY0FBcEIsQ0FBZDtBQUNBLG9CQUFJLDBCQUEwQjtBQUM1Qix3QkFBTSxXQURzQjtBQUU1QixzQkFBSSxRQUFRLElBRmdCO0FBRzVCLHdCQUFNLFFBQVEsRUFIYztBQUk1Qix3QkFBTTtBQUNKLG9DQUFnQix5QkFEWjtBQUVKLDJCQUFPLEtBQUsseUJBQWUsS0FBZixDQUFMO0FBRkg7QUFKc0IsaUJBQTlCOztBQVVBLHlCQUFTLGdCQUFULENBQTBCLHVCQUExQixHQUFvRCxNQUFNLG9CQUFOLENBQTJCLHVCQUEzQixFQUFvRCxRQUFRLEVBQTVELEVBQWdFLFNBQVMsV0FBVCxDQUFxQixXQUFyRixDQUFwRDtBQUNBLHlCQUFTLGFBQVQsR0FBeUIsSUFBekI7QUFDQSx3QkFBUSxFQUFDLFNBQVMsdUJBQVYsRUFBbUMsVUFBVSxRQUE3QyxFQUFSO0FBQ0QsZUFyR0Q7O0FBdUdGO0FBQ0EsaUJBQUsseUJBQUw7O0FBRUUsc0JBQVEsR0FBUixDQUFZLHlCQUFaO0FBQ0EsdUJBQVMsYUFBVCxHQUF5QixJQUF6Qjs7QUFFQSxzQkFBUSxLQUFLLEtBQUwsQ0FBVyxLQUFLLFFBQVEsSUFBUixDQUFhLEtBQWxCLENBQVgsQ0FBUjs7QUFFQSxtQkFBSyxNQUFNLE1BQU4sQ0FBYSxNQUFiLENBQW9CLE1BQU0sRUFBMUIsQ0FBTDtBQUNBLGtCQUFJLE9BQU8sTUFBTSxNQUFOLENBQWEsTUFBYixDQUFvQixNQUFNLEtBQTFCLENBQVg7QUFDQSxxQkFBTyxNQUFNLE1BQU4sQ0FBYSxNQUFiLENBQW9CLE1BQU0sSUFBMUIsQ0FBUDs7QUFFQSxvQkFBTSxNQUFOLENBQWEsVUFBYixDQUF3QixTQUFTLElBQVQsQ0FBYyxtQkFBdEMsRUFBMkQsSUFBM0QsRUFBaUUsRUFBakUsRUFBcUUsSUFBckUsQ0FBMEUseUJBQWlCO0FBQ3pGLHdCQUFRLEdBQVIsQ0FBWSxlQUFaLEVBQTZCLGFBQTdCO0FBQ0EseUJBQVMsZ0JBQVQsQ0FBMEIsdUJBQTFCLEdBQW9ELE1BQU0sb0JBQU4sQ0FBMkIsT0FBM0IsRUFBb0MsZ0JBQWdCLEVBQXBELENBQXBEOztBQUVBLG9CQUFJLGtCQUFrQixNQUFNLG9CQUFOLENBQTJCLE9BQTNCLEVBQW9DLE9BQU8sRUFBM0MsQ0FBdEI7QUFDQSxzQkFBTSxNQUFOLENBQWEsVUFBYixDQUF3QixTQUFTLElBQVQsQ0FBYyxnQkFBdEMsRUFBd0QsZUFBeEQsRUFBeUUsSUFBekUsRUFBK0UsSUFBL0UsQ0FBb0Ysa0JBQVU7QUFDNUYsMEJBQVEsR0FBUixDQUFZLGFBQVosRUFBMkIsTUFBM0I7O0FBRUE7QUFDQSxzQkFBSSxTQUFTLGNBQWIsRUFBNkI7QUFDM0Isd0JBQUksaUJBQWlCO0FBQ25CLDRCQUFNLFFBRGE7QUFFbkIsMEJBQUksUUFBUSxJQUZPO0FBR25CLDRCQUFNLFFBQVEsRUFISztBQUluQiw0QkFBTTtBQUNKLCtCQUFPLFNBQVMsY0FBVCxDQUF3QixJQUF4QixDQUE2QjtBQURoQztBQUphLHFCQUFyQjs7QUFTQSw0QkFBUSxFQUFDLFNBQVMsY0FBVixFQUEwQixVQUFVLFFBQXBDLEVBQVI7O0FBRUE7QUFDRCxtQkFiRCxNQWFPO0FBQ0wsMEJBQU0sdUJBQU4sQ0FBOEIsT0FBOUIsRUFBdUMsUUFBdkMsRUFBaUQsSUFBakQsQ0FBc0QsaUJBQVM7QUFDN0QsOEJBQVEsS0FBUjtBQUNELHFCQUZEO0FBR0Q7QUFDRixpQkF0QkQ7QUF1QkQsZUE1QkQ7O0FBOEJGO0FBQ0EsaUJBQUssb0JBQUw7O0FBRUUsc0JBQVEsR0FBUixDQUFZLG9CQUFaOztBQUVBLGtCQUFJLGlCQUFpQixLQUFLLEtBQUwsQ0FBVyxLQUFLLFFBQVEsSUFBUixDQUFhLEtBQWxCLENBQVgsQ0FBckI7QUFDQSxxQkFBTyxNQUFNLE1BQU4sQ0FBYSxNQUFiLENBQW9CLGVBQWUsSUFBbkMsQ0FBUDtBQUNBLG1CQUFLLE1BQU0sTUFBTixDQUFhLE1BQWIsQ0FBb0IsZUFBZSxFQUFuQyxDQUFMO0FBQ0Esa0JBQUksaUJBQWlCLE1BQU0sTUFBTixDQUFhLE1BQWIsQ0FBb0IsZUFBZSxLQUFuQyxDQUFyQjtBQUNBLGtCQUFJLG9CQUFKO0FBQ0Esa0JBQUksbUJBQUo7QUFDQSxrQkFBSSxzQkFBSjtBQUNBLGtCQUFJLCtCQUFKOztBQUVBLHNCQUFRLEdBQVIsQ0FBWSxxQ0FBWixFQUFtRCxTQUFTLElBQVQsQ0FBYyxtQkFBakUsRUFBc0YsY0FBdEYsRUFBc0csRUFBdEc7O0FBRUEsb0JBQU0sTUFBTixDQUFhLFVBQWIsQ0FBd0IsU0FBUyxJQUFULENBQWMsbUJBQXRDLEVBQTJELGNBQTNELEVBQTJFLEVBQTNFLEVBQStFLElBQS9FLENBQW9GLDBCQUFrQjs7QUFFcEcsOEJBQWMsS0FBSyxLQUFMLENBQVcsY0FBWCxDQUFkO0FBQ0EsNkJBQWEsTUFBTSxNQUFOLENBQWEsTUFBYixDQUFvQixZQUFZLEtBQWhDLENBQWI7QUFDQSxnQ0FBZ0IsWUFBWSxhQUE1Qjs7QUFFQSxvQkFBSSxnQkFBZ0IsTUFBTSxvQkFBTixDQUEyQixPQUEzQixFQUFvQyxpQkFBaUIsRUFBckQsQ0FBcEI7O0FBRUEsdUJBQU8sTUFBTSxNQUFOLENBQWEsVUFBYixDQUF3QixTQUFTLElBQVQsQ0FBYyxnQkFBdEMsRUFBd0QsYUFBeEQsRUFBdUUsSUFBdkUsQ0FBUDtBQUVELGVBVkQsRUFVRyxJQVZILENBVVEsc0JBQWM7O0FBRXBCOztBQUVBLHNCQUFNLHFCQUFOLENBQTRCLGFBQTVCLElBQThDLEVBQUMsWUFBWSxVQUFiLEVBQXlCLGFBQWEsSUFBdEMsRUFBOUM7O0FBRUEscUJBQUssTUFBTSxNQUFOLENBQWEsVUFBYixFQUFMO0FBQ0Esc0JBQU0sRUFBTixHQUFXLE1BQU0sTUFBTixDQUFhLE1BQWIsQ0FBb0IsRUFBcEIsQ0FBWDs7QUFFQSx1QkFBTyxNQUFNLE1BQU4sQ0FBYSxVQUFiLENBQXdCLFNBQVMsSUFBVCxDQUFjLHFCQUF0QyxFQUE2RCxNQUE3RCxFQUFxRSxFQUFyRSxDQUFQO0FBQ0QsZUFwQkQsRUFvQkcsSUFwQkgsQ0FvQlEsMEJBQWtCOztBQUV4Qix5Q0FBeUI7QUFDdkIsd0JBQU0sV0FEaUI7QUFFdkIsc0JBQUksUUFBUSxJQUZXO0FBR3ZCLHdCQUFNLFFBQVEsRUFIUztBQUl2Qix3QkFBTTtBQUNKLG9DQUFnQjtBQURaO0FBSmlCLGlCQUF6Qjs7QUFTQSxzQkFBTSxLQUFOLEdBQWMsTUFBTSxNQUFOLENBQWEsTUFBYixDQUFvQixjQUFwQixDQUFkO0FBQ0Esb0JBQUksZ0JBQWdCLE1BQU0sb0JBQU4sQ0FBMkIsc0JBQTNCLEVBQW1ELFNBQVMsRUFBNUQsRUFBZ0UsU0FBUyxXQUFULENBQXFCLFdBQXJGLENBQXBCOztBQUVBLHVCQUFPLE1BQU0sTUFBTixDQUFhLFFBQWIsQ0FBc0IsU0FBUyxJQUFULENBQWMsa0JBQXBDLEVBQXdELGFBQXhELENBQVA7QUFDRCxlQW5DRCxFQW1DRyxJQW5DSCxDQW1DUSx5QkFBaUI7QUFDdkIsb0JBQUksYUFBYSxLQUFLLHlCQUFlLEVBQUMsT0FBTyxNQUFNLEtBQWQsRUFBcUIsTUFBTSxNQUFNLE1BQU4sQ0FBYSxNQUFiLENBQW9CLGFBQXBCLENBQTNCLEVBQStELElBQUksTUFBTSxFQUF6RSxFQUFmLENBQUwsQ0FBakI7O0FBRUEsdUNBQXVCLElBQXZCLENBQTRCLEtBQTVCLEdBQW9DLFVBQXBDO0FBQ0Esd0JBQVEsRUFBQyxTQUFTLHNCQUFWLEVBQWtDLFVBQVUsUUFBNUMsRUFBUjtBQUNELGVBeENEOztBQTBDRjtBQUNBLGlCQUFLLHFCQUFMOztBQUVFLHNCQUFRLEdBQVIsQ0FBWSxxQkFBWjs7QUFFQSxrQkFBSSx5QkFBeUIsS0FBSyxLQUFMLENBQVcsS0FBSyxRQUFRLElBQVIsQ0FBYSxLQUFsQixDQUFYLENBQTdCO0FBQ0Esa0JBQUksZUFBZSxNQUFNLE1BQU4sQ0FBYSxNQUFiLENBQW9CLHVCQUF1QixJQUEzQyxDQUFuQjtBQUNBLG1CQUFLLE1BQU0sTUFBTixDQUFhLE1BQWIsQ0FBb0IsdUJBQXVCLEVBQTNDLENBQUw7QUFDQSxrQkFBSSx5QkFBeUIsTUFBTSxNQUFOLENBQWEsTUFBYixDQUFvQix1QkFBdUIsS0FBM0MsQ0FBN0I7O0FBRUEsb0JBQU0sTUFBTixDQUFhLFVBQWIsQ0FBd0IsU0FBUyxJQUFULENBQWMsbUJBQXRDLEVBQTJELHNCQUEzRCxFQUFtRixFQUFuRixFQUF1RixJQUF2RixDQUE0RiwwQkFBa0I7O0FBRTVHLG9CQUFJLGtCQUFrQixNQUFNLG9CQUFOLENBQTJCLE9BQTNCLEVBQW9DLGlCQUFpQixFQUFyRCxDQUF0QjtBQUNBLHVCQUFPLE1BQU0sTUFBTixDQUFhLFVBQWIsQ0FBd0IsU0FBUyxJQUFULENBQWMsZ0JBQXRDLEVBQXdELGVBQXhELEVBQXlFLFlBQXpFLENBQVA7QUFDRCxlQUpELEVBSUcsSUFKSCxDQUlRLHNCQUFjO0FBQ3BCOztBQUVBLG9CQUFJLFdBQVcsU0FBUyxRQUF4Qjs7QUFFQSxvQkFBSSxRQUFKLEVBQWM7QUFDWiwyQkFBUyxjQUFUO0FBQ0Q7QUFDRCx3QkFBUSxjQUFSO0FBQ0QsZUFiRDs7QUFlRjtBQUNBO0FBQ0UscUJBQU8sT0FBUDtBQTFYSjtBQVAwQztBQW1ZM0MsT0FuWU0sQ0FBUDtBQW9ZRDs7OzRDQUV1QixPLEVBQVMsUSxFQUFVO0FBQ3pDLFVBQUksUUFBUSxJQUFaO0FBQ0EsVUFBSSxtQkFBbUIsTUFBTSxxQkFBTixDQUE0QixTQUFTLGFBQXJDLENBQXZCO0FBQ0EsVUFBSSw4QkFBSjtBQUNBLFVBQUksdUJBQUo7QUFDQSxVQUFJLG1CQUFKO0FBQ0EsVUFBSSxXQUFKO0FBQ0EsVUFBSSxRQUFRLEVBQVo7O0FBRUEsYUFBTyxzQkFBWSxVQUFTLE9BQVQsRUFBa0IsTUFBbEIsRUFBMEI7O0FBRTNDO0FBQ0EsWUFBSSxDQUFDLGdCQUFMLEVBQXVCO0FBQ3JCLHVCQUFhLE1BQU0sTUFBTixDQUFhLGNBQWIsRUFBYjtBQUNBLGdCQUFNLHFCQUFOLENBQTRCLFNBQVMsYUFBckMsSUFBc0QsRUFBQyxZQUFZLFVBQWIsRUFBeUIsYUFBYSxJQUF0QyxFQUF0RDtBQUNELFNBSEQsTUFHTztBQUNMLHVCQUFhLGlCQUFpQixVQUE5QjtBQUNEOztBQUVELHlCQUFpQix5QkFBZSxFQUFDLE9BQU8sTUFBTSxNQUFOLENBQWEsTUFBYixDQUFvQixVQUFwQixDQUFSLEVBQXlDLGVBQWUsU0FBUyxhQUFqRSxFQUFmLENBQWpCOztBQUVBLGFBQUssTUFBTSxNQUFOLENBQWEsVUFBYixFQUFMO0FBQ0EsY0FBTSxFQUFOLEdBQVcsTUFBTSxNQUFOLENBQWEsTUFBYixDQUFvQixFQUFwQixDQUFYO0FBQ0EsY0FBTSxNQUFOLENBQWEsVUFBYixDQUF3QixTQUFTLElBQVQsQ0FBYyxxQkFBdEMsRUFBNkQsY0FBN0QsRUFBNkUsRUFBN0UsRUFBaUYsSUFBakYsQ0FBc0YsMEJBQWtCOztBQUV0RyxrQ0FBd0I7QUFDdEIsa0JBQU0sV0FEZ0I7QUFFdEIsZ0JBQUksUUFBUSxJQUZVO0FBR3RCLGtCQUFNLFFBQVEsRUFIUTtBQUl0QixrQkFBTTtBQUNKLDhCQUFnQixvQkFEWjtBQUVKLHFCQUFPLE1BQU0sTUFBTixDQUFhLE1BQWIsQ0FBb0IsY0FBcEI7QUFGSDtBQUpnQixXQUF4Qjs7QUFVQSxjQUFJLGtCQUFrQixNQUFNLG9CQUFOLENBQTJCLHFCQUEzQixFQUFrRCxpQkFBaUIsRUFBbkUsRUFBdUUsU0FBUyxXQUFULENBQXFCLFdBQTVGLENBQXRCOztBQUVBLGlCQUFPLE1BQU0sTUFBTixDQUFhLFFBQWIsQ0FBc0IsU0FBUyxJQUFULENBQWMsa0JBQXBDLEVBQXdELGVBQXhELENBQVA7QUFDRCxTQWZELEVBZUcsSUFmSCxDQWVRLHlCQUFpQjs7QUFFdkIsY0FBSSxnQkFBZ0IsS0FBSyx5QkFBZSxFQUFDLE9BQU8sc0JBQXNCLElBQXRCLENBQTJCLEtBQW5DLEVBQTBDLE1BQU0sTUFBTSxNQUFOLENBQWEsTUFBYixDQUFvQixhQUFwQixDQUFoRCxFQUFvRixJQUFJLE1BQU0sRUFBOUYsRUFBZixDQUFMLENBQXBCOztBQUVBLGdDQUFzQixJQUF0QixDQUEyQixLQUEzQixHQUFtQyxhQUFuQztBQUNBLGtCQUFRLEVBQUMsU0FBUyxxQkFBVixFQUFpQyxVQUFVLFFBQTNDLEVBQVI7QUFDRCxTQXJCRDtBQXNCRCxPQXBDTSxDQUFQO0FBcUNEOztBQUVEOzs7Ozs7Ozs4Q0FLMEIsYSxFQUFlO0FBQ3ZDLFVBQUksUUFBUSxJQUFaOztBQUVBLGFBQU8sc0JBQVksVUFBUyxPQUFULEVBQWtCLE1BQWxCLEVBQTBCOztBQUUzQzs7QUFFQSxZQUFJLGFBQWEsY0FBYyxLQUFkLENBQW9CLEdBQXBCLENBQWpCO0FBQ0EsWUFBSSxXQUFXLFdBQVcsQ0FBWCxJQUFnQixJQUFoQixHQUF1QixXQUFXLENBQVgsQ0FBdkIsR0FBdUMsR0FBdkMsR0FBNkMsV0FBVyxDQUFYLENBQTVEO0FBQ0EsWUFBSSxXQUFXLE1BQVgsR0FBb0IsQ0FBeEIsRUFBMkI7QUFDekIscUJBQVcsV0FBVyxDQUFYLElBQWdCLElBQWhCLEdBQXVCLFdBQVcsQ0FBWCxDQUF2QixHQUF1QyxHQUF2QyxHQUE2QyxXQUFXLENBQVgsQ0FBN0MsR0FBNkQsR0FBN0QsR0FBbUUsV0FBVyxDQUFYLENBQTlFO0FBQ0Q7O0FBRUQ7QUFDQSxZQUFJLGNBQWMsTUFBTSxRQUFOLENBQWUsd0JBQWYsQ0FBd0MsUUFBeEMsQ0FBbEI7O0FBRUEsWUFBSSxXQUFKLEVBQWlCO0FBQ2Ysa0JBQVEsV0FBUjtBQUNELFNBRkQsTUFFTztBQUNMO0FBQ0EsY0FBSSxvQkFBb0IsTUFBTSxtQkFBTixDQUEwQixRQUExQixDQUF4Qjs7QUFFQSxjQUFJLGlCQUFKLEVBQXVCO0FBQ3JCLG9CQUFRLGlCQUFSO0FBQ0QsV0FGRCxNQUVPO0FBQ0w7QUFDQSxnQkFBSSxvQkFBb0IsTUFBTSxRQUFOLENBQWUsOEJBQWYsQ0FBOEMsYUFBOUMsQ0FBeEI7O0FBRUEsZ0JBQUksaUJBQUosRUFBdUI7QUFDckIsc0JBQVEsaUJBQVI7QUFDRCxhQUZELE1BRU87O0FBRUw7QUFDQTtBQUNBLG9CQUFNLFFBQU4sQ0FBZSx3QkFBZixDQUF3QyxRQUF4QyxFQUFrRCxXQUFXLENBQVgsQ0FBbEQsRUFBaUUsSUFBakUsQ0FBc0Usc0JBQWM7QUFDbEYsc0JBQU0sbUJBQU4sQ0FBMEIsUUFBMUIsSUFBc0MsV0FBVyxRQUFqRDtBQUNBLHdCQUFRLFdBQVcsUUFBbkI7QUFDRCxlQUhELEVBR0csZUFBTztBQUNSLHVCQUFPLEdBQVA7QUFDRCxlQUxEO0FBTUQ7QUFDRjtBQUNGO0FBQ0YsT0F4Q00sQ0FBUDtBQXlDRDs7QUFFRDs7Ozs7Ozs7Ozt5Q0FPcUIsTyxFQUFTLGMsRUFBZ0IsUSxFQUFVOztBQUV0RCxhQUFPO0FBQ0wsY0FBTSxRQUFRLElBRFQ7QUFFTCxjQUFNLFFBQVEsSUFGVDtBQUdMLFlBQU0sUUFBUSxFQUhUO0FBSUwsY0FBTTtBQUNKLG9CQUFVLFlBQVksUUFBUSxJQUFSLENBQWEsUUFEL0I7QUFFSixpQkFBTyxrQkFBa0IsUUFBUSxJQUFSLENBQWEsS0FGbEM7QUFHSiwwQkFBZ0IsUUFBUSxJQUFSLENBQWE7QUFIekI7QUFKRCxPQUFQO0FBVUQ7O0FBRUQ7Ozs7Ozs7Ozs7bUNBT2UsTyxFQUFTLE8sRUFBUyxRLEVBQVU7QUFDekMsVUFBSSxRQUFRLElBQVo7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBSSxPQUFRLFFBQUQsR0FBYSxRQUFRLEVBQXJCLEdBQTBCLFFBQVEsSUFBN0M7QUFDQSxVQUFJLEtBQU0sUUFBRCxHQUFhLFFBQVEsSUFBckIsR0FBNEIsUUFBUSxFQUE3Qzs7QUFFQSxVQUFJLFdBQVcsTUFBTSxXQUFOLENBQWtCLE9BQWxCLENBQWY7O0FBRUEsVUFBSSxnQkFDSjtBQUNFLHFCQUNBO0FBQ0UsbUJBQVMsSUFEWDtBQUVFLGtCQUFRLFNBQVMsV0FBVCxDQUFxQixXQUFyQixDQUFpQyxRQUYzQztBQUdFLHNCQUFZLFNBQVMsT0FBVCxDQUFpQixPQUgvQjtBQUlFLHFCQUFXLFNBQVMsT0FBVCxDQUFpQixNQUo5QjtBQUtFLHFCQUFXLFNBQVMsU0FMdEI7QUFNRSx1QkFBYSxTQUFTO0FBTnhCLFNBRkY7QUFVRSxtQkFDQTtBQUNFLG1CQUFTLEVBRFg7QUFFRSxrQkFBUSxTQUZWO0FBR0UscUJBQVcsU0FIYjtBQUlFLHFCQUFXO0FBSmIsU0FYRjtBQWlCRSxjQUNBO0FBQ0UsK0JBQXFCLFNBRHZCO0FBRUUsaUNBQXVCLFNBRnpCO0FBR0UsNEJBQWtCLFNBSHBCO0FBSUUsOEJBQW9CLFNBSnRCO0FBS0Usb0JBQVUsU0FMWjtBQU1FLHNCQUFZLFNBTmQ7QUFPRSx3QkFBYyxTQVBoQjtBQVFFLHFCQUFXO0FBUmIsU0FsQkY7QUE0QkUsMEJBQWtCO0FBQ2hCLHVCQUFhLFNBREc7QUFFaEIseUJBQWUsU0FGQztBQUdoQiw2QkFBbUIsU0FISDtBQUloQixtQ0FBeUI7QUFKVCxTQTVCcEI7QUFrQ0Usd0JBQWlCLFFBQVEsSUFBUixDQUFhLE1BQWQsR0FBd0IsU0FBeEIsR0FBb0MsT0FsQ3REO0FBbUNFLGtCQUFVLFFBQVEsUUFuQ3BCO0FBb0NFLHVCQUFlLEtBcENqQjtBQXFDRSx1QkFBZSxRQUFRO0FBckN6QixPQURBOztBQXlDQSxhQUFPLGFBQVA7QUFDRDs7O3dCQWg4Q2dCO0FBQ2YsVUFBSSxRQUFRLElBQVo7QUFDQSxhQUFPLE1BQU0sV0FBYjtBQUNEOztBQUVEOzs7OztzQkFJZSxVLEVBQVk7QUFDekIsVUFBSSxRQUFRLElBQVo7QUFDQSxZQUFNLFdBQU4sR0FBb0IsVUFBcEI7QUFFRDs7QUFFRDs7Ozs7Ozt3QkFJZTtBQUNiLFVBQUksUUFBUSxJQUFaO0FBQ0EsYUFBTyxNQUFNLFNBQWI7QUFDRDs7QUFFRDs7Ozs7c0JBSWEsUSxFQUFVO0FBQ3JCLFVBQUksUUFBUSxJQUFaO0FBQ0EsWUFBTSxTQUFOLEdBQWtCLFFBQWxCO0FBQ0Q7Ozs7O2tCQW82Q1ksYzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDMWhEVCxjO0FBRUosMEJBQVksT0FBWixFQUFxQjtBQUFBOztBQUNuQixTQUFLLE9BQUwsR0FBZSxPQUFmO0FBQ0Q7Ozs7b0NBRWUsTyxFQUFTLGlCLEVBQW1CO0FBQzFDLFVBQUksUUFBUSxJQUFaO0FBQ0EsYUFBTyxzQkFBWSxVQUFDLE9BQUQsRUFBVSxNQUFWLEVBQXFCOztBQUV0QyxZQUFJLFdBQVcsTUFBTSxPQUFOLENBQWMsV0FBZCxDQUEwQixPQUExQixFQUFtQyxpQkFBbkMsQ0FBZjs7QUFFQSxZQUFJLGFBQWEsU0FBakIsRUFBNEI7QUFDMUIsY0FBSSxTQUFTLHFCQUFULEtBQW1DLFNBQXZDLEVBQWtEO0FBQ2hELHFCQUFTLHFCQUFULENBQStCLGNBQS9CLENBQThDLE1BQU0sT0FBcEQsRUFBNkQsT0FBN0QsRUFBc0UsSUFBdEUsQ0FBMkUsb0JBQVk7QUFDckYsc0JBQVEsUUFBUjtBQUNELGFBRkQsRUFFRyxVQUFDLEtBQUQsRUFBVztBQUNaLHFCQUFPLEtBQVA7QUFDRCxhQUpEO0FBS0QsV0FORCxNQU1PO0FBQ0wsZ0JBQUksU0FBUyxVQUFULEtBQXdCLFNBQTVCLEVBQXVDO0FBQ3JDLHVCQUFTLFVBQVQsQ0FBb0IsY0FBcEIsQ0FBbUMsTUFBTSxPQUF6QyxFQUFrRCxPQUFsRCxFQUEyRCxJQUEzRCxDQUFnRSxvQkFBWTtBQUMxRSx3QkFBUSxRQUFSO0FBQ0QsZUFGRCxFQUVHLFVBQUMsS0FBRCxFQUFXO0FBQ1osdUJBQU8sS0FBUDtBQUNELGVBSkQ7QUFLRCxhQU5ELE1BTU87QUFDTCxzQkFBUSxDQUFDLE9BQUQsQ0FBUjtBQUNEO0FBQ0Y7QUFDRixTQWxCRCxNQWtCTztBQUNMLGtCQUFRLENBQUMsT0FBRCxDQUFSO0FBQ0Q7QUFDRixPQXpCTSxDQUFQO0FBMEJEOzs7Z0NBRVcsTyxFQUFTLEssRUFBTztBQUMxQixVQUFJLFFBQVEsSUFBWjtBQUNBLFVBQUksQ0FBQyxNQUFNLE9BQU4sQ0FBYyxlQUFuQixFQUFvQyxNQUFNLElBQUksS0FBSixDQUFVLGdFQUFWLENBQU47O0FBRXBDLGFBQU8sc0JBQVksVUFBQyxPQUFELEVBQVUsTUFBVixFQUFxQjtBQUN0QyxZQUFJLE1BQU0sT0FBTixDQUFjLGVBQWQsQ0FBOEIsYUFBOUIsQ0FBNEMsQ0FBNUMsRUFBK0MsVUFBL0MsS0FBOEQsUUFBUSxFQUExRSxFQUE4RTtBQUM1RSxjQUFJLFVBQVcsUUFBUSxFQUFULENBQWEsS0FBYixDQUFtQixLQUFuQixDQUFkO0FBQ0EsY0FBSSxRQUFRLENBQVIsTUFBZSxTQUFuQixFQUE4QjtBQUM1QixrQkFBTSxPQUFOLENBQWMsZUFBZCxDQUE4QixzQkFBOUIsQ0FBcUQsS0FBckQsRUFBNEQsSUFBNUQsQ0FBaUUsa0JBQVU7QUFDekUsc0JBQVEsRUFBUixHQUFhLE9BQU8sVUFBcEI7QUFDQSxzQkFBUSxJQUFSLENBQWEsR0FBYixHQUFtQixTQUFuQjtBQUNBLHNCQUFRLE9BQVI7QUFDQSxvQkFBTSxPQUFOLENBQWMsZUFBZCxDQUE4QixXQUE5QixDQUEwQyxXQUExQyxDQUFzRCxPQUF0RDtBQUNELGFBTEQsRUFLRyxVQUFDLEtBQUQsRUFBVztBQUNaLHFCQUFPLEtBQVA7QUFDRCxhQVBEO0FBUUQsV0FURCxNQVNPO0FBQ0wsb0JBQVEsT0FBUjtBQUNEO0FBQ0YsU0FkRCxNQWNPO0FBQ0wsa0JBQVEsT0FBUjtBQUNEO0FBQ0YsT0FsQk0sQ0FBUDtBQW1CRDs7O3FDQUVnQixPLEVBQVMsVSxFQUFZO0FBQ3BDLFVBQUksUUFBUSxJQUFaO0FBQ0EsVUFBSSxDQUFDLE1BQU0sT0FBTixDQUFjLGVBQW5CLEVBQW9DLE1BQU0sSUFBSSxLQUFKLENBQVUsZ0VBQVYsQ0FBTjs7QUFFcEMsYUFBTyxzQkFBWSxVQUFDLE9BQUQsRUFBYTtBQUM5QixZQUFJLE1BQU0sT0FBTixDQUFjLGVBQWQsQ0FBOEIsYUFBOUIsQ0FBNEMsQ0FBNUMsRUFBK0MsVUFBL0MsS0FBOEQsUUFBUSxFQUExRSxFQUE4RTtBQUM1RSxjQUFJLFVBQVcsUUFBUSxFQUFULENBQWEsS0FBYixDQUFtQixLQUFuQixDQUFkO0FBQ0EsY0FBSSxRQUFRLENBQVIsTUFBZSxTQUFuQixFQUE4QjtBQUM1QixvQkFBUSxFQUFSLEdBQWEsVUFBYjtBQUNBLG9CQUFRLElBQVIsQ0FBYSxHQUFiLEdBQW1CLFNBQW5CO0FBQ0Esb0JBQVEsT0FBUjtBQUNBLGtCQUFNLE9BQU4sQ0FBYyxlQUFkLENBQThCLFdBQTlCLENBQTBDLFdBQTFDLENBQXNELE9BQXREO0FBQ0QsV0FMRCxNQUtPO0FBQ0wsb0JBQVEsT0FBUjtBQUNEO0FBQ0YsU0FWRCxNQVVPO0FBQ0wsa0JBQVEsT0FBUjtBQUNEO0FBQ0YsT0FkTSxDQUFQO0FBZUQ7Ozt5Q0FFb0IsTyxFQUFTLEksRUFBTTtBQUNsQyxVQUFJLFFBQVEsSUFBWjtBQUNBLGFBQU8sc0JBQVksVUFBQyxPQUFELEVBQWE7QUFDOUIsWUFBSSxtQkFBbUI7QUFDckIsZ0JBQU0sUUFBUSxFQURPO0FBRXJCLGNBQUksUUFBUSxJQUZTO0FBR3JCLGdCQUFNO0FBQ0osbUJBQU87QUFESCxXQUhlO0FBTXJCLGdCQUFNLFFBQVE7QUFOTyxTQUF2QjtBQVFBLGdCQUFRLE9BQVI7QUFDQSxjQUFNLE9BQU4sQ0FBYyxlQUFkLENBQThCLFdBQTlCLENBQTBDLFdBQTFDLENBQXNELGdCQUF0RDtBQUNELE9BWE0sQ0FBUDtBQVlEOzs7OztrQkFJWSxjOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQ3BHVCxTOzs7Ozs7O3dCQUVBLE0sRUFBUTtBQUNWLGFBQU8sT0FBTyxDQUFQLEtBQWEsT0FBTyxDQUFQLENBQXBCO0FBQ0Q7Ozs0QkFFTyxNLEVBQVE7QUFDZCxVQUFJLFFBQVEsU0FBUyxPQUFPLENBQVAsRUFBVSxDQUFWLENBQVQsQ0FBWjtBQUNBLFVBQUksTUFBTSxTQUFTLE9BQU8sQ0FBUCxFQUFVLENBQVYsQ0FBVCxDQUFWO0FBQ0EsVUFBSSxNQUFNLE9BQU8sQ0FBUCxDQUFWOztBQUVBLFVBQUksTUFBTSxLQUFWLEVBQWlCO0FBQ2YsY0FBTyxNQUFNLEtBQVAsR0FBZ0IsT0FBTyxJQUF2QixHQUE4QixHQUFwQztBQUNBLGVBQU8sSUFBUDtBQUNEOztBQUVELGFBQVEsTUFBTSxLQUFOLElBQWUsTUFBTSxHQUE3QjtBQUNEOzs7MkJBRU0sTSxFQUFRO0FBQ2IsYUFBTyxPQUFPLE9BQU8sQ0FBUCxDQUFQLE1BQXNCLEdBQXRCLElBQTZCLE9BQU8sT0FBTyxDQUFQLENBQVAsTUFBc0IsT0FBTyxPQUFPLENBQVAsQ0FBUCxDQUExRDtBQUNEOzs7Z0NBRVcsTSxFQUFRO0FBQ2xCLGFBQU8sT0FBTyxDQUFQLElBQVksT0FBTyxDQUFQLENBQW5CO0FBQ0Q7Ozt3QkFFRSxNLEVBQVE7QUFDVCxhQUFPLE9BQU8sQ0FBUCxFQUFVLE9BQVYsQ0FBa0IsT0FBTyxDQUFQLENBQWxCLElBQStCLENBQUMsQ0FBdkM7QUFDRDs7OzZCQUVRLE0sRUFBUTtBQUNmLGFBQU8sT0FBTyxDQUFQLElBQVksT0FBTyxDQUFQLENBQW5CO0FBQ0Q7Ozt3QkFFRyxNLEVBQVE7QUFDVixhQUFPLENBQUMsT0FBTyxDQUFQLENBQVI7QUFDRDs7O3VCQUVFLE0sRUFBUTtBQUNULGFBQU8sT0FBTyxDQUFQLEtBQWEsT0FBTyxDQUFQLENBQXBCO0FBQ0Q7Ozs7O2tCQUlZLFM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdDZjs7Ozs7O0FBRUE7Ozs7Ozs7SUFPTSxHO0FBRUosZUFBWSxPQUFaLEVBQXFCO0FBQUE7O0FBQ25CLFNBQUssT0FBTCxHQUFlLE9BQWY7QUFDQSxTQUFLLFNBQUwsR0FBaUIseUJBQWpCO0FBQ0Q7Ozs7cUNBRWdCLE8sRUFBUyxpQixFQUFtQjtBQUMzQyxVQUFJLFdBQVcsS0FBSyxPQUFMLENBQWEsV0FBYixDQUF5QixPQUF6QixFQUFrQyxpQkFBbEMsQ0FBZjtBQUNBLFVBQUksU0FBUyxnQkFBYjs7QUFFQSxVQUFJLGFBQWEsU0FBakIsRUFBNEI7QUFDMUIsaUJBQVMsS0FBSyxjQUFMLENBQW9CLE9BQXBCLEVBQTZCLFNBQVMscUJBQXRDLEVBQTZELGlCQUE3RCxDQUFUO0FBQ0EsWUFBSSxVQUFVLFdBQVcsZ0JBQXpCLEVBQTJDO0FBQ3pDLGNBQUksYUFBYSxLQUFLLGNBQUwsQ0FBb0IsT0FBcEIsRUFBNkIsU0FBUyxVQUF0QyxFQUFrRCxpQkFBbEQsQ0FBakI7QUFDQSxjQUFJLGVBQWUsZ0JBQW5CLEVBQXFDO0FBQ25DLHFCQUFTLFVBQVQ7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsYUFBTyxNQUFQO0FBQ0Q7OzttQ0FFYyxPLEVBQVMsTSxFQUFRLFUsRUFBWTtBQUMxQyxVQUFJLFNBQVMsZ0JBQWI7QUFDQSxVQUFJLE1BQUosRUFBWTtBQUNWLGlCQUFTLE9BQU8sYUFBUCxDQUFxQixLQUFLLE9BQTFCLEVBQW1DLE9BQW5DLEVBQTRDLFVBQTVDLENBQVQ7QUFDRDs7QUFFRCxhQUFPLE1BQVA7QUFDRDs7Ozs7a0JBSVksRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVDZjs7OztBQUNBOzs7O0FBQ0E7Ozs7OztJQUVNLEc7O0FBRUo7Ozs7QUFJQSxlQUFZLE9BQVosRUFBcUI7QUFBQTs7QUFDbkIsUUFBSSxRQUFRLElBQVo7O0FBRUEsVUFBTSxHQUFOLEdBQVksa0JBQVEsT0FBUixDQUFaO0FBQ0EsVUFBTSxjQUFOLEdBQXVCLDZCQUFtQixPQUFuQixDQUF2QjtBQUNBLFVBQU0sT0FBTixHQUFnQixPQUFoQjtBQUNBLFlBQVEsR0FBUixHQUFjLEtBQWQ7O0FBRUE7QUFDQSxZQUFRLGtCQUFSO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7OzhCQU9VLE0sRUFBUSxHLEVBQUssTSxFQUFRLGtCLEVBQW9CO0FBQ2pELFVBQUksQ0FBQyxNQUFMLEVBQWEsTUFBTSxJQUFJLEtBQUosQ0FBVSx1QkFBVixDQUFOO0FBQ2IsVUFBSSxDQUFDLEdBQUwsRUFBVSxNQUFNLElBQUksS0FBSixDQUFVLG9CQUFWLENBQU47O0FBRVYsVUFBSSxXQUFXLFNBQWYsRUFBMEI7QUFDeEIsaUJBQVMscUJBQVcsR0FBWCxFQUFnQixFQUFoQixFQUFvQixFQUFwQixFQUF3QixrQkFBeEIsQ0FBVDtBQUNELE9BRkQsTUFFTztBQUNMLFlBQUksRUFBRSxrQ0FBRixDQUFKLEVBQWlDO0FBQy9CLG1CQUFTLHFCQUFXLE9BQU8sR0FBbEIsRUFBdUIsT0FBTyxLQUE5QixFQUFxQyxPQUFPLE9BQTVDLEVBQXFELE9BQU8sa0JBQTVELENBQVQ7QUFDRDtBQUNGOztBQUVELGNBQVEsTUFBUjtBQUNFLGFBQUssa0JBQUw7QUFDRSxlQUFLLE9BQUwsQ0FBYSxZQUFiLENBQTBCLE1BQTFCLEVBQWtDLE1BQWxDLEVBQTBDLEdBQTFDO0FBQ0E7QUFDRixhQUFLLE1BQUw7QUFDRSxlQUFLLE9BQUwsQ0FBYSxZQUFiLENBQTBCLEdBQTFCLElBQWlDLE1BQWpDO0FBQ0EsZUFBSyxPQUFMLENBQWEsWUFBYixDQUEwQixNQUExQjtBQUNBO0FBQ0Y7QUFDRSxnQkFBTSxNQUFNLDRCQUE0QixNQUFsQyxDQUFOO0FBVEo7QUFXRDs7OzhCQUVTLE8sRUFBUztBQUFBOztBQUNqQixjQUFRLEdBQVIsQ0FBWSx1QkFBWjtBQUNBLGNBQVEsR0FBUixDQUFZLE9BQVo7QUFDQSxVQUFJLENBQUMsT0FBTCxFQUFjLE1BQU0sSUFBSSxLQUFKLENBQVUsd0JBQVYsQ0FBTjtBQUNkLFVBQUksQ0FBQyxRQUFRLElBQWIsRUFBbUIsTUFBTSxJQUFJLEtBQUosQ0FBVSw2QkFBVixDQUFOO0FBQ25CLFVBQUksQ0FBQyxRQUFRLEVBQWIsRUFBaUIsTUFBTSxJQUFJLEtBQUosQ0FBVSwyQkFBVixDQUFOO0FBQ2pCLFVBQUksQ0FBQyxRQUFRLElBQWIsRUFBbUIsTUFBTSxJQUFJLEtBQUosQ0FBVSw2QkFBVixDQUFOO0FBQ25CLGNBQVEsSUFBUixHQUFlLFFBQVEsSUFBUixJQUFnQixFQUEvQjs7QUFFQSxhQUFPLHNCQUFZLFVBQUMsT0FBRCxFQUFVLE1BQVYsRUFBcUI7O0FBRXRDLGdCQUFRLElBQVIsR0FBZSxRQUFRLElBQVIsSUFBZ0IsRUFBL0I7QUFDQSxZQUFJLGNBQUo7QUFDQSxZQUFJLGVBQUo7QUFDQSxZQUFJLE1BQU0sV0FBTixDQUFrQixPQUFsQixDQUFKLEVBQWdDO0FBQUE7QUFDOUIsZ0JBQUksYUFBYSxNQUFNLGtCQUFOLENBQXlCLE9BQXpCLENBQWpCO0FBQ0Esa0JBQU0sT0FBTixDQUFjLG9CQUFkLENBQW1DLE9BQW5DLEVBQTRDLFVBQTVDLEVBQXdELElBQXhELENBQTZELG1CQUFXO0FBQ3RFLHVCQUFTLE1BQU0sR0FBTixDQUFVLGdCQUFWLENBQTJCLE9BQTNCLEVBQW9DLFVBQXBDLENBQVQ7QUFDQSxrQkFBSSxXQUFXLGdCQUFmLEVBQWlDO0FBQy9CLHlCQUFTLE1BQU0sT0FBTixDQUFjLGdCQUF2QjtBQUNBLHdCQUFRLElBQVIsQ0FBYSxJQUFiLEdBQW9CLEtBQXBCO0FBQ0Q7QUFDRCxvQkFBTSxjQUFOLENBQXFCLGVBQXJCLENBQXFDLE9BQXJDLEVBQThDLFVBQTlDLEVBQTBELElBQTFELENBQStELG9CQUFZO0FBQ3pFLHFCQUFLLElBQUksQ0FBVCxJQUFjLFFBQWQsRUFBd0I7QUFDdEIsNEJBQVUsU0FBUyxDQUFULENBQVY7QUFDQSx3QkFBTSxPQUFOLENBQWMsZ0JBQWQsQ0FBK0IsT0FBL0IsRUFBd0MsVUFBeEMsRUFBb0QsTUFBcEQsRUFBNEQsSUFBNUQsQ0FBaUUsbUJBQVc7QUFDMUUsd0JBQUksTUFBSixFQUFZO0FBQ1YsOEJBQVEsSUFBUixDQUFhLElBQWIsR0FBcUIsUUFBUSxJQUFSLENBQWEsSUFBYixLQUFzQixTQUF2QixHQUFvQyxJQUFwQyxHQUEyQyxRQUFRLElBQVIsQ0FBYSxJQUE1RTtBQUNBLDhCQUFRLE9BQVI7QUFDRCxxQkFIRCxNQUdPO0FBQ0wsMEJBQUksZUFBZSxFQUFFLE1BQU0sRUFBRSxNQUFNLEdBQVIsRUFBYSxhQUFhLG1CQUExQixFQUFSLEVBQXlELE1BQU0sUUFBUSxFQUF2RSxFQUEyRSxJQUFJLFFBQVEsSUFBdkYsRUFBNkYsTUFBTSxVQUFuRyxFQUFuQjtBQUNBLDZCQUFPLFlBQVA7QUFDRDtBQUNGLG1CQVJELEVBUUcsVUFBQyxLQUFELEVBQVc7QUFDWiwyQkFBTyxLQUFQO0FBQ0QsbUJBVkQ7QUFXRDtBQUNGLGVBZkQsRUFlRyxVQUFDLEtBQUQsRUFBVztBQUNaLHVCQUFPLEtBQVA7QUFDRCxlQWpCRDtBQWtCRCxhQXhCRCxFQXdCRyxVQUFDLEtBQUQsRUFBVztBQUNaLHFCQUFPLEtBQVA7QUFDRCxhQTFCRDtBQUY4QjtBQTZCL0IsU0E3QkQsTUE2Qk87QUFDTCxtQkFBUyxNQUFNLE9BQU4sQ0FBYyxnQkFBdkI7QUFDQSxjQUFJLE1BQUosRUFBWTtBQUNWLG9CQUFRLElBQVIsQ0FBYSxJQUFiLEdBQW9CLEtBQXBCO0FBQ0Esb0JBQVEsT0FBUjtBQUNELFdBSEQsTUFHTztBQUNMLGdCQUFJLGVBQWUsRUFBRSxNQUFNLEVBQUUsTUFBTSxHQUFSLEVBQWEsYUFBYSxtQkFBMUIsRUFBUixFQUF5RCxNQUFNLFFBQVEsRUFBdkUsRUFBMkUsSUFBSSxRQUFRLElBQXZGLEVBQTZGLE1BQU0sVUFBbkcsRUFBbkI7QUFDQSxtQkFBTyxZQUFQO0FBQ0Q7QUFDRjtBQUNGLE9BNUNNLENBQVA7QUE2Q0Q7OztrQ0FFYSxPLEVBQVM7QUFDckIsVUFBSSxlQUFKO0FBQ0EsY0FBUSxJQUFSLEdBQWUsUUFBUSxJQUFSLElBQWdCLEVBQS9CO0FBQ0EsVUFBSSxLQUFLLFdBQUwsQ0FBaUIsT0FBakIsQ0FBSixFQUErQjtBQUM3QixZQUFJLGFBQWEsS0FBSyxrQkFBTCxDQUF3QixPQUF4QixDQUFqQjtBQUNBLGtCQUFVLEtBQUssT0FBTCxDQUFhLG9CQUFiLENBQWtDLE9BQWxDLEVBQTJDLFVBQTNDLENBQVY7QUFDQSxpQkFBUyxLQUFLLEdBQUwsQ0FBUyxnQkFBVCxDQUEwQixPQUExQixFQUFtQyxVQUFuQyxDQUFUO0FBQ0EsWUFBSSxXQUFXLGdCQUFmLEVBQWlDO0FBQy9CLG1CQUFTLEtBQUssT0FBTCxDQUFhLGdCQUF0QjtBQUNBLGtCQUFRLElBQVIsQ0FBYSxJQUFiLEdBQW9CLEtBQXBCO0FBQ0Q7QUFDRCxhQUFLLGNBQUwsQ0FBb0IsZUFBcEIsQ0FBb0MsT0FBcEMsRUFBNkMsVUFBN0M7QUFDQSxrQkFBVSxLQUFLLE9BQUwsQ0FBYSxnQkFBYixDQUE4QixPQUE5QixFQUF1QyxVQUF2QyxFQUFtRCxNQUFuRCxDQUFWO0FBQ0EsWUFBSSxNQUFKLEVBQVk7QUFDVixrQkFBUSxJQUFSLENBQWEsSUFBYixHQUFxQixRQUFRLElBQVIsQ0FBYSxJQUFiLEtBQXNCLFNBQXZCLEdBQW9DLElBQXBDLEdBQTJDLFFBQVEsSUFBUixDQUFhLElBQTVFO0FBQ0EsaUJBQU8sSUFBUDtBQUNELFNBSEQsTUFHTztBQUNMLGlCQUFPLEtBQVA7QUFDRDtBQUNGLE9BaEJELE1BZ0JPO0FBQ0wsaUJBQVMsS0FBSyxPQUFMLENBQWEsZ0JBQXRCO0FBQ0EsWUFBSSxNQUFKLEVBQVk7QUFDVixrQkFBUSxJQUFSLENBQWEsSUFBYixHQUFvQixLQUFwQjtBQUNBLGlCQUFPLElBQVA7QUFDRCxTQUhELE1BR087QUFDTCxpQkFBTyxLQUFQO0FBQ0Q7QUFDRjtBQUNGOzs7dUNBRWtCLE8sRUFBUztBQUMxQixhQUFRLFFBQVEsSUFBUixLQUFpQixTQUFqQixJQUE4QixRQUFRLElBQVIsQ0FBYSxRQUFiLEtBQTBCLFNBQXpELEdBQXNFLElBQXRFLEdBQTZFLEtBQXBGO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztnQ0FNWSxPLEVBQVM7QUFDbkIsVUFBSSxrQkFBa0IsQ0FBQyxRQUFELEVBQVcsWUFBWCxFQUF5QixRQUF6QixFQUFtQyxpQkFBbkMsRUFBc0QsU0FBdEQsQ0FBdEI7QUFDQSxVQUFJLFlBQWEsUUFBUSxJQUFULENBQWUsS0FBZixDQUFxQixLQUFyQixDQUFoQjtBQUNBLFVBQUksYUFBYSxVQUFVLENBQVYsQ0FBakI7QUFDQSxVQUFJLFVBQVcsUUFBUSxFQUFULENBQWEsS0FBYixDQUFtQixLQUFuQixDQUFkO0FBQ0EsVUFBSSxXQUFZLFFBQVEsQ0FBUixDQUFoQjs7QUFFQSxVQUFJLFFBQVEsSUFBUixLQUFpQixVQUFqQixJQUErQixRQUFRLEVBQVIsS0FBZSxRQUE5QyxJQUEwRCxRQUFRLElBQVIsS0FBaUIsTUFBM0UsSUFBcUYsUUFBUSxJQUFSLEtBQWlCLFVBQTFHLEVBQXNIO0FBQ3BILGVBQU8sS0FBUDtBQUNELE9BRkQsTUFFTztBQUNMLGVBQU8sZ0JBQWdCLE9BQWhCLENBQXdCLFVBQXhCLE1BQXdDLENBQUMsQ0FBekMsSUFBOEMsZ0JBQWdCLE9BQWhCLENBQXdCLFFBQXhCLE1BQXNDLENBQUMsQ0FBNUY7QUFDRDtBQUNGOzs7aUNBRVksTSxFQUFRLEcsRUFBSztBQUN4QixVQUFJLENBQUMsTUFBTCxFQUFhLE1BQU0sSUFBSSxLQUFKLENBQVUsdUJBQVYsQ0FBTjtBQUNiLFVBQUksV0FBVyxHQUFYLElBQWtCLENBQUMsR0FBdkIsRUFBNEIsTUFBTSxJQUFJLEtBQUosQ0FBVSxvQkFBVixDQUFOOztBQUU1QixjQUFRLE1BQVI7QUFDRSxhQUFLLEdBQUw7QUFDRSxlQUFLLE9BQUwsQ0FBYSxxQkFBYixHQUFxQyxFQUFyQztBQUNBLGVBQUssT0FBTCxDQUFhLFlBQWIsR0FBNEIsRUFBNUI7QUFDQSxlQUFLLE9BQUwsQ0FBYSxnQkFBYixHQUFnQyxTQUFoQztBQUNBLGVBQUssT0FBTCxDQUFhLFlBQWIsQ0FBMEIsTUFBMUI7QUFDQSxlQUFLLE9BQUwsQ0FBYSxZQUFiLENBQTBCLGtCQUExQjtBQUNBLGVBQUssT0FBTCxDQUFhLGdCQUFiO0FBQ0E7QUFDRixhQUFLLGtCQUFMO0FBQ0UsaUJBQU8sS0FBSyxPQUFMLENBQWEscUJBQWIsQ0FBbUMsR0FBbkMsQ0FBUDtBQUNBLGVBQUssT0FBTCxDQUFhLFlBQWI7QUFDQTtBQUNGLGFBQUssTUFBTDtBQUNFLGlCQUFPLEtBQUssT0FBTCxDQUFhLFlBQWIsQ0FBMEIsR0FBMUIsQ0FBUDtBQUNBLGNBQUksUUFBUSxLQUFLLE9BQUwsQ0FBYSxnQkFBekIsRUFBMkM7QUFDekMsaUJBQUssT0FBTCxDQUFhLGdCQUFiLEdBQWdDLFNBQWhDO0FBQ0EsaUJBQUssT0FBTCxDQUFhLGdCQUFiO0FBQ0Q7QUFDRCxlQUFLLE9BQUwsQ0FBYSxZQUFiLENBQTBCLE1BQTFCO0FBQ0E7QUFDRjtBQUNFLGdCQUFNLE1BQU0sNEJBQTRCLE1BQWxDLENBQU47QUF0Qko7QUF3QkQ7Ozs7O2tCQUlZLEc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwTWY7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztJQUVNLE07QUFFSixrQkFBWSxHQUFaLEVBQWlCLEtBQWpCLEVBQXdCLE9BQXhCLEVBQWlDLGtCQUFqQyxFQUFxRDtBQUFBOztBQUNuRCxRQUFJLENBQUMsR0FBTCxFQUFVLE1BQU0sSUFBSSxLQUFKLENBQVUsb0JBQVYsQ0FBTjtBQUNWLFFBQUksQ0FBQyxPQUFMLEVBQWMsTUFBTSxJQUFJLEtBQUosQ0FBVSx5QkFBVixDQUFOOztBQUVkLFNBQUssT0FBTCxHQUFlLE9BQWY7QUFDQSxTQUFLLEdBQUwsR0FBVyxHQUFYO0FBQ0EsU0FBSyxTQUFMLENBQWUsS0FBZjtBQUNBLFNBQUssc0JBQUwsQ0FBNEIsa0JBQTVCO0FBQ0Q7Ozs7OEJBRVMsTSxFQUFRLEssRUFBTztBQUN2QixXQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWtCLEVBQUUsUUFBUSxNQUFWLEVBQWtCLE9BQU8sS0FBekIsRUFBbEI7QUFDRDs7OytCQUVVLFEsRUFBVSxTLEVBQVcsSyxFQUFPLE0sRUFBUSxRLEVBQVU7QUFDdkQsVUFBSSxhQUFhLFNBQWpCLEVBQTRCO0FBQzFCLG1CQUFXLEtBQUssZUFBTCxLQUF5QixDQUFwQztBQUNEO0FBQ0QsVUFBSSxPQUFPLG1CQUFTLFFBQVQsRUFBbUIsU0FBbkIsRUFBOEIsS0FBOUIsRUFBcUMsTUFBckMsRUFBNkMsUUFBN0MsQ0FBWDtBQUNBLFdBQUssS0FBTCxDQUFXLElBQVgsQ0FBZ0IsSUFBaEI7QUFDRDs7OytCQUVVLEksRUFBTTtBQUNmLFVBQUksZ0JBQWdCLEtBQUssS0FBTCxDQUFXLE9BQVgsQ0FBbUIsSUFBbkIsQ0FBcEI7QUFDQSxXQUFLLEtBQUwsQ0FBVyxNQUFYLENBQWtCLGFBQWxCLEVBQWlDLENBQWpDO0FBQ0Q7OzttQ0FFYyxPLEVBQVMsTyxFQUFTO0FBQUE7O0FBQy9CLGFBQU8sc0JBQVksVUFBQyxPQUFELEVBQVUsTUFBVixFQUFxQjtBQUN0QyxZQUFJLFVBQVUsRUFBZDtBQUNBLFlBQUksTUFBSyxPQUFMLENBQWEsTUFBYixLQUF3QixDQUE1QixFQUErQjtBQUM3QixlQUFLLElBQUksQ0FBVCxJQUFjLE1BQUssT0FBbkIsRUFBNEI7QUFDMUIsZ0JBQUksU0FBUyxRQUFRLEdBQVIsQ0FBWSxjQUFaLENBQTJCLE1BQUssT0FBTCxDQUFhLENBQWIsRUFBZ0IsTUFBM0MsRUFBbUQsT0FBbkQsRUFBNEQsTUFBSyxPQUFMLENBQWEsQ0FBYixFQUFnQixLQUE1RSxDQUFiO0FBQ0Esb0JBQVEsSUFBUixDQUFhLE1BQWI7QUFDRDtBQUNELDRCQUFRLEdBQVIsQ0FBWSxPQUFaLEVBQXFCLElBQXJCLENBQTBCLFVBQUMsUUFBRCxFQUFjO0FBQ3RDLG9CQUFRLFFBQVI7QUFDRCxXQUZELEVBRUcsaUJBQVM7QUFDVixtQkFBTyxLQUFQO0FBQ0QsV0FKRDtBQUtELFNBVkQsTUFVTztBQUNMLGtCQUFRLENBQUMsT0FBRCxDQUFSO0FBQ0Q7QUFDRixPQWZNLENBQVA7QUFnQkQ7OztrQ0FFYSxPLEVBQVMsTyxFQUFTLFUsRUFBWTtBQUMxQyxVQUFJLFVBQVUsRUFBZDtBQUNBLFdBQUssSUFBSSxDQUFULElBQWMsS0FBSyxLQUFuQixFQUEwQjtBQUN4QixnQkFBUSxJQUFSLENBQWEsS0FBSyxLQUFMLENBQVcsQ0FBWCxFQUFjLFFBQWQsQ0FBdUIsT0FBdkIsRUFBZ0MsT0FBaEMsRUFBeUMsVUFBekMsQ0FBYjtBQUNEOztBQUVELGFBQU8sS0FBSyxrQkFBTCxDQUF3QixPQUF4QixDQUFnQyxPQUFoQyxDQUFQO0FBQ0Q7OztzQ0FFaUI7QUFDaEIsVUFBSSxhQUFhLEVBQWpCOztBQUVBLFVBQUksS0FBSyxLQUFMLENBQVcsTUFBWCxLQUFzQixDQUExQixFQUE2QjtBQUMzQixhQUFLLElBQUksQ0FBVCxJQUFjLEtBQUssS0FBbkIsRUFBMEI7QUFDeEIscUJBQVcsSUFBWCxDQUFnQixLQUFLLEtBQUwsQ0FBVyxDQUFYLEVBQWMsUUFBOUI7QUFDRDtBQUNELGVBQU8sS0FBSyxHQUFMLENBQVMsS0FBVCxDQUFlLElBQWYsRUFBcUIsVUFBckIsQ0FBUDtBQUNELE9BTEQsTUFLTztBQUNMLGVBQU8sQ0FBQyxDQUFSO0FBQ0Q7QUFDRjs7O3NDQUVpQixRLEVBQVU7QUFDMUIsV0FBSyxJQUFJLENBQVQsSUFBYyxLQUFLLEtBQW5CLEVBQTBCO0FBQ3hCLFlBQUksT0FBTyxLQUFLLEtBQUwsQ0FBVyxDQUFYLEVBQWMsUUFBckIsTUFBbUMsT0FBTyxRQUFQLENBQXZDLEVBQXlEO0FBQ3ZELGlCQUFPLEtBQUssS0FBTCxDQUFXLENBQVgsQ0FBUDtBQUNEO0FBQ0Y7QUFDRCxZQUFNLE1BQU0sd0JBQXdCLFFBQXhCLEdBQW1DLGtCQUF6QyxDQUFOO0FBQ0Q7OzsyQ0FFc0Isa0IsRUFBb0I7QUFDekMsVUFBSSxDQUFDLGtCQUFMLEVBQXlCO0FBQ3ZCLDZCQUFxQixnQkFBckI7QUFDRDtBQUNELGNBQVEsa0JBQVI7QUFDRSxhQUFLLGdCQUFMO0FBQ0UsZUFBSyxrQkFBTCxHQUEwQiw4QkFBMUI7QUFDQTtBQUNGLGFBQUssZ0JBQUw7QUFDRSxlQUFLLGtCQUFMLEdBQTBCLDhCQUExQjtBQUNBO0FBQ0YsYUFBSyxpQkFBTDtBQUNFLGVBQUssa0JBQUwsR0FBMEIsK0JBQTFCO0FBQ0E7QUFDRjtBQUNFLGdCQUFNLE1BQU0sd0JBQXdCLGtCQUE5QixDQUFOO0FBWEo7QUFhRDs7OzhCQUVTLEssRUFBTztBQUNmLFdBQUssS0FBTCxHQUFhLEVBQWI7O0FBRUEsV0FBSyxJQUFJLENBQVQsSUFBYyxLQUFkLEVBQXFCO0FBQ25CLFlBQUksT0FBTyxNQUFNLENBQU4sQ0FBWDtBQUNBLFlBQUksS0FBSyxRQUFMLEtBQWtCLFNBQXRCLEVBQWlDO0FBQy9CLGVBQUssUUFBTCxHQUFnQixLQUFLLGVBQUwsS0FBeUIsQ0FBekM7QUFDRDtBQUNELFlBQUksRUFBRSw4QkFBRixDQUFKLEVBQTZCO0FBQzNCLGlCQUFPLG1CQUFTLEtBQUssUUFBZCxFQUF3QixLQUFLLFNBQTdCLEVBQXdDLEtBQUssS0FBN0MsRUFBb0QsS0FBSyxNQUF6RCxFQUFpRSxLQUFLLFFBQXRFLENBQVA7QUFDRDtBQUNELGFBQUssS0FBTCxDQUFXLElBQVgsQ0FBZ0IsSUFBaEI7QUFDRDtBQUNGOzs7Z0NBRVc7QUFDVixhQUFPLEtBQUssS0FBTCxDQUFXLElBQVgsQ0FBZ0IsVUFBUyxDQUFULEVBQVksQ0FBWixFQUFlO0FBQ3BDLFlBQUksSUFBSSxFQUFFLFFBQVYsQ0FBb0IsSUFBSSxJQUFJLEVBQUUsUUFBVjtBQUNwQixlQUFTLElBQUksQ0FBTCxHQUFVLENBQUMsQ0FBWCxHQUFpQixJQUFJLENBQUwsR0FBVSxDQUFWLEdBQWMsQ0FBdEM7QUFDRCxPQUhNLENBQVA7QUFJRDs7Ozs7a0JBSVksTTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0hmOzs7O0lBRU0sVTtBQUVKLHdCQUFjO0FBQUE7O0FBQ1osU0FBSyxnQkFBTCxHQUF3QixJQUF4QjtBQUNBLFNBQUssTUFBTCxHQUFjLEVBQWQ7QUFDRDs7Ozt3QkFFWTtBQUNYLGFBQU8sS0FBSyxPQUFaO0FBQ0QsSztzQkEwQlUsTSxFQUFRO0FBQ2pCLFVBQUksT0FBTyxPQUFPLE9BQVAsQ0FBZSxJQUExQjtBQUNBLFVBQUksNEJBQWdCLElBQWhCLENBQUosRUFBMkI7QUFDekIsYUFBSyxPQUFMLEdBQWUsc0JBQVUsSUFBVixFQUFnQixJQUEvQjtBQUNELE9BRkQsTUFFTztBQUNMLGFBQUssT0FBTCxHQUFlLFNBQWY7QUFDRDtBQUNGOzs7d0JBL0JVO0FBQ1QsYUFBTyxLQUFLLEtBQVo7QUFDRCxLO3NCQStCUSxHLEVBQUs7QUFDWixVQUFJLE9BQU8sSUFBSSxJQUFKLEVBQVg7QUFDQSxVQUFJLE1BQU0sT0FBTyxLQUFLLE9BQUwsRUFBUCxDQUFWO0FBQ0EsVUFBSSxJQUFJLE1BQUosS0FBZSxDQUFuQixFQUFzQjtBQUNwQixjQUFNLE1BQU0sR0FBWjtBQUNEO0FBQ0QsVUFBSSxRQUFRLE9BQU8sS0FBSyxRQUFMLEtBQWtCLENBQXpCLENBQVo7QUFDQSxVQUFJLE1BQU0sTUFBTixLQUFpQixDQUFyQixFQUF3QjtBQUN0QixnQkFBUSxNQUFNLEtBQWQ7QUFDRDtBQUNELFdBQUssS0FBTCxHQUFhLE1BQU0sR0FBTixHQUFZLEtBQVosR0FBb0IsR0FBcEIsR0FBMEIsS0FBSyxXQUFMLEVBQXZDO0FBQ0Q7Ozt3QkF4Q1k7QUFDWCxhQUFPLEtBQUssT0FBWjtBQUNELEs7c0JBd0NVLE0sRUFBUTtBQUNqQixVQUFJLE9BQU8sT0FBUCxDQUFlLElBQWYsQ0FBb0IsUUFBcEIsS0FBaUMsU0FBckMsRUFBZ0Q7QUFDOUMsYUFBSyxPQUFMLEdBQWUsd0JBQVksT0FBTyxPQUFQLENBQWUsSUFBZixDQUFvQixRQUFwQixDQUE2QixXQUE3QixDQUF5QyxRQUFyRCxFQUErRCxNQUE5RTtBQUNEO0FBQ0Y7Ozt3QkExQ1U7QUFDVCxhQUFPLEtBQUssS0FBWjtBQUNELEs7c0JBMENRLE0sRUFBUTtBQUNmLFVBQUksVUFBVSxPQUFPLE9BQXJCO0FBQ0EsVUFBSSxRQUFRLElBQVIsQ0FBYSxLQUFiLEtBQXVCLFNBQTNCLEVBQXNDO0FBQ3BDLGFBQUssS0FBTCxHQUFhLFFBQVEsSUFBUixDQUFhLEtBQWIsQ0FBbUIsWUFBaEM7QUFDRDtBQUNGOzs7d0JBN0NZO0FBQ1gsYUFBTyxLQUFLLE9BQVo7QUFDRCxLO3NCQTZDVSxNLEVBQVE7QUFDakIsVUFBSSxPQUFPLE9BQVAsQ0FBZSxJQUFmLENBQW9CLFFBQXBCLEtBQWlDLFNBQXJDLEVBQWdEO0FBQzlDLGFBQUssT0FBTCxHQUFlLE9BQU8sT0FBUCxDQUFlLElBQWYsQ0FBb0IsUUFBcEIsQ0FBNkIsV0FBN0IsQ0FBeUMsUUFBeEQ7QUFDRDtBQUNGOzs7d0JBL0NVO0FBQ1QsYUFBTyxLQUFLLEtBQVo7QUFDRCxLO3NCQStDUSxHLEVBQUs7QUFDWixZQUFNLElBQUksSUFBSixFQUFOO0FBQ0EsVUFBSSxVQUFVLE9BQU8sSUFBSSxVQUFKLEVBQVAsQ0FBZDtBQUNBLFVBQUksUUFBUSxNQUFSLEtBQW1CLENBQXZCLEVBQTBCO0FBQ3hCLGtCQUFVLE1BQU0sT0FBaEI7QUFDRDtBQUNELFdBQUssS0FBTCxHQUFhLFNBQVMsT0FBTyxJQUFJLFFBQUosRUFBUCxJQUF5QixPQUFsQyxDQUFiO0FBQ0Q7Ozt3QkFwRGE7QUFDWixhQUFPLEtBQUssUUFBWjtBQUNELEs7c0JBb0RXLEcsRUFBSztBQUNmLFdBQUssUUFBTCxHQUFnQixPQUFPLElBQUksSUFBSixHQUFXLE1BQVgsRUFBUCxDQUFoQjtBQUNEOzs7OztrQkFJWSxVOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3RmY7Ozs7QUFDQTs7OztBQUNBOzs7O0lBR00sSTtBQUVKLGdCQUFZLFFBQVosRUFBc0IsU0FBdEIsRUFBaUMsS0FBakMsRUFBd0MsTUFBeEMsRUFBZ0QsUUFBaEQsRUFBMEQ7QUFBQTs7QUFDeEQsU0FBSyxRQUFMLEdBQWdCLFFBQWhCO0FBQ0EsU0FBSyxZQUFMLENBQWtCLFNBQWxCO0FBQ0EsU0FBSyxRQUFMLEdBQWdCLFFBQWhCO0FBQ0EsU0FBSyxLQUFMLEdBQWEsS0FBYjtBQUNBLFNBQUssTUFBTCxHQUFjLE1BQWQ7QUFDRDs7OztpQ0FFWSxTLEVBQVc7QUFDdEIsVUFBSSxFQUFFLDRDQUFrQyxnREFBbEMsSUFBZ0YsZ0RBQWxGLENBQUosRUFBK0g7QUFDN0gsWUFBSSxZQUFZLFVBQVUsU0FBMUI7QUFDQSxnQkFBUSxTQUFSO0FBQ0UsZUFBSyxjQUFMO0FBQ0UsaUJBQUssU0FBTCxHQUFpQixnQ0FBMEIsVUFBVSxTQUFwQyxFQUErQyxVQUFVLFFBQXpELEVBQW1FLFVBQVUsTUFBN0UsQ0FBakI7QUFDQTtBQUNGLGVBQUssU0FBTDtBQUNFLGlCQUFLLFNBQUwsR0FBaUIsZ0NBQXNCLFNBQXRCLENBQWpCO0FBQ0E7QUFDRjtBQUNFLGlCQUFLLFNBQUwsR0FBaUIsd0JBQWMsVUFBVSxTQUF4QixFQUFtQyxVQUFVLFFBQTdDLEVBQXVELFVBQVUsTUFBakUsQ0FBakI7QUFSSjtBQVVELE9BWkQsTUFZTztBQUNMLGFBQUssU0FBTCxHQUFpQixTQUFqQjtBQUNEO0FBQ0Y7Ozs2QkFFUSxPLEVBQVMsTyxFQUFTLFUsRUFBWTtBQUNyQyxVQUFJLFFBQVMsVUFBRCxHQUFlLFFBQVEsRUFBdkIsR0FBNEIsUUFBUSxJQUFoRDtBQUNBLFVBQUksb0JBQUo7QUFDQSxjQUFRLEtBQUssS0FBYjtBQUNFLGFBQUssUUFBTDtBQUNFOztBQUVGLGFBQUssU0FBTDtBQUNFLGNBQUksNEJBQWdCLEtBQWhCLENBQUosRUFBNEI7QUFDMUIsZ0JBQUksV0FBVyxRQUFRLGVBQVIsQ0FBd0Isd0JBQXhCLENBQWlELDhCQUFrQixLQUFsQixDQUFqRCxDQUFmO0FBQ0EsZ0JBQUksYUFBYSxTQUFqQixFQUE0QjtBQUMxQiw0QkFBYyxRQUFRLGVBQVIsQ0FBd0IsY0FBeEIsQ0FBdUMsUUFBdkMsQ0FBZDtBQUNEO0FBQ0YsV0FMRCxNQUtPO0FBQ0wsZ0JBQUksTUFBTSxLQUFOLENBQVksS0FBWixFQUFtQixDQUFuQixNQUEwQixTQUE5QixFQUF5QztBQUN2Qyw0QkFBYyxRQUFRLGVBQVIsQ0FBd0IsY0FBeEIsQ0FBdUMsOEJBQWtCLEtBQWxCLENBQXZDLENBQWQ7QUFDRDtBQUNGO0FBQ0QsY0FBSSxnQkFBZ0IsS0FBSyxNQUF6QixFQUFpQztBQUMvQjtBQUNEOztBQUVELGlCQUFPLGdCQUFQOztBQUVGLGFBQUssVUFBTDtBQUNFLGNBQUksY0FBSjs7QUFFQSxjQUFJLDRCQUFnQixLQUFoQixDQUFKLEVBQTRCO0FBQzFCLGdCQUFJLFlBQVcsUUFBUSxlQUFSLENBQXdCLHdCQUF4QixDQUFpRCw4QkFBa0IsS0FBbEIsQ0FBakQsQ0FBZjtBQUNBLG9CQUFRLFFBQVEsZUFBUixDQUF3QixlQUF4QixDQUF3QyxTQUF4QyxDQUFSO0FBQ0QsV0FIRCxNQUdPO0FBQ0wsZ0JBQUksTUFBTSxLQUFOLENBQVksS0FBWixFQUFtQixDQUFuQixNQUEwQixTQUE5QixFQUF5QztBQUN2QyxzQkFBUSxRQUFRLGVBQVIsQ0FBd0IsZUFBeEIsQ0FBd0MsOEJBQWtCLEtBQWxCLENBQXhDLENBQVI7QUFDRDtBQUNGO0FBQ0QsY0FBSSxVQUFVLFNBQWQsRUFBeUI7QUFDdkIsb0JBQVEsZ0NBQW9CLEtBQXBCLENBQVI7QUFDRDtBQUNELGNBQUksVUFBVSxLQUFLLE1BQW5CLEVBQTJCO0FBQ3pCO0FBQ0Q7O0FBRUQsaUJBQU8sZ0JBQVA7QUF2Q0o7O0FBMENBLFVBQUksS0FBSyxTQUFMLENBQWUsWUFBZixDQUE0QixPQUE1QixFQUFxQyxPQUFyQyxFQUE4QyxLQUFLLEtBQW5ELEVBQTBELEtBQUssTUFBL0QsQ0FBSixFQUE0RTtBQUMxRSxlQUFPLEtBQUssUUFBWjtBQUNELE9BRkQsTUFFTztBQUNMLGVBQU8sZ0JBQVA7QUFDRDtBQUNGOzs7OztrQkFHWSxJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RGZjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7Ozs7SUFJTSxjOzs7Ozs7Ozs7QUFFSjs7Ozs7NEJBS1EsUyxFQUFXO0FBQ2pCLFVBQUksVUFBVSxPQUFWLENBQWtCLElBQWxCLE1BQTRCLENBQUMsQ0FBakMsRUFBb0M7QUFDbEMsZUFBTyxJQUFQO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsWUFBSSxVQUFVLE9BQVYsQ0FBa0IsS0FBbEIsTUFBNkIsQ0FBQyxDQUFsQyxFQUFxQztBQUNuQyxpQkFBTyxLQUFQO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsaUJBQU8sZ0JBQVA7QUFDRDtBQUNGO0FBQ0Y7Ozs7O2tCQUlZLGM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaERmOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQTs7OztJQUlNLGM7Ozs7Ozs7OztBQUVKOzs7Ozs0QkFLUSxTLEVBQVc7QUFDakIsVUFBSSxVQUFVLE9BQVYsQ0FBa0IsS0FBbEIsTUFBNkIsQ0FBQyxDQUFsQyxFQUFxQztBQUNuQyxlQUFPLEtBQVA7QUFDRCxPQUZELE1BRU87QUFDTCxZQUFJLFVBQVUsT0FBVixDQUFrQixJQUFsQixNQUE0QixDQUFDLENBQWpDLEVBQW9DO0FBQ2xDLGlCQUFPLElBQVA7QUFDRCxTQUZELE1BRU87QUFDTCxpQkFBTyxnQkFBUDtBQUNEO0FBQ0Y7QUFDRjs7Ozs7a0JBSVksYzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoRGY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBOzs7O0lBSU0sZTs7Ozs7Ozs7O0FBRUo7Ozs7OzRCQUtRLFMsRUFBVztBQUNqQixXQUFLLElBQUksQ0FBVCxJQUFjLFNBQWQsRUFBeUI7QUFDdkIsWUFBSSxVQUFVLENBQVYsTUFBaUIsZ0JBQXJCLEVBQXVDO0FBQ3JDLGlCQUFPLFVBQVUsQ0FBVixDQUFQO0FBQ0Q7QUFDRjtBQUNELGFBQU8sZ0JBQVA7QUFDRDs7Ozs7a0JBSVksZTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0NmOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0lBRU0saUI7QUFFSiw2QkFBWSxTQUFaLEVBQXVCO0FBQUE7O0FBQ3JCLFNBQUssU0FBTCxHQUFpQix5QkFBakI7QUFDQSxRQUFJLFVBQVUsU0FBVixLQUF3QixTQUE1QixFQUF1QztBQUNyQyxrQkFBWSxVQUFVLFNBQXRCO0FBQ0Q7QUFDRCxnQkFBWSxLQUFLLGNBQUwsQ0FBb0IsU0FBcEIsQ0FBWjtBQUNBLFNBQUssU0FBTCxHQUFpQixTQUFqQjtBQUNEOzs7O21DQUVjLFMsRUFBVztBQUN4QixVQUFJLE1BQU0sT0FBTixDQUFjLFVBQVUsQ0FBVixDQUFkLENBQUosRUFBaUM7QUFDL0Isa0JBQVUsQ0FBVixJQUFlLEtBQUssY0FBTCxDQUFvQixVQUFVLENBQVYsQ0FBcEIsQ0FBZjtBQUNELE9BRkQsTUFFTztBQUNMLFlBQUksVUFBVSxDQUFWLEVBQWEsU0FBYixLQUEyQixjQUEvQixFQUErQztBQUM3QyxvQkFBVSxDQUFWLElBQWUsb0NBQTBCLFVBQVUsQ0FBVixFQUFhLFNBQXZDLEVBQWtELFVBQVUsQ0FBVixFQUFhLFFBQS9ELEVBQXlFLFVBQVUsQ0FBVixFQUFhLE1BQXRGLENBQWY7QUFDRCxTQUZELE1BRU87QUFDTCxvQkFBVSxDQUFWLElBQWUsd0JBQWMsVUFBVSxDQUFWLEVBQWEsU0FBM0IsRUFBc0MsVUFBVSxDQUFWLEVBQWEsUUFBbkQsRUFBNkQsVUFBVSxDQUFWLEVBQWEsTUFBMUUsQ0FBZjtBQUNEO0FBQ0Y7O0FBRUQsVUFBSSxVQUFVLENBQVYsTUFBaUIsU0FBckIsRUFBZ0M7QUFDOUIsWUFBSSxNQUFNLE9BQU4sQ0FBYyxVQUFVLENBQVYsQ0FBZCxDQUFKLEVBQWlDO0FBQy9CLG9CQUFVLENBQVYsSUFBZSxLQUFLLGNBQUwsQ0FBb0IsVUFBVSxDQUFWLENBQXBCLENBQWY7QUFDRCxTQUZELE1BRU87QUFDTCxjQUFJLFVBQVUsQ0FBVixFQUFhLFNBQWIsS0FBMkIsY0FBL0IsRUFBK0M7QUFDN0Msc0JBQVUsQ0FBVixJQUFlLG9DQUEwQixVQUFVLENBQVYsRUFBYSxTQUF2QyxFQUFrRCxVQUFVLENBQVYsRUFBYSxRQUEvRCxFQUF5RSxVQUFVLENBQVYsRUFBYSxNQUF0RixDQUFmO0FBQ0QsV0FGRCxNQUVPO0FBQ0wsc0JBQVUsQ0FBVixJQUFlLHdCQUFjLFVBQVUsQ0FBVixFQUFhLFNBQTNCLEVBQXNDLFVBQVUsQ0FBVixFQUFhLFFBQW5ELEVBQTZELFVBQVUsQ0FBVixFQUFhLE1BQTFFLENBQWY7QUFDRDtBQUNGO0FBQ0Y7QUFDRCxhQUFPLFNBQVA7QUFDRDs7O2lDQUVZLE8sRUFBUyxPLEVBQVMsSyxFQUFPLE0sRUFBUSxRLEVBQVUsSSxFQUFNLEssRUFBTztBQUNuRSxVQUFJLENBQUMsUUFBTCxFQUFlO0FBQ2IsbUJBQVcsS0FBSyxTQUFMLENBQWUsQ0FBZixDQUFYO0FBQ0EsZUFBTyxLQUFLLFNBQUwsQ0FBZSxDQUFmLENBQVA7QUFDQSxnQkFBUSxLQUFLLFNBQUwsQ0FBZSxDQUFmLENBQVI7QUFDRDs7QUFFRCxhQUFPLEVBQUUsbUNBQUYsSUFBK0IsRUFBRSwrQ0FBRixDQUEvQixHQUEyRSxPQUFPLElBQVAsS0FBZ0IsU0FBbEcsRUFBOEc7QUFDNUcsZUFBTyxLQUFLLFlBQUwsQ0FBa0IsT0FBbEIsRUFBMkIsT0FBM0IsRUFBb0MsS0FBcEMsRUFBMkMsTUFBM0MsRUFBbUQsS0FBSyxDQUFMLENBQW5ELEVBQTRELEtBQUssQ0FBTCxDQUE1RCxFQUFxRSxLQUFLLENBQUwsQ0FBckUsQ0FBUDtBQUNEO0FBQ0QsVUFBSSxVQUFVLFNBQWQsRUFBeUI7QUFDdkIsZUFBTyxFQUFFLG9DQUFGLElBQWdDLEVBQUUsZ0RBQUYsQ0FBaEMsR0FBNkUsT0FBTyxLQUFQLEtBQWlCLFNBQXJHLEVBQWlIO0FBQy9HLGtCQUFRLEtBQUssWUFBTCxDQUFrQixPQUFsQixFQUEyQixPQUEzQixFQUFvQyxLQUFwQyxFQUEyQyxNQUEzQyxFQUFtRCxNQUFNLENBQU4sQ0FBbkQsRUFBNkQsTUFBTSxDQUFOLENBQTdELEVBQXVFLE1BQU0sQ0FBTixDQUF2RSxDQUFSO0FBQ0Q7QUFDRjs7QUFFRCxVQUFJLGFBQWMsT0FBTyxJQUFQLEtBQWdCLFNBQWpCLEdBQThCLElBQTlCLEdBQXFDLEtBQUssWUFBTCxDQUFrQixPQUFsQixFQUEyQixPQUEzQixFQUFvQyxLQUFwQyxFQUEyQyxNQUEzQyxDQUF0RDtBQUNBLFVBQUksb0JBQUo7QUFDQSxVQUFJLFVBQVUsU0FBZCxFQUF5QjtBQUN2QixzQkFBZSxPQUFPLEtBQVAsS0FBaUIsU0FBbEIsR0FBK0IsS0FBL0IsR0FBdUMsTUFBTSxZQUFOLENBQW1CLE9BQW5CLEVBQTRCLE9BQTVCLEVBQXFDLEtBQXJDLEVBQTRDLE1BQTVDLENBQXJEO0FBQ0Q7QUFDRCxhQUFPLEtBQUssU0FBTCxDQUFlLFFBQWYsRUFBeUIsQ0FBQyxVQUFELEVBQWEsV0FBYixDQUF6QixDQUFQO0FBQ0Q7Ozs7O2tCQUlZLGlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzQ2Y7Ozs7OztBQUVBOzs7O0lBSU0sUzs7QUFFSjs7Ozs7OztBQU9BLHFCQUFZLFNBQVosRUFBdUIsUUFBdkIsRUFBaUMsTUFBakMsRUFBeUM7QUFBQTs7QUFDdkMsU0FBSyxTQUFMLEdBQWlCLFNBQWpCO0FBQ0EsU0FBSyxRQUFMLEdBQWdCLFFBQWhCO0FBQ0EsU0FBSyxNQUFMLEdBQWMsTUFBZDtBQUNBLFNBQUssU0FBTCxHQUFpQix5QkFBakI7QUFDRDs7QUFFRDs7Ozs7Ozs7O2lDQUthLE8sRUFBUyxPLEVBQVM7QUFDN0IsY0FBUSxLQUFLLFNBQWIsSUFBMEIsRUFBRSxTQUFTLE9BQVgsRUFBMUI7QUFDQSxVQUFJLFFBQVEsUUFBUSxLQUFLLFNBQWIsQ0FBWjtBQUNBLFVBQUksa0JBQUo7O0FBRUEsVUFBSSxLQUFLLFFBQUwsS0FBa0IsSUFBdEIsRUFBNEI7QUFDMUIsWUFBSSxDQUFFLE1BQU0sT0FBTixDQUFjLEtBQUssTUFBbkIsQ0FBTixFQUFtQztBQUNqQyxzQkFBWSxRQUFRLFFBQVIsQ0FBaUIsS0FBSyxNQUF0QixFQUE4QixRQUFRLEVBQXRDLENBQVo7QUFDQSxpQkFBTyxLQUFLLFNBQUwsQ0FBZSxLQUFLLFFBQXBCLEVBQThCLENBQUMsU0FBRCxFQUFZLEtBQVosQ0FBOUIsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsYUFBTyxLQUFLLFNBQUwsQ0FBZSxLQUFLLFFBQXBCLEVBQThCLENBQUMsS0FBSyxNQUFOLEVBQWMsS0FBZCxDQUE5QixDQUFQO0FBQ0Q7OztLQS9ESDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0JBbUVlLFM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1Q2Y7Ozs7OztBQUVBOzs7O0lBSU0scUI7OztBQUVKOzs7Ozs7O0FBT0EsaUNBQVksU0FBWixFQUF1QixRQUF2QixFQUFpQyxNQUFqQyxFQUF5QztBQUFBO0FBQUEsK0pBQ2pDLFNBRGlDLEVBQ3RCLFFBRHNCLEVBQ1osTUFEWTtBQUV4Qzs7QUFFRDs7Ozs7Ozs7O2lDQUthLE8sRUFBUyxPLEVBQVM7QUFDN0IsVUFBSSxpQkFBaUIsUUFBUSxJQUFSLEtBQWlCLFdBQXRDO0FBQ0EsVUFBSSxpQkFBaUIsUUFBUSxjQUFSLENBQXVCLFFBQVEsSUFBL0IsQ0FBckI7QUFDQSxVQUFJLGlCQUFpQixjQUFyQixFQUFxQztBQUNuQyxnTEFBMEIsT0FBMUIsRUFBbUMsT0FBbkM7QUFDRCxPQUZELE1BRU87QUFDTCxlQUFPLEtBQVA7QUFDRDtBQUNGOzs7d0JBdkRIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrQkEyRGUscUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0RmOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7Ozs7SUFFTSxjOzs7QUFFSiwwQkFBWSxRQUFaLEVBQXNCLGVBQXRCLEVBQXVDLGNBQXZDLEVBQXVEO0FBQUE7O0FBQUE7O0FBRXJELFdBQUssUUFBTCxHQUFnQixRQUFoQjtBQUNBLFdBQUssZUFBTCxHQUF1QixlQUF2QjtBQUNBLFdBQUssZ0JBQUwsR0FBd0IsU0FBeEI7QUFDQSxXQUFLLHFCQUFMLEdBQTZCLEVBQTdCO0FBQ0EsV0FBSyxZQUFMLEdBQW9CLEVBQXBCO0FBQ0EsV0FBSyxjQUFMLEdBQXNCLGNBQXRCO0FBUHFEO0FBUXREOzs7O3lDQVVvQjtBQUNuQixVQUFJLFFBQVEsSUFBWjs7QUFFQSxhQUFPLHNCQUFZLFVBQUMsT0FBRCxFQUFVLE1BQVYsRUFBcUI7O0FBRXRDLGNBQU0sY0FBTixDQUFxQixHQUFyQixDQUF5QixzQkFBekIsRUFBaUQsSUFBakQsQ0FBc0QsVUFBQyxLQUFELEVBQVc7QUFDL0QsZ0JBQU0sZ0JBQU4sR0FBeUIsS0FBekI7O0FBRUEsaUJBQU8sTUFBTSxjQUFOLENBQXFCLEdBQXJCLENBQXlCLGdCQUF6QixDQUFQO0FBQ0QsU0FKRCxFQUlHLElBSkgsQ0FJUSxVQUFDLFNBQUQsRUFBZTtBQUNyQixjQUFJLFNBQVMsU0FBYjtBQUNBLGdCQUFNLE1BQU4sR0FBZ0IsV0FBVyxTQUFaLEdBQXlCLEVBQXpCLEdBQThCLE1BQTdDOztBQUVBLGlCQUFPLE1BQU0sY0FBTixDQUFxQixHQUFyQixDQUF5QixvQkFBekIsQ0FBUDtBQUNELFNBVEQsRUFTRyxJQVRILENBU1EsVUFBQyxZQUFELEVBQWtCO0FBQ3hCLGNBQUksYUFBYSxZQUFqQjtBQUNBLGdCQUFNLHFCQUFOLEdBQStCLGVBQWUsU0FBaEIsR0FBNkIsRUFBN0IsR0FBa0MsVUFBaEU7O0FBRUEsZ0JBQU0saUJBQU4sR0FBMEIsSUFBMUIsQ0FBK0IsWUFBTTtBQUNuQztBQUNELFdBRkQ7QUFHRCxTQWhCRDtBQWlCRCxPQW5CTSxDQUFQO0FBb0JEOzs7eUNBRW9CLE8sRUFBUyxVLEVBQVk7QUFBQTs7QUFDeEMsYUFBTyxzQkFBWSxVQUFDLE9BQUQsRUFBVSxNQUFWLEVBQXFCOztBQUV0QyxZQUFJLGNBQUo7QUFDQSxZQUFJLFVBQUosRUFBZ0I7QUFDZCxjQUFJLE1BQU0saUJBQU4sQ0FBd0IsT0FBeEIsQ0FBSixFQUFzQztBQUNwQyxrQkFBTSxRQUFOLENBQWUsY0FBZixDQUE4QixPQUE5QixFQUF1QyxJQUF2QyxDQUE0QyxVQUFTLE9BQVQsRUFBa0I7QUFDNUQ7O0FBRUEsc0JBQVEsT0FBUjtBQUNELGFBSkQsRUFJRyxVQUFDLEtBQUQsRUFBVztBQUNaLHFCQUFPLEtBQVA7QUFDQTs7OztBQUlELGFBVkQ7QUFXRCxXQVpELE1BWU87QUFDTCxvQkFBUSxPQUFSO0FBQ0Q7QUFDRixTQWhCRCxNQWdCTztBQUNMLGNBQUksTUFBTSxVQUFOLENBQWlCLE9BQWpCLENBQUosRUFBK0I7QUFDN0Isa0JBQU0sWUFBTixDQUFtQixPQUFuQixFQUE0QixJQUE1QixDQUFpQyxvQkFBWTtBQUMzQyxzQkFBUSxJQUFSLENBQWEsUUFBYixHQUF3QixRQUF4QjtBQUNBLHNCQUFRLE9BQVI7QUFDRCxhQUhELEVBR0csVUFBQyxLQUFELEVBQVc7QUFDWixxQkFBTyxLQUFQO0FBQ0QsYUFMRDtBQU1ELFdBUEQsTUFPTztBQUNMLG9CQUFRLE9BQVI7QUFDRDtBQUNGO0FBRUYsT0FoQ00sQ0FBUDtBQWlDRDs7O2dDQUVXLE8sRUFBUyxpQixFQUFtQjtBQUN0QyxVQUFJLFdBQVcsRUFBZjs7QUFFQSxVQUFJLEtBQUssZ0JBQUwsS0FBMEIsU0FBOUIsRUFBeUM7QUFDdkMsaUJBQVMsVUFBVCxHQUFzQixLQUFLLFlBQUwsQ0FBa0IsS0FBSyxnQkFBdkIsQ0FBdEI7QUFDRDs7QUFFRCxlQUFTLHFCQUFULEdBQWlDLEtBQUssd0JBQUwsQ0FBOEIsT0FBOUIsRUFBdUMsaUJBQXZDLENBQWpDOztBQUVBLGFBQU8sUUFBUDtBQUNEOzs7bUNBRWMsTyxFQUFTO0FBQ3RCLFVBQUksUUFBUSxJQUFaO0FBQ0EsYUFBTyxzQkFBWSxVQUFDLE9BQUQsRUFBVSxNQUFWLEVBQXFCO0FBQ3RDLFlBQUksUUFBUSxJQUFSLENBQWEsS0FBYixDQUFtQixLQUFuQixFQUEwQixNQUExQixHQUFtQyxDQUF2QyxFQUEwQztBQUN4QyxnQkFBTSxRQUFOLENBQWUseUJBQWYsQ0FBeUMsUUFBUSxJQUFqRCxFQUF1RCxJQUF2RCxDQUE0RCxzQkFBYztBQUN4RSxnQkFBSSxlQUFlLFFBQVEsSUFBUixDQUFhLE1BQWhDLEVBQXdDO0FBQ3RDLHNCQUFRLE9BQVI7QUFDRCxhQUZELE1BRU87QUFDTCxxQkFBTyx5Q0FBUDtBQUNEO0FBQ0YsV0FORCxFQU1HLFVBQUMsS0FBRCxFQUFXO0FBQ1osbUJBQU8sS0FBUDtBQUNELFdBUkQ7QUFTRCxTQVZELE1BVU87QUFDTCxrQkFBUSxPQUFSO0FBQ0Q7QUFDRixPQWRNLENBQVA7QUFlRDs7O3FDQUVnQixPLEVBQVMsVSxFQUFZLE0sRUFBUTtBQUM1QyxVQUFJLFFBQVEsSUFBWjtBQUNBLGFBQU8sc0JBQVksVUFBQyxPQUFELEVBQVUsTUFBVixFQUFxQjtBQUN0QyxZQUFJLGFBQWEsTUFBakIsRUFBeUI7QUFDdkIsY0FBSSxpQkFBaUIsUUFBUSxJQUFSLEtBQWlCLFdBQXRDO0FBQ0EsY0FBSSxpQkFBaUIsTUFBTSxjQUFOLENBQXFCLFFBQVEsSUFBN0IsQ0FBckI7QUFDQSxjQUFJLGlCQUFpQixjQUFyQixFQUFxQztBQUNuQyxrQkFBTSxzQkFBTixDQUE2QixPQUE3QixFQUFzQyxJQUF0QyxDQUEyQyxZQUFNO0FBQy9DLHNCQUFRLE9BQVI7QUFDRCxhQUZELEVBRUcsVUFBQyxLQUFELEVBQVc7QUFDWixxQkFBTyxLQUFQO0FBQ0QsYUFKRDtBQUtELFdBTkQsTUFNTztBQUNMLG9CQUFRLE9BQVI7QUFDRDtBQUNGLFNBWkQsTUFZTztBQUNMLGNBQUksTUFBTSxpQkFBTixDQUF3QixPQUF4QixDQUFKLEVBQXNDO0FBQ3BDLGtCQUFNLFFBQU4sQ0FBZSxjQUFmLENBQThCLE9BQTlCLEVBQXVDLElBQXZDLENBQTRDLFVBQUMsT0FBRCxFQUFhO0FBQ3ZELHNCQUFRLE9BQVI7QUFDRCxhQUZELEVBRUcsVUFBQyxLQUFELEVBQVc7QUFDWixxQkFBTyxLQUFQO0FBQ0QsYUFKRDtBQUtELFdBTkQsTUFNTztBQUNMLG9CQUFRLE9BQVI7QUFDRDtBQUNGO0FBQ0YsT0F4Qk0sQ0FBUDtBQXlCRDs7OzJDQUVzQixPLEVBQVM7QUFDOUIsVUFBSSxRQUFRLElBQVo7QUFDQSxhQUFPLHNCQUFZLFVBQVMsT0FBVCxFQUFrQixNQUFsQixFQUEwQjtBQUMzQyxZQUFJLEtBQUssUUFBUSxFQUFSLENBQVcsS0FBWCxDQUFpQixHQUFqQixDQUFUO0FBQ0EsWUFBSSxZQUFZLEdBQUcsT0FBSCxDQUFXLGNBQVgsQ0FBaEI7QUFDQSxZQUFJLDJCQUEyQixjQUFjLENBQUMsQ0FBOUM7QUFDQSxZQUFJLGlCQUFpQixNQUFNLGNBQU4sQ0FBcUIsUUFBUSxJQUE3QixDQUFyQjtBQUNBLFlBQUksMkJBQTJCLGNBQS9CLEVBQStDO0FBQUE7QUFDN0MsZUFBRyxHQUFIO0FBQ0EsZ0JBQUksZ0JBQWdCLEdBQUcsQ0FBSCxJQUFRLElBQVIsR0FBZSxHQUFHLENBQUgsQ0FBZixHQUF1QixHQUF2QixHQUE2QixHQUFHLENBQUgsQ0FBakQ7QUFDQSxrQkFBTSxRQUFOLENBQWUsc0JBQWYsQ0FBc0MsYUFBdEMsRUFBcUQsUUFBUSxJQUFSLENBQWEsVUFBbEUsRUFBOEUsSUFBOUUsQ0FBbUYsWUFBTTtBQUN2RixvQkFBTSxlQUFOLENBQXNCLGtCQUF0QixDQUF5QyxhQUF6QyxFQUF3RCxRQUFRLElBQVIsQ0FBYSxVQUFyRTtBQUNBO0FBQ0QsYUFIRCxFQUdHLFVBQUMsS0FBRCxFQUFXO0FBQ1oscUJBQU8sS0FBUDtBQUNELGFBTEQ7QUFINkM7QUFTOUM7QUFDRixPQWZNLENBQVA7QUFnQkQ7OztrQ0FFYTtBQUNaLFVBQUksYUFBYSxLQUFLLFFBQUwsQ0FBYyxhQUFkLEVBQWpCO0FBQ0EsVUFBSSxTQUFTLEVBQWI7O0FBRUEsV0FBSyxJQUFJLENBQVQsSUFBYyxVQUFkLEVBQTBCO0FBQ3hCLGVBQU8sSUFBUCxDQUFZLGdDQUFvQixXQUFXLENBQVgsRUFBYyxRQUFsQyxDQUFaO0FBQ0Q7O0FBRUQsYUFBTyxNQUFQO0FBQ0Q7OztxQ0FFZ0I7QUFDZixVQUFJLFlBQVksS0FBSyxlQUFMLENBQXFCLGFBQXJDO0FBQ0EsVUFBSSxpQkFBaUIsRUFBckI7O0FBRUEsV0FBSyxJQUFJLENBQVQsSUFBYyxTQUFkLEVBQXlCO0FBQ3ZCLFlBQUksY0FBYyxVQUFVLENBQVYsRUFBYSxVQUEvQjtBQUNBLFlBQUksZUFBZSxPQUFmLENBQXVCLFdBQXZCLE1BQXdDLENBQUMsQ0FBN0MsRUFBZ0Q7QUFDOUMseUJBQWUsSUFBZixDQUFvQixXQUFwQjtBQUNEO0FBQ0Y7O0FBRUQsYUFBTyxjQUFQO0FBQ0Q7Ozs2Q0FFd0IsTyxFQUFTLFUsRUFBWTtBQUM1QyxVQUFJLGVBQUo7O0FBRUEsVUFBSSxVQUFKLEVBQWdCO0FBQ2QsWUFBSSxZQUFZLEtBQUssZUFBTCxDQUFxQixjQUFyQixDQUFvQyxRQUFRLEVBQTVDLENBQWhCO0FBQ0EsaUJBQVMsS0FBSyxxQkFBTCxDQUEyQixTQUEzQixDQUFUO0FBQ0QsT0FIRCxNQUdPO0FBQ0wsWUFBSSxjQUFjLEtBQUssZUFBTCxDQUFxQixjQUFyQixDQUFvQyxRQUFRLElBQTVDLENBQWxCO0FBQ0EsaUJBQVMsS0FBSyxxQkFBTCxDQUEyQixXQUEzQixDQUFUO0FBQ0Q7QUFDRCxhQUFPLE1BQVA7QUFDRDs7O21DQUVjLEksRUFBTTtBQUNuQixVQUFJLFlBQVksS0FBSyxLQUFMLENBQVcsS0FBWCxDQUFoQjtBQUNBLGFBQU8sVUFBVSxDQUFWLE1BQWlCLFNBQWpCLElBQThCLFNBQVMsS0FBSyxlQUFMLENBQXFCLFVBQXJCLEdBQWtDLEtBQWhGO0FBQ0Q7OzsrQkFFVSxPLEVBQVM7QUFDbEIsVUFBSSxrQkFBa0IsQ0FBQyxZQUFELEVBQWUsU0FBZixFQUEwQixRQUExQixDQUF0QjtBQUNBLFVBQUksWUFBYSxRQUFRLElBQVQsQ0FBZSxLQUFmLENBQXFCLEtBQXJCLENBQWhCO0FBQ0EsVUFBSSxhQUFhLFVBQVUsQ0FBVixDQUFqQjs7QUFFQSxhQUFPLGdCQUFnQixPQUFoQixDQUF3QixVQUF4QixNQUF3QyxDQUFDLENBQWhEO0FBQ0Q7OzsyQkFFTSxHLEVBQUs7QUFDVixVQUFJLFdBQVcsSUFBSSxLQUFKLENBQVUsR0FBVixDQUFmO0FBQ0EsYUFBTyxTQUFTLENBQVQsSUFBYyxJQUFkLEdBQXFCLFNBQVMsQ0FBVCxDQUFyQixHQUFtQyxHQUFuQyxHQUF5QyxTQUFTLENBQVQsQ0FBaEQ7QUFDRDs7O2lDQUVZLE8sRUFBUztBQUNwQixVQUFJLFFBQVEsSUFBUixLQUFpQixRQUFyQixFQUErQjtBQUM3QixlQUFPLEtBQUssUUFBTCxDQUFjLG9CQUFkLENBQW1DLFFBQVEsSUFBUixDQUFhLE1BQWhELENBQVA7QUFDRDs7QUFFRCxVQUFJLFFBQVEsSUFBUixLQUFpQixVQUFqQixJQUErQixRQUFRLElBQVIsQ0FBYSxNQUFiLEtBQXdCLFNBQTNELEVBQXNFO0FBQ3BFLGVBQU8sS0FBSyxRQUFMLENBQWMsb0JBQWQsQ0FBbUMsUUFBUSxJQUFSLENBQWEsTUFBaEQsQ0FBUDtBQUNEOztBQUVELFVBQUksc0JBQVUsUUFBUSxJQUFsQixFQUF3QixJQUF4QixLQUFpQyxTQUFyQyxFQUFnRDtBQUM5QyxlQUFPLEtBQUssUUFBTCxDQUFjLG9CQUFkLENBQW1DLFFBQVEsSUFBM0MsQ0FBUDtBQUNELE9BRkQsTUFFTztBQUNMLGVBQU8sS0FBSyxRQUFMLENBQWMsb0JBQWQsQ0FBbUMsS0FBSyxNQUFMLENBQVksUUFBUSxJQUFwQixDQUFuQyxDQUFQO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7OztzQ0FPa0IsTyxFQUFTO0FBQ3pCLFVBQUksV0FBVyxRQUFRLElBQVIsS0FBaUIsUUFBaEM7QUFDQSxVQUFJLGdCQUFnQixzQkFBVSxRQUFRLElBQWxCLEVBQXdCLElBQXhCLEtBQWlDLFNBQXJEO0FBQ0EsVUFBSSxjQUFjLHNCQUFVLFFBQVEsRUFBbEIsRUFBc0IsSUFBdEIsS0FBK0IsU0FBakQ7QUFDQSxVQUFJLGlCQUFpQiw0QkFBZ0IsUUFBUSxFQUF4QixDQUFyQjs7QUFFQSxhQUFRLFlBQVksYUFBWixJQUE2QixXQUE5QixJQUErQyxZQUFZLGFBQVosSUFBNkIsY0FBNUUsSUFBK0YsUUFBUSxJQUFSLEtBQWlCLFdBQWhILElBQStILFFBQVEsSUFBUixLQUFpQixRQUF2SjtBQUNEOztBQUVEOzs7Ozs7O3dDQUlvQjtBQUFBOztBQUNsQixVQUFJLFFBQVEsSUFBWjs7QUFFQSxhQUFPLHNCQUFZLFVBQUMsT0FBRCxFQUFVLE1BQVYsRUFBcUI7O0FBRXRDLGNBQU0sY0FBTixDQUFxQixHQUFyQixDQUF5QixzQkFBekIsRUFBaUQsSUFBakQsQ0FBc0QsVUFBQyxLQUFELEVBQVc7QUFDL0QsY0FBSSxXQUFXLEtBQWY7QUFDQSxjQUFJLGFBQWEsU0FBakIsRUFBNEI7QUFDMUIsaUJBQUssSUFBSSxDQUFULElBQWMsUUFBZCxFQUF3QjtBQUN0QixxQkFBSyxHQUFMLENBQVMsU0FBVCxDQUFtQixNQUFuQixFQUEyQixDQUEzQixFQUE4QixTQUFTLENBQVQsQ0FBOUI7QUFDRDtBQUNGO0FBQ0Q7QUFDRCxTQVJEO0FBU0QsT0FYTSxDQUFQO0FBYUQ7OzsyQ0FFc0IsRyxFQUFLO0FBQzFCLFVBQUksUUFBUSxJQUFJLEtBQUosQ0FBVSxHQUFWLENBQVo7QUFDQSxhQUFPLE1BQU0sTUFBTSxNQUFOLEdBQWUsQ0FBckIsQ0FBUDtBQUNEOzs7cUNBRWdCLFEsRUFBVTtBQUN6QixXQUFLLElBQUksQ0FBVCxJQUFjLFFBQWQsRUFBd0I7QUFDdEIsWUFBSSxxQkFBcUIsU0FBUyxDQUFULEVBQVksa0JBQXJDO0FBQ0EsWUFBSSxzREFBSixFQUFrRDtBQUNoRCxtQkFBUyxDQUFULEVBQVksa0JBQVosR0FBaUMsZ0JBQWpDO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsY0FBSSxzREFBSixFQUFrRDtBQUNoRCxxQkFBUyxDQUFULEVBQVksa0JBQVosR0FBaUMsZ0JBQWpDO0FBQ0QsV0FGRCxNQUVPO0FBQ0wsZ0JBQUksdURBQUosRUFBbUQ7QUFDakQsdUJBQVMsQ0FBVCxFQUFZLGtCQUFaLEdBQWlDLGlCQUFqQztBQUNELGFBRkQsTUFFTztBQUNMLHVCQUFTLENBQVQsRUFBWSxrQkFBWixHQUFpQyxTQUFqQztBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELGFBQU8sUUFBUDtBQUNEOzs7dUNBRWtCO0FBQUE7O0FBQ2pCLFVBQUksUUFBUSxJQUFaOztBQUVBLGFBQU8sc0JBQVksVUFBQyxPQUFELEVBQVUsTUFBVixFQUFxQjtBQUN0QyxjQUFNLGNBQU4sQ0FBcUIsR0FBckIsQ0FBeUIsc0JBQXpCLEVBQWlELENBQWpELEVBQW9ELE9BQUssZ0JBQXpELEVBQTJFLElBQTNFLENBQWdGLFlBQU07QUFDcEY7QUFDRCxTQUZEO0FBR0QsT0FKTSxDQUFQO0FBS0Q7OztpQ0FFWTtBQUFBOztBQUNYLFVBQUksUUFBUSxJQUFaOztBQUVBLGFBQU8sc0JBQVksVUFBQyxPQUFELEVBQVUsTUFBVixFQUFxQjtBQUN0QyxjQUFNLGNBQU4sQ0FBcUIsR0FBckIsQ0FBeUIsZ0JBQXpCLEVBQTJDLENBQTNDLEVBQThDLE9BQUssTUFBbkQsRUFBMkQsSUFBM0QsQ0FBZ0UsWUFBTTtBQUNwRTtBQUNELFNBRkQ7QUFHRCxPQUpNLENBQVA7QUFLRDs7O2lDQUVZLE0sRUFBUSxNLEVBQVEsRyxFQUFLO0FBQ2hDLFVBQUkscUJBQUo7O0FBRUEsY0FBUSxNQUFSO0FBQ0UsYUFBSyxNQUFMO0FBQ0UseUJBQWUseUJBQWUsS0FBSyxZQUFwQixDQUFmO0FBQ0EseUJBQWUsS0FBSyxnQkFBTCxDQUFzQixLQUFLLEtBQUwsQ0FBVyxZQUFYLENBQXRCLENBQWY7QUFDQSxlQUFLLGNBQUwsQ0FBb0IsR0FBcEIsQ0FBd0Isc0JBQXhCLEVBQWdELENBQWhELEVBQW1ELFlBQW5EO0FBQ0E7QUFDRixhQUFLLGtCQUFMO0FBQ0UsY0FBSSxXQUFXLFNBQVgsR0FBdUIsUUFBUSxTQUFuQyxFQUE4QztBQUM1QyxpQkFBSyxxQkFBTCxDQUEyQixHQUEzQixJQUFrQyxNQUFsQztBQUNEO0FBQ0QseUJBQWUseUJBQWUsS0FBSyxxQkFBcEIsQ0FBZjtBQUNBLHlCQUFlLEtBQUssZ0JBQUwsQ0FBc0IsS0FBSyxLQUFMLENBQVcsWUFBWCxDQUF0QixDQUFmO0FBQ0EsZUFBSyxjQUFMLENBQW9CLEdBQXBCLENBQXdCLG9CQUF4QixFQUE4QyxDQUE5QyxFQUFpRCxZQUFqRDtBQUNBO0FBQ0Y7QUFDRSxnQkFBTSxNQUFNLDRCQUE0QixNQUFsQyxDQUFOO0FBZko7QUFpQkQ7OztxQ0FFZ0I7QUFDZixVQUFJLFdBQVcsS0FBSyxNQUFwQjtBQUNBLFVBQUksY0FBYyxFQUFsQjtBQUNBLFVBQUksYUFBYSxTQUFqQixFQUE0QjtBQUMxQixhQUFLLElBQUksU0FBVCxJQUFzQixRQUF0QixFQUFnQztBQUM5QixzQkFBWSxJQUFaLENBQWlCLFNBQWpCO0FBQ0Q7QUFDRjtBQUNELGFBQU8sV0FBUDtBQUNEOzs7NkJBRVEsUyxFQUFXLFcsRUFBYTtBQUMvQixVQUFJLFVBQVUsRUFBZDs7QUFFQSxVQUFJLGNBQWMsZUFBbEIsRUFBbUM7QUFDakMsWUFBSSxnQkFBZ0IsWUFBWSxLQUFaLENBQWtCLEdBQWxCLENBQXBCO0FBQ0Esc0JBQWMsR0FBZDtBQUNBLHdCQUFnQixjQUFjLENBQWQsSUFBbUIsSUFBbkIsR0FBMEIsY0FBYyxDQUFkLENBQTFDO0FBQ0Esa0JBQVUsS0FBSyxlQUFMLENBQXFCLHFCQUFyQixDQUEyQyxhQUEzQyxDQUFWO0FBQ0QsT0FMRCxNQUtPO0FBQ0wsWUFBSSxLQUFLLE1BQUwsQ0FBWSxTQUFaLE1BQTJCLFNBQS9CLEVBQTBDO0FBQ3hDLG9CQUFVLEtBQUssTUFBTCxDQUFZLFNBQVosQ0FBVjtBQUNEO0FBQ0Y7O0FBRUQsYUFBTyxPQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Z0NBSVksUyxFQUFXO0FBQ3JCLFdBQUssTUFBTCxDQUFZLFNBQVosSUFBeUIsRUFBekI7QUFDQSxXQUFLLFVBQUw7QUFDRDs7O2dDQUVXLFMsRUFBVztBQUNyQixhQUFPLEtBQUssTUFBTCxDQUFZLFNBQVosQ0FBUDtBQUNBLFdBQUssVUFBTDtBQUNEOztBQUVEOzs7Ozs7OzsrQkFLVyxTLEVBQVcsUyxFQUFXO0FBQy9CLFVBQUksV0FBVyxLQUFLLE1BQXBCO0FBQ0EsVUFBSSxTQUFTLFNBQVQsTUFBd0IsU0FBNUIsRUFBdUM7QUFDckMsWUFBSSxTQUFTLFNBQVQsRUFBb0IsT0FBcEIsQ0FBNEIsU0FBNUIsTUFBMkMsQ0FBQyxDQUFoRCxFQUFtRDtBQUNqRCxtQkFBUyxTQUFULEVBQW9CLElBQXBCLENBQXlCLFNBQXpCO0FBQ0EsZUFBSyxVQUFMO0FBQ0Q7QUFDRixPQUxELE1BS087QUFDTCxjQUFNLE1BQU0sWUFBWSxTQUFaLEdBQXdCLG1CQUE5QixDQUFOO0FBQ0Q7QUFDRjs7O29DQUVlLFMsRUFBVyxTLEVBQVc7QUFDcEMsVUFBSSxRQUFRLEtBQUssTUFBTCxDQUFZLFNBQVosQ0FBWjs7QUFFQSxZQUFNLE1BQU4sQ0FBYSxNQUFNLE9BQU4sQ0FBYyxTQUFkLENBQWIsRUFBdUMsQ0FBdkM7QUFDQSxXQUFLLFVBQUw7QUFDRDs7O3dCQXZZa0I7QUFDakIsYUFBTyxLQUFLLGFBQVo7QUFDRCxLO3NCQUVnQixNLEVBQVE7QUFDdkIsV0FBSyxhQUFMLEdBQXFCLE9BQU8sT0FBUCxDQUFlLElBQWYsQ0FBb0IsVUFBekM7QUFDRDs7Ozs7a0JBcVlZLGM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZZZjs7Ozs7O0FBRUE7Ozs7SUFJTSxlOzs7QUFFSiwyQkFBWSxFQUFaLEVBQWdCLEdBQWhCLEVBQXFCLGFBQXJCLEVBQW1DLFVBQW5DLEVBQStDLFVBQS9DLEVBQTJELElBQTNELEVBQWlFLElBQWpFLEVBQXVFLE9BQXZFLEVBQWdGLE9BQWhGLEVBQXlGO0FBQUE7O0FBQUEseUpBQ2pGLEVBRGlGLEVBQzdFLEdBRDZFLEVBQ3hFLGFBRHdFOztBQUV2RixRQUFJLGNBQUo7QUFDQSxVQUFNLFdBQU4sR0FBb0IsVUFBcEI7QUFDQSxVQUFNLFdBQU4sR0FBb0IsVUFBcEI7QUFDQSxVQUFNLEtBQU4sR0FBYyxJQUFkO0FBQ0EsVUFBTSxLQUFOLEdBQWMsSUFBZDtBQUNBLFVBQU0sUUFBTixHQUFpQixPQUFqQjtBQUNBLFVBQU0sUUFBTixHQUFpQixPQUFqQjtBQVJ1RjtBQVN4Rjs7OztzQkFFUSxRLEVBQVU7QUFDakIsVUFBSSxRQUFRLElBQVo7QUFDQSxZQUFNLElBQU4sR0FBYSxRQUFiO0FBQ0QsSzt3QkFFVTtBQUNULFVBQUksUUFBUSxJQUFaO0FBQ0EsYUFBTyxNQUFNLEtBQWI7QUFDRDs7O3dCQUVnQjtBQUNmLFVBQUksUUFBUSxJQUFaO0FBQ0EsYUFBTyxNQUFNLFdBQWI7QUFDRDs7O3dCQUVnQjtBQUNmLFVBQUksUUFBUSxJQUFaO0FBQ0EsYUFBTyxNQUFNLFdBQWI7QUFDRDs7O3dCQUVnQjtBQUNmLFVBQUksUUFBUSxJQUFaO0FBQ0EsYUFBTyxNQUFNLFdBQU4sQ0FBa0IsV0FBekI7QUFDRDs7O2dDQWhFSDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tCQW1FZSxlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0NmOzs7O0FBQ0E7Ozs7QUFFQTs7QUFDQTs7OztBQTFCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTRCQSxJQUFNLFNBQVMsRUFBRSxVQUFVLFVBQVosRUFBd0IsVUFBVSxhQUFsQyxFQUFmOztBQUVBOzs7QUFHQTs7OztJQUdNLFE7O0FBRUo7Ozs7Ozs7OztBQVNBLG9CQUFZLFVBQVosRUFBd0IsVUFBeEIsRUFBb0MsY0FBcEMsRUFBb0QsZ0JBQXBELEVBQXNFLG1CQUF0RSxFQUEyRixjQUEzRixFQUEyRyxjQUEzRyxFQUEySDtBQUFBOzs7QUFFekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFJLENBQUMsVUFBTCxFQUFpQixNQUFNLElBQUksS0FBSixDQUFVLHdCQUFWLENBQU47QUFDakIsUUFBSSxDQUFDLGNBQUwsRUFBcUIsTUFBTSxJQUFJLEtBQUosQ0FBVSw0QkFBVixDQUFOO0FBQ3JCOztBQUVBLFFBQUksUUFBUSxJQUFaOztBQUVBLFVBQU0sV0FBTixHQUFvQixhQUFhLFlBQWpDO0FBQ0EsVUFBTSxVQUFOLEdBQW1CLFVBQW5CO0FBQ0EsVUFBTSxVQUFOLEdBQW1CLFVBQW5CO0FBQ0EsVUFBTSxnQkFBTixHQUF5QixnQkFBekI7QUFDQSxVQUFNLGNBQU4sR0FBdUIsY0FBdkI7QUFDQSxVQUFNLFFBQU4sR0FBaUIsY0FBakI7QUFDQSxVQUFNLGNBQU4sR0FBdUIsY0FBdkI7QUFDQSxVQUFNLG1CQUFOLEdBQTRCLG1CQUE1QjtBQUNBLFVBQU0sVUFBTixHQUFtQixLQUFLLEtBQUwsQ0FBWSxLQUFLLE1BQUwsS0FBZ0IsS0FBakIsR0FBMEIsQ0FBckMsQ0FBbkI7O0FBRUE7QUFDQTtBQUNBLFVBQU0sV0FBTixHQUFvQixJQUFwQjs7QUFFQSxVQUFNLHFCQUFOLEdBQThCLEVBQTlCO0FBQ0EsVUFBTSxhQUFOLEdBQXNCLEVBQXRCO0FBQ0EsVUFBTSxjQUFOLEdBQXVCLEVBQXZCO0FBQ0EsVUFBTSxZQUFOLEdBQXFCLEVBQXJCO0FBQ0EsVUFBTSxjQUFOLEdBQXVCLEVBQXZCO0FBQ0EsVUFBTSx3QkFBTixHQUFpQyxFQUFqQztBQUNBLFVBQU0sYUFBTixHQUFzQixFQUFDLFNBQVMsRUFBVixFQUFjLFlBQVksRUFBMUIsRUFBdEI7QUFDQSxVQUFNLE9BQU4sR0FBZ0IsRUFBaEI7O0FBRUEsVUFBTSxPQUFOLEdBQWdCLHNCQUFVLE1BQU0sV0FBaEIsRUFBNkIsTUFBN0M7QUFDQSxVQUFNLGFBQU4sQ0FBb0IsVUFBcEIsQ0FBK0IsVUFBL0IsSUFBNkMsVUFBN0M7QUFDQSxRQUFJLGFBQWEsbUNBQW1CLE9BQW5CLEVBQTRCLElBQTVCLENBQWpCO0FBQ0EsVUFBTSxjQUFOLEdBQXVCLFVBQXZCO0FBQ0Q7Ozs7OztBQWlERDs7Ozs7Ozs7QUFRQTsyQ0FDdUIsSyxFQUFPLE0sRUFBUTtBQUNwQyxVQUFJLFFBQVEsSUFBWjtBQUNBLFVBQUkscUJBQUo7O0FBRUEsVUFBSSxDQUFDLE1BQUwsRUFBYTtBQUNYLHVCQUFlLE1BQU0sT0FBckI7QUFDRCxPQUZELE1BRU87QUFDTCx1QkFBZSxNQUFmO0FBQ0Q7O0FBRUQsVUFBSSxjQUFjLFlBQVksTUFBTSxTQUFOLENBQWdCLE1BQU0sT0FBTixDQUFjLEdBQWQsSUFBcUIsQ0FBckMsRUFBd0MsTUFBTSxNQUE5QyxDQUFaLEdBQW9FLEdBQXBFLEdBQTBFLE1BQU0sU0FBTixDQUFnQixDQUFoQixFQUFtQixNQUFNLE9BQU4sQ0FBYyxHQUFkLENBQW5CLENBQTVGOztBQUVBO0FBQ0EsVUFBSSxVQUFVO0FBQ1osY0FBTSxNQURNLEVBQ0UsTUFBTSxNQUFNLFdBRGQsRUFDMkIsSUFBSSx1QkFBdUIsWUFBdkIsR0FBc0MsR0FEckUsRUFDMEUsTUFBTSxFQUFFLFVBQVUsV0FBWjtBQURoRixPQUFkOztBQUlBLGNBQVEsR0FBUixDQUFZLFdBQVosRUFBeUIsT0FBekIsRUFBa0MsWUFBbEMsRUFBZ0QsV0FBaEQ7O0FBRUE7QUFDQSxhQUFPLHNCQUFZLFVBQVMsT0FBVCxFQUFrQixNQUFsQixFQUEwQjs7QUFFM0MsY0FBTSxXQUFOLENBQWtCLFdBQWxCLENBQThCLE9BQTlCLEVBQXVDLFVBQUMsS0FBRCxFQUFXO0FBQ2hELGtCQUFRLEdBQVIsQ0FBWSxlQUFaLEVBQTZCLEtBQTdCOztBQUVBLGNBQUksZ0JBQUo7QUFDQSxjQUFJLG1CQUFKO0FBQ0EsY0FBSSxvQkFBSjtBQUNBLGNBQUksUUFBUSxNQUFNLElBQU4sQ0FBVyxLQUF2Qjs7QUFFQSxlQUFLLE9BQUwsSUFBZ0IsS0FBaEIsRUFBdUI7QUFDckIsZ0JBQUksTUFBTSxPQUFOLEVBQWUsWUFBZixLQUFnQyxTQUFwQyxFQUErQztBQUM3QyxrQkFBSSxlQUFlLFNBQW5CLEVBQThCO0FBQzVCLDZCQUFhLElBQUksSUFBSixDQUFTLE1BQU0sT0FBTixFQUFlLFlBQXhCLENBQWI7QUFDQSw4QkFBYyxPQUFkO0FBQ0QsZUFIRCxNQUdPO0FBQ0wsb0JBQUksY0FBYyxJQUFJLElBQUosQ0FBUyxNQUFNLE9BQU4sRUFBZSxZQUF4QixDQUFsQjtBQUNBLG9CQUFJLFdBQVcsT0FBWCxLQUF1QixZQUFZLE9BQVosRUFBM0IsRUFBa0Q7QUFDaEQsK0JBQWEsV0FBYjtBQUNBLGdDQUFjLE9BQWQ7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7QUFFRCxrQkFBUSxHQUFSLENBQVksZ0JBQVosRUFBOEIsV0FBOUIsRUFBMkMsVUFBM0M7O0FBRUEsY0FBSSxhQUFhLFdBQWpCOztBQUVBLGNBQUksZUFBZSxTQUFuQixFQUE4QjtBQUM1QixtQkFBTyxPQUFPLHdCQUFQLENBQVA7QUFDRDs7QUFFRCxjQUFJLFlBQVk7QUFDZCxnQkFBSSxLQURVO0FBRWQsd0JBQVksTUFBTSxVQUFOLEVBQWtCLFVBRmhCO0FBR2Qsd0JBQVk7QUFIRSxXQUFoQjs7QUFNQSxrQkFBUSxHQUFSLENBQVksdUNBQVosRUFBcUQsU0FBckQ7QUFDQSxrQkFBUSxTQUFSO0FBQ0QsU0F2Q0Q7QUF3Q0QsT0ExQ00sQ0FBUDtBQTJDRDs7OzJDQUVzQixJLEVBQU0sVSxFQUFZO0FBQ3ZDLFVBQUksUUFBUSxJQUFaOztBQUVBLFdBQUssSUFBSSxPQUFULElBQW9CLE1BQU0sYUFBMUIsRUFBeUM7QUFDdkMsWUFBSSxRQUFRLE1BQU0sYUFBTixDQUFvQixPQUFwQixDQUFaO0FBQ0EsWUFBSSxNQUFNLFdBQU4sS0FBc0IsVUFBMUIsRUFBc0M7QUFDcEMsa0JBQVEsSUFBUjtBQUNFLGlCQUFLLFVBQUw7QUFDRSxxQkFBTyxNQUFNLEtBQU4sQ0FBWSxRQUFuQjtBQUNGLGlCQUFLLElBQUw7QUFDRSxxQkFBTyxNQUFNLEtBQU4sQ0FBWSxFQUFuQjtBQUNGLGlCQUFLLFFBQUw7QUFDRSxxQkFBTyxNQUFNLEtBQU4sQ0FBWSxNQUFuQjtBQUNGLGlCQUFLLFFBQUw7QUFDRSxxQkFBTyxNQUFNLEtBQU4sQ0FBWSxNQUFuQjtBQUNGLGlCQUFLLFNBQUw7QUFDRSxxQkFBTyxNQUFNLEtBQU4sQ0FBWSxPQUFuQjtBQUNGLGlCQUFLLEdBQUw7QUFDRSxxQkFBTyxNQUFNLEtBQWI7QUFDRjtBQUNFLHFCQUFPLEVBQVA7QUFkSjtBQWdCRDtBQUNGO0FBQ0QsYUFBTyxFQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OzZDQUt5QixHLEVBQUssTSxFQUFROztBQUVwQyxVQUFJLFFBQVEsSUFBWjs7QUFFQSxhQUFPLHNCQUFZLFVBQVMsT0FBVCxFQUFrQixNQUFsQixFQUEwQjs7QUFFM0MsWUFBSSxxQkFBSjs7QUFFQSxZQUFJLENBQUMsTUFBTCxFQUFhO0FBQ1gseUJBQWUsTUFBTSxPQUFyQjtBQUNELFNBRkQsTUFFTztBQUNMLHlCQUFlLE1BQWY7QUFDRDs7QUFFRCxZQUFJLE1BQU07QUFDUixnQkFBTSxNQURFLEVBQ00sTUFBTSxNQUFNLFdBRGxCLEVBQytCLElBQUksdUJBQXVCLFlBQXZCLEdBQXNDLEdBRHpFLEVBQzhFLE1BQU0sRUFBRSxVQUFVLEdBQVo7QUFEcEYsU0FBVjs7QUFJQSxjQUFNLFdBQU4sQ0FBa0IsV0FBbEIsQ0FBOEIsR0FBOUIsRUFBbUMsVUFBQyxLQUFELEVBQVc7O0FBRTVDLGNBQUksYUFBYSxNQUFNLElBQU4sQ0FBVyxLQUE1Qjs7QUFFQSxjQUFJLFVBQUosRUFBZ0I7QUFDZCxvQkFBUSxVQUFSO0FBQ0QsV0FGRCxNQUVPO0FBQ0wsbUJBQU8sc0JBQVA7QUFDRDtBQUNGLFNBVEQ7QUFVRCxPQXhCTSxDQUFQO0FBeUJEOztBQUVEOzs7Ozs7b0NBR2dCO0FBQ2QsVUFBSSxRQUFRLElBQVo7QUFDQSxhQUFPLE1BQU0sVUFBYjtBQUNEOztBQUVEOzs7Ozs7OztvQ0FLZ0IsVSxFQUFZOztBQUUxQixVQUFJLFFBQVEsSUFBWjtBQUNBLFVBQUksZ0JBQUo7O0FBRUEsV0FBSyxJQUFJLEtBQVQsSUFBa0IsTUFBTSxhQUF4QixFQUF1QztBQUNyQyxZQUFJLFVBQVUsTUFBTSxhQUFOLENBQW9CLEtBQXBCLENBQWQ7QUFDQSxZQUFJLFFBQVEsVUFBUixLQUF1QixVQUEzQixFQUF1QztBQUNyQyxvQkFBVSxRQUFRLElBQVIsQ0FBYSxPQUF2QjtBQUNEO0FBQ0Y7QUFDRCxhQUFPLE9BQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7bUNBS2UsRyxFQUFLO0FBQ2xCLFVBQUksUUFBUSxJQUFaOztBQUVBLFVBQUksZUFBZSxzQkFBVSxHQUFWLEVBQWUsSUFBZixLQUF3QixTQUEzQzs7QUFFQTtBQUNBLFVBQUksb0JBQUo7O0FBRUE7QUFDQSxVQUFJLGFBQWMsWUFBRCxHQUFpQixhQUFhLEdBQTlCLEdBQW9DLE1BQU0sd0JBQU4sQ0FBK0IsR0FBL0IsQ0FBckQ7O0FBRUEsV0FBSyxJQUFJLEtBQVQsSUFBa0IsTUFBTSxhQUF4QixFQUF1QztBQUNyQyxZQUFJLFVBQVUsTUFBTSxhQUFOLENBQW9CLEtBQXBCLENBQWQ7QUFDQSxZQUFJLFFBQVEsVUFBUixLQUF1QixVQUEzQixFQUF1QztBQUNyQyx3QkFBYyxRQUFRLFVBQXRCO0FBQ0E7QUFDRDtBQUNGO0FBQ0QsYUFBTyxXQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O21DQUtlLGEsRUFBZTtBQUM1QixVQUFJLFFBQVEsSUFBWjs7QUFFQSxVQUFJLGFBQWEsTUFBTSxjQUFOLENBQXFCLGFBQXJCLENBQWpCOztBQUVBLGFBQU8sc0JBQVksVUFBUyxPQUFULEVBQWtCLE1BQWxCLEVBQTBCO0FBQzNDLFlBQUksVUFBSixFQUFnQjtBQUNkLGtCQUFRLFdBQVcsUUFBbkI7QUFDRCxTQUZELE1BRU87QUFDTCxpQkFBTyx1QkFBUDtBQUNEO0FBQ0YsT0FOTSxDQUFQO0FBT0Q7O0FBRUQ7Ozs7Ozs7OzZDQUt5QixhLEVBQWU7QUFDdEMsVUFBSSxRQUFRLElBQVo7O0FBRUEsVUFBSSxhQUFhLE1BQU0sY0FBTixDQUFxQixhQUFyQixDQUFqQjs7QUFFQSxhQUFRLFVBQUQsR0FBZSxXQUFXLFFBQTFCLEdBQXFDLFNBQTVDO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O21EQUsrQixHLEVBQUs7QUFDbEMsVUFBSSxRQUFRLElBQVo7O0FBRUEsYUFBTyxNQUFNLHdCQUFOLENBQStCLEdBQS9CLENBQVA7QUFDRDs7QUFFRDs7Ozs7OztpREFJNkIsYSxFQUFlLFUsRUFBWTtBQUN0RCxVQUFJLFFBQVEsSUFBWjtBQUNBLFVBQUksTUFBTSx3QkFBTixDQUErQixhQUEvQixNQUFrRCxTQUF0RCxFQUFpRTtBQUMvRCxjQUFNLHdCQUFOLENBQStCLGFBQS9CLElBQWdELFVBQWhEO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7MENBS3NCLGEsRUFBZTtBQUNuQyxVQUFJLFFBQVEsSUFBWjtBQUNBLFVBQUksYUFBYSxNQUFNLGNBQU4sQ0FBcUIsYUFBckIsQ0FBakI7QUFDQSxVQUFJLFVBQVUsRUFBZDs7QUFFQSxVQUFJLFVBQUosRUFBZ0I7QUFDZCxrQkFBVSxXQUFXLE9BQXJCO0FBQ0Q7QUFDRCxhQUFPLE9BQVA7QUFDRDs7QUFFRDs7Ozs7Ozs2Q0FJeUI7QUFDdkIsVUFBSSxRQUFRLElBQVo7O0FBRUEsVUFBSSxvQkFBb0IsRUFBeEI7O0FBRUEsYUFBTyxzQkFBWSxVQUFTLE9BQVQsRUFBaUIsTUFBakIsRUFBeUI7O0FBRTFDLGFBQUssSUFBSSxLQUFULElBQWtCLE1BQU0sYUFBeEIsRUFBdUM7QUFDckMsY0FBSSxVQUFVLE1BQU0sYUFBTixDQUFvQixLQUFwQixDQUFkO0FBQ0EsY0FBSSxTQUFTLE1BQU0seUJBQU4sQ0FBZ0MsUUFBUSxJQUFSLENBQWEsT0FBN0MsRUFBc0QsUUFBUSxVQUE5RCxDQUFiO0FBQ0EsNEJBQWtCLElBQWxCLENBQXVCLE1BQXZCO0FBQ0Q7O0FBRUQsMEJBQVEsR0FBUixDQUFZLGlCQUFaLEVBQStCLElBQS9CLENBQW9DLFlBQU07O0FBRXhDLGtCQUFRLHlDQUFSO0FBQ0QsU0FIRCxFQUdHLGlCQUFTO0FBQUUsaUJBQU8sS0FBUDtBQUFlLFNBSDdCO0FBSUQsT0FaTSxDQUFQO0FBYUQ7O0FBRUQ7Ozs7Ozs7Ozs4Q0FNMEIsSSxFQUFNLGUsRUFBaUI7QUFDL0M7QUFDQSxVQUFJLFFBQVEsSUFBWjs7QUFFQSxVQUFJLFVBQVUsRUFBRSxNQUFNLFFBQVIsRUFBa0IsTUFBTSxNQUFNLFdBQTlCO0FBQ0UsWUFBSSx1QkFBdUIsTUFBTSxPQUE3QixHQUF1QyxHQUQ3QztBQUVFLGNBQU0sRUFBRSxPQUFPLEVBQUMsTUFBTSxJQUFQLEVBQWEsS0FBSyxlQUFsQixFQUFULEVBRlIsRUFBZDs7QUFJQSxZQUFNLFdBQU4sQ0FBa0IsV0FBbEIsQ0FBOEIsT0FBOUIsRUFBdUMsVUFBQyxLQUFELEVBQVc7QUFDaEQsZ0JBQVEsR0FBUixDQUFZLDBCQUFaLEVBQXdDLEtBQXhDO0FBQ0QsT0FGRDtBQUdEOztBQUVEOzs7Ozs7OzZDQUl5QixJLEVBQU07QUFDN0IsVUFBSSxRQUFRLElBQVo7O0FBRUEsVUFBSSxVQUFVLEVBQUUsTUFBTSxRQUFSLEVBQWtCLE1BQU0sTUFBTSxXQUE5QjtBQUNFLFlBQUksdUJBQXVCLE1BQU0sT0FBN0IsR0FBdUMsR0FEN0M7QUFFRSxjQUFNLEVBQUUsT0FBTyxFQUFDLE1BQU0sSUFBUCxFQUFULEVBRlIsRUFBZDs7QUFJQSxZQUFNLFdBQU4sQ0FBa0IsV0FBbEIsQ0FBOEIsT0FBOUIsRUFBdUMsVUFBQyxLQUFELEVBQVc7QUFDaEQsZ0JBQVEsR0FBUixDQUFZLDZCQUFaLEVBQTJDLEtBQTNDO0FBQ0QsT0FGRDtBQUdEOztBQUVEOzs7Ozs7MENBR3NCLFEsRUFBVSxLLEVBQU87QUFDckMsVUFBSSxRQUFRLElBQVo7O0FBRUEsVUFBSSxVQUFVLEVBQUUsTUFBTSxRQUFSLEVBQWtCLE1BQU0sTUFBTSxXQUE5QjtBQUNFLFlBQUksdUJBQXVCLE1BQU0sT0FBN0IsR0FBdUMsR0FEN0M7QUFFRSxjQUFNLEVBQUUsVUFBVSxRQUFaLEVBQXNCLE9BQU8sS0FBN0IsRUFGUixFQUFkOztBQUlBLFlBQU0sV0FBTixDQUFrQixJQUFsQixDQUF1QixXQUF2QixDQUFtQyxPQUFuQyxFQUE0QyxVQUFDLEtBQUQsRUFBVztBQUNyRCxnQkFBUSxHQUFSLENBQVksdUJBQVosRUFBcUMsS0FBckM7QUFDRCxPQUZEO0FBR0Q7O0FBRUQ7Ozs7Ozs7O3VDQUttQixhLEVBQWUsYSxFQUFlO0FBQy9DLFVBQUksUUFBUSxJQUFaO0FBQ0EsVUFBSSxhQUFhLE1BQU0sY0FBTixDQUFxQixhQUFyQixDQUFqQjs7QUFFQSxVQUFJLFVBQUosRUFBZ0I7QUFDZCxtQkFBVyxXQUFYLENBQXVCLElBQXZCLENBQTRCLGFBQTVCO0FBQ0EsY0FBTSxjQUFOLENBQXFCLGFBQXJCLElBQXNDLFVBQXRDO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7NkNBS3lCLGEsRUFBZTtBQUN0QyxVQUFJLFFBQVEsSUFBWjtBQUNBLFVBQUksYUFBYSxNQUFNLGNBQU4sQ0FBcUIsYUFBckIsQ0FBakI7O0FBRUEsVUFBSSxVQUFKLEVBQWdCO0FBQ2QsZUFBTyxXQUFXLFdBQWxCO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsY0FBTSx5QkFBTjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7Ozt1Q0FTbUIsVSxFQUFZLGdCLEVBQWtCLGEsRUFBZSxrQixFQUFvQixTLEVBQVcsVSxFQUFZLFMsRUFBVztBQUNwSCxVQUFJLFFBQVEsSUFBWjs7QUFFQSxhQUFPLHNCQUFZLFVBQVMsT0FBVCxFQUFrQixNQUFsQixFQUEwQjs7QUFFM0MsWUFBSSxhQUFhLEVBQWpCO0FBQ0EsWUFBSSxxQkFBcUIsY0FBYyxLQUFkLENBQW9CLEdBQXBCLENBQXpCO0FBQ0EsbUJBQVcsSUFBWCxDQUFnQixtQkFBbUIsQ0FBbkIsQ0FBaEI7O0FBRUEsY0FBTSxjQUFOLENBQXFCLEdBQXJCLENBQXlCLHlCQUF6QixFQUFvRCxJQUFwRCxDQUF5RCxVQUFDLFFBQUQsRUFBYzs7QUFFckUsY0FBSSxDQUFDLFFBQUwsRUFBZTtBQUNiLHVCQUFXLEVBQVg7QUFDRDs7QUFFRDtBQUNBLG1CQUFTLGFBQWEsZ0JBQWIsR0FBZ0MsU0FBaEMsR0FBNEMsa0JBQXJELElBQTJFLFdBQVcsT0FBdEY7O0FBRUE7QUFDQSxjQUFJLGVBQWUsRUFBQyxNQUFNLFVBQVAsRUFBbUIsV0FBVyxTQUE5QixFQUF5QyxhQUFhLFVBQXRELEVBQWtFLFFBQVEsZ0JBQTFFLEVBQTRGLEtBQUssYUFBakcsRUFBZ0gsU0FBUyxNQUFNLFdBQS9ILEVBQTRJLFVBQVUsa0JBQXRKLEVBQTBLLFNBQVMsU0FBbkwsRUFBOEwsYUFBYSxFQUEzTSxFQUFuQjs7QUFFQSxjQUFJLGdCQUFKOztBQUVBLGNBQUksV0FBVyxVQUFmLEVBQTJCOztBQUV6QixvQkFBUSxHQUFSLENBQVksaUNBQVosRUFBK0MsYUFBL0M7O0FBRUEsc0JBQVUsRUFBQyxNQUFLLFFBQU4sRUFBZ0IsTUFBTSxNQUFNLFdBQTVCLEVBQXlDLElBQUksdUJBQXVCLE1BQU0sY0FBN0IsR0FBOEMsR0FBM0YsRUFBZ0csTUFBTSxFQUFDLE9BQU8sWUFBUixFQUFzQixRQUFRLFFBQTlCLEVBQXRHLEVBQVY7QUFFRCxXQU5ELE1BTU87O0FBRUwsb0JBQVEsR0FBUixDQUFZLG1EQUFaLEVBQWlFLGFBQWpFOztBQUVBOzs7QUFJQSxzQkFBVTtBQUNSLG9CQUFNLFFBREU7QUFFUixrQkFBSSx1QkFBdUIsTUFBTSxjQUE3QixHQUE4QyxHQUYxQztBQUdSLG9CQUFNLE1BQU0sV0FISjtBQUlSLG9CQUFNLEVBQUMsVUFBVSxhQUFYLEVBQTBCLE9BQU8sTUFBakMsRUFBeUMsV0FBVyxRQUFwRDtBQUpFLGFBQVY7QUFPRDs7QUFFRCxnQkFBTSxjQUFOLENBQXFCLGFBQXJCLElBQXNDLFlBQXRDOztBQUVBO0FBQ0EsZ0JBQU0sY0FBTixDQUFxQixHQUFyQixDQUF5Qix5QkFBekIsRUFBb0QsQ0FBcEQsRUFBdUQsUUFBdkQsRUFBaUUsSUFBakUsQ0FBc0UsWUFBTTs7QUFFMUU7Ozs7Ozs7QUFPQSxrQkFBTSxXQUFOLENBQWtCLFdBQWxCLENBQThCLE9BQTlCLEVBQXVDLFVBQUMsS0FBRCxFQUFXO0FBQ2hELHNCQUFRLEdBQVIsQ0FBWSxpQ0FBWixFQUErQyxLQUEvQztBQUNBLGtCQUFJLE1BQU0sSUFBTixDQUFXLElBQVgsS0FBb0IsR0FBeEIsRUFBNkI7QUFDM0Isd0JBQVEsSUFBUjtBQUNELGVBRkQsTUFFTztBQUNMLHVCQUFPLDhCQUFQO0FBQ0Q7QUFDRixhQVBEO0FBUUQsV0FqQkQ7QUFrQkQsU0ExREQ7QUEyREQsT0FqRU0sQ0FBUDtBQWtFRDs7OzRDQUV1QixVLEVBQVk7QUFDbEMsVUFBSSxRQUFRLElBQVo7O0FBRUEsYUFBTyxzQkFBWSxVQUFDLE9BQUQsRUFBVSxNQUFWLEVBQW9COztBQUVyQyxZQUFJLGtCQUFKOztBQUVBO0FBQ0E7QUFDQSxZQUFJLE9BQVEsV0FBVyxXQUFuQixLQUFvQyxRQUF4QyxFQUFrRDtBQUNoRCxzQkFBWSxFQUFaO0FBQ0Esb0JBQVUsSUFBVixDQUFlLFdBQVcsV0FBMUI7QUFDRCxTQUhELE1BR087QUFDTCxzQkFBWSxXQUFXLFdBQXZCO0FBQ0Q7O0FBRUQsWUFBSSx1QkFBdUIsV0FBVyxXQUF0QztBQUNBLFlBQUksbUJBQW1CLEVBQXZCOztBQUVBO0FBQ0EsYUFBSyxJQUFJLEtBQVQsSUFBa0Isb0JBQWxCLEVBQXdDO0FBQ3RDLDJCQUFpQixJQUFqQixDQUFzQixNQUFNLGdCQUFOLENBQXVCLHVCQUF2QixDQUErQyxxQkFBcUIsS0FBckIsQ0FBL0MsQ0FBdEI7QUFDRDs7QUFFRDtBQUNBLDBCQUFRLEdBQVIsQ0FBWSxnQkFBWixFQUE4QixJQUE5QixDQUFtQyxVQUFTLFdBQVQsRUFBc0I7O0FBRXZELGNBQUksc0JBQXNCLEVBQTFCO0FBQ0EsZUFBSyxJQUFJLE1BQVQsSUFBa0IsV0FBbEIsRUFBK0I7QUFDN0IsZ0JBQUksYUFBYSxZQUFZLE1BQVosQ0FBakI7QUFDQSxnQ0FBb0IsSUFBcEIsQ0FBeUIsV0FBVyxhQUFYLENBQXlCLFVBQXpCLENBQW9DLFVBQXBDLENBQStDLE1BQS9DLENBQXNELFFBQS9FO0FBQ0Q7O0FBRUQsa0JBQVEsR0FBUixDQUFZLGlCQUFaLEVBQStCLG1CQUEvQjtBQUNBLGtCQUFRLEdBQVIsQ0FBWSxtQkFBWixFQUFpQyxTQUFqQzs7QUFFQSxrQkFBUSxFQUFDLFdBQVcsU0FBWixFQUF1QixZQUFZLG1CQUFuQyxFQUFSO0FBQ0QsU0FaRDtBQWFELE9BbkNNLENBQVA7QUFvQ0Q7O0FBRUQ7Ozs7Ozs7O3dDQUtvQixJLEVBQU07QUFDeEIsVUFBSSxRQUFRLElBQVo7O0FBRUEsYUFBTyxzQkFBWSxVQUFDLE9BQUQsRUFBVSxNQUFWLEVBQXFCOztBQUV0QyxZQUFJLGFBQWMsS0FBSyxRQUFOLEdBQWtCLHlCQUFsQixHQUE4QyxzQkFBL0Q7O0FBRUEsY0FBTSxjQUFOLENBQXFCLEdBQXJCLENBQXlCLFVBQXpCLEVBQXFDLElBQXJDLENBQTBDLFVBQUMsUUFBRCxFQUFjOztBQUV0RCxjQUFJLENBQUMsUUFBTCxFQUFlO0FBQ2IsdUJBQVcsRUFBWDtBQUNEOztBQUVELGNBQUksZUFBZSxzQkFBbkIsRUFBMkM7QUFDekMsa0JBQU0sdUJBQU4sQ0FBOEIsSUFBOUIsRUFBb0MsSUFBcEMsQ0FBeUMsVUFBQyxLQUFELEVBQVc7QUFDbEQsa0JBQUksU0FBUyxNQUFNLFNBQU4sR0FBa0IsTUFBTSxVQUFqQyxDQUFKLEVBQWtEO0FBQ2hELHdCQUFRLEdBQVIsQ0FBWSx3QkFBWjtBQUNBLHVCQUFPLFFBQVEsU0FBUyxNQUFNLFNBQU4sR0FBa0IsTUFBTSxVQUFqQyxDQUFSLENBQVA7QUFDRCxlQUhELE1BR087QUFDTCx3QkFBUSxHQUFSLENBQVksMkNBQVo7QUFDQSx1QkFBTyxRQUFRLFNBQVIsQ0FBUDtBQUNEO0FBQ0YsYUFSRDtBQVNELFdBVkQsTUFVTzs7QUFFTCxnQkFBSSxrQkFBa0IsS0FBSyxJQUFMLEdBQVksS0FBSyxNQUFqQixHQUEwQixLQUFLLFNBQS9CLEdBQTJDLEtBQUssUUFBdEU7O0FBRUEsZ0JBQUksU0FBUyxlQUFULENBQUosRUFBK0I7QUFDN0Isc0JBQVEsR0FBUixDQUFZLDJCQUFaO0FBQ0EscUJBQU8sUUFBUSxTQUFTLGVBQVQsQ0FBUixDQUFQO0FBQ0QsYUFIRCxNQUdPO0FBQ0wsc0JBQVEsR0FBUixDQUFZLDZDQUFaO0FBQ0EscUJBQU8sUUFBUSxTQUFSLENBQVA7QUFDRDtBQUNGO0FBRUYsU0E3QkQ7QUErQkQsT0FuQ00sQ0FBUDtBQW9DRDs7QUFFRDs7Ozs7Ozs7O29DQU1nQixPLEVBQVMsYSxFQUFlLFUsRUFBWSxVLEVBQVk7QUFDOUQsVUFBSSxRQUFRLElBQVo7O0FBRUEsVUFBSSw0QkFBSjs7QUFFQSxhQUFPLHNCQUFZLFVBQVMsT0FBVCxFQUFrQixNQUFsQixFQUEwQjs7QUFFM0M7QUFDQTtBQUNBLFlBQUksWUFBWSxzQkFBVSxhQUFWLEVBQXlCLE1BQXpDOztBQUVBLFlBQUksVUFBVSxRQUFWLENBQW1CLFdBQW5CLENBQUosRUFBcUM7QUFDbkMsc0JBQVksVUFBVSxPQUFWLENBQWtCLFlBQWxCLEVBQWdDLEVBQWhDLENBQVo7QUFDRDs7QUFFRCxjQUFNLFFBQU4sQ0FBZSxvQkFBZixHQUFzQyxJQUF0QyxDQUEyQyxVQUFTLE1BQVQsRUFBaUI7QUFDMUQsY0FBSSxjQUFjLE9BQU8sV0FBekI7QUFDQSxjQUFJLGNBQWMsWUFBWSxPQUE5Qjs7QUFFQSxjQUFJLE1BQU0sV0FBTixLQUFzQixTQUExQixFQUFxQztBQUNuQyxtQkFBTyxzQ0FBUDtBQUNELFdBRkQsTUFFTztBQUNMO0FBQ0Esa0JBQU0sT0FBTixDQUFjLHVCQUF1QixTQUFyQyxFQUFnRCxJQUFoRCxDQUFxRCxZQUFXOztBQUU5RCxxQkFBTyxNQUFNLGNBQU4sQ0FBcUIsR0FBckIsQ0FBeUIsc0JBQXpCLENBQVA7QUFDRCxhQUhELEVBR0csSUFISCxDQUdRLFVBQUMsUUFBRCxFQUFjOztBQUVwQixvQkFBTSx1QkFBTixDQUE4QixVQUE5QixFQUEwQyxJQUExQyxDQUErQyxVQUFDLEtBQUQsRUFBVzs7QUFFeEQsc0NBQXNCLEtBQXRCOztBQUVBLG9CQUFJLENBQUMsUUFBTCxFQUFlO0FBQ2IsNkJBQVcsRUFBWDtBQUNEOztBQUVELHlCQUFTLG9CQUFvQixTQUFwQixHQUFnQyxvQkFBb0IsVUFBN0QsSUFBMkUsV0FBVyxPQUF0RjtBQUNBLHNCQUFNLGNBQU4sQ0FBcUIsR0FBckIsQ0FBeUIsc0JBQXpCLEVBQWlELENBQWpELEVBQW9ELFFBQXBELEVBQThELElBQTlELENBQW1FLFlBQU07O0FBRXZFLHdCQUFNLGNBQU4sR0FBdUIsU0FBdkI7O0FBRUE7QUFDQSxzQkFBSSxRQUFRLElBQVIsS0FBaUIsS0FBckIsRUFBNEI7QUFDMUIsMEJBQU0sYUFBTixDQUFvQixVQUFwQixDQUErQixXQUFXLE9BQVgsQ0FBbUIsQ0FBbkIsQ0FBL0IsSUFBd0QsT0FBeEQ7QUFDRCxtQkFGRCxNQUVPLElBQUksUUFBUSxJQUFSLEtBQWlCLFFBQXJCLEVBQStCO0FBQ3BDLDBCQUFNLGFBQU4sQ0FBb0IsT0FBcEIsQ0FBNEIsV0FBVyxPQUFYLENBQW1CLENBQW5CLENBQTVCLElBQXFELE9BQXJEO0FBQ0QsbUJBRk0sTUFFQTtBQUNMLDJCQUFPLG1CQUFQO0FBQ0Q7O0FBRUQsc0JBQUksVUFBVSw4QkFBb0IsTUFBTSxVQUExQixFQUFzQyxNQUFNLFdBQTVDLEVBQ2QsYUFEYyxFQUNDLFVBREQsRUFDYSxXQUFXLE9BQVgsQ0FBbUIsQ0FBbkIsQ0FEYixFQUNvQyxXQURwQyxDQUFkOztBQUdBLDBCQUFRLFVBQVIsR0FBcUIsb0JBQW9CLFNBQXpDO0FBQ0EsMEJBQVEsWUFBUixHQUF1QixvQkFBb0IsVUFBM0M7QUFDQSx3QkFBTSxhQUFOLENBQW9CLElBQXBCLENBQXlCLE9BQXpCOztBQUVBO0FBQ0Esc0JBQUkscUJBQUo7QUFDQSxzQkFBSSxnQkFBSjs7QUFFQSxzQkFBSSxXQUFXLFVBQWYsRUFBMkI7QUFDekIsNEJBQVEsR0FBUixDQUFZLDZCQUFaLEVBQTJDLFdBQVcsT0FBWCxDQUFtQixDQUFuQixDQUEzQzs7QUFFQSxtQ0FBZSxFQUFDLE1BQU0sV0FBUCxFQUFxQixZQUFZLGFBQWpDLEVBQWdELEtBQUssV0FBVyxPQUFYLENBQW1CLENBQW5CLENBQXJELEVBQTRFLFNBQVMsTUFBTSxXQUEzRixFQUF3RyxXQUFXLG9CQUFvQixTQUF2SSxFQUFrSixhQUFhLG9CQUFvQixVQUFuTCxFQUFmOztBQUVBLDhCQUFVLEVBQUMsTUFBSyxRQUFOLEVBQWdCLE1BQU0sTUFBTSxXQUE1QixFQUF5QyxJQUFJLHVCQUF1QixNQUFNLGNBQTdCLEdBQThDLEdBQTNGLEVBQWdHLE1BQU0sRUFBQyxPQUFPLFlBQVIsRUFBc0IsUUFBUSxRQUE5QixFQUF0RyxFQUFWO0FBRUQsbUJBUEQsTUFPTztBQUNMLDRCQUFRLEdBQVIsQ0FBWSwrQ0FBWixFQUE2RCxXQUFXLE9BQVgsQ0FBbUIsQ0FBbkIsQ0FBN0Q7O0FBRUEsOEJBQ0UsRUFBQyxNQUFNLFFBQVA7QUFDQywwQkFBSSx1QkFBdUIsTUFBTSxjQUE3QixHQUE4QyxHQURuRDtBQUVDLDRCQUFNLE1BQU0sV0FGYjtBQUdDLDRCQUFNLEVBQUMsVUFBVSxXQUFXLE9BQVgsQ0FBbUIsQ0FBbkIsQ0FBWCxDQUFnQyx3Q0FBaEM7QUFIUCxxQkFERjtBQU9EOztBQUVEOzs7Ozs7O0FBT0Esd0JBQU0sV0FBTixDQUFrQixXQUFsQixDQUE4QixPQUE5QixFQUF1QyxVQUFDLEtBQUQsRUFBVztBQUNoRCw0QkFBUSxHQUFSLENBQVksOEJBQVosRUFBNEMsS0FBNUM7O0FBRUEsd0JBQUksTUFBTSxJQUFOLENBQVcsSUFBWCxLQUFvQixHQUF4QixFQUE2QjtBQUMzQiw4QkFBUSxXQUFXLE9BQVgsQ0FBbUIsQ0FBbkIsQ0FBUjtBQUNELHFCQUZELE1BRU87QUFDTCw2QkFBTywrQkFBUDtBQUNEO0FBQ0YsbUJBUkQ7O0FBVUE7QUFDQTtBQUNBLHNCQUFJLGlCQUFpQixZQUFZLFlBQVc7O0FBRTFDOzs7Ozs7O0FBT0Esd0JBQUksVUFBVSxFQUFDLE1BQUssUUFBTixFQUFnQixNQUFNLE1BQU0sV0FBNUIsRUFBeUMsSUFBSSx1QkFBdUIsTUFBTSxjQUE3QixHQUE4QyxHQUEzRixFQUFnRyxNQUFNLEVBQUUsVUFBVSxXQUFXLE9BQVgsQ0FBbUIsQ0FBbkIsQ0FBWixFQUF0RyxFQUFkOztBQUVBLDBCQUFNLFdBQU4sQ0FBa0IsV0FBbEIsQ0FBOEIsT0FBOUIsRUFBdUMsVUFBQyxLQUFELEVBQVc7QUFDaEQsOEJBQVEsR0FBUixDQUFZLHdCQUFaLEVBQXNDLEtBQXRDO0FBQ0QscUJBRkQ7QUFHRCxtQkFkb0IsRUFjaEIsTUFBTSxXQUFOLEdBQW9CLEdBQXJCLEdBQTRCLENBQTdCLEdBQWtDLElBZGhCLENBQXJCO0FBZ0JELGlCQTlFRCxFQThFRyxLQTlFSCxDQThFUyxVQUFTLE1BQVQsRUFBaUI7QUFDeEIsMEJBQVEsR0FBUixDQUFZLGtCQUFaLEVBQWdDLE1BQWhDO0FBQ0EseUJBQU8sTUFBUDtBQUNELGlCQWpGRDtBQWtGRCxlQTNGRDtBQTRGRCxhQWpHRDtBQWtHRDtBQUNGLFNBM0dELEVBMkdHLFVBQVMsR0FBVCxFQUFjO0FBQ2YsaUJBQU8sOEJBQVAsRUFBdUMsR0FBdkM7QUFDRCxTQTdHRDtBQThHRCxPQXhITSxDQUFQO0FBeUhEOztBQUVEOzs7Ozs7O3NDQUlrQixHLEVBQUs7QUFDckIsVUFBSSxRQUFRLElBQVo7O0FBRUEsYUFBTyxzQkFBWSxVQUFTLE9BQVQsRUFBaUIsTUFBakIsRUFBeUI7O0FBRTFDLFlBQUksUUFBUSxLQUFaO0FBQ0EsWUFBSSxRQUFRLENBQVo7O0FBRUEsYUFBSyxRQUFRLENBQWIsRUFBZ0IsUUFBUSxNQUFNLGFBQU4sQ0FBb0IsTUFBNUMsRUFBb0QsT0FBcEQsRUFBNkQ7QUFDM0QsY0FBSSxVQUFVLE1BQU0sYUFBTixDQUFvQixLQUFwQixDQUFkO0FBQ0EsY0FBSSxZQUFZLFNBQWhCLEVBQTJCO0FBQ3pCLGdCQUFJLFFBQVEsVUFBUixLQUF1QixHQUEzQixFQUFnQztBQUM5QixzQkFBUSxJQUFSO0FBQ0E7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsWUFBSSxVQUFVLEtBQWQsRUFBcUI7QUFDbkIsaUJBQU8sbUJBQVA7QUFDRCxTQUZELE1BRU87QUFDTCxpQkFBTyxNQUFNLGFBQU4sQ0FBb0IsS0FBcEIsQ0FBUDtBQUNBLGtCQUFRLDhCQUFSO0FBQ0Q7QUFDRixPQXJCTSxDQUFQO0FBdUJEOztBQUVEOzs7Ozs7OztzQ0FLa0IsRyxFQUFLO0FBQ3JCLFVBQUksQ0FBQyxHQUFMLEVBQVUsTUFBTSxJQUFJLEtBQUosQ0FBVSxzQkFBVixDQUFOO0FBQ1YsVUFBSSxRQUFRLElBQVo7O0FBRUEsYUFBTyxzQkFBWSxVQUFTLE9BQVQsRUFBaUIsTUFBakIsRUFBeUI7O0FBRTFDLFlBQUksYUFBYSxzQkFBVSxHQUFWLENBQWpCO0FBQ0EsWUFBSSxZQUFZLFdBQVcsTUFBM0I7O0FBRUEsWUFBSSxNQUFNLGNBQU4sQ0FBcUIsY0FBckIsQ0FBb0MsU0FBcEMsS0FBa0QsTUFBTSxjQUFOLENBQXFCLFNBQXJCLEVBQWdDLE1BQWhDLEtBQTJDLE9BQU8sUUFBeEcsRUFBa0g7QUFDaEgsa0JBQVEsTUFBTSxjQUFOLENBQXFCLFNBQXJCLENBQVI7QUFDRCxTQUZELE1BRU87QUFDTCxnQkFBTSxjQUFOLENBQXFCLFNBQXJCLElBQWtDO0FBQ2hDLG9CQUFRLE9BQU87QUFEaUIsV0FBbEM7O0FBSUEsaUJBQU8sOENBQVA7QUFDRDtBQUNGLE9BZE0sQ0FBUDtBQWdCRDs7QUFFRDs7Ozs7Ozs7O2lDQU1hLE8sRUFBUyxTLEVBQVc7QUFDL0IsVUFBSSxRQUFRLElBQVo7O0FBRUEsYUFBTyxzQkFBWSxVQUFTLE9BQVQsRUFBaUIsTUFBakIsRUFBeUI7O0FBRTFDLFlBQUksNEJBQUo7O0FBRUE7QUFDQSxZQUFJLE1BQU0sV0FBTixLQUFzQixTQUExQixFQUFxQztBQUNuQyxpQkFBTyxzQ0FBUDtBQUNEOztBQUVEO0FBQ0EsWUFBSSxDQUFDLFVBQVUsT0FBVixDQUFrQixXQUFsQixDQUFMLEVBQXFDO0FBQ25DLHNCQUFZLFVBQVUsU0FBVixDQUFvQixVQUFVLE9BQVYsQ0FBa0IsR0FBbEIsSUFBeUIsQ0FBN0MsQ0FBWjtBQUNEOztBQUVELDhCQUFzQixjQUFjLFNBQWQsR0FBMEIsYUFBMUIsR0FBMEMsS0FBSyxLQUFMLENBQVksS0FBSyxNQUFMLEtBQWdCLEtBQWpCLEdBQTBCLENBQXJDLENBQWhFOztBQUVBO0FBQ0E7QUFDQSxjQUFNLGNBQU4sQ0FBcUIsU0FBckIsSUFBa0M7QUFDaEMsZUFBSyxtQkFEMkI7QUFFaEMsa0JBQVEsT0FBTztBQUZpQixTQUFsQzs7QUFLQTtBQUNBLGNBQU0sYUFBTixDQUFvQixPQUFwQixDQUE0QixtQkFBNUIsSUFBbUQsT0FBbkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFRLG1CQUFSOztBQUVBLGNBQU0sV0FBTixDQUFrQixXQUFsQixDQUE4QixzQkFBc0IsU0FBcEQsRUFBK0QsVUFBQyxHQUFELEVBQVM7QUFDdEUsY0FBSSxJQUFJLFFBQUosS0FBaUIsSUFBSSxFQUFKLEdBQVMsU0FBOUIsRUFBeUM7QUFDdkMsb0JBQVEsR0FBUixDQUFZLHNDQUFaLEVBQW9ELElBQUksSUFBSixDQUFTLEtBQTdEO0FBQ0Q7QUFDRixTQUpEO0FBS0QsT0FyQ00sQ0FBUDtBQXVDRDs7QUFFRDs7Ozs7OzttQ0FJZSxpQixFQUFtQjtBQUNoQyxVQUFJLFFBQVEsSUFBWjs7QUFFQSxhQUFPLHNCQUFZLFVBQVMsT0FBVCxFQUFrQixNQUFsQixFQUEwQjs7QUFFM0MsWUFBSSxNQUFNLGNBQU4sQ0FBcUIsY0FBckIsQ0FBb0MsaUJBQXBDLENBQUosRUFBNEQ7QUFDMUQsaUJBQU8sTUFBTSxjQUFOLENBQXFCLGlCQUFyQixDQUFQO0FBQ0Esa0JBQVEsc0JBQVI7QUFDRCxTQUhELE1BR087QUFDTCxpQkFBTyw0Q0FBUDtBQUNEO0FBQ0YsT0FSTSxDQUFQO0FBU0Q7O0FBRUQ7Ozs7Ozs7OztxQ0FNaUIsTyxFQUFTLFMsRUFBVztBQUNuQyxVQUFJLFFBQVEsSUFBWjs7QUFFQSxhQUFPLHNCQUFZLFVBQVMsT0FBVCxFQUFpQixNQUFqQixFQUF5Qjs7QUFFMUMsWUFBSSx3QkFBSjs7QUFFQTtBQUNBLFlBQUksTUFBTSxXQUFOLEtBQXNCLFNBQTFCLEVBQXFDO0FBQ25DLGlCQUFPLHNDQUFQO0FBQ0Q7O0FBRUQsMEJBQWtCLGtCQUFrQixTQUFsQixHQUE4QixRQUE5QixHQUF5QyxLQUFLLEtBQUwsQ0FBWSxLQUFLLE1BQUwsS0FBZ0IsS0FBakIsR0FBMEIsQ0FBckMsQ0FBM0Q7O0FBRUE7QUFDQSxjQUFNLFlBQU4sQ0FBbUIsU0FBbkIsSUFBZ0M7QUFDOUIsZUFBSyxlQUR5QjtBQUU5QixrQkFBUSxPQUFPO0FBRmUsU0FBaEM7O0FBS0EsY0FBTSxhQUFOLENBQW9CLE9BQXBCLENBQTRCLGVBQTVCLElBQStDLE9BQS9DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBUSxlQUFSOztBQUVBLGNBQU0sV0FBTixDQUFrQixXQUFsQixDQUE4QixrQkFBa0IsU0FBaEQsRUFBMkQsVUFBQyxHQUFELEVBQVM7QUFDbEUsY0FBSSxJQUFJLFFBQUosS0FBaUIsSUFBSSxFQUFKLEdBQVMsU0FBOUIsRUFBeUM7QUFDdkMsb0JBQVEsR0FBUixDQUFZLGtDQUFaLEVBQWdELElBQUksSUFBSixDQUFTLEtBQXpEO0FBQ0Q7QUFDRixTQUpEO0FBS0QsT0E5Qk0sQ0FBUDtBQStCRDs7QUFFRDs7Ozs7Ozs7cUNBS2lCLEcsRUFBSztBQUNwQixVQUFJLENBQUMsR0FBTCxFQUFVLE1BQU0sSUFBSSxLQUFKLENBQVUsc0JBQVYsQ0FBTjtBQUNWLFVBQUksUUFBUSxJQUFaOztBQUVBLGFBQU8sc0JBQVksVUFBUyxPQUFULEVBQWtCLE1BQWxCLEVBQTBCOztBQUUzQyxZQUFJLGFBQWEsc0JBQVUsR0FBVixDQUFqQjtBQUNBLFlBQUksWUFBWSxXQUFXLE1BQTNCOztBQUVBLFlBQUksTUFBTSxZQUFOLENBQW1CLGNBQW5CLENBQWtDLFNBQWxDLEtBQWdELE1BQU0sWUFBTixDQUFtQixTQUFuQixFQUE4QixNQUE5QixLQUF5QyxPQUFPLFFBQXBHLEVBQThHO0FBQzVHLGtCQUFRLE1BQU0sWUFBTixDQUFtQixTQUFuQixDQUFSO0FBQ0QsU0FGRCxNQUVPO0FBQ0w7QUFDQSxnQkFBTSxZQUFOLENBQW1CLFNBQW5CLElBQWdDO0FBQzlCLG9CQUFRLE9BQU87QUFEZSxXQUFoQztBQUdBLGlCQUFPLDZDQUFQO0FBQ0Q7QUFDRixPQWRNLENBQVA7QUFnQkQ7O0FBRUQ7Ozs7Ozs7OztnQ0FNWSxXLEVBQWEsTyxFQUFTO0FBQ2hDLFVBQUksUUFBUSxJQUFaOztBQUVBLGFBQU8sc0JBQVksVUFBUyxPQUFULEVBQWlCLE1BQWpCLEVBQXlCO0FBQzFDO0FBQ0EsY0FBTSxPQUFOLENBQWMsT0FBZCxJQUF5QixXQUF6QjtBQUNBLGdCQUFRLDZCQUFSO0FBQ0QsT0FKTSxDQUFQO0FBTUQ7O0FBRUQ7Ozs7Ozs7a0NBSWMsaUIsRUFBbUI7QUFDL0IsVUFBSSxRQUFRLElBQVo7O0FBRUEsYUFBTyxzQkFBWSxVQUFTLE9BQVQsRUFBaUIsTUFBakIsRUFBeUI7O0FBRTFDLFlBQUksU0FBUyxNQUFNLE9BQU4sQ0FBYyxpQkFBZCxDQUFiOztBQUVBLFlBQUksV0FBVyxTQUFmLEVBQTBCO0FBQ3hCLGlCQUFPLGdCQUFQO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsa0JBQVEsMkJBQVI7QUFDRDtBQUNGLE9BVE0sQ0FBUDtBQVdEOztBQUVEOzs7Ozs7OzRCQUlRLEssRUFBTztBQUNiO0FBQ0EsY0FBUSxHQUFSLENBQVksU0FBWjtBQUNEOztBQUVEOzs7Ozs7OzsrQkFLVyxHLEVBQUs7QUFDZCxVQUFJLENBQUMsR0FBTCxFQUFVLE1BQU0sSUFBSSxLQUFKLENBQVUsc0JBQVYsQ0FBTjtBQUNWLGNBQVEsR0FBUixDQUFZLGNBQVosRUFBNEIsR0FBNUI7O0FBRUEsVUFBSSxRQUFRLElBQVo7QUFDQSxhQUFPLHNCQUFZLFVBQVMsT0FBVCxFQUFpQixNQUFqQixFQUF5Qjs7QUFFMUMsWUFBSSxnQkFBSjs7QUFFQTtBQUNBLGtCQUFVLE1BQU0sYUFBTixDQUFvQixVQUFwQixDQUErQixHQUEvQixDQUFWOztBQUVBO0FBQ0EsWUFBSSxDQUFDLE9BQUwsRUFBYztBQUNaLG9CQUFVLE1BQU0sYUFBTixDQUFvQixPQUFwQixDQUE0QixHQUE1QixDQUFWOztBQUVBLGNBQUksQ0FBQyxPQUFMLEVBQWM7O0FBRVosZ0JBQUksU0FBUyxzQkFBVSxHQUFWLEVBQWUsTUFBNUI7O0FBRUE7QUFDQSxpQkFBSyxJQUFJLE9BQVQsSUFBb0IsTUFBTSxhQUFOLENBQW9CLE9BQXhDLEVBQWlEO0FBQy9DLGtCQUFJLFFBQVEsUUFBUixDQUFpQixNQUFqQixDQUFKLEVBQThCO0FBQzVCLDBCQUFVLE1BQU0sYUFBTixDQUFvQixPQUFwQixDQUE0QixPQUE1QixDQUFWO0FBQ0E7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7QUFFRCxZQUFJLENBQUMsT0FBTCxFQUFjO0FBQ1osaUJBQU8sMkJBQTJCLEdBQWxDO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsa0JBQVEsT0FBUjtBQUNEO0FBRUYsT0EvQk0sQ0FBUDtBQWdDRDs7QUFFRDs7Ozs7Ozs7NEJBS1EsRyxFQUFLO0FBQ1gsY0FBUSxHQUFSLENBQVksYUFBYSxHQUF6QjtBQUNBLFVBQUksUUFBUSxJQUFaOztBQUVBLGFBQU8sc0JBQVksVUFBQyxPQUFELEVBQVUsTUFBVixFQUFxQjs7QUFFdEM7QUFDQTtBQUNBLFlBQUksYUFBYSxzQkFBVSxHQUFWLENBQWpCO0FBQ0EsWUFBSSxZQUFZLFdBQVcsTUFBM0I7QUFDQSxZQUFJLE9BQU8sV0FBVyxJQUF0Qjs7QUFFQTtBQUNBLFlBQUksSUFBSSxRQUFKLENBQWEsbUJBQWIsQ0FBSixFQUF1QztBQUNyQyxzQkFBWSxNQUFNLE9BQWxCO0FBQ0Q7O0FBRUQsWUFBSSxDQUFDLFVBQVUsT0FBVixDQUFrQixXQUFsQixDQUFELElBQW1DLENBQUMsVUFBVSxPQUFWLENBQWtCLFdBQWxCLENBQXhDLEVBQXdFO0FBQ3RFLHNCQUFZLFVBQVUsU0FBVixDQUFvQixVQUFVLE9BQVYsQ0FBa0IsR0FBbEIsSUFBeUIsQ0FBN0MsQ0FBWjtBQUNEOztBQUVELFlBQUksMkJBQUo7QUFDQSxZQUFJLFNBQVMsWUFBYixFQUEyQjtBQUN6QiwrQkFBc0IsTUFBTSxZQUFOLENBQW1CLGNBQW5CLENBQWtDLFNBQWxDLElBQStDLE1BQU0sWUFBTixDQUFtQixTQUFuQixDQUEvQyxHQUErRSxLQUFyRztBQUNELFNBRkQsTUFFTztBQUNMLCtCQUFzQixNQUFNLGNBQU4sQ0FBcUIsY0FBckIsQ0FBb0MsU0FBcEMsSUFBaUQsTUFBTSxjQUFOLENBQXFCLFNBQXJCLENBQWpELEdBQW1GLEtBQXpHO0FBQ0Q7O0FBRUQsWUFBSSxzQkFBc0IsbUJBQW1CLGNBQW5CLENBQWtDLFFBQWxDLENBQXRCLElBQXFFLG1CQUFtQixNQUFuQixLQUE4QixPQUFPLFFBQTlHLEVBQXdIO0FBQ3RILGtCQUFRLElBQVIsQ0FBYSxZQUFiLEVBQTJCLG1CQUFtQixHQUE5QztBQUNBLGtCQUFRLG1CQUFtQixHQUEzQjtBQUNELFNBSEQsTUFHTztBQUNMLGNBQUksU0FBUyxZQUFiLEVBQTJCO0FBQ3pCOztBQUVBLGtCQUFNLE9BQU4sQ0FBYyxZQUFkLENBQTJCLFNBQTNCLEVBQXNDLElBQXRDLENBQTJDLFVBQUMsTUFBRCxFQUFZO0FBQ3JELG1DQUFzQixNQUFNLFlBQU4sQ0FBbUIsU0FBbkIsQ0FBdEI7QUFDQSxzQkFBUSxJQUFSLENBQWEscUJBQWIsRUFBb0Msa0JBQXBDLEVBQXdELE1BQXhEO0FBQ0Esb0JBQU0sWUFBTixDQUFtQixTQUFuQixFQUE4QixNQUE5QixHQUF1QyxPQUFPLFFBQTlDO0FBQ0Esc0JBQVEsbUJBQW1CLEdBQTNCO0FBQ0QsYUFMRCxFQUtHLEtBTEgsQ0FLUyxVQUFDLE1BQUQsRUFBWTtBQUNuQixzQkFBUSxLQUFSLENBQWMsNEJBQWQsRUFBNEMsTUFBNUM7QUFDQSxxQkFBTyxNQUFQO0FBQ0QsYUFSRDtBQVVELFdBYkQsTUFhTztBQUNMOztBQUVBLGtCQUFNLE9BQU4sQ0FBYyxRQUFkLENBQXVCLFNBQXZCLEVBQWtDLElBQWxDLENBQXVDLFVBQUMsTUFBRCxFQUFZO0FBQ2pELG1DQUFzQixNQUFNLGNBQU4sQ0FBcUIsU0FBckIsQ0FBdEI7QUFDQSxzQkFBUSxJQUFSLENBQWEsc0JBQWIsRUFBcUMsa0JBQXJDLEVBQXlELE1BQXpEO0FBQ0Esb0JBQU0sY0FBTixDQUFxQixTQUFyQixFQUFnQyxNQUFoQyxHQUF5QyxPQUFPLFFBQWhEO0FBQ0Esc0JBQVEsbUJBQW1CLEdBQTNCO0FBQ0QsYUFMRCxFQUtHLEtBTEgsQ0FLUyxVQUFDLE1BQUQsRUFBWTtBQUNuQixzQkFBUSxLQUFSLENBQWMsNkJBQWQsRUFBNkMsTUFBN0M7QUFDQSxxQkFBTyxNQUFQO0FBQ0QsYUFSRDtBQVNEO0FBRUY7QUFFRixPQXpETSxDQUFQO0FBMEREOzs7c0JBMWlDVSxNLEVBQVE7QUFDakIsVUFBSSxRQUFRLElBQVo7QUFDQSxZQUFNLE9BQU4sR0FBZ0IsTUFBaEI7QUFDRCxLO3dCQUVZO0FBQ1gsVUFBSSxRQUFRLElBQVo7QUFDQSxhQUFPLE1BQU0sT0FBYjtBQUNEOztBQUVEOzs7Ozs7O3dCQUlpQjtBQUNmLFVBQUksUUFBUSxJQUFaO0FBQ0EsYUFBTyxNQUFNLFdBQWI7QUFDRDs7QUFFRDs7Ozs7c0JBSWUsVSxFQUFZO0FBQ3pCLFVBQUksUUFBUSxJQUFaO0FBQ0EsWUFBTSxXQUFOLEdBQW9CLFVBQXBCOztBQUVBLFlBQU0sV0FBTixDQUFrQixXQUFsQixDQUE4QixNQUFNLFdBQXBDLEVBQWlELFVBQVMsR0FBVCxFQUFjOztBQUU3RCxZQUFJLFVBQVUsTUFBTSxzQkFBTixDQUE2QixJQUFJLElBQUosQ0FBUyxRQUF0QyxFQUFnRCxJQUFJLElBQUosQ0FBUyxRQUF6RCxDQUFkOztBQUVBLFlBQUksUUFBUSxFQUFDLElBQUksSUFBSSxFQUFULEVBQWEsTUFBTSxVQUFuQixFQUErQixJQUFJLElBQUksSUFBdkMsRUFBNkMsTUFBTSxJQUFJLEVBQXZELEVBQTJELE1BQU0sRUFBQyxVQUFVLE9BQVgsRUFBakUsRUFBWjtBQUNBLGNBQU0sSUFBTixDQUFXLElBQVgsR0FBbUIsT0FBRCxHQUFZLEdBQVosR0FBa0IsR0FBcEM7O0FBRUEsY0FBTSxXQUFOLENBQWtCLFdBQWxCLENBQThCLEtBQTlCO0FBQ0QsT0FSRDs7QUFVQTtBQUNBO0FBQ0EsWUFBTSxRQUFOLENBQWUsVUFBZixHQUE0QixVQUE1Qjs7QUFFQTtBQUNBLFVBQUksb0JBQW9CLGdDQUFzQixNQUFNLFdBQTVCLEVBQXlDLFVBQXpDLEVBQXFELEtBQXJELENBQXhCO0FBQ0EsWUFBTSxpQkFBTixHQUEwQixpQkFBMUI7QUFFRDs7Ozs7a0JBaWdDWSxROzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hvQ2Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkE7Ozs7SUFJTSxpQjtBQUVKLDZCQUFZLEVBQVosRUFBZ0IsR0FBaEIsRUFBcUIsYUFBckIsRUFBb0MsWUFBcEMsRUFBa0QsWUFBbEQsRUFBZ0UsTUFBaEUsRUFBd0UsS0FBeEUsRUFBK0Usa0JBQS9FLEVBQW1HO0FBQUE7O0FBQ2pHLFFBQUksUUFBUSxJQUFaOztBQUVBLFVBQU0sR0FBTixHQUFZLEVBQVo7QUFDQSxVQUFNLElBQU4sR0FBYSxHQUFiO0FBQ0EsVUFBTSxjQUFOLEdBQXVCLGFBQXZCO0FBQ0EsVUFBTSxhQUFOLEdBQXNCLFlBQXRCO0FBQ0EsVUFBTSxhQUFOLEdBQXNCLFlBQXRCO0FBQ0EsVUFBTSxPQUFOLEdBQWdCLE1BQWhCO0FBQ0EsVUFBTSxNQUFOLEdBQWUsS0FBZjtBQUNBLFVBQU0sbUJBQU4sR0FBNEIsa0JBQTVCO0FBQ0Q7Ozs7d0JBRVE7QUFDUCxVQUFJLFFBQVEsSUFBWjtBQUNBLGFBQU8sTUFBTSxHQUFiO0FBQ0Q7Ozt3QkFFUztBQUNSLFVBQUksUUFBUSxJQUFaO0FBQ0EsYUFBTyxNQUFNLElBQWI7QUFDRDs7O3dCQUVnQjtBQUNmLFVBQUksUUFBUSxJQUFaO0FBQ0EsYUFBTyxNQUFNLGNBQWI7QUFDRDs7Ozs7a0JBSVksaUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxRGY7Ozs7SUFFTSxXO0FBRUosdUJBQVksVUFBWixFQUF3QixTQUF4QixFQUFtQyxvQkFBbkMsRUFBeUQ7QUFBQTs7QUFDdkQsUUFBSSxDQUFDLFVBQUwsRUFBaUIsTUFBTSxNQUFNLHdEQUFOLENBQU47QUFDakIsUUFBSSxDQUFDLFNBQUwsRUFBZ0IsTUFBTSxNQUFNLDZDQUFOLENBQU47QUFDaEIsUUFBSSxDQUFDLG9CQUFMLEVBQTJCLE1BQU0sTUFBTSxnREFBTixDQUFOOztBQUUzQixTQUFLLG9CQUFMLEdBQTRCLG9CQUE1QjtBQUNBLFNBQUssVUFBTCxHQUFrQixVQUFsQjtBQUNBLFNBQUssU0FBTCxHQUFpQixTQUFqQjtBQUNEOzs7O3lDQUVxQixVLEVBQVk7QUFDaEMsYUFBTyxLQUFLLFNBQUwsQ0FBZSxvQkFBZixDQUFvQyxVQUFwQyxDQUFQO0FBQ0Q7OztzQ0FFa0IsTyxFQUFTO0FBQUE7O0FBRTFCLGFBQU8sc0JBQVksVUFBQyxPQUFELEVBQVUsTUFBVixFQUFxQjs7QUFFdEMsWUFBSSxhQUFhLHNCQUFVLE9BQVYsQ0FBakI7QUFDQSxZQUFJLFNBQVMsV0FBVyxNQUF4QjtBQUNBLFlBQUksWUFBWSxXQUFXLFFBQTNCO0FBQ0EsWUFBSSxxQkFBSjs7QUFFQSxZQUFJLG1CQUFtQixzQkFBVSxNQUFLLFVBQWYsQ0FBdkI7QUFDQSxZQUFJLGVBQWUsaUJBQWlCLE1BQXBDOztBQUVBLFlBQUksQ0FBQyxNQUFMLEVBQWE7QUFDWCxtQkFBUyxXQUFUO0FBQ0Q7O0FBRUQsWUFBSSxDQUFDLFNBQUwsRUFBZ0I7QUFDZCxzQkFBWSxTQUFaO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsc0JBQVksVUFBVSxTQUFWLENBQW9CLFVBQVUsV0FBVixDQUFzQixHQUF0QixJQUE2QixDQUFqRCxDQUFaO0FBQ0Q7O0FBRUQsdUJBQWUscUJBQVMsTUFBSyxvQkFBZCxFQUFvQyxlQUFwQyxFQUFxRCxjQUFyRCxFQUFxRSxTQUFyRSxDQUFmO0FBQ0EsWUFBSSxXQUFXLE1BQUssb0JBQUwsQ0FBMEIsTUFBekMsRUFBaUQ7QUFDL0MsY0FBSSxDQUFDLFFBQVEsT0FBUixDQUFnQixPQUFoQixDQUFELElBQTZCLENBQUMsUUFBUSxPQUFSLENBQWdCLG1CQUFoQixDQUFsQyxFQUF3RTtBQUN0RSwyQkFBZSxPQUFmO0FBQ0QsV0FGRCxNQUVPOztBQUVMO0FBQ0EsZ0JBQUksV0FBVyxzQ0FBMEIsTUFBSyxvQkFBL0IsRUFBcUQsZUFBckQsRUFBc0UsY0FBdEUsQ0FBZjtBQUNBLDJCQUFlLFNBQVMsTUFBVCxHQUFrQixNQUFsQixHQUEyQixTQUFTLE1BQXBDLEdBQTZDLFNBQTVEO0FBQ0Q7QUFDRjs7QUFFRCxnQkFBUSxHQUFSLENBQVksbUNBQW1DLE1BQW5DLEdBQTRDLEtBQXhELEVBQStELFlBQS9EO0FBQ0EsZUFBTyxNQUFLLFNBQUwsQ0FBZSxpQkFBZixDQUFpQyxZQUFqQyxFQUErQyxJQUEvQyxDQUFvRCxVQUFDLE1BQUQsRUFBWTs7QUFFckUsa0JBQVEsTUFBUjtBQUVELFNBSk0sRUFJSixLQUpJLENBSUUsVUFBQyxLQUFELEVBQVc7O0FBRWxCLGtCQUFRLEdBQVIsQ0FBWSxTQUFaLEVBQXVCLEtBQXZCOztBQUVBLHNCQUFZLE1BQVo7QUFDQSxtQkFBUyxZQUFUOztBQUVBLGNBQUksV0FBVyxzQ0FBMEIsTUFBSyxvQkFBL0IsRUFBcUQsZUFBckQsRUFBc0UsY0FBdEUsQ0FBZjtBQUNBLHlCQUFlLFNBQVMsTUFBVCxHQUFrQixNQUFsQixHQUEyQixTQUFTLE1BQXBDLEdBQTZDLFNBQTVEOztBQUVBLGtCQUFRLEdBQVIsQ0FBWSwrQ0FBK0MsTUFBL0MsR0FBd0QsS0FBcEUsRUFBMkUsU0FBM0U7QUFDQSxpQkFBTyxNQUFLLFNBQUwsQ0FBZSxpQkFBZixDQUFpQyxZQUFqQyxDQUFQO0FBQ0QsU0FoQk0sRUFnQkosSUFoQkksQ0FnQkMsVUFBQyxNQUFELEVBQVk7QUFDbEIsa0JBQVEsTUFBUjtBQUNELFNBbEJNLEVBa0JKLEtBbEJJLENBa0JFLFVBQUMsTUFBRCxFQUFZO0FBQ25CLGlCQUFPLE1BQVA7QUFDRCxTQXBCTSxDQUFQO0FBc0JELE9BdkRNLENBQVA7QUF3REQ7OzswQ0FFcUIsVyxFQUFhO0FBQUE7O0FBQ2pDLGFBQU8sc0JBQVksVUFBQyxPQUFELEVBQVUsTUFBVixFQUFxQjs7QUFFdEMsWUFBSSxhQUFhLHNCQUFVLFdBQVYsQ0FBakI7QUFDQSxZQUFJLFNBQVMsV0FBVyxNQUF4QjtBQUNBLFlBQUksV0FBVyxXQUFXLFFBQTFCOztBQUVBLFlBQUksbUJBQW1CLHNCQUFVLE9BQUssVUFBZixDQUF2QjtBQUNBLFlBQUksZUFBZSxpQkFBaUIsTUFBcEM7O0FBRUEsWUFBSSxDQUFDLE1BQUwsRUFBYTtBQUNYLG1CQUFTLFdBQVQ7QUFDRDs7QUFFRCxZQUFJLFdBQVcsWUFBWCxJQUEyQixDQUFDLFFBQWhDLEVBQTBDO0FBQ3hDLHFCQUFXLFNBQVg7QUFDRCxTQUZELE1BRU87QUFDTCxxQkFBVyxTQUFTLFNBQVQsQ0FBbUIsU0FBUyxXQUFULENBQXFCLEdBQXJCLElBQTRCLENBQS9DLENBQVg7QUFDRDs7QUFFRCxZQUFJLFdBQVcsc0NBQTBCLE9BQUssb0JBQS9CLEVBQXFELGVBQXJELEVBQXNFLFVBQXRFLENBQWY7O0FBRUEsc0JBQWMsU0FBUyxNQUFULEdBQWtCLE1BQWxCLEdBQTJCLFNBQVMsTUFBcEMsR0FBNkMsUUFBM0Q7QUFDQSxnQkFBUSxHQUFSLENBQVksZ0NBQWdDLE1BQWhDLEdBQXlDLEtBQXJELEVBQTRELFdBQTVEO0FBQ0EsZUFBTyxPQUFLLFNBQUwsQ0FBZSxxQkFBZixDQUFxQyxXQUFyQyxFQUFrRCxJQUFsRCxDQUF1RCxVQUFDLE1BQUQsRUFBWTs7QUFFeEUsa0JBQVEsTUFBUjtBQUVELFNBSk0sRUFJSixLQUpJLENBSUUsWUFBTTs7QUFFYixxQkFBVyxNQUFYO0FBQ0EsbUJBQVMsWUFBVDs7QUFFQSx3QkFBYyxxQkFBUyxPQUFLLG9CQUFkLEVBQW9DLGVBQXBDLEVBQXFELFVBQXJELEVBQWlFLFFBQWpFLENBQWQ7O0FBRUEsa0JBQVEsR0FBUixDQUFZLGdDQUFnQyxNQUFoQyxHQUF5QyxLQUFyRCxFQUE0RCxXQUE1RDtBQUNBLGlCQUFPLE9BQUssU0FBTCxDQUFlLHFCQUFmLENBQXFDLFdBQXJDLENBQVA7QUFDRCxTQWJNLEVBYUosSUFiSSxDQWFDLFVBQUMsTUFBRCxFQUFZO0FBQ2xCLGtCQUFRLE1BQVI7QUFDRCxTQWZNLEVBZUosS0FmSSxDQWVFLFVBQUMsTUFBRCxFQUFZO0FBQ25CLGlCQUFPLE1BQVA7QUFDRCxTQWpCTSxDQUFQO0FBbUJELE9BMUNNLENBQVA7QUEyQ0Q7Ozs7O2tCQUdZLFc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0hmOztBQUNBOzs7O0FBQ0E7Ozs7OztJQUVNLE07QUFFSixrQkFBWSxvQkFBWixFQUFrQztBQUFBOztBQUNoQyxRQUFJLENBQUMsb0JBQUwsRUFBMkIsTUFBTSxNQUFNLHVEQUFOLENBQU47QUFDM0IsU0FBSyxvQkFBTCxHQUE0QixvQkFBNUI7QUFDRDs7QUFFRDs7Ozs7Ozs7OztBQXNGQTs7OztnQ0FJWSxvQixFQUFzQjtBQUFBOztBQUVoQyxVQUFJLENBQUMsS0FBSyxXQUFMLEVBQUwsRUFBeUIsT0FBTyxLQUFQO0FBQ3pCLFVBQUksQ0FBQyxvQkFBTCxFQUEyQixNQUFNLElBQUksS0FBSixDQUFVLDRDQUFWLENBQU47O0FBRTNCLGFBQU8sc0JBQVksVUFBQyxPQUFELEVBQVUsTUFBVixFQUFxQjs7QUFFdEMsWUFBSSxvQkFBSjtBQUNBLFlBQUksd0JBQUo7QUFDQSxZQUFJLDJCQUFKO0FBQ0EsWUFBSSw4QkFBSjtBQUNBLFlBQUksWUFBWSxLQUFoQjs7QUFFQSxZQUFJLGNBQWMsU0FBZCxXQUFjLENBQUMsTUFBRCxFQUFZO0FBQzVCLGtCQUFRLEtBQVIsQ0FBYywwQ0FBZCxFQUEwRCxNQUExRDtBQUNBLGlCQUFPLE1BQVA7QUFDRCxTQUhEOztBQUtBLFlBQUksY0FBYyxTQUFkLFdBQWMsQ0FBQyxNQUFELEVBQVk7QUFDNUIsc0JBQVksSUFBWjtBQUNBLGlCQUFPLE1BQVA7QUFDRCxTQUhEOztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQVEsSUFBUixDQUFhLHFEQUFiO0FBQ0EsZ0JBQVEsSUFBUixDQUFhLDhCQUFiLEVBQTZDLG9CQUE3QztBQUNBLGVBQU8sTUFBSyxXQUFMLENBQWlCLG9CQUFqQixDQUFzQyxvQkFBdEMsRUFDTixJQURNLENBQ0QsVUFBQyxpQkFBRCxFQUF1QjtBQUMzQjtBQUNBLGtCQUFRLElBQVIsQ0FBYSw4QkFBYjs7QUFFQTtBQUNBO0FBQ0EsK0JBQXFCLGlCQUFyQjs7QUFFQSxjQUFJLG1CQUFtQixrQkFBa0IsZ0JBQXpDOztBQUVBLGNBQUkscUJBQXFCLGdCQUF6QixFQUEyQztBQUN6QyxtQkFBTyxrQkFBa0IsYUFBekI7QUFDRDs7QUFFRDtBQUNBLGlCQUFPLE1BQUssZ0JBQUwsQ0FBc0IsdUJBQXRCLENBQThDLGdCQUE5QyxDQUFQO0FBQ0QsU0FqQk0sRUFpQkosV0FqQkksRUFrQk4sSUFsQk0sQ0FrQkQsVUFBQyxhQUFELEVBQW1CO0FBQ3ZCLGNBQUksU0FBSixFQUFlLE9BQU8sS0FBUDs7QUFFZixrQkFBUSxJQUFSLENBQWEsK0JBQWI7O0FBRUE7O0FBRUEsa0NBQXdCLGFBQXhCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFJLFNBQVMsSUFBYjs7QUFFQSxpQkFBTyxNQUFQO0FBQ0QsU0FyQ00sRUFxQ0osV0FyQ0ksRUFzQ04sSUF0Q00sQ0FzQ0QsVUFBQyxZQUFELEVBQWtCO0FBQ3RCLGNBQUksU0FBSixFQUFlLE9BQU8sS0FBUDtBQUNmLGtCQUFRLElBQVIsQ0FBYSxtQ0FBbUMsWUFBaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBSSxnQkFBZ0IsSUFBcEI7QUFDQSxjQUFJLGdCQUFKOztBQUVBLGNBQUksYUFBSixFQUFtQjs7QUFFakI7QUFDQSxzQkFBVSxNQUFLLFFBQUwsQ0FBYyxhQUFkLEVBQVY7O0FBRUE7QUFDRCxXQU5ELE1BTU87O0FBRUwsZ0JBQUksU0FBUyxzQkFBVSxvQkFBVixFQUFnQyxNQUE3Qzs7QUFFQTtBQUNBLHNCQUFVLE1BQUssUUFBTCxDQUFjLFVBQWQsQ0FBeUIsTUFBekIsQ0FBVjtBQUNEOztBQUVEO0FBQ0EsaUJBQU8sT0FBUDtBQUNELFNBckVNLEVBcUVKLFdBckVJLEVBc0VOLElBdEVNLENBc0VELFVBQUMsT0FBRCxFQUFhO0FBQ2pCLGNBQUksU0FBSixFQUFlLE9BQU8sS0FBUDtBQUNmLGtCQUFRLElBQVIsQ0FBYSx1QkFBYixFQUFzQyxPQUF0Qzs7QUFFQTtBQUNBO0FBQ0EsaUJBQU8sT0FBUDtBQUNELFNBN0VNLEVBNkVKLFVBQUMsTUFBRCxFQUFZO0FBQ2IsY0FBSSxTQUFKLEVBQWUsT0FBTyxLQUFQO0FBQ2Ysa0JBQVEsS0FBUixDQUFjLG9DQUFkOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQUksVUFBVSxNQUFLLGVBQUwsQ0FBcUIsYUFBckIsRUFBZDs7QUFFQSxrQkFBUSxXQUFSLENBQW9CLEdBQXBCLEVBQXlCLFVBQUMsR0FBRCxFQUFTO0FBQ2hDLGtCQUFLLFVBQUwsQ0FBZ0IsV0FBaEIsQ0FBNEIsR0FBNUI7QUFDRCxXQUZEOztBQUlBLGlCQUFPLE9BQVA7QUFDRCxTQTNGTSxFQTJGSixXQTNGSSxFQTRGTixJQTVGTSxDQTRGRCxVQUFDLE9BQUQsRUFBYTtBQUNqQixjQUFJLFNBQUosRUFBZSxPQUFPLEtBQVA7QUFDZixrQkFBUSxJQUFSLENBQWEsZ0NBQWI7O0FBRUEsNEJBQWtCLE9BQWxCOztBQUVBLGNBQUksb0JBQW9CLENBQXhCO0FBQ0EsaUJBQU8sTUFBSyxrQkFBTCxDQUF3QixNQUF4QixDQUErQixNQUFLLFNBQUwsQ0FBZSxPQUE5QyxFQUF1RCxpQkFBdkQsRUFBMEUsa0JBQTFFLEVBQThGLFNBQTlGLENBQVA7QUFDRCxTQXBHTSxFQW9HSixXQXBHSSxFQXFHTixJQXJHTSxDQXFHRCxVQUFDLFNBQUQsRUFBZTtBQUNuQixjQUFJLFNBQUosRUFBZSxPQUFPLEtBQVA7QUFDZixrQkFBUSxJQUFSLENBQWEseUNBQWI7O0FBRUE7QUFDQSxpQkFBTyxNQUFLLFFBQUwsQ0FBYyxlQUFkLENBQThCLGVBQTlCLEVBQStDLG9CQUEvQyxFQUFxRSxrQkFBckUsRUFBeUYsU0FBekYsQ0FBUDtBQUNELFNBM0dNLEVBMkdKLFdBM0dJLEVBNEdOLElBNUdNLENBNEdELFVBQUMsVUFBRCxFQUFnQjtBQUNwQixjQUFJLFNBQUosRUFBZSxPQUFPLEtBQVA7QUFDZixrQkFBUSxJQUFSLENBQWEsd0NBQWIsRUFBdUQsVUFBdkQ7O0FBRUE7QUFDQSx3QkFBYyxVQUFkOztBQUVBO0FBQ0EsY0FBSSxnQkFBZ0IsRUFBcEI7QUFDQSxjQUFJLENBQUMsd0JBQVksbUJBQW1CLGFBQS9CLENBQUwsRUFBb0Q7QUFDbEQsZ0JBQUk7QUFDRiw4QkFBZ0Isc0JBQWMsRUFBZCxFQUFrQixLQUFLLEtBQUwsQ0FBVyxtQkFBbUIsYUFBOUIsQ0FBbEIsQ0FBaEI7QUFDRCxhQUZELENBRUUsT0FBTyxDQUFQLEVBQVU7QUFDViw4QkFBZ0IsbUJBQW1CLGFBQW5DO0FBQ0Q7QUFDRjtBQUNELHdCQUFjLFVBQWQsR0FBMkIsTUFBSyxXQUFoQzs7QUFFQTs7QUFFQSxjQUFJO0FBQ0YsbUJBQU8sZ0JBQWdCLGVBQWhCLENBQWdDLHNCQUFzQixVQUF0RCxFQUFrRSxXQUFsRSxFQUErRSxhQUEvRSxDQUFQO0FBQ0QsV0FGRCxDQUVFLE9BQU8sQ0FBUCxFQUFVO0FBQ1Ysb0JBQVEsS0FBUixDQUFjLDRCQUFkLEVBQTRDLENBQTVDO0FBQ0EsbUJBQU8sQ0FBUDtBQUNEO0FBQ0YsU0F0SU0sRUFzSUosV0F0SUksRUF1SU4sSUF2SU0sQ0F1SUQsVUFBQyxxQkFBRCxFQUEyQjtBQUMvQixjQUFJLFNBQUosRUFBZSxPQUFPLEtBQVA7QUFDZixrQkFBUSxJQUFSLENBQWEsMENBQWIsRUFBeUQscUJBQXpEOztBQUVBOztBQUVBO0FBQ0EsZ0JBQUssVUFBTCxDQUFnQixXQUFoQixDQUE0QixXQUE1QixFQUF5QyxVQUFDLEdBQUQsRUFBUztBQUNoRCw0QkFBZ0IsV0FBaEIsQ0FBNEIsR0FBNUI7QUFDRCxXQUZEOztBQUlBO0FBQ0EsY0FBSSxVQUFVO0FBQ1osK0JBQW1CLFdBRFA7QUFFWixvQkFBUTtBQUZJLFdBQWQ7O0FBS0Esa0JBQVEsT0FBUjs7QUFFQTtBQUNBLGtCQUFRLElBQVIsQ0FBYSxpREFBYjtBQUNELFNBNUpNLEVBNEpKLFdBNUpJLEVBNkpOLEtBN0pNLENBNkpBLFdBN0pBLENBQVA7QUE4SkQsT0F0TE0sQ0FBUDtBQXVMRDs7QUFFRDs7Ozs7Ozs2QkFJUyxZLEVBQWM7QUFBQTs7QUFFckIsVUFBSSxDQUFDLEtBQUssV0FBTCxFQUFMLEVBQXlCLE9BQU8sS0FBUDtBQUN6QixVQUFJLENBQUMsWUFBTCxFQUFtQixNQUFNLElBQUksS0FBSixDQUFVLDhDQUFWLENBQU47O0FBRW5CLGFBQU8sc0JBQVksVUFBQyxPQUFELEVBQVUsTUFBVixFQUFxQjs7QUFFdEMsWUFBSSxTQUFTLHNCQUFVLFlBQVYsRUFBd0IsTUFBckM7O0FBRUEsWUFBSSxDQUFDLE1BQUwsRUFBYTtBQUNYLG1CQUFTLFlBQVQ7QUFDRDs7QUFFRCxZQUFJLHFCQUFKO0FBQ0EsWUFBSSx3QkFBSjtBQUNBLFlBQUksNkJBQUo7QUFDQSxZQUFJLDJCQUFKO0FBQ0EsWUFBSSxZQUFZLEtBQWhCOztBQUVBLFlBQUksY0FBYyxTQUFkLFdBQWMsQ0FBQyxNQUFELEVBQVk7QUFDNUIsa0JBQVEsS0FBUixDQUFjLGtEQUFkLEVBQWtFLE1BQWxFO0FBQ0EsaUJBQU8sTUFBUDtBQUNELFNBSEQ7O0FBS0EsWUFBSSxjQUFjLFNBQWQsV0FBYyxDQUFDLE1BQUQsRUFBWTtBQUM1QixzQkFBWSxJQUFaO0FBQ0EsaUJBQU8sTUFBUDtBQUNELFNBSEQ7O0FBS0E7QUFDQSxnQkFBUSxJQUFSLENBQWEsNkRBQWI7QUFDQSxnQkFBUSxJQUFSLENBQWEsaURBQWIsRUFBZ0UsTUFBaEU7QUFDQSxlQUFLLFFBQUwsQ0FBYyxpQkFBZCxDQUFnQyxNQUFoQyxFQUF3QyxJQUF4QyxDQUE2QyxVQUFDLG1CQUFELEVBQXlCO0FBQ3BFO0FBQ0Esa0JBQVEsSUFBUixDQUFhLCtCQUFiLEVBQThDLE1BQTlDLEVBQXNELElBQXRELEVBQTRELG1CQUE1RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBSSxPQUFPLE9BQUssUUFBTCxDQUFjLGNBQWQsQ0FBNkIsTUFBN0IsQ0FBWDtBQUNBLGtCQUFRLElBQVI7QUFDQSxrQkFBUSxJQUFSLENBQWEsdURBQWI7QUFDRCxTQWRELEVBZUMsS0FmRCxDQWVPLFVBQUMsTUFBRCxFQUFZOztBQUVqQjtBQUNBLGtCQUFRLElBQVIsQ0FBYSw2QkFBNkIsTUFBMUM7O0FBRUE7O0FBRUE7QUFDQSxpQkFBSyxXQUFMLENBQWlCLGlCQUFqQixDQUFtQyxZQUFuQyxFQUNDLElBREQsQ0FDTSxVQUFDLGNBQUQsRUFBb0I7QUFDeEIsZ0JBQUksU0FBSixFQUFlLE9BQU8sS0FBUDtBQUNmLG9CQUFRLElBQVIsQ0FBYSxvQ0FBYjs7QUFFQTtBQUNBLDhCQUFrQixjQUFsQjs7QUFFQSxnQkFBSSxtQkFBbUIsZUFBZSxnQkFBdEM7O0FBRUEsZ0JBQUkscUJBQXFCLGdCQUF6QixFQUEyQztBQUN6QyxxQkFBTyxlQUFlLGFBQXRCO0FBQ0Q7O0FBRUQ7QUFDQSxtQkFBTyxPQUFLLGdCQUFMLENBQXNCLHVCQUF0QixDQUE4QyxnQkFBOUMsQ0FBUDtBQUNELFdBaEJELEVBZ0JHLFdBaEJILEVBaUJDLEtBakJELENBaUJPLFdBakJQLEVBa0JDLElBbEJELENBa0JNLFVBQUMsaUJBQUQsRUFBdUI7QUFDM0IsZ0JBQUksU0FBSixFQUFlLE9BQU8sS0FBUDtBQUNmLG9CQUFRLElBQVIsQ0FBYSxxQ0FBYjs7QUFFQTs7QUFFQSxpQ0FBcUIsaUJBQXJCOztBQUVBO0FBQ0EsZ0JBQUksU0FBUyxJQUFiO0FBQ0EsbUJBQU8sTUFBUDtBQUNELFdBN0JELEVBNkJHLFdBN0JILEVBOEJDLElBOUJELENBOEJNLFVBQUMsTUFBRCxFQUFZO0FBQ2hCLGdCQUFJLFNBQUosRUFBZSxPQUFPLEtBQVA7O0FBRWY7QUFDQSxtQkFBTyxPQUFLLFFBQUwsQ0FBYyxVQUFkLENBQXlCLE1BQXpCLENBQVA7QUFDRCxXQW5DRCxFQW9DQyxJQXBDRCxDQW9DTSxVQUFDLFdBQUQsRUFBaUI7QUFDckIsZ0JBQUksU0FBSixFQUFlLE9BQU8sS0FBUDtBQUNmLG9CQUFRLElBQVIsQ0FBYSwwREFBYixFQUF5RSxXQUF6RTs7QUFFQTs7QUFFQSwyQkFBZSxXQUFmO0FBQ0EsbUJBQU8sV0FBUDtBQUNELFdBNUNELEVBNkNDLEtBN0NELENBNkNPLFVBQUMsTUFBRCxFQUFZO0FBQ2pCLGdCQUFJLFNBQUosRUFBZSxPQUFPLEtBQVA7QUFDZixvQkFBUSxJQUFSLENBQWEsK0NBQWIsRUFBOEQsTUFBOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQUksVUFBVSxPQUFLLGVBQUwsQ0FBcUIsYUFBckIsRUFBZDtBQUNBLG9CQUFRLFdBQVIsQ0FBb0IsR0FBcEIsRUFBeUIsVUFBQyxHQUFELEVBQVM7QUFDaEMscUJBQUssVUFBTCxDQUFnQixXQUFoQixDQUE0QixHQUE1QjtBQUNELGFBRkQ7O0FBSUEsbUJBQU8sT0FBUDtBQUNELFdBMURELEVBMkRDLElBM0RELENBMkRNLFVBQUMsT0FBRCxFQUFhO0FBQ2pCLGdCQUFJLFNBQUosRUFBZSxPQUFPLEtBQVA7QUFDZixvQkFBUSxJQUFSLENBQWEsNkNBQWIsRUFBNEQsT0FBNUQsRUFBcUUsWUFBckUsRUFBbUYsTUFBbkY7O0FBRUEsMkJBQWUsT0FBZjs7QUFFQTtBQUNBLG1CQUFPLE9BQUssUUFBTCxDQUFjLFlBQWQsQ0FBMkIsWUFBM0IsRUFBeUMsTUFBekMsQ0FBUDtBQUNELFdBbkVELEVBbUVHLFdBbkVILEVBb0VDLElBcEVELENBb0VNLFVBQUMsbUJBQUQsRUFBeUI7QUFDN0IsZ0JBQUksU0FBSixFQUFlLE9BQU8sS0FBUDtBQUNmLG9CQUFRLElBQVIsQ0FBYSx1Q0FBYixFQUFzRCxtQkFBdEQ7O0FBRUE7O0FBRUEsbUNBQXVCLG1CQUF2Qjs7QUFFQTtBQUNBLGdCQUFJLGdCQUFnQixFQUFwQjtBQUNBLGdCQUFJLENBQUMsd0JBQVksZ0JBQWdCLGFBQTVCLENBQUwsRUFBaUQ7QUFDL0Msa0JBQUk7QUFDRixnQ0FBZ0Isc0JBQWMsRUFBZCxFQUFrQixLQUFLLEtBQUwsQ0FBVyxnQkFBZ0IsYUFBM0IsQ0FBbEIsQ0FBaEI7QUFDRCxlQUZELENBRUUsT0FBTyxDQUFQLEVBQVU7QUFDVixnQ0FBZ0IsZ0JBQWdCLGFBQWhDO0FBQ0Q7QUFDRjs7QUFFRCwwQkFBYyxVQUFkLEdBQTJCLE9BQUssV0FBaEM7O0FBRUE7QUFDQSxnQkFBSTtBQUNGLHFCQUFPLGFBQWEsZUFBYixDQUE2QixtQkFBbUIsVUFBaEQsRUFBNEQsbUJBQTVELEVBQWlGLGFBQWpGLENBQVA7QUFDRCxhQUZELENBRUUsT0FBTyxDQUFQLEVBQVU7QUFDVixzQkFBUSxLQUFSLENBQWMsNEJBQWQsRUFBNEMsQ0FBNUM7QUFDQSxxQkFBTyxDQUFQO0FBQ0Q7QUFDRixXQS9GRCxFQStGRyxXQS9GSCxFQWdHQyxJQWhHRCxDQWdHTSxVQUFDLHFCQUFELEVBQTJCO0FBQy9CLGdCQUFJLFNBQUosRUFBZSxPQUFPLEtBQVA7QUFDZixvQkFBUSxJQUFSLENBQWEsaURBQWIsRUFBZ0UscUJBQWhFOztBQUVBOztBQUVBO0FBQ0EsbUJBQUssVUFBTCxDQUFnQixXQUFoQixDQUE0QixvQkFBNUIsRUFBa0QsVUFBQyxHQUFELEVBQVM7QUFDekQsMkJBQWEsV0FBYixDQUF5QixHQUF6QjtBQUNELGFBRkQ7O0FBSUE7QUFDQSxnQkFBSSxPQUFPLE9BQUssUUFBTCxDQUFjLGNBQWQsQ0FBNkIsTUFBN0IsQ0FBWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFRLEdBQVIsQ0FBWSxZQUFaLEVBQTBCLElBQTFCLEVBQWdDLE1BQWhDLEVBQXdDLE9BQUssUUFBTCxDQUFjLGNBQXREOztBQUVBLG9CQUFRLElBQVI7QUFDQSxvQkFBUSxJQUFSLENBQWEsdURBQWI7QUFFRCxXQXpIRCxFQXlIRyxXQXpISCxFQTBIQyxLQTFIRCxDQTBITyxXQTFIUDtBQTRIRCxTQW5KRDtBQXFKRCxPQWhMTSxDQUFQO0FBa0xEOztBQUVEOzs7Ozs7O2lDQUlhLFcsRUFBYTtBQUFBOztBQUV4QixVQUFJLENBQUMsS0FBSyxXQUFMLEVBQUwsRUFBeUIsT0FBTyxLQUFQO0FBQ3pCLFVBQUksQ0FBQyxXQUFMLEVBQWtCLE1BQU0sSUFBSSxLQUFKLENBQVUsNkNBQVYsQ0FBTjs7QUFFbEIsYUFBTyxzQkFBWSxVQUFDLE9BQUQsRUFBVSxNQUFWLEVBQXFCOztBQUV0QyxZQUFJLFNBQVMsc0JBQVUsV0FBVixFQUF1QixNQUFwQzs7QUFFQSxZQUFJLENBQUMsTUFBTCxFQUFhO0FBQ1gsbUJBQVMsV0FBVDtBQUNEOztBQUVELFlBQUksc0JBQUo7QUFDQSxZQUFJLHlCQUFKO0FBQ0EsWUFBSSw0QkFBSjtBQUNBLFlBQUksNEJBQUo7QUFDQSxZQUFJLFlBQVksS0FBaEI7O0FBRUEsWUFBSSxjQUFjLFNBQWQsV0FBYyxDQUFDLE1BQUQsRUFBWTtBQUM1QixrQkFBUSxLQUFSLENBQWMsOENBQWQsRUFBOEQsTUFBOUQ7QUFDQSxpQkFBTyxNQUFQO0FBQ0QsU0FIRDs7QUFLQSxZQUFJLGNBQWMsU0FBZCxXQUFjLENBQUMsTUFBRCxFQUFZO0FBQzVCLHNCQUFZLElBQVo7QUFDQSxpQkFBTyxNQUFQO0FBQ0QsU0FIRDs7QUFLQTtBQUNBLGdCQUFRLElBQVIsQ0FBYSxvRUFBYjtBQUNBLGdCQUFRLElBQVIsQ0FBYSxvREFBYixFQUFtRSxNQUFuRTtBQUNBLGVBQU8sT0FBSyxRQUFMLENBQWMsZ0JBQWQsQ0FBK0IsTUFBL0IsRUFDTixJQURNLENBQ0QsVUFBQyxrQkFBRCxFQUF3QjtBQUM1QjtBQUNBLGtCQUFRLElBQVIsQ0FBYSwwQkFBYixFQUF5QyxrQkFBekM7O0FBRUE7O0FBRUEsY0FBSSxXQUFXLE9BQUssUUFBTCxDQUFjLFlBQWQsQ0FBMkIsTUFBM0IsQ0FBZjtBQUNBLGtCQUFRLEdBQVIsQ0FBWSxZQUFaLEVBQTBCLFFBQTFCOztBQUVBLGtCQUFRLFFBQVI7QUFDQSxrQkFBUSxJQUFSLENBQWEsdURBQWI7QUFDRCxTQVpNLEVBYU4sS0FiTSxDQWFBLFVBQUMsTUFBRCxFQUFZOztBQUVqQjtBQUNBLGtCQUFRLElBQVIsQ0FBYSx3QkFBYixFQUF1QyxNQUF2Qzs7QUFFQTs7QUFFQTtBQUNBLGlCQUFLLFdBQUwsQ0FBaUIscUJBQWpCLENBQXVDLFdBQXZDLEVBQ0MsSUFERCxDQUNNLFVBQUMsZUFBRCxFQUFxQjs7QUFFekIsb0JBQVEsSUFBUixDQUFhLG1DQUFiOztBQUVBO0FBQ0EsK0JBQW1CLGVBQW5COztBQUVBLGdCQUFJLG1CQUFtQixnQkFBZ0IsZ0JBQXZDOztBQUVBLGdCQUFJLHFCQUFxQixnQkFBekIsRUFBMkM7QUFDekMscUJBQU8sZ0JBQWdCLGFBQXZCO0FBQ0Q7O0FBRUQ7QUFDQSxtQkFBTyxPQUFLLGdCQUFMLENBQXNCLHVCQUF0QixDQUE4QyxnQkFBOUMsQ0FBUDtBQUNELFdBaEJELEVBZ0JHLFdBaEJILEVBaUJDLElBakJELENBaUJNLFVBQUMsYUFBRCxFQUFtQjtBQUN2QixnQkFBSSxTQUFKLEVBQWUsT0FBTyxLQUFQO0FBQ2Ysb0JBQVEsSUFBUixDQUFhLHVDQUFiOztBQUVBOztBQUVBLGtDQUFzQixhQUF0Qjs7QUFFQTtBQUNBLGdCQUFJLFNBQVMsSUFBYjtBQUNBLG1CQUFPLE1BQVA7QUFDRCxXQTVCRCxFQTRCRyxXQTVCSCxFQTZCQyxJQTdCRCxDQTZCTSxVQUFDLE1BQUQsRUFBWTtBQUNoQixnQkFBSSxTQUFKLEVBQWUsT0FBTyxLQUFQOztBQUVmO0FBQ0EsbUJBQU8sT0FBSyxRQUFMLENBQWMsVUFBZCxDQUF5QixNQUF6QixDQUFQO0FBQ0QsV0FsQ0QsRUFtQ0MsSUFuQ0QsQ0FtQ00sVUFBQyxZQUFELEVBQWtCO0FBQ3RCLGdCQUFJLFNBQUosRUFBZSxPQUFPLEtBQVA7QUFDZixvQkFBUSxJQUFSLENBQWEseURBQWIsRUFBd0UsWUFBeEU7O0FBRUEsNEJBQWdCLFlBQWhCO0FBQ0EsbUJBQU8sWUFBUDtBQUNELFdBekNELEVBMENDLEtBMUNELENBMENPLFVBQUMsTUFBRCxFQUFZO0FBQ2pCLGdCQUFJLFNBQUosRUFBZSxPQUFPLEtBQVA7QUFDZixvQkFBUSxJQUFSLENBQWEsOENBQWIsRUFBNkQsTUFBN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQUksVUFBVSxPQUFLLGVBQUwsQ0FBcUIsYUFBckIsRUFBZDtBQUNBLG9CQUFRLFdBQVIsQ0FBb0IsR0FBcEIsRUFBeUIsVUFBQyxHQUFELEVBQVM7QUFDaEMscUJBQUssVUFBTCxDQUFnQixXQUFoQixDQUE0QixHQUE1QjtBQUNELGFBRkQ7O0FBSUEsbUJBQU8sT0FBUDtBQUNELFdBdkRELEVBd0RDLElBeERELENBd0RNLFVBQUMsT0FBRCxFQUFhO0FBQ2pCLGdCQUFJLFNBQUosRUFBZSxPQUFPLEtBQVA7QUFDZixvQkFBUSxJQUFSLENBQWEsNkNBQWIsRUFBNEQsT0FBNUQsRUFBcUUsWUFBckUsRUFBbUYsTUFBbkY7O0FBRUEsNEJBQWdCLE9BQWhCOztBQUVBO0FBQ0EsbUJBQU8sT0FBSyxRQUFMLENBQWMsZ0JBQWQsQ0FBK0IsT0FBL0IsRUFBd0MsTUFBeEMsQ0FBUDtBQUNELFdBaEVELEVBZ0VHLFdBaEVILEVBaUVDLElBakVELENBaUVNLFVBQUMsa0JBQUQsRUFBd0I7QUFDNUIsZ0JBQUksU0FBSixFQUFlLE9BQU8sS0FBUDtBQUNmLG9CQUFRLElBQVIsQ0FBYSx1Q0FBYixFQUFzRCxrQkFBdEQ7O0FBRUE7O0FBRUEsa0NBQXNCLGtCQUF0Qjs7QUFFQTtBQUNBLGdCQUFJLGdCQUFnQixFQUFwQjtBQUNBLGdCQUFJLENBQUMsd0JBQVksaUJBQWlCLGFBQTdCLENBQUwsRUFBa0Q7QUFDaEQsa0JBQUk7QUFDRixnQ0FBZ0Isc0JBQWMsRUFBZCxFQUFrQixLQUFLLEtBQUwsQ0FBVyxpQkFBaUIsYUFBNUIsQ0FBbEIsQ0FBaEI7QUFDRCxlQUZELENBRUUsT0FBTyxDQUFQLEVBQVU7QUFDVixnQ0FBZ0IsaUJBQWlCLGFBQWpDO0FBQ0Q7QUFDRjtBQUNELDBCQUFjLFVBQWQsR0FBMkIsT0FBSyxXQUFoQzs7QUFFQTtBQUNBLGdCQUFJO0FBQ0YscUJBQU8sY0FBYyxlQUFkLENBQThCLG9CQUFvQixVQUFsRCxFQUE4RCxrQkFBOUQsRUFBa0YsYUFBbEYsQ0FBUDtBQUNELGFBRkQsQ0FFRSxPQUFPLENBQVAsRUFBVTtBQUNWLHNCQUFRLEtBQVIsQ0FBYyw0QkFBZCxFQUE0QyxDQUE1QztBQUNBLHFCQUFPLENBQVA7QUFDRDtBQUNGLFdBM0ZELEVBMkZHLFdBM0ZILEVBNEZDLElBNUZELENBNEZNLFVBQUMscUJBQUQsRUFBMkI7QUFDL0IsZ0JBQUksU0FBSixFQUFlLE9BQU8sS0FBUDtBQUNmLG9CQUFRLElBQVIsQ0FBYSxpREFBYixFQUFnRSxxQkFBaEU7O0FBRUE7O0FBRUE7QUFDQSxtQkFBSyxVQUFMLENBQWdCLFdBQWhCLENBQTRCLG1CQUE1QixFQUFpRCxVQUFDLEdBQUQsRUFBUztBQUN4RCw0QkFBYyxXQUFkLENBQTBCLEdBQTFCO0FBQ0QsYUFGRDs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFLLFFBQUwsQ0FBYyxZQUFkLENBQTJCLE1BQTNCLEVBQW1DLE1BQW5DLEdBQTRDLFVBQTVDO0FBQ0EsZ0JBQUksV0FBVyxPQUFLLFFBQUwsQ0FBYyxZQUFkLENBQTJCLE1BQTNCLENBQWY7O0FBRUEsb0JBQVEsR0FBUixDQUFZLFlBQVosRUFBMEIsUUFBMUI7O0FBRUEsb0JBQVEsUUFBUjtBQUNBLG9CQUFRLElBQVIsQ0FBYSx1REFBYjtBQUVELFdBdkhELEVBdUhHLFdBdkhILEVBd0hDLEtBeEhELENBd0hPLFdBeEhQO0FBeUhELFNBOUlNLENBQVA7QUFnSkQsT0EzS00sQ0FBUDtBQTRLRDs7QUFFRDs7OztrQ0FDYzs7QUFFWixVQUFJLFNBQVMsS0FBYjs7QUFFQSxVQUFJLENBQUMsS0FBSyxXQUFWLEVBQXVCLE1BQU0sSUFBSSxLQUFKLENBQVUseUNBQVYsQ0FBTjtBQUN2QixVQUFJLENBQUMsS0FBSyxZQUFWLEVBQXdCLE1BQU0sSUFBSSxLQUFKLENBQVUsMENBQVYsQ0FBTjtBQUN4QixVQUFJLENBQUMsS0FBSyxpQkFBVixFQUE2QixNQUFNLElBQUksS0FBSixDQUFVLGdEQUFWLENBQU47QUFDN0IsVUFBSSxDQUFDLEtBQUssU0FBVixFQUFxQixNQUFNLElBQUksS0FBSixDQUFVLHdDQUFWLENBQU47QUFDckIsVUFBSSxDQUFDLEtBQUssZUFBVixFQUEyQixNQUFNLElBQUksS0FBSixDQUFVLCtDQUFWLENBQU47O0FBRTNCLGVBQVMsSUFBVDtBQUNBLGFBQU8sTUFBUDtBQUNEOzs7c0JBcnBCYyxLLEVBQU87QUFDcEIsV0FBSyxXQUFMLEdBQW1CLEtBQW5CO0FBQ0Q7O0FBRUQ7Ozs7O3dCQUlpQjtBQUNmLGFBQU8sS0FBSyxXQUFaO0FBQ0Q7O0FBRUQ7Ozs7Ozs7c0JBSWEsSyxFQUFPO0FBQ2xCLFdBQUssU0FBTCxHQUFpQixLQUFqQjs7QUFFQTtBQUNBLFVBQUksb0JBQW9CLGdDQUFzQixLQUFLLFdBQTNCLEVBQXdDLEtBQUssWUFBN0MsRUFBMkQsS0FBSyxTQUFoRSxDQUF4QjtBQUNBLFdBQUssa0JBQUwsR0FBMEIsaUJBQTFCO0FBQ0Q7O0FBRUQ7Ozs7O3dCQUllO0FBQ2IsYUFBTyxLQUFLLFNBQVo7QUFDRDs7QUFFRDs7Ozs7OztzQkFJcUIsSyxFQUFPO0FBQzFCLFdBQUssaUJBQUwsR0FBeUIsS0FBekI7O0FBRUEsV0FBSyxXQUFMLEdBQW1CLDBCQUFnQixLQUFLLFdBQXJCLEVBQWtDLEtBQWxDLEVBQXlDLEtBQUssb0JBQTlDLENBQW5CO0FBQ0Q7O0FBRUQ7Ozs7O3dCQUl1QjtBQUNyQixhQUFPLEtBQUssaUJBQVo7QUFDRDs7QUFFRDs7Ozs7OztzQkFJZSxLLEVBQU87QUFDcEIsV0FBSyxZQUFMLEdBQW9CLEtBQXBCO0FBQ0Q7O0FBRUQ7Ozs7O3dCQUlpQjtBQUNmLGFBQU8sS0FBSyxZQUFaO0FBQ0Q7O0FBRUQ7Ozs7Ozs7c0JBSW1CLEssRUFBTztBQUN4QixXQUFLLGVBQUwsR0FBdUIsS0FBdkI7QUFDRDs7QUFFRDs7Ozs7d0JBSXFCO0FBQ25CLGFBQU8sS0FBSyxlQUFaO0FBQ0Q7Ozs7O2tCQXlrQlksTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqcEJmOztBQUdBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBRUE7Ozs7QUFDQTs7QUFHQTs7OztBQUNBOzs7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FBSkE7O0FBbENBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQW9ETSxTOztBQUVKOzs7OztBQUtBLHFCQUFZLGNBQVosRUFBNEIsTUFBNUIsRUFBb0M7QUFBQTs7O0FBRWxDLFFBQUksQ0FBQyxjQUFMLEVBQXFCLE1BQU0sSUFBSSxLQUFKLENBQVUsMkNBQVYsQ0FBTjtBQUNyQixRQUFJLENBQUMsTUFBTCxFQUFhLE1BQU0sSUFBSSxLQUFKLENBQVUsZ0NBQVYsQ0FBTjs7QUFFYjtBQUNBLFNBQUssb0JBQUwsR0FBNEIsc0JBQWMsRUFBQyxRQUFRLE1BQVQsRUFBZCw2Q0FBNUI7O0FBRUEsU0FBSyxjQUFMLEdBQXNCLGNBQXRCO0FBQ0EsU0FBSyxnQkFBTCxHQUF3QixlQUFlLHNCQUFmLEVBQXhCOztBQUVBLFFBQUksT0FBTyxlQUFlLHNCQUF0QixLQUFpRCxVQUFyRCxFQUFpRTtBQUMvRCxXQUFLLGtCQUFMLEdBQTBCLGVBQWUsc0JBQWYsRUFBMUI7QUFDRCxLQUZELE1BRU87QUFDTCxZQUFNLElBQUksS0FBSixDQUFVLGlGQUFWLENBQU47QUFDRDs7QUFFRCxRQUFJLE9BQU8sZUFBZSxrQkFBdEIsS0FBNkMsVUFBakQsRUFBNkQ7QUFDM0QsV0FBSyxrQkFBTCxHQUEwQixlQUFlLGtCQUFmLEVBQTFCO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsWUFBTSxJQUFJLEtBQUosQ0FBVSxtRkFBVixDQUFOO0FBQ0Q7O0FBRUQsUUFBSSxPQUFPLGVBQWUsY0FBdEIsS0FBeUMsVUFBN0MsRUFBeUQ7QUFDdkQsV0FBSyxjQUFMLEdBQXNCLGVBQWUsY0FBZixFQUF0QjtBQUNELEtBRkQsTUFFTztBQUNMLFlBQU0sSUFBSSxLQUFKLENBQVUsK0VBQVYsQ0FBTjtBQUNEO0FBQ0QsUUFBSSxPQUFPLGVBQWUsbUJBQXRCLEtBQThDLFVBQWxELEVBQThEO0FBQzVELFdBQUssbUJBQUwsR0FBMkIsZUFBZSxtQkFBZixDQUFtQyxLQUFLLGNBQXhDLENBQTNCO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsY0FBUSxJQUFSLENBQWEsbUZBQWI7QUFDRDtBQUVGOzs7OzJCQUVNO0FBQUE7O0FBRUwsYUFBTyxzQkFBWSxVQUFDLE9BQUQsRUFBVSxNQUFWLEVBQXFCOztBQUV0QyxlQUFLLE1BQUwsR0FBYyxPQUFLLG9CQUFMLENBQTBCLE1BQXhDOztBQUVBLFlBQUk7QUFDRixjQUFJLGtCQUFrQixPQUFLLG1CQUFMLENBQXlCLHNCQUF6QixFQUF0QjtBQUNBLGNBQUksZ0JBQWdCLE9BQUssY0FBTCxDQUFvQixHQUFwQixDQUF3QixhQUF4QixDQUFwQjs7QUFFQSw0QkFBUSxHQUFSLENBQVksQ0FBQyxhQUFELEVBQWdCLGVBQWhCLENBQVosRUFBOEMsSUFBOUMsQ0FBbUQsVUFBQyxPQUFELEVBQWE7O0FBRTlELG1CQUFLLFVBQUwsR0FBa0IsUUFBUSxDQUFSLElBQWEsUUFBUSxDQUFSLEVBQVcsVUFBeEIsR0FBcUMsUUFBUSxDQUFSLENBQXZEO0FBQ0EsZ0JBQUksQ0FBQyxPQUFLLFVBQVYsRUFBc0I7QUFDcEIscUJBQUssVUFBTCxHQUFrQixlQUFlLE9BQUssTUFBcEIsR0FBNkIsR0FBN0IsR0FBbUMsMEJBQXJEO0FBQ0EscUJBQUssY0FBTCxDQUFvQixHQUFwQixDQUF3QixhQUF4QixFQUF1QyxDQUF2QyxFQUEwQyxFQUFDLFlBQVksT0FBSyxVQUFsQixFQUExQztBQUNEOztBQUVELG1CQUFLLFlBQUwsR0FBb0IsUUFBUSxDQUFSLENBQXBCOztBQUVBLG1CQUFPLE9BQUssZUFBTCxFQUFQO0FBRUQsV0FaRCxFQVlHLElBWkgsQ0FZUSxVQUFDLE1BQUQsRUFBWTtBQUNsQixvQkFBUSxNQUFSO0FBQ0QsV0FkRCxFQWNHLEtBZEgsQ0FjUyxVQUFDLEtBQUQsRUFBVztBQUNsQixvQkFBUSxLQUFSLENBQWMsU0FBZCxFQUF5QixLQUF6QjtBQUNBLG1CQUFPLEtBQVA7QUFDRCxXQWpCRDtBQW1CRCxTQXZCRCxDQXVCRSxPQUFPLENBQVAsRUFBVTtBQUNWLGlCQUFPLENBQVA7QUFDRDtBQUVGLE9BL0JNLENBQVA7QUFpQ0Q7OztzQ0FFaUI7QUFBQTs7QUFFaEIsYUFBTyxzQkFBWSxVQUFDLE9BQUQsRUFBVSxNQUFWLEVBQXFCOztBQUV0QyxZQUFJOztBQUVGO0FBQ0EsaUJBQUssTUFBTCxHQUFjLHFCQUFXLE9BQUssb0JBQWhCLENBQWQ7O0FBRUE7QUFDQSxpQkFBSyxjQUFMLEdBQXNCLDZCQUFtQixPQUFLLFVBQXhCLEVBQW9DLE9BQUssbUJBQXpDLEVBQThELE9BQUssY0FBbkUsQ0FBdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBSSxhQUFhLE9BQUssY0FBTCxDQUFvQixnQkFBcEIsRUFBakI7O0FBRUE7QUFDQSxpQkFBSyxRQUFMLEdBQWdCLHVCQUFhLE9BQUssVUFBbEIsRUFBOEIsVUFBOUIsRUFBMEMsT0FBSyxjQUEvQyxFQUErRCxPQUFLLGdCQUFwRSxFQUFzRixPQUFLLG1CQUEzRixFQUFnSCxPQUFLLGNBQXJILENBQWhCOztBQUVBO0FBQ0EsaUJBQUssUUFBTCxDQUFjLE1BQWQsR0FBdUIsT0FBSyxNQUE1Qjs7QUFFQTtBQUNBLGlCQUFLLFVBQUwsR0FBa0IseUJBQWUsT0FBSyxRQUFwQixDQUFsQjs7QUFFQTtBQUNBLGlCQUFLLFlBQUwsR0FBb0Isa0JBQVEsNkJBQW1CLE9BQUssY0FBeEIsRUFBd0MsT0FBSyxRQUE3QyxFQUF1RCxPQUFLLGNBQTVELENBQVIsQ0FBcEI7O0FBRUEsaUJBQUssVUFBTCxDQUFnQixRQUFoQixDQUF5QixRQUF6QixHQUFvQzs7QUFFbEM7QUFDQSxvQkFBQyxHQUFELEVBQVM7QUFDUCxtQkFBSyxZQUFMLENBQWtCLFNBQWxCLENBQTRCLElBQUksR0FBaEMsRUFBcUMsSUFBckMsQ0FBMEMsVUFBQyxVQUFELEVBQWdCO0FBQ3hELGtCQUFJLEdBQUosR0FBVSxVQUFWO0FBQ0Esa0JBQUksSUFBSjtBQUNELGFBSEQsRUFHRyxLQUhILENBR1MsVUFBQyxNQUFELEVBQVk7QUFDbkIsc0JBQVEsS0FBUixDQUFjLE1BQWQ7QUFDQSxrQkFBSSxJQUFKLENBQVMsTUFBVDtBQUNELGFBTkQ7QUFPRCxXQVhpQyxDQUFwQzs7QUFjQTtBQUNBLHFCQUFXLFdBQVgsQ0FBdUIsR0FBdkIsRUFBNEIsVUFBQyxHQUFELEVBQVM7QUFDbkMsbUJBQUssVUFBTCxDQUFnQixXQUFoQixDQUE0QixHQUE1QjtBQUNELFdBRkQ7O0FBSUE7QUFDQSxpQkFBSyxRQUFMLENBQWMsVUFBZCxHQUEyQixPQUFLLFVBQWhDOztBQUVBO0FBQ0EsaUJBQUssY0FBTCxDQUFvQixRQUFwQixHQUErQixPQUFLLFFBQXBDOztBQUVBO0FBQ0E7QUFDQSxpQkFBSyxjQUFMLENBQW9CLFVBQXBCLEdBQWlDLE9BQUssVUFBdEM7O0FBRUE7QUFDQSxpQkFBSyxjQUFMLEdBQXNCLDZCQUFtQixPQUFLLFVBQXhCLEVBQW9DLE9BQUssVUFBekMsRUFBcUQsT0FBSyxRQUExRCxFQUFvRSxPQUFLLGdCQUF6RSxFQUEyRixPQUFLLGNBQWhHLENBQXRCOztBQUVBO0FBQ0EsaUJBQUssTUFBTCxDQUFZLFVBQVosR0FBeUIsT0FBSyxVQUE5QjtBQUNBLGlCQUFLLE1BQUwsQ0FBWSxVQUFaLEdBQXlCLE9BQUssVUFBOUI7QUFDQSxpQkFBSyxNQUFMLENBQVksUUFBWixHQUF1QixPQUFLLFFBQTVCO0FBQ0EsaUJBQUssTUFBTCxDQUFZLGdCQUFaLEdBQStCLE9BQUssZ0JBQXBDO0FBQ0EsaUJBQUssTUFBTCxDQUFZLGNBQVosR0FBNkIsT0FBSyxjQUFsQzs7QUFFQTtBQUNBOztBQUVBLGtCQUFRLElBQVI7QUFDRCxTQXBFRCxDQW9FRSxPQUFPLENBQVAsRUFBVTtBQUNWLGlCQUFPLENBQVA7QUFDRDtBQUVGLE9BMUVNLENBQVA7QUE0RUQ7O0FBRUQ7Ozs7Ozs7Z0NBSVksb0IsRUFBc0I7QUFBQTs7QUFFaEMsVUFBSSxDQUFDLG9CQUFMLEVBQTJCLE1BQU0sSUFBSSxLQUFKLENBQVUsNENBQVYsQ0FBTjs7QUFFM0IsYUFBTyxzQkFBWSxVQUFDLE9BQUQsRUFBVSxNQUFWLEVBQXFCOztBQUV0QyxlQUFLLE1BQUwsQ0FBWSxXQUFaLENBQXdCLG9CQUF4QixFQUNDLElBREQsQ0FDTSxVQUFDLE1BQUQsRUFBWTtBQUNoQixrQkFBUSxNQUFSO0FBQ0QsU0FIRCxFQUlDLEtBSkQsQ0FJTyxVQUFDLE1BQUQsRUFBWTtBQUNqQixpQkFBTyxNQUFQO0FBQ0QsU0FORDtBQVFELE9BVk0sQ0FBUDtBQVlEOztBQUVEOzs7Ozs7OzZCQUlTLFksRUFBYztBQUFBOztBQUVyQixVQUFJLENBQUMsWUFBTCxFQUFtQixNQUFNLElBQUksS0FBSixDQUFVLDhDQUFWLENBQU47O0FBRW5CLGFBQU8sc0JBQVksVUFBQyxPQUFELEVBQVUsTUFBVixFQUFxQjs7QUFFdEMsZUFBSyxNQUFMLENBQVksUUFBWixDQUFxQixZQUFyQixFQUNDLElBREQsQ0FDTSxVQUFDLE1BQUQsRUFBWTtBQUNoQixrQkFBUSxNQUFSO0FBQ0QsU0FIRCxFQUlDLEtBSkQsQ0FJTyxVQUFDLE1BQUQsRUFBWTtBQUNqQixpQkFBTyxNQUFQO0FBQ0QsU0FORDtBQVFELE9BVk0sQ0FBUDtBQVlEOztBQUVEOzs7Ozs7O2lDQUlhLFcsRUFBYTtBQUFBOztBQUV4QixVQUFJLENBQUMsV0FBTCxFQUFrQixNQUFNLElBQUksS0FBSixDQUFVLHFFQUFWLENBQU47O0FBRWxCLGFBQU8sc0JBQVksVUFBQyxPQUFELEVBQVUsTUFBVixFQUFxQjtBQUN0QyxlQUFLLE1BQUwsQ0FBWSxZQUFaLENBQXlCLFdBQXpCLEVBQ0MsSUFERCxDQUNNLFVBQUMsTUFBRCxFQUFZO0FBQ2hCLGtCQUFRLE1BQVI7QUFDRCxTQUhELEVBSUMsS0FKRCxDQUlPLFVBQUMsTUFBRCxFQUFZO0FBQ2pCLGlCQUFPLE1BQVA7QUFDRCxTQU5EO0FBT0QsT0FSTSxDQUFQO0FBVUQ7O0FBRUQ7Ozs7Ozs7NEJBSVE7QUFDTixVQUFJLFFBQVEsSUFBWjs7QUFFQSxjQUFRLElBQVIsQ0FBYSwwQkFBYjtBQUNBLGFBQU8sc0JBQVksVUFBUyxPQUFULEVBQWtCLE1BQWxCLEVBQTBCOztBQUUzQyxjQUFNLFFBQU4sQ0FBZSxzQkFBZixHQUF3QyxJQUF4QyxDQUE2QyxVQUFTLE1BQVQsRUFBaUI7QUFDNUQsa0JBQVEsSUFBUixDQUFhLGdEQUFiLEVBQStELE1BQS9EO0FBQ0Esa0JBQVEsSUFBUjtBQUNELFNBSEQsRUFHRyxLQUhILENBR1MsVUFBUyxNQUFULEVBQWlCO0FBQ3hCLGtCQUFRLEtBQVIsQ0FBYyxvQ0FBZCxFQUFvRCxNQUFwRDtBQUNBLGlCQUFPLEtBQVA7QUFDRCxTQU5EO0FBUUQsT0FWTSxDQUFQO0FBWUQ7Ozs7O0FBL1FIOzs7a0JBbVJlLFM7Ozs7Ozs7OztBQzVTUixJQUFNLHNEQUF1Qjs7QUFFbEMsZUFBYTtBQUNYLGNBQVU7QUFDUixjQUFRLG9CQURBO0FBRVIsY0FBUTtBQUZBLEtBREM7QUFLWCxvQkFBZ0I7QUFDZCxjQUFRLG9CQURNO0FBRWQsY0FBUTtBQUZNLEtBTEw7QUFTWCxlQUFXO0FBQ1QsY0FBUSxvQkFEQztBQUVULGNBQVE7QUFGQyxLQVRBO0FBYVgsZUFBVztBQUNULGNBQVEsb0JBREM7QUFFVCxjQUFRO0FBRkMsS0FiQTtBQWlCWCxvQkFBZ0I7QUFDZCxjQUFRLG9CQURNO0FBRWQsY0FBUTtBQUZNLEtBakJMO0FBcUJYLGlCQUFhO0FBQ1gsY0FBUSxvQkFERztBQUVYLGNBQVE7QUFGRztBQXJCRixHQUZxQjtBQTRCbEMsaUJBQWU7QUFDYixrQkFBYztBQUNaLGNBQVEsZ0NBREk7QUFFWixjQUFRLDRCQUZJO0FBR1osZ0JBQVU7QUFIRSxLQUREO0FBTWIsY0FBVTtBQUNSLGNBQVEsZ0NBREE7QUFFUixjQUFRLHlCQUZBO0FBR1IsZ0JBQVU7QUFIRjtBQU5HLEdBNUJtQjtBQXdDbEMsY0FBWTtBQUNWLFlBQVEsb0JBREU7QUFFVixZQUFRLEVBRkU7QUFHViw4QkFBMEIsNkJBSGhCO0FBSVYsNkJBQXlCLDRCQUpmO0FBS1YsNEJBQXdCO0FBTGQsR0F4Q3NCO0FBK0NsQyxxQkFBbUI7QUFDakIsWUFBUSxvQkFEUztBQUVqQixZQUFRO0FBRlMsR0EvQ2U7QUFtRGxDLHFCQUFtQjtBQW5EZSxDQUE3Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBUDs7QUFDQTs7Ozs7O0lBRU0sYztBQUVKLDBCQUFZLE1BQVosRUFBb0IsR0FBcEIsRUFBeUIsU0FBekIsRUFBb0M7QUFBQTs7QUFDbEMsUUFBSSxRQUFRLElBQVo7O0FBRUEsVUFBTSxPQUFOLEdBQWdCLE1BQWhCO0FBQ0EsVUFBTSxJQUFOLEdBQWEsR0FBYjtBQUNBLFVBQU0sVUFBTixHQUFtQixTQUFuQjs7QUFFQSxVQUFNLGVBQU4sR0FBd0IsT0FBTyxlQUEvQjs7QUFFQSxVQUFNLElBQU4sR0FBYSxPQUFPLElBQXBCOztBQUVBLFVBQU0sY0FBTixHQUF1QixFQUF2QjtBQUNBLFVBQU0scUJBQU4sR0FBOEIsRUFBOUI7QUFDRDs7OztxQ0FFZ0IsTyxFQUFTO0FBQ3hCLFVBQUksUUFBUSxJQUFaOztBQUVBLFlBQU0sY0FBTixDQUFxQixPQUFyQixJQUFnQywyQkFBaUIsTUFBTSxJQUF2QixFQUE2QixPQUE3QixFQUFzQyxNQUFNLElBQTVDLEVBQWtELE1BQU0sVUFBeEQsRUFBb0UsS0FBcEUsQ0FBaEM7QUFDRDs7O29DQUVlLE8sRUFBUztBQUN2QixVQUFJLFFBQVEsSUFBWjs7QUFFQSxZQUFNLGdCQUFOLENBQXVCLE9BQXZCO0FBQ0Q7Ozt1Q0FFa0IsTyxFQUFTO0FBQzFCLFVBQUksUUFBUSxJQUFaOztBQUVBLFVBQUksU0FBUyxzQkFBVSxPQUFWLEVBQW1CLE1BQWhDO0FBQ0EsVUFBSSxxQkFBcUIsTUFBTSxJQUFOLEdBQWEsZUFBdEM7O0FBRUEsVUFBSSxlQUFlLE1BQU0sY0FBTixDQUFxQixPQUFyQixDQUFuQjtBQUNBLFVBQUksWUFBSixFQUFrQjtBQUNoQjtBQUNBLGNBQU0sSUFBTixDQUFXLFdBQVgsQ0FBdUI7QUFDckIsZ0JBQU0sYUFEZSxFQUNBLE1BQU0sTUFBTSxPQUFOLENBQWMsSUFEcEIsRUFDMEIsSUFBSSxrQkFEOUI7QUFFckIsZ0JBQU0sRUFBRSxVQUFVLE1BQU0sSUFBbEI7QUFGZSxTQUF2Qjs7QUFLQTtBQUNBO0FBQ0EsY0FBTSxJQUFOLENBQVcsV0FBWCxDQUF1QjtBQUNyQixnQkFBTSxhQURlLEVBQ0EsTUFBTSxNQUFNLE9BQU4sQ0FBYyxJQURwQixFQUMwQixJQUFJLHVCQUF1QixNQUF2QixHQUFnQyxLQUQ5RDtBQUVyQixnQkFBTSxFQUFFLFVBQVUsTUFBTSxJQUFsQixFQUF3QixtQkFBbUIsTUFBTSxVQUFqRDtBQUZlLFNBQXZCOztBQUtBLHFCQUFhLGlCQUFiO0FBQ0EsZUFBTyxNQUFNLGNBQU4sQ0FBcUIsT0FBckIsQ0FBUDtBQUNEO0FBQ0Y7Ozs7O2tCQUlZLGM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNURmOztBQUNBOzs7Ozs7SUFFTSxjO0FBRUosMEJBQVksTUFBWixFQUFvQixLQUFwQixFQUEyQixHQUEzQixFQUFnQztBQUFBOztBQUM5QixRQUFJLFFBQVEsSUFBWjs7QUFFQSxVQUFNLE9BQU4sR0FBZ0IsTUFBaEI7QUFDQSxVQUFNLE1BQU4sR0FBZSxLQUFmO0FBQ0EsVUFBTSxJQUFOLEdBQWEsR0FBYjs7QUFFQSxVQUFNLElBQU4sR0FBYSxPQUFPLElBQXBCO0FBQ0EsVUFBTSxlQUFOLEdBQXdCLE9BQU8sZUFBL0I7O0FBRUEsVUFBTSxPQUFOLEdBQWdCLHNCQUFVLEtBQVYsRUFBaUIsTUFBakM7QUFDQSxVQUFNLGtCQUFOLEdBQTJCLE1BQU0sSUFBTixHQUFhLGVBQXhDOztBQUVBLFVBQU0sY0FBTixHQUF1QixFQUF2QjtBQUNBLFVBQU0sVUFBTixHQUFtQixFQUFuQjtBQUNBLFVBQU0sa0JBQU4sR0FBMkIsRUFBM0I7O0FBRUEsVUFBTSxTQUFOLEdBQWtCLEVBQWxCOztBQUVBLFVBQU0sa0JBQU47QUFDRDs7Ozt5Q0FFb0I7QUFDbkIsVUFBSSxRQUFRLElBQVo7O0FBRUE7QUFDQSxZQUFNLHFCQUFOLEdBQThCLE1BQU0sSUFBTixDQUFXLFdBQVgsQ0FBdUIsTUFBTSxrQkFBN0IsRUFBaUQsVUFBQyxHQUFELEVBQVM7QUFDdEYsZ0JBQVEsR0FBUixDQUFZLE1BQU0sa0JBQU4sR0FBMkIsUUFBdkMsRUFBaUQsR0FBakQ7QUFDQSxnQkFBUSxJQUFJLElBQVo7QUFDRSxlQUFLLFdBQUw7QUFBa0Isa0JBQU0sa0JBQU4sQ0FBeUIsR0FBekIsRUFBK0I7QUFDakQsZUFBSyxhQUFMO0FBQW9CLGtCQUFNLG9CQUFOLENBQTJCLEdBQTNCLEVBQWlDO0FBQ3JELGVBQUssVUFBTDtBQUFpQixrQkFBTSxpQkFBTixDQUF3QixHQUF4QixFQUE4QjtBQUhqRDtBQUtELE9BUDZCLENBQTlCOztBQVNBLFVBQUksWUFBWSxNQUFNLElBQU4sR0FBYSxVQUE3QjtBQUNBLFlBQU0sZUFBTixHQUF3QixNQUFNLElBQU4sQ0FBVyxXQUFYLENBQXVCLFNBQXZCLEVBQWtDLFVBQUMsR0FBRCxFQUFTO0FBQ2pFO0FBQ0EsWUFBSSxJQUFJLElBQUosQ0FBUyxTQUFiLEVBQXdCO0FBQ3RCLGdCQUFNLE9BQU4sQ0FBYyxpQkFBZCxDQUFnQyxVQUFoQyxDQUEyQyxNQUFNLElBQWpELEVBQXVELE1BQXZELEVBQStELElBQUksSUFBSixDQUFTLFNBQXhFLEVBQW1GLElBQUksSUFBSixDQUFTLEtBQTVGLEVBQW1HLElBQW5HO0FBQ0Q7QUFDRCxnQkFBUSxHQUFSLENBQVksb0JBQW9CLFNBQXBCLEdBQWdDLFFBQTVDLEVBQXNELEdBQXREO0FBQ0QsT0FOdUIsQ0FBeEI7QUFPRDs7O3dDQUVtQixhLEVBQWU7QUFDakMsVUFBSSxRQUFRLElBQVo7O0FBRUEsMEJBQVksYUFBWixFQUEyQixPQUEzQixDQUFtQyxVQUFDLEdBQUQsRUFBUztBQUMxQyxZQUFJLGFBQWEsY0FBYyxHQUFkLENBQWpCO0FBQ0E7QUFDQSxZQUFJLENBQUMsTUFBTSxjQUFOLENBQXFCLFVBQXJCLENBQUwsRUFBdUM7QUFDckMsZ0JBQU0sY0FBTixDQUFxQixVQUFyQixJQUFtQywyQkFBaUIsTUFBTSxJQUF2QixFQUE2QixNQUFNLE1BQW5DLEVBQTJDLE1BQU0sSUFBakQsRUFBdUQsTUFBTSxVQUE3RCxFQUF5RSxJQUF6RSxDQUFuQztBQUNEO0FBQ0YsT0FORDtBQVFEOzs7d0NBRW1CO0FBQ2xCLFVBQUksUUFBUSxJQUFaOztBQUVBLFlBQU0scUJBQU4sQ0FBNEIsTUFBNUI7O0FBRUEsWUFBTSxlQUFOLENBQXNCLE1BQXRCOztBQUVBLFlBQU0sa0JBQU4sQ0FBeUIsT0FBekIsQ0FBaUMsVUFBQyxFQUFELEVBQVE7QUFDdkMsV0FBRyxNQUFIO0FBQ0QsT0FGRDs7QUFJQSwwQkFBWSxNQUFNLFNBQWxCLEVBQTZCLE9BQTdCLENBQXFDLFVBQUMsR0FBRCxFQUFTO0FBQzVDLGNBQU0sa0JBQU4sQ0FBeUIsR0FBekI7QUFDRCxPQUZEOztBQUlBO0FBQ0EsMEJBQVksTUFBTSxjQUFsQixFQUFrQyxPQUFsQyxDQUEwQyxVQUFDLEdBQUQsRUFBUztBQUNqRCxjQUFNLGNBQU4sQ0FBcUIsR0FBckIsRUFBMEIsaUJBQTFCO0FBQ0QsT0FGRDtBQUdEOztBQUVEOzs7Ozs7OztxQ0FLaUIsUyxFQUFXO0FBQzFCLFVBQUksUUFBUSxJQUFaOztBQUVBO0FBQ0EsVUFBSSxtQkFBbUI7QUFDckIsY0FBTSxXQURlLEVBQ0YsTUFBTSxNQUFNLE9BQU4sQ0FBYyxJQURsQixFQUN3QixJQUFJLHVCQUF1QixNQUFNLE9BQTdCLEdBQXVDLEtBRG5FO0FBRXJCLGNBQU0sRUFBRSxXQUFXLFNBQWIsRUFBd0IsUUFBUSxNQUFNLE1BQXRDO0FBRmUsT0FBdkI7O0FBS0EsYUFBTyxzQkFBWSxVQUFDLE9BQUQsRUFBVSxNQUFWLEVBQXFCO0FBQ3RDLGNBQU0sSUFBTixDQUFXLFdBQVgsQ0FBdUIsZ0JBQXZCLEVBQXlDLFVBQUMsS0FBRCxFQUFXO0FBQ2xELGtCQUFRLEdBQVIsQ0FBWSx3Q0FBWixFQUFzRCxLQUF0RDtBQUNBLGNBQUksTUFBTSxJQUFOLENBQVcsSUFBWCxLQUFvQixHQUF4QixFQUE2QjtBQUMzQixnQkFBSSxhQUFhLE1BQU0sSUFBTixDQUFXLFVBQVgsQ0FBc0IsTUFBTSxJQUE1QixFQUFrQyxNQUFNLE1BQXhDLENBQWpCO0FBQ0Esa0JBQU0sU0FBTixDQUFnQixVQUFVLENBQVYsQ0FBaEIsSUFBZ0MsVUFBaEM7QUFDQTtBQUNELFdBSkQsTUFJTztBQUNMLG1CQUFPLHFDQUFxQyxNQUFNLElBQU4sQ0FBVyxJQUF2RDtBQUNEO0FBQ0YsU0FURDtBQVVELE9BWE0sQ0FBUDtBQVlEOztBQUVEOzs7Ozs7O3VDQUltQixPLEVBQVM7QUFDMUIsVUFBSSxRQUFRLElBQVo7O0FBRUEsWUFBTSxTQUFOLENBQWdCLE9BQWhCLEVBQXlCLE1BQXpCO0FBQ0EsYUFBTyxNQUFNLFNBQU4sQ0FBZ0IsT0FBaEIsQ0FBUDs7QUFFQTtBQUNBLFVBQUkscUJBQXFCO0FBQ3ZCLGNBQU0sYUFEaUIsRUFDRixNQUFNLE1BQU0sT0FBTixDQUFjLElBRGxCLEVBQ3dCLElBQUksdUJBQXVCLE1BQU0sT0FBN0IsR0FBdUMsS0FEbkU7QUFFdkIsY0FBTSxFQUFFLFdBQVcsQ0FBQyxPQUFELENBQWIsRUFBd0IsUUFBUSxNQUFNLE1BQXRDO0FBRmlCLE9BQXpCOztBQUtBLFlBQU0sSUFBTixDQUFXLFdBQVgsQ0FBdUIsa0JBQXZCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O2lDQUthLFMsRUFBVztBQUN0QixVQUFJLFFBQVEsSUFBWjs7QUFFQSxhQUFPLHNCQUFZLFVBQUMsT0FBRCxFQUFVLE1BQVYsRUFBcUI7QUFDdEMsWUFBSSxVQUFVLE1BQVYsS0FBcUIsQ0FBekIsRUFBNEI7QUFDMUI7QUFDQTtBQUNEOztBQUVELFlBQUksZUFBZSxNQUFNLElBQU4sR0FBYSxZQUFoQztBQUNBLGNBQU0sVUFBTixDQUFpQixJQUFqQixDQUFzQixTQUF0Qjs7QUFFQTs7Ozs7OztBQVFBLFlBQUksZ0JBQWdCLEVBQXBCO0FBQ0Esa0JBQVUsT0FBVixDQUFrQixVQUFDLEtBQUQ7QUFBQSxpQkFBVyxjQUFjLElBQWQsQ0FBbUIsZUFBZSxLQUFsQyxDQUFYO0FBQUEsU0FBbEI7O0FBRUE7O0FBRUE7QUFDQSxZQUFJLG1CQUFtQjtBQUNyQixnQkFBTSxXQURlLEVBQ0YsTUFBTSxNQUFNLE9BQU4sQ0FBYyxJQURsQixFQUN3QixJQUFJLHVCQUF1QixNQUFNLE9BQTdCLEdBQXVDLEtBRG5FO0FBRXJCLGdCQUFNLEVBQUUsV0FBVyxhQUFiLEVBQTRCLFFBQVEsTUFBTSxNQUExQztBQUZlLFNBQXZCOztBQUtBLGNBQU0sSUFBTixDQUFXLFdBQVgsQ0FBdUIsZ0JBQXZCLEVBQXlDLFVBQUMsS0FBRCxFQUFXO0FBQ2xELGtCQUFRLEdBQVIsQ0FBWSxxQ0FBWixFQUFtRCxLQUFuRDtBQUNBLGNBQUksTUFBTSxJQUFOLENBQVcsSUFBWCxLQUFvQixHQUF4QixFQUE2Qjs7QUFFM0I7QUFDQSwwQkFBYyxPQUFkLENBQXNCLFVBQUMsUUFBRCxFQUFjO0FBQ2xDLGtCQUFJLGdCQUFnQixNQUFNLElBQU4sQ0FBVyxXQUFYLENBQXVCLFFBQXZCLEVBQWlDLFVBQUMsR0FBRCxFQUFTO0FBQzVEO0FBQ0Esd0JBQVEsR0FBUixDQUFZLG9CQUFvQixRQUFwQixHQUErQixRQUEzQyxFQUFxRCxHQUFyRDtBQUNELGVBSG1CLENBQXBCO0FBSUEsb0JBQU0sa0JBQU4sQ0FBeUIsSUFBekIsQ0FBOEIsYUFBOUI7O0FBRUEsa0JBQUksY0FBYyxNQUFNLElBQU4sQ0FBVyxVQUFYLENBQXNCLFFBQXRCLEVBQWdDLE1BQU0sTUFBdEMsQ0FBbEI7QUFDQSxvQkFBTSxrQkFBTixDQUF5QixJQUF6QixDQUE4QixXQUE5QjtBQUNELGFBVEQ7O0FBV0E7QUFDRCxXQWZELE1BZU87QUFDTCxtQkFBTyxxQ0FBcUMsTUFBTSxJQUFOLENBQVcsSUFBdkQ7QUFDRDtBQUNGLFNBcEJEO0FBcUJELE9BakRNLENBQVA7QUFrREQ7Ozs4QkFFUTtBQUNQLFVBQUksUUFBUSxJQUFaO0FBQ0EsVUFBSSxTQUFTLHNCQUFVLE1BQU0sTUFBaEIsRUFBd0IsTUFBckM7O0FBRUE7QUFDQSxZQUFNLElBQU4sQ0FBVyxXQUFYLENBQXVCO0FBQ3JCLGNBQU0sUUFEZSxFQUNMLE1BQU0sTUFBTSxrQkFEUCxFQUMyQixJQUFJLE1BQU0sSUFBTixHQUFhO0FBRDVDLE9BQXZCOztBQUlBO0FBQ0EsWUFBTSxJQUFOLENBQVcsV0FBWCxDQUF1QjtBQUNyQixjQUFNLFFBRGUsRUFDTCxNQUFNLE1BQU0sT0FBTixDQUFjLElBRGYsRUFDcUIsSUFBSSx1QkFBdUIsTUFBdkIsR0FBZ0MsNEJBRHpEO0FBRXJCLGNBQU0sRUFBRSxVQUFVLE1BQU0sSUFBbEIsRUFBd0IsbUJBQW1CLE1BQU0sVUFBakQ7QUFGZSxPQUF2Qjs7QUFLQSxZQUFNLGlCQUFOO0FBQ0EsYUFBTyxNQUFNLE9BQU4sQ0FBYyxVQUFkLENBQXlCLE1BQU0sSUFBL0IsQ0FBUDtBQUNEOzs7c0NBRWlCLEcsRUFBSztBQUNyQixVQUFJLFFBQVEsSUFBWjs7QUFFQSxZQUFNLElBQU4sQ0FBVyxXQUFYLENBQXVCO0FBQ3JCLFlBQUksSUFBSSxFQURhLEVBQ1QsTUFBTSxVQURHLEVBQ1MsTUFBTSxJQUFJLEVBRG5CLEVBQ3VCLElBQUksTUFBTSxJQURqQztBQUVyQixjQUFNLEVBQUUsTUFBTSxJQUFJLElBQUosQ0FBUyxJQUFqQixFQUF1QixVQUFVLElBQUksSUFBSixDQUFTLFFBQTFDLEVBQW9ELFFBQVEsSUFBSSxJQUFoRTtBQUZlLE9BQXZCO0FBSUQ7O0FBRUQ7Ozs7dUNBQ21CLEcsRUFBSztBQUN0QixVQUFJLFFBQVEsSUFBWjtBQUNBLFVBQUksYUFBYSxJQUFJLElBQUosQ0FBUyxVQUExQjs7QUFFQTtBQUNBLFVBQUksTUFBTSxjQUFOLENBQXFCLFVBQXJCLENBQUosRUFBc0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFNLGNBQU4sQ0FBcUIsVUFBckIsRUFBaUMsaUJBQWpDO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLFVBQUksT0FBTyxTQUFYOztBQUVBLFVBQUksU0FBUyxTQUFiLEVBQXdCO0FBQ3RCO0FBQ0EsWUFBSSxhQUFhO0FBQ2YsZ0JBQU0sU0FEUyxFQUNFLE1BQU0sTUFBTSxJQURkLEVBQ29CLElBQUksTUFBTSxNQUQ5QjtBQUVmLGdCQUFNLEVBQUUsTUFBTSxJQUFJLElBQVosRUFBa0IsTUFBTSxVQUF4QixFQUFvQyxJQUFJLE1BQU0sSUFBOUMsRUFBb0QsVUFBVSxJQUFJLElBQUosQ0FBUyxRQUF2RTtBQUZTLFNBQWpCOztBQUtBLGNBQU0sSUFBTixDQUFXLFdBQVgsQ0FBdUIsVUFBdkIsRUFBbUMsVUFBQyxLQUFELEVBQVc7QUFDNUMsa0JBQVEsR0FBUixDQUFZLGlCQUFaLEVBQStCLEtBQS9CO0FBQ0EsY0FBSSxNQUFNLElBQU4sQ0FBVyxJQUFYLEtBQW9CLEdBQXhCLEVBQTZCO0FBQzNCLGdCQUFJLENBQUMsTUFBTSxjQUFOLENBQXFCLFVBQXJCLENBQUwsRUFBdUM7QUFDckMsb0JBQU0sY0FBTixDQUFxQixVQUFyQixJQUFtQywyQkFBaUIsTUFBTSxJQUF2QixFQUE2QixNQUFNLE1BQW5DLEVBQTJDLE1BQU0sSUFBakQsRUFBdUQsTUFBTSxVQUE3RCxFQUF5RSxJQUF6RSxDQUFuQztBQUNEO0FBQ0Y7O0FBRUQ7QUFDQSxjQUFJLGdCQUFKO0FBQ0EsY0FBSSxJQUFJLElBQUosQ0FBUyxRQUFULElBQXFCLElBQUksSUFBSixDQUFTLFFBQVQsQ0FBa0IsV0FBbEIsQ0FBOEIsT0FBdkQsRUFBZ0U7QUFDOUQsc0JBQVUsSUFBSSxJQUFKLENBQVMsUUFBVCxDQUFrQixXQUFsQixDQUE4QixPQUF4QztBQUNBLGtCQUFNLE9BQU4sQ0FBYyxpQkFBZCxDQUFnQyxNQUFoQyxDQUF1QyxNQUFNLElBQTdDLEVBQW1ELGlCQUFuRCxFQUFzRSxPQUF0RTtBQUNEOztBQUVELGdCQUFNLE9BQU4sQ0FBYyxpQkFBZCxDQUFnQyxNQUFoQyxDQUF1QyxNQUFNLElBQTdDLEVBQW1ELGVBQW5ELEVBQW9FLFVBQXBFOztBQUVBO0FBQ0EsZ0JBQU0sSUFBTixDQUFXLFdBQVgsQ0FBdUI7QUFDckIsZ0JBQUksSUFBSSxFQURhLEVBQ1QsTUFBTSxVQURHLEVBQ1MsTUFBTSxJQUFJLEVBRG5CLEVBQ3VCLElBQUksSUFBSSxJQUQvQjtBQUVyQixrQkFBTSxNQUFNO0FBRlMsV0FBdkI7QUFLRCxTQXZCRDtBQXdCRDtBQUVGOztBQUVEOzs7O3lDQUNxQixHLEVBQUs7QUFDeEIsVUFBSSxRQUFRLElBQVo7QUFDQSxVQUFJLGFBQWEsSUFBSSxJQUFKLENBQVMsVUFBMUI7O0FBRUEsVUFBSSxlQUFlLE1BQU0sY0FBTixDQUFxQixVQUFyQixDQUFuQjtBQUNBLFVBQUksWUFBSixFQUFrQjtBQUNoQixxQkFBYSxpQkFBYjtBQUNBLGVBQU8sTUFBTSxjQUFOLENBQXFCLFVBQXJCLENBQVA7O0FBRUE7QUFDRDtBQUVGOzs7OztrQkFJWSxjOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQ3RTVCxnQjtBQUVKLDRCQUFZLGNBQVosRUFBNEI7QUFBQTs7QUFDMUIsUUFBSSxDQUFDLGNBQUwsRUFBcUIsTUFBTSxJQUFJLEtBQUosQ0FBVSwyREFBVixDQUFOOztBQUVyQixTQUFLLGVBQUwsR0FBdUIsY0FBdkI7QUFDQSxTQUFLLGdCQUFMLEdBQXdCLEVBQXhCO0FBQ0Q7Ozs7d0JBRUcsUSxFQUFVLFUsRUFBWSxNLEVBQVEsTSxFQUFRLEksRUFBTSxZLEVBQWMsUSxFQUFVLGlCLEVBQW1CLGMsRUFBZ0I7O0FBRXpHLFVBQUksT0FBTyxLQUFLLGdCQUFMLENBQXNCLFVBQXRCLENBQVg7QUFDQSxVQUFJLENBQUMsS0FBSyxnQkFBTCxDQUFzQixjQUF0QixDQUFxQyxJQUFyQyxDQUFMLEVBQWlELEtBQUssZ0JBQUwsQ0FBc0IsSUFBdEIsSUFBOEIsRUFBOUI7O0FBRWpELFVBQUksQ0FBQyxLQUFLLGdCQUFMLENBQXNCLElBQXRCLEVBQTRCLGNBQTVCLENBQTJDLFFBQTNDLENBQUwsRUFBMkQ7QUFDekQsYUFBSyxnQkFBTCxDQUFzQixJQUF0QixFQUE0QixRQUE1QixJQUF3QztBQUN0QyxvQkFBVSxRQUQ0QjtBQUV0QyxzQkFBWSxVQUYwQjtBQUd0Qyx5QkFBZSxFQUh1QjtBQUl0QywyQkFBaUI7QUFKcUIsU0FBeEM7QUFNRDs7QUFFRCxVQUFJLFVBQUosRUFBZ0IsS0FBSyxnQkFBTCxDQUFzQixJQUF0QixFQUE0QixRQUE1QixFQUFzQyxLQUF0QyxHQUE4QyxZQUE5Qzs7QUFFaEIsVUFBSSxJQUFKLEVBQVUsS0FBSyxnQkFBTCxDQUFzQixJQUF0QixFQUE0QixRQUE1QixFQUFzQyxJQUF0QyxHQUE2QyxJQUE3QztBQUNWLFVBQUksTUFBSixFQUFZLEtBQUssZ0JBQUwsQ0FBc0IsSUFBdEIsRUFBNEIsUUFBNUIsRUFBc0MsTUFBdEMsR0FBK0MsTUFBL0M7QUFDWixVQUFJLE1BQUosRUFBWSxLQUFLLGdCQUFMLENBQXNCLElBQXRCLEVBQTRCLFFBQTVCLEVBQXNDLE1BQXRDLEdBQStDLE1BQS9DO0FBQ1osVUFBSSxRQUFKLEVBQWMsS0FBSyxnQkFBTCxDQUFzQixJQUF0QixFQUE0QixRQUE1QixFQUFzQyxRQUF0QyxHQUFpRCxRQUFqRDtBQUNkLFVBQUksaUJBQUosRUFBdUIsS0FBSyxnQkFBTCxDQUFzQixJQUF0QixFQUE0QixRQUE1QixFQUFzQyxpQkFBdEMsR0FBMEQsaUJBQTFEOztBQUV2QixjQUFRLEdBQVIsQ0FBWSxNQUFaLEVBQW9CLFlBQXBCLEVBQWtDLENBQUMsVUFBbkM7QUFDQSxVQUFJLGdCQUFnQixDQUFDLFVBQXJCLEVBQWlDO0FBQy9CLFlBQUksS0FBSyxnQkFBTCxDQUFzQixJQUF0QixFQUE0QixRQUE1QixFQUFzQyxhQUF0QyxDQUFvRCxPQUFwRCxDQUE0RCxZQUE1RCxDQUFKLEVBQStFLEtBQUssZ0JBQUwsQ0FBc0IsSUFBdEIsRUFBNEIsUUFBNUIsRUFBc0MsYUFBdEMsQ0FBb0QsSUFBcEQsQ0FBeUQsWUFBekQ7QUFDaEY7O0FBRUQsVUFBSSxjQUFKLEVBQW9CO0FBQ2xCLFlBQUksS0FBSyxnQkFBTCxDQUFzQixJQUF0QixFQUE0QixRQUE1QixFQUFzQyxlQUF0QyxDQUFzRCxPQUF0RCxDQUE4RCxjQUE5RCxDQUFKLEVBQW1GLEtBQUssZ0JBQUwsQ0FBc0IsSUFBdEIsRUFBNEIsUUFBNUIsRUFBc0MsZUFBdEMsQ0FBc0QsSUFBdEQsQ0FBMkQsY0FBM0Q7QUFDcEY7O0FBRUQsY0FBUSxHQUFSLENBQVksT0FBWixFQUFxQixLQUFLLGdCQUFMLENBQXNCLElBQXRCLEVBQTRCLFFBQTVCLENBQXJCLEVBQTRELFlBQTVEOztBQUVBLGFBQU8sS0FBSyxlQUFMLENBQXFCLEdBQXJCLENBQXlCLDJCQUF6QixFQUFzRCxDQUF0RCxFQUF5RCxLQUFLLGdCQUE5RCxDQUFQO0FBRUQ7OzsrQkFFVSxRLEVBQVUsRyxFQUFLLFMsRUFBVyxLLEVBQTBCO0FBQUEsVUFBbkIsVUFBbUIsdUVBQU4sSUFBTTs7QUFDN0QsVUFBSSxPQUFPLEtBQUssZ0JBQUwsQ0FBc0IsVUFBdEIsQ0FBWDs7QUFFQSxVQUFJLEtBQUssZ0JBQUwsQ0FBc0IsY0FBdEIsQ0FBcUMsSUFBckMsS0FBOEMsS0FBSyxnQkFBTCxDQUFzQixJQUF0QixFQUE0QixRQUE1QixDQUE5QyxJQUF1RixRQUF2RixJQUFtRyxHQUFuRyxJQUEwRyxLQUE5RyxFQUFxSDs7QUFFbkgsWUFBSSxRQUFRLGVBQVIsSUFBMkIsUUFBUSxpQkFBdkMsRUFBMEQ7QUFDeEQsZUFBSyxjQUFMLENBQW9CLFFBQXBCLEVBQThCLEdBQTlCLEVBQW1DLEtBQW5DLEVBQTBDLElBQTFDO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsZUFBSyxnQkFBTCxDQUFzQixJQUF0QixFQUE0QixRQUE1QixFQUFzQyxHQUF0QyxFQUEyQyxTQUEzQyxJQUF3RCxLQUF4RDtBQUNEOztBQUVELGVBQU8sS0FBSyxlQUFMLENBQXFCLEdBQXJCLENBQXlCLDJCQUF6QixFQUFzRCxDQUF0RCxFQUF5RCxLQUFLLGdCQUE5RCxDQUFQO0FBRUQsT0FWRCxNQVVPO0FBQ0w7QUFDRDtBQUNGOzs7MkJBRU0sUSxFQUFVLEcsRUFBSyxLLEVBQTBCO0FBQUEsVUFBbkIsVUFBbUIsdUVBQU4sSUFBTTs7QUFDOUMsVUFBSSxPQUFPLEtBQUssZ0JBQUwsQ0FBc0IsVUFBdEIsQ0FBWDs7QUFFQSxVQUFJLEtBQUssZ0JBQUwsQ0FBc0IsY0FBdEIsQ0FBcUMsSUFBckMsS0FBOEMsS0FBSyxnQkFBTCxDQUFzQixJQUF0QixFQUE0QixRQUE1QixDQUE5QyxJQUF1RixRQUF2RixJQUFtRyxHQUFuRyxJQUEwRyxLQUE5RyxFQUFxSDs7QUFFbkgsWUFBSSxRQUFRLGVBQVIsSUFBMkIsUUFBUSxpQkFBdkMsRUFBMEQ7QUFDeEQsZUFBSyxjQUFMLENBQW9CLFFBQXBCLEVBQThCLEdBQTlCLEVBQW1DLEtBQW5DLEVBQTBDLElBQTFDO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsZUFBSyxnQkFBTCxDQUFzQixJQUF0QixFQUE0QixRQUE1QixFQUFzQyxHQUF0QyxJQUE2QyxLQUE3QztBQUNEOztBQUVELGVBQU8sS0FBSyxlQUFMLENBQXFCLEdBQXJCLENBQXlCLDJCQUF6QixFQUFzRCxDQUF0RCxFQUF5RCxLQUFLLGdCQUE5RCxDQUFQO0FBRUQsT0FWRCxNQVVPO0FBQ0w7QUFDRDtBQUNGOzs7NEJBRU0sUSxFQUFVLEcsRUFBSyxLLEVBQU87QUFDM0IsVUFBSSxLQUFLLGdCQUFMLENBQXNCLFFBQXRCLEtBQW1DLFFBQW5DLElBQStDLEdBQS9DLElBQXNELEtBQTFELEVBQWlFOztBQUUvRCxZQUFJLFFBQVEsZUFBUixJQUEyQixRQUFRLGlCQUF2QyxFQUEwRDtBQUN4RCxlQUFLLGdCQUFMLENBQXNCLFFBQXRCLEVBQWdDLEdBQWhDO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsaUJBQU8sS0FBSyxnQkFBTCxDQUFzQixRQUF0QixFQUFnQyxHQUFoQyxDQUFQO0FBQ0Q7O0FBRUQsZUFBTyxLQUFLLGVBQUwsQ0FBcUIsR0FBckIsQ0FBeUIsMkJBQXpCLEVBQXNELENBQXRELEVBQXlELEtBQUssZ0JBQTlELENBQVA7QUFFRCxPQVZELE1BVU87QUFDTCxjQUFNLElBQUksS0FBSixDQUFVLDZDQUE2QyxRQUE3QyxHQUF3RCxjQUF4RCxHQUF5RSxHQUF6RSxHQUErRSxlQUEvRSxHQUFpRyxLQUEzRyxDQUFOO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7OzttQ0FJZSxRLEVBQVU7QUFBQTs7QUFDdkIsVUFBSSxRQUFKLEVBQWM7O0FBRVosZUFBTyxLQUFLLE1BQUwsR0FBYyxJQUFkLENBQW1CLFVBQUMsaUJBQUQsRUFBdUI7QUFDL0MsY0FBSSxNQUFNLGlCQUFWOztBQUVBLGNBQUksSUFBSSxjQUFKLENBQW1CLFFBQW5CLENBQUosRUFBa0M7QUFDaEMsbUJBQU8sSUFBSSxTQUFKLENBQWMsUUFBZCxDQUFQO0FBQ0EsbUJBQU8sSUFBSSxTQUFKLENBQWMsUUFBZCxDQUFQO0FBQ0EsbUJBQU8sTUFBSyxlQUFMLENBQXFCLEdBQXJCLENBQXlCLDJCQUF6QixFQUFzRCxDQUF0RCxFQUF5RCxHQUF6RCxDQUFQO0FBQ0Q7QUFDRixTQVJNLENBQVA7QUFVRCxPQVpELE1BWU87QUFDTCxjQUFNLElBQUksS0FBSixDQUFVLDZDQUE2QyxRQUF2RCxDQUFOO0FBQ0Q7QUFFRjs7OzZCQUVRO0FBQ1AsYUFBTyxLQUFLLGVBQUwsQ0FBcUIsR0FBckIsQ0FBeUIsMkJBQXpCLENBQVA7QUFDRDs7O3dCQUVHLFEsRUFBVTtBQUNaLFVBQUksS0FBSyxnQkFBTCxDQUFzQixRQUF0QixDQUFKLEVBQXFDO0FBQ25DLGVBQU8sS0FBSyxnQkFBTCxDQUFzQixRQUF0QixDQUFQO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsY0FBTSxJQUFJLEtBQUosQ0FBVSwyQ0FBMkMsUUFBckQsQ0FBTjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7OzsyQ0FHdUIsRyxFQUFLLFUsRUFBWTtBQUFBOztBQUV0QyxjQUFRLEdBQVIsQ0FBWSxNQUFaLEVBQW9CLEdBQXBCOztBQUVBLGFBQU8sc0JBQVksVUFBQyxPQUFELEVBQWE7O0FBRTlCLFlBQUksT0FBTyxPQUFLLGdCQUFMLENBQXNCLFVBQXRCLENBQVg7O0FBRUEsZUFBSyxNQUFMLEdBQWMsSUFBZCxDQUFtQixVQUFDLGlCQUFELEVBQXVCOztBQUV4QyxjQUFJLENBQUMsaUJBQUwsRUFBd0I7QUFDdEIsb0JBQVEsR0FBUixDQUFZLGlDQUFaO0FBQ0EsbUJBQU8sUUFBUSxJQUFSLENBQVA7QUFDRDs7QUFFRCxjQUFJLElBQUksSUFBSixDQUFTLGNBQVQsQ0FBd0IsUUFBeEIsS0FBcUMsQ0FBQyxJQUFJLElBQUosQ0FBUyxNQUFuRCxFQUEyRDtBQUN6RCxtQkFBTyxRQUFRLElBQVIsQ0FBUDtBQUNEOztBQUVEO0FBQ0E7QUFDQSxjQUFJLFNBQVMsRUFBYjtBQUNBLGNBQUksa0JBQWtCLE9BQUssZ0JBQUwsQ0FBc0Isa0JBQWtCLElBQWxCLENBQXRCLEVBQStDLElBQUksSUFBbkQsQ0FBdEI7QUFDQSxjQUFJLFVBQVUsT0FBSyxRQUFMLENBQWMsa0JBQWtCLElBQWxCLENBQWQsRUFBdUMsSUFBSSxJQUEzQyxDQUFkOztBQUVBLGNBQUksSUFBSSxjQUFKLENBQW1CLE1BQW5CLEtBQThCLGVBQTlCLElBQWlELE9BQXJELEVBQThEO0FBQzVELGdCQUFJLFdBQVcsT0FBSywyQkFBTCxDQUFpQyxrQkFBa0IsSUFBbEIsQ0FBakMsRUFBMEQsSUFBSSxJQUE5RCxDQUFmO0FBQ0EsZ0JBQUksb0JBQW9CLE9BQUssdUJBQUwsQ0FBNkIsa0JBQWtCLElBQWxCLENBQTdCLEVBQXNELElBQUksSUFBSixDQUFTLFFBQS9ELENBQXhCO0FBQ0EsZ0JBQUksa0JBQWtCLE9BQUsscUJBQUwsQ0FBMkIsa0JBQWtCLElBQWxCLENBQTNCLEVBQW9ELElBQUksSUFBSixDQUFTLE1BQTdELENBQXRCO0FBQ0EsZ0JBQUksWUFBWSxPQUFLLG1CQUFMLENBQXlCLGtCQUFrQixJQUFsQixDQUF6QixFQUFrRCxJQUFJLElBQUosQ0FBUyxLQUEzRCxDQUFoQjs7QUFFQTtBQUNBO0FBQ0EscUJBQVMsT0FBSyxhQUFMLENBQW1CLGlCQUFuQixFQUFzQyxlQUF0QyxFQUF1RCxTQUF2RCxFQUFrRSxRQUFsRSxDQUFUO0FBQ0QsV0FURCxNQVNPO0FBQ0wsbUJBQU8sUUFBUSxJQUFSLENBQVA7QUFDRDs7QUFFRCxjQUFJLE9BQU8sRUFBWDtBQUNBLGlCQUFPLE9BQVAsQ0FBZSxVQUFDLEdBQUQsRUFBUztBQUN0QixnQkFBSSxvQkFBb0Isa0JBQWtCLElBQWxCLEVBQXdCLEdBQXhCLENBQXhCO0FBQ0EsaUJBQUssR0FBTCxJQUFZLGlCQUFaO0FBQ0EsbUJBQU8sSUFBUDtBQUNELFdBSkQ7O0FBTUEsa0JBQVEsR0FBUixDQUFZLHlCQUFaLEVBQXVDLElBQXZDOztBQUVBLGtCQUFRLElBQVI7QUFDRCxTQXhDRDtBQTBDRCxPQTlDTSxDQUFQO0FBZ0REOzs7NENBRXVCLFUsRUFBWSxPLEVBQVM7QUFDM0MsYUFBTyxvQkFBWSxVQUFaLEVBQXdCLE1BQXhCLENBQStCLFVBQUMsU0FBRCxFQUFlO0FBQ25ELGVBQU8sV0FBVyxTQUFYLEVBQXNCLGVBQXRCLENBQXNDLE1BQXRDLENBQTZDLFVBQUMsT0FBRCxFQUFhO0FBQy9ELGlCQUFPLFlBQVksT0FBbkI7QUFDRCxTQUZNLEVBRUosTUFGSDtBQUdELE9BSk0sQ0FBUDtBQUtEOzs7Z0RBRTJCLFUsRUFBWSxZLEVBQWM7QUFDcEQsYUFBTyxvQkFBWSxVQUFaLEVBQXdCLE1BQXhCLENBQStCLFVBQUMsU0FBRCxFQUFlO0FBQ25ELGVBQU8sV0FBVyxTQUFYLEVBQXNCLGFBQXRCLENBQW9DLE1BQXBDLENBQTJDLFVBQUMsT0FBRCxFQUFhO0FBQzdELGtCQUFRLEdBQVIsQ0FBWSxVQUFaLEVBQXdCLE9BQXhCLEVBQWlDLFlBQWpDO0FBQ0EsaUJBQU8sWUFBWSxZQUFuQjtBQUNELFNBSE0sRUFHSixNQUhIO0FBSUQsT0FMTSxDQUFQO0FBT0Q7OzswQ0FFcUIsVSxFQUFZLE0sRUFBUTtBQUN4QyxhQUFPLG9CQUFZLFVBQVosRUFBd0IsTUFBeEIsQ0FBK0IsVUFBQyxTQUFELEVBQWU7QUFDbkQsWUFBSSxnQkFBZ0IsV0FBVyxTQUFYLENBQXBCO0FBQ0EsZUFBTyxvQkFBWSxhQUFaLEVBQTJCLE1BQTNCLENBQWtDLFVBQUMsR0FBRCxFQUFTO0FBQ2hELGlCQUFPLFFBQVEsUUFBUixJQUFvQixjQUFjLEdBQWQsTUFBdUIsTUFBbEQ7QUFDRCxTQUZNLEVBRUosTUFGSDtBQUdELE9BTE0sQ0FBUDtBQU1EOzs7d0NBRW1CLFUsRUFBWSxJLEVBQU07QUFDcEMsVUFBSSxDQUFDLElBQUwsRUFBVyxPQUFPLEVBQVA7O0FBRVgsYUFBTyxvQkFBWSxVQUFaLEVBQXdCLE1BQXhCLENBQStCLFVBQUMsU0FBRCxFQUFlO0FBQ25ELFlBQUksZ0JBQWdCLFdBQVcsU0FBWCxFQUFzQixJQUExQztBQUNBLGVBQU8sb0JBQVksYUFBWixFQUEyQixNQUEzQixDQUFrQyxVQUFDLEdBQUQsRUFBUztBQUNoRDtBQUNBLGlCQUFPLG9CQUFZLElBQVosRUFBa0IsTUFBbEIsQ0FBeUIscUJBQWE7QUFDM0MsbUJBQU8sUUFBUSxTQUFSLElBQXFCLGNBQWMsR0FBZCxNQUF1QixLQUFLLFNBQUwsQ0FBbkQ7QUFDRCxXQUZNLEVBRUosTUFGSDtBQUlELFNBTk0sRUFNSixNQU5IO0FBT0QsT0FUTSxDQUFQO0FBVUQ7OztxQ0FFZ0IsVSxFQUFZLFksRUFBYztBQUN6QyxVQUFJLENBQUMsVUFBTCxFQUFpQixPQUFPLEtBQVA7O0FBRWpCLGFBQU8sb0JBQVksVUFBWixFQUF3QixNQUF4QixDQUErQixVQUFDLFNBQUQsRUFBZTtBQUNuRCxlQUFPLFdBQVcsU0FBWCxFQUFzQixhQUF0QixDQUFvQyxNQUFwQyxDQUEyQyxVQUFDLE9BQUQsRUFBYTtBQUM3RCxpQkFBTyxZQUFZLFlBQW5CO0FBQ0QsU0FGTSxFQUVKLE1BRkg7QUFHRCxPQUpNLEVBSUosTUFKSSxHQUlLLENBSkwsR0FJUyxJQUpULEdBSWdCLEtBSnZCO0FBS0Q7Ozs2QkFFUSxVLEVBQVksRyxFQUFLO0FBQ3hCLFVBQUksQ0FBQyxVQUFMLEVBQWlCLE9BQU8sS0FBUDs7QUFFakIsYUFBTyxvQkFBWSxVQUFaLEVBQXdCLE1BQXhCLENBQStCLFVBQUMsU0FBRCxFQUFlO0FBQ25ELGVBQU8sV0FBVyxTQUFYLEVBQXNCLEtBQXRCLEtBQWdDLEdBQXZDO0FBQ0QsT0FGTSxFQUVKLE1BRkksR0FFSyxDQUZMLEdBRVMsSUFGVCxHQUVnQixLQUZ2QjtBQUdEOzs7b0NBRWU7QUFDZCxVQUFJLE9BQU8sb0JBQVcsU0FBWCxDQUFYOztBQUVBLFVBQUksU0FBUyxLQUFLLE1BQUwsQ0FBWSxVQUFDLEtBQUQsRUFBUSxNQUFSLEVBQW1CO0FBQzFDLGVBQU8sTUFBTSxNQUFOLENBQWEsTUFBYixDQUFQO0FBQ0QsT0FGWSxFQUVWLE1BRlUsQ0FFSCxVQUFDLEtBQUQsRUFBUSxLQUFSLEVBQWUsSUFBZixFQUF3QjtBQUNoQyxlQUFPLEtBQUssT0FBTCxDQUFhLEtBQWIsTUFBd0IsS0FBL0I7QUFDRCxPQUpZLENBQWI7QUFLQSxjQUFRLEdBQVIsQ0FBWSxxQ0FBWixFQUFtRCxNQUFuRDtBQUNBLGFBQU8sTUFBUDtBQUNEOzs7bUNBRWMsUSxFQUFVLEcsRUFBSyxLLEVBQU8sSSxFQUFNO0FBQ3pDLFVBQUksS0FBSyxnQkFBTCxDQUFzQixJQUF0QixFQUE0QixRQUE1QixFQUFzQyxHQUF0QyxFQUEyQyxPQUEzQyxDQUFtRCxLQUFuRCxDQUFKLEVBQStELEtBQUssZ0JBQUwsQ0FBc0IsSUFBdEIsRUFBNEIsUUFBNUIsRUFBc0MsR0FBdEMsRUFBMkMsSUFBM0MsQ0FBZ0QsS0FBaEQ7QUFDaEU7OztxQ0FFZ0IsUSxFQUFVLEcsRUFBSyxLLEVBQU87QUFDckMsVUFBSSxlQUFlLEtBQUssZ0JBQUwsQ0FBc0IsUUFBdEIsRUFBZ0MsR0FBaEMsRUFBcUMsT0FBckMsQ0FBNkMsS0FBN0MsQ0FBbkI7QUFDQSxVQUFJLFlBQUosRUFBa0IsS0FBSyxnQkFBTCxDQUFzQixRQUF0QixFQUFnQyxHQUFoQyxFQUFxQyxNQUFyQyxDQUE0QyxZQUE1QyxFQUEwRCxDQUExRDtBQUNuQjs7OzhCQUVTLEcsRUFBSyxHLEVBQUssSyxFQUFPO0FBQ3pCLGFBQU8sSUFBSSxjQUFKLENBQW1CLEdBQW5CLEtBQTJCLElBQUksR0FBSixNQUFhLEtBQS9DO0FBQ0Q7OztxQ0FFZ0IsVSxFQUFZO0FBQzNCLGFBQU8sYUFBYSxXQUFiLEdBQTJCLFdBQWxDO0FBQ0Q7Ozs7O2tCQUlZLGdCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQ3pSVCxZO0FBRUosd0JBQVksR0FBWixFQUFpQixLQUFqQixFQUF3QixHQUF4QixFQUE2QixTQUE3QixFQUF3QyxVQUF4QyxFQUFvRDtBQUFBOztBQUNsRCxRQUFJLFFBQVEsSUFBWjtBQUNBLFFBQUksZUFBZSxNQUFNLFlBQXpCO0FBQ0EsUUFBSSxZQUFZLE1BQU0sVUFBdEI7O0FBRUE7QUFDQSxVQUFNLGVBQU4sR0FBd0IsSUFBSSxXQUFKLENBQWdCLFNBQWhCLEVBQTJCLFVBQUMsR0FBRCxFQUFTO0FBQzFELFVBQUksSUFBSSxJQUFKLEtBQWEsUUFBakIsRUFBMkI7QUFDekIsZ0JBQVEsR0FBUixDQUFZLHVCQUFaLEVBQXFDLEdBQXJDOztBQUVBO0FBQ0EsWUFBSSx5QkFBeUI7QUFDM0IsZ0JBQU0sUUFEcUIsRUFDWCxNQUFNLElBQUksSUFEQyxFQUNLLElBQUksS0FEVDtBQUUzQixnQkFBTSxFQUFFLFVBQVUsSUFBSSxJQUFKLENBQVMsUUFBckIsRUFBK0IsVUFBVSxHQUF6QztBQUZxQixTQUE3Qjs7QUFLQTtBQUNBLFlBQUksV0FBSixDQUFnQixzQkFBaEIsRUFBd0MsVUFBQyxLQUFELEVBQVc7QUFDakQsa0JBQVEsR0FBUixDQUFZLDZCQUFaLEVBQTJDLEtBQTNDO0FBQ0EsY0FBSSxNQUFNLElBQU4sQ0FBVyxJQUFYLEtBQW9CLEdBQXhCLEVBQTZCO0FBQzNCLGtCQUFNLGlCQUFOO0FBQ0Q7QUFDRixTQUxEO0FBTUQ7QUFDRixLQWxCdUIsQ0FBeEI7O0FBb0JBO0FBQ0EsUUFBSSxVQUFKLEVBQWdCO0FBQ2QsWUFBTSxlQUFOLEdBQXdCLElBQUksVUFBSixDQUFlLFNBQWYsQ0FBeEI7QUFDRCxLQUZELE1BRU87QUFDTCxZQUFNLGVBQU4sR0FBd0IsSUFBSSxVQUFKLENBQWUsU0FBZixFQUEwQixLQUExQixDQUF4QjtBQUNEOztBQUVELFVBQU0sa0JBQU4sR0FBMkIsRUFBM0I7QUFDQSxjQUFVLE9BQVYsQ0FBa0IsVUFBQyxLQUFELEVBQVc7QUFDM0IsVUFBSSxVQUFVLGVBQWUsS0FBN0I7O0FBRUE7QUFDQSxVQUFJLGtCQUFrQixJQUFJLFVBQUosQ0FBZSxPQUFmLENBQXRCO0FBQ0EsWUFBTSxrQkFBTixDQUF5QixJQUF6QixDQUE4QixlQUE5Qjs7QUFFQTtBQUNBLFVBQUksQ0FBQyxVQUFMLEVBQWlCO0FBQ2YsWUFBSSxjQUFjLElBQUksVUFBSixDQUFlLE9BQWYsRUFBd0IsS0FBeEIsQ0FBbEI7QUFDQSxjQUFNLGtCQUFOLENBQXlCLElBQXpCLENBQThCLFdBQTlCO0FBQ0Q7QUFDRixLQVpEO0FBYUQ7Ozs7d0NBRW1CO0FBQ2xCLFVBQUksUUFBUSxJQUFaOztBQUVBLFlBQU0sZUFBTixDQUFzQixNQUF0Qjs7QUFFQSxZQUFNLGVBQU4sQ0FBc0IsTUFBdEI7O0FBRUEsWUFBTSxrQkFBTixDQUF5QixPQUF6QixDQUFpQyxVQUFDLE9BQUQsRUFBYTtBQUM1QyxnQkFBUSxNQUFSO0FBQ0QsT0FGRDtBQUdEOzs7OztrQkFJWSxZOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0NmOztBQUNBOztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOztBQUVBOzs7Ozs7QUFFQTs7OztJQUlNLGM7QUFDSjs7Ozs7Ozs7O0FBVUEsMEJBQVksVUFBWixFQUF3QixHQUF4QixFQUE2QixRQUE3QixFQUF1QyxPQUF2QyxFQUFnRCxjQUFoRCxFQUFnRSxTQUFoRSxFQUEyRTtBQUFBOztBQUN6RSxRQUFJLENBQUMsVUFBTCxFQUFpQixNQUFNLElBQUksS0FBSixDQUFVLG9EQUFWLENBQU47QUFDakIsUUFBSSxDQUFDLEdBQUwsRUFBVSxNQUFNLElBQUksS0FBSixDQUFVLG1EQUFWLENBQU47QUFDVixRQUFJLENBQUMsUUFBTCxFQUFlLE1BQU0sSUFBSSxLQUFKLENBQVUsaURBQVYsQ0FBTjtBQUNmLFFBQUksQ0FBQyxPQUFMLEVBQWMsTUFBTSxJQUFJLEtBQUosQ0FBVSx5REFBVixDQUFOO0FBQ2QsUUFBSSxDQUFDLGNBQUwsRUFBcUIsTUFBTSxJQUFJLEtBQUosQ0FBVSxzREFBVixDQUFOOztBQUVyQixRQUFJLFFBQVEsSUFBWjs7QUFFQSxVQUFNLElBQU4sR0FBYSxHQUFiO0FBQ0EsVUFBTSxTQUFOLEdBQWtCLFFBQWxCO0FBQ0EsVUFBTSxRQUFOLEdBQWlCLE9BQWpCO0FBQ0EsVUFBTSxlQUFOLEdBQXdCLGNBQXhCOztBQUVBO0FBQ0EsVUFBTSxJQUFOLEdBQWEsYUFBYSxLQUExQjtBQUNBLFVBQU0sVUFBTixHQUFtQixhQUFhLG9CQUFoQzs7QUFFQSxVQUFNLFVBQU4sR0FBbUIsRUFBbkI7QUFDQSxVQUFNLFVBQU4sR0FBbUIsRUFBbkI7O0FBRUEsVUFBTSxpQkFBTixHQUEwQiwrQkFBcUIsY0FBckIsQ0FBMUI7O0FBRUE7QUFDQSxVQUFNLE9BQU4sR0FBZ0Isc0JBQVUsVUFBVixFQUFzQixNQUF0Qzs7QUFFQSxVQUFNLEdBQU4sR0FBWSxtQ0FBbUIsS0FBbkIsRUFBMEIsRUFBMUIsQ0FBWjs7QUFFQSxRQUFJLFNBQUosRUFBZTtBQUNiLFlBQU0sVUFBTixHQUFtQixTQUFuQjtBQUNELEtBRkQsTUFFTztBQUNMLFlBQU0sVUFBTixHQUFtQixnQ0FBc0IsTUFBTSxVQUE1QixFQUF3QyxHQUF4QyxFQUE2QyxNQUFNLFNBQW5ELENBQW5CO0FBQ0Q7O0FBRUQsUUFBSSxXQUFKLENBQWdCLE1BQU0sSUFBdEIsRUFBNEIsVUFBQyxHQUFELEVBQVM7QUFDbkMsY0FBUSxHQUFSLENBQVksc0JBQVosRUFBb0MsR0FBcEM7QUFDQSxjQUFRLElBQUksSUFBWjtBQUNFLGFBQUssUUFBTDtBQUFlLGdCQUFNLFNBQU4sQ0FBZ0IsR0FBaEIsRUFBc0I7QUFDckMsYUFBSyxRQUFMO0FBQWUsZ0JBQU0sU0FBTixDQUFnQixHQUFoQixFQUFzQjtBQUNyQyxhQUFLLFdBQUw7QUFBa0IsZ0JBQU0saUJBQU4sQ0FBd0IsR0FBeEIsRUFBOEI7QUFDaEQsYUFBSyxhQUFMO0FBQW9CLGdCQUFNLG1CQUFOLENBQTBCLEdBQTFCLEVBQWdDO0FBSnREO0FBTUQsS0FSRDtBQVVEOzs7Ozs7QUFJRDs4QkFDVSxHLEVBQUs7QUFBQTs7QUFFYixVQUFJLElBQUksSUFBSixDQUFTLGNBQVQsQ0FBd0IsUUFBeEIsS0FBcUMsQ0FBQyxJQUFJLElBQUosQ0FBUyxNQUEvQyxJQUF5RCxDQUFDLElBQUksSUFBSixDQUFTLE1BQXZFLEVBQStFO0FBQzdFLGFBQUssVUFBTCxDQUFnQixHQUFoQjtBQUNELE9BRkQsTUFFTztBQUNMLGFBQUssaUJBQUwsQ0FBdUIsc0JBQXZCLENBQThDLEdBQTlDLEVBQW1ELElBQW5ELEVBQXlELElBQXpELENBQThELFVBQUMsTUFBRCxFQUFZOztBQUV4RSxrQkFBUSxHQUFSLENBQVksMkNBQVosRUFBeUQsTUFBekQsRUFBaUUsR0FBakU7O0FBRUEsY0FBSSxVQUFVLG9CQUFZLE1BQVosRUFBb0IsTUFBcEIsR0FBNkIsQ0FBM0MsRUFBOEM7O0FBRTVDO0FBQ0EsZ0NBQVksTUFBWixFQUFvQixPQUFwQixDQUE0QixVQUFDLE1BQUQsRUFBWTtBQUN0QyxzQkFBUSxHQUFSLENBQVksK0RBQVosRUFBNkUsT0FBTyxNQUFQLENBQTdFO0FBQ0EscUJBQUssYUFBTCxDQUFtQixHQUFuQixFQUF3QixPQUFPLE1BQVAsQ0FBeEI7QUFDRCxhQUhEO0FBS0QsV0FSRCxNQVFPO0FBQ0w7QUFDQSxnQkFBSSxRQUFRLEVBQVo7QUFDQSxrQkFBTSxFQUFOLEdBQVcsSUFBSSxFQUFmO0FBQ0Esa0JBQU0sSUFBTixHQUFhLElBQUksRUFBakI7QUFDQSxrQkFBTSxFQUFOLEdBQVcsSUFBSSxJQUFmO0FBQ0Esa0JBQU0sSUFBTixHQUFhLFVBQWI7QUFDQSxrQkFBTSxJQUFOLEdBQWE7QUFDWCxvQkFBTSxHQURLO0FBRVgsb0JBQU07QUFGSyxhQUFiO0FBSUEsbUJBQUssSUFBTCxDQUFVLFdBQVYsQ0FBc0IsS0FBdEI7QUFDRDtBQUVGLFNBMUJEO0FBMkJEO0FBRUY7OzsrQkFFVSxHLEVBQUs7QUFBQTs7QUFDZCxVQUFJLFFBQVEsSUFBWjs7QUFFQSxVQUFJLFFBQVEsSUFBSSxJQUFoQjtBQUNBLFVBQUksU0FBUyxzQkFBVSxJQUFJLElBQWQsRUFBb0IsTUFBakM7O0FBRUEsVUFBSSxJQUFJLElBQUosQ0FBUyxRQUFiLEVBQXVCO0FBQ3JCLGNBQU0sVUFBTixDQUFpQixHQUFqQixFQUFzQixJQUFJLElBQUosQ0FBUyxRQUEvQjtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQSxZQUFNLFFBQU4sQ0FBZSx1QkFBZixDQUF1QyxJQUFJLElBQUosQ0FBUyxNQUFoRCxFQUF3RCxJQUF4RCxDQUE2RCxVQUFDLFVBQUQsRUFBZ0I7O0FBRTNFLFlBQUksYUFBYSxXQUFXLGFBQVgsQ0FBeUIsVUFBekIsQ0FBb0MsVUFBckQ7QUFDQSxZQUFJLFNBQVMsV0FBVyxNQUFYLEdBQW9CLFdBQVcsTUFBWCxDQUFrQixRQUF0QyxHQUFpRCxVQUE5RDtBQUNBLFlBQUksWUFBWSxXQUFXLFFBQVgsR0FBc0IsV0FBVyxRQUFYLENBQW9CLFFBQTFDLEdBQXFELEVBQXJFOztBQUVBO0FBQ0E7QUFDQSxnREFBaUIsTUFBakIsRUFBeUIsVUFBekIsRUFBcUMsSUFBSSxJQUFKLENBQVMsS0FBOUM7O0FBRUEsWUFBSSxhQUFhO0FBQ2YsZ0JBQU0sSUFBSSxJQUFKLENBQVMsS0FBVCxDQUFlLElBRE47QUFFZixrQkFBUSxJQUFJLElBQUosQ0FBUyxLQUFULENBQWUsTUFGUjtBQUdmLG9CQUFVLElBQUksSUFBSixDQUFTLEtBQVQsQ0FBZSxRQUhWO0FBSWYscUJBQVcsSUFBSSxJQUFKLENBQVMsS0FBVCxDQUFlO0FBSlgsU0FBakI7O0FBT0E7QUFDQSxZQUFJLGtCQUFrQixJQUFJLElBQUosQ0FBUyxLQUFULENBQWUsUUFBckM7O0FBRUE7QUFDQSxjQUFNLFVBQU4sQ0FBaUIsTUFBakIsQ0FBd0IsTUFBeEIsRUFBZ0MsQ0FBaEMsRUFBbUMsVUFBbkMsRUFBK0MsTUFBL0MsRUFBdUQsZUFBdkQsRUFBd0UsSUFBeEUsQ0FBNkUsVUFBQyxTQUFELEVBQWU7QUFDMUYsY0FBSSxTQUFTLFVBQVUsT0FBVixDQUFrQixDQUFsQixDQUFiOztBQUVBLGtCQUFRLEdBQVIsQ0FBWSxtQkFBWixFQUFpQyxTQUFqQzs7QUFFQSxjQUFJLGtCQUFrQixTQUFTLGVBQS9COztBQUVBLGtCQUFRLEdBQVIsQ0FBWSxrQkFBWixFQUFnQyxlQUFoQzs7QUFFQTtBQUNBLGtCQUFRLElBQVIsQ0FBYSxtQkFBYixFQUFrQyxJQUFJLElBQUosQ0FBUyxLQUFULENBQWUsSUFBakQsRUFBdUQsSUFBSSxJQUFKLENBQVMsS0FBVCxDQUFlLE1BQXRFLEVBQThFLE1BQTlFLEVBQXNGLElBQUksSUFBSixDQUFTLEtBQVQsQ0FBZSxRQUFyRyxFQUErRyxJQUFJLElBQUosQ0FBUyxLQUFULENBQWUsU0FBOUg7QUFDQSxnQkFBTSxTQUFOLENBQWdCLGtCQUFoQixDQUFtQyxJQUFJLElBQUosQ0FBUyxLQUFULENBQWUsSUFBbEQsRUFBd0QsSUFBSSxJQUFKLENBQVMsS0FBVCxDQUFlLE1BQXZFLEVBQStFLE1BQS9FLEVBQXVGLElBQUksSUFBSixDQUFTLEtBQVQsQ0FBZSxRQUF0RyxFQUFnSCxJQUFJLElBQUosQ0FBUyxLQUFULENBQWUsU0FBL0gsRUFBMEksU0FBMUksRUFBcUosSUFBSSxJQUFKLENBQVMsU0FBOUosRUFBeUssSUFBekssQ0FBOEssVUFBQyxPQUFELEVBQWE7QUFDekwsb0JBQVEsR0FBUixDQUFZLG9DQUFaLEVBQWtELE9BQWxEOztBQUVBO0FBQ0EsZ0JBQUksaUJBQUo7O0FBRUEsZ0JBQUksQ0FBQyxPQUFLLFVBQUwsQ0FBZ0IsTUFBaEIsQ0FBTCxFQUE4QjtBQUM1Qix5QkFBVyw2QkFBbUIsS0FBbkIsRUFBMEIsS0FBMUIsRUFBaUMsTUFBakMsQ0FBWDtBQUNELGFBRkQsTUFFTztBQUNMLHlCQUFXLE9BQUssVUFBTCxDQUFnQixNQUFoQixDQUFYO0FBQ0Q7O0FBRUQsb0JBQVEsR0FBUixDQUFZLGtDQUFaLEVBQWdELEdBQWhEOztBQUVBLGdCQUFJLElBQUksSUFBSixDQUFTLGNBQVQsQ0FBd0IsT0FBeEIsS0FBb0MsSUFBSSxJQUFKLENBQVMsS0FBakQsRUFBd0Q7QUFDdEQ7QUFDQSxrQkFBSSxnQkFBSjtBQUNBLGtCQUFJLElBQUksSUFBSixDQUFTLGNBQVQsQ0FBd0IsVUFBeEIsS0FBdUMsSUFBSSxJQUFKLENBQVMsUUFBVCxDQUFrQixXQUFsQixDQUE4QixPQUF6RSxFQUFrRjtBQUNoRiwwQkFBVSxJQUFJLElBQUosQ0FBUyxRQUFULENBQWtCLFdBQWxCLENBQThCLE9BQXhDO0FBQ0Q7O0FBRUQsb0JBQU0saUJBQU4sQ0FBd0IsR0FBeEIsQ0FBNEIsTUFBNUIsRUFBb0MsSUFBcEMsRUFBMEMsSUFBSSxJQUFKLENBQVMsTUFBbkQsRUFBMkQsSUFBM0QsRUFBaUUsSUFBSSxJQUFKLENBQVMsS0FBMUUsRUFBaUYsS0FBakYsRUFBd0YsSUFBeEYsRUFBOEYsU0FBOUYsRUFBeUcsT0FBekc7QUFDRDs7QUFFRCxxQkFBUyxnQkFBVCxDQUEwQixDQUFDLE1BQUQsRUFBUyxlQUFULENBQTFCLEVBQXFELElBQXJELENBQTBELFlBQU07QUFDOUQsdUJBQVMsWUFBVCxDQUFzQixTQUF0QixFQUFpQyxJQUFqQyxDQUFzQyxZQUFNO0FBQzFDLHNCQUFNLFVBQU4sQ0FBaUIsTUFBakIsSUFBMkIsUUFBM0I7O0FBRUE7QUFDQSxzQkFBTSxJQUFOLENBQVcsV0FBWCxDQUF1QjtBQUNyQixzQkFBSSxJQUFJLEVBRGEsRUFDVCxNQUFNLFVBREcsRUFDUyxNQUFNLElBQUksRUFEbkIsRUFDdUIsSUFBSSxLQUQzQjtBQUVyQix3QkFBTSxFQUFFLE1BQU0sR0FBUixFQUFhLFVBQVUsTUFBdkIsRUFBK0IsbUJBQW1CLFNBQWxEO0FBRmUsaUJBQXZCOztBQUtBO0FBQ0E7QUFDQSwyQkFBVyxZQUFNO0FBQ2Y7QUFDQSx3QkFBTSxVQUFOLENBQWlCLEdBQWpCLEVBQXNCLE1BQXRCO0FBQ0QsaUJBSEQ7QUFJRCxlQWZEO0FBZ0JELGFBakJEO0FBa0JELFdBMUNELEVBMENHLFVBQVMsS0FBVCxFQUFnQjtBQUNqQixvQkFBUSxLQUFSLENBQWMsS0FBZDtBQUNELFdBNUNEO0FBOENELFNBekREO0FBMERELE9BL0VELEVBK0VHLEtBL0VILENBK0VTLFVBQUMsTUFBRCxFQUFZO0FBQ25CO0FBQ0EsWUFBSSxjQUFjO0FBQ2hCLGNBQUksSUFBSSxFQURRLEVBQ0osTUFBTSxVQURGLEVBQ2MsTUFBTSxJQUFJLEVBRHhCLEVBQzRCLElBQUksS0FEaEM7QUFFaEIsZ0JBQU0sRUFBRSxNQUFNLEdBQVIsRUFBYSxNQUFNLE1BQW5CO0FBRlUsU0FBbEI7O0FBS0EsY0FBTSxJQUFOLENBQVcsV0FBWCxDQUF1QixXQUF2QjtBQUNELE9BdkZEO0FBeUZEOzs7a0NBRWEsRyxFQUFLLFksRUFBYztBQUFBOztBQUUvQixVQUFJLFFBQVEsSUFBWjs7QUFFQSxVQUFJLFFBQVEsSUFBSSxJQUFoQjtBQUNBLFVBQUksU0FBUyxhQUFhLE1BQTFCO0FBQ0EsVUFBSSxXQUFXLGFBQWEsUUFBNUI7QUFDQSxVQUFJLGNBQWMsYUFBYSxJQUEvQjs7QUFFQSxjQUFRLEdBQVIsQ0FBWSxpQ0FBWixFQUErQyxHQUEvQzs7QUFFQSxVQUFJLFVBQVUsR0FBZDtBQUNBLGNBQVEsSUFBUixDQUFhLFNBQWIsR0FBeUIsYUFBYSxhQUF0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBTSxRQUFOLENBQWUsdUJBQWYsQ0FBdUMsTUFBdkMsRUFBK0MsSUFBL0MsQ0FBb0QsVUFBQyxVQUFELEVBQWdCOztBQUVsRSxZQUFJLGFBQWEsV0FBVyxhQUFYLENBQXlCLFVBQXpCLENBQW9DLFVBQXJEO0FBQ0EsWUFBSSxTQUFTLFdBQVcsTUFBWCxHQUFvQixXQUFXLE1BQVgsQ0FBa0IsUUFBdEMsR0FBaUQsVUFBOUQ7QUFDQSxZQUFJLFlBQVksV0FBVyxRQUFYLEdBQXNCLFdBQVcsUUFBWCxDQUFvQixRQUExQyxHQUFxRCxFQUFyRTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWlCLE1BQWpCLEVBQXlCLFVBQXpCLEVBQXFDLFdBQXJDOztBQUVBO0FBQ0EsWUFBSSxpQkFBSjs7QUFFQSxZQUFJLENBQUMsT0FBSyxVQUFMLENBQWdCLFFBQWhCLENBQUwsRUFBZ0M7QUFDOUIscUJBQVcsNkJBQW1CLEtBQW5CLEVBQTBCLEtBQTFCLEVBQWlDLFFBQWpDLENBQVg7QUFDRCxTQUZELE1BRU87QUFDTCxxQkFBVyxPQUFLLFVBQUwsQ0FBZ0IsUUFBaEIsQ0FBWDtBQUNEOztBQUVELGNBQU0sVUFBTixDQUFpQixRQUFqQixJQUE2QixRQUE3Qjs7QUFFQSxpQkFBUyxtQkFBVCxDQUE2QixhQUFhLGFBQTFDOztBQUVBO0FBQ0EsY0FBTSxJQUFOLENBQVcsV0FBWCxDQUF1QjtBQUNyQixjQUFJLElBQUksRUFEYSxFQUNULE1BQU0sVUFERyxFQUNTLE1BQU0sSUFBSSxFQURuQixFQUN1QixJQUFJLEtBRDNCO0FBRXJCLGdCQUFNLEVBQUUsTUFBTSxHQUFSLEVBQWEsVUFBVSxRQUF2QixFQUFpQyxtQkFBbUIsU0FBcEQsRUFBK0QsUUFBUSxNQUF2RSxFQUErRSxPQUFPLGFBQWEsSUFBbkc7QUFGZSxTQUF2Qjs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFRCxPQXBDRDtBQXFDRDs7OytCQUVVLEcsRUFBSyxNLEVBQVE7QUFDdEIsVUFBSSxRQUFRLElBQVo7QUFDQSxVQUFJLG9CQUFvQixTQUFTLGVBQWpDOztBQUVBLFVBQUksSUFBSixDQUFTLFNBQVQsQ0FBbUIsT0FBbkIsQ0FBMkIsVUFBQyxVQUFELEVBQWdCO0FBQ3pDO0FBQ0EsY0FBTSxJQUFOLENBQVcsV0FBWCxDQUF1QjtBQUNyQixnQkFBTSxRQURlLEVBQ0wsTUFBTSxpQkFERCxFQUNvQixJQUFJLFVBRHhCO0FBRXJCLGdCQUFNLEVBQUUsVUFBVSxJQUFJLElBQUosQ0FBUyxRQUFyQixFQUErQixRQUFRLElBQUksSUFBM0MsRUFBaUQsT0FBTyxJQUFJLElBQUosQ0FBUyxLQUFqRSxFQUF3RSxRQUFRLElBQUksSUFBSixDQUFTLE1BQXpGO0FBRmUsU0FBdkI7QUFJRCxPQU5EO0FBT0Q7O0FBRUQ7Ozs7OEJBQ1UsRyxFQUFLO0FBQ2IsVUFBSSxRQUFRLElBQVo7O0FBRUEsVUFBSSxTQUFTLElBQUksSUFBSixDQUFTLFFBQXRCOztBQUVBLFVBQUksU0FBUyxNQUFNLFVBQU4sQ0FBaUIsTUFBakIsQ0FBYjtBQUNBLFVBQUksTUFBSixFQUFZO0FBQ1Y7QUFDQSxlQUFPLE1BQVA7O0FBRUEsYUFBSyxpQkFBTCxDQUF1QixjQUF2QixDQUFzQyxNQUF0Qzs7QUFFQTtBQUNBLGNBQU0sSUFBTixDQUFXLFdBQVgsQ0FBdUI7QUFDckIsY0FBSSxJQUFJLEVBRGEsRUFDVCxNQUFNLFVBREcsRUFDUyxNQUFNLElBQUksRUFEbkIsRUFDdUIsSUFBSSxJQUFJLElBRC9CO0FBRXJCLGdCQUFNLEVBQUUsTUFBTSxHQUFSO0FBRmUsU0FBdkI7QUFJRDtBQUNGOztBQUVEOzs7O3NDQUNrQixHLEVBQUs7QUFBQTs7QUFFckIsV0FBSyxpQkFBTCxDQUF1QixzQkFBdkIsQ0FBOEMsR0FBOUMsRUFBbUQsS0FBbkQsRUFBMEQsSUFBMUQsQ0FBK0QsVUFBQyxNQUFELEVBQVk7O0FBRXpFLGdCQUFRLEdBQVIsQ0FBWSw4Q0FBWixFQUE0RCxNQUE1RDs7QUFFQSxZQUFJLFVBQVUsb0JBQVksTUFBWixFQUFvQixNQUFwQixHQUE2QixDQUEzQyxFQUE4Qzs7QUFFNUM7QUFDQSw4QkFBWSxNQUFaLEVBQW9CLE9BQXBCLENBQTRCLFVBQUMsTUFBRCxFQUFZO0FBQ3RDLG9CQUFRLEdBQVIsQ0FBWSxrRUFBWixFQUFnRixPQUFPLE1BQVAsQ0FBaEY7QUFDQSxtQkFBSyxtQkFBTCxDQUF5QixHQUF6QixFQUE4QixPQUFPLE1BQVAsQ0FBOUI7QUFDRCxXQUhEO0FBS0QsU0FSRCxNQVFPLElBQUksSUFBSSxJQUFKLENBQVMsTUFBVCxJQUFtQixJQUFJLElBQUosQ0FBUyxRQUFoQyxFQUEwQztBQUMvQyxrQkFBUSxHQUFSLENBQVkscUNBQVosRUFBbUQsSUFBSSxJQUFKLENBQVMsTUFBNUQsRUFBb0UsSUFBSSxJQUFKLENBQVMsUUFBN0U7QUFDQSxpQkFBSyxnQkFBTCxDQUFzQixHQUF0QjtBQUNELFNBSE0sTUFHQTtBQUNMO0FBQ0EsY0FBSSxRQUFRLEVBQVo7QUFDQSxnQkFBTSxFQUFOLEdBQVcsSUFBSSxFQUFmO0FBQ0EsZ0JBQU0sSUFBTixHQUFhLElBQUksRUFBakI7QUFDQSxnQkFBTSxFQUFOLEdBQVcsSUFBSSxJQUFmO0FBQ0EsZ0JBQU0sSUFBTixHQUFhLFVBQWI7QUFDQSxnQkFBTSxJQUFOLEdBQWE7QUFDWCxrQkFBTSxHQURLO0FBRVgsa0JBQU07QUFGSyxXQUFiO0FBSUEsaUJBQUssSUFBTCxDQUFVLFdBQVYsQ0FBc0IsS0FBdEI7QUFDRDtBQUVGLE9BN0JEO0FBK0JEOzs7cUNBRWdCLEcsRUFBSztBQUFBOztBQUNwQixVQUFJLFFBQVEsSUFBWjs7QUFFQSxVQUFJLFNBQVMsSUFBSSxJQUFKLENBQVMsUUFBdEI7O0FBRUEsVUFBSSxhQUFhLElBQUksSUFBckI7QUFDQSxVQUFJLFNBQVMsc0JBQVUsTUFBVixFQUFrQixNQUEvQjtBQUNBLFVBQUkscUJBQXFCLFNBQVMsZUFBbEM7O0FBRUEsVUFBSSxlQUFlLFNBQVMsWUFBNUI7O0FBRUE7QUFDQSxZQUFNLFFBQU4sQ0FBZSx1QkFBZixDQUF1QyxJQUFJLElBQUosQ0FBUyxNQUFoRCxFQUF3RCxJQUF4RCxDQUE2RCxVQUFDLFVBQUQsRUFBZ0I7QUFDM0UsWUFBSSxhQUFhLFdBQVcsYUFBWCxDQUF5QixVQUF6QixDQUFvQyxVQUFyRDtBQUNBLFlBQUksWUFBWSxXQUFXLFFBQVgsR0FBc0IsV0FBVyxRQUFYLENBQW9CLFFBQTFDLEdBQXFELEVBQXJFOztBQUVBO0FBQ0EsWUFBSSxnQkFBZ0IsRUFBcEI7QUFDQSxzQkFBYyxJQUFkLENBQW1CLFNBQVMsVUFBNUI7QUFDQSxrQkFBVSxPQUFWLENBQWtCLFVBQUMsS0FBRDtBQUFBLGlCQUFXLGNBQWMsSUFBZCxDQUFtQixlQUFlLEtBQWxDLENBQVg7QUFBQSxTQUFsQjs7QUFFQTtBQUNBLFlBQUksbUJBQW1CO0FBQ3JCLGdCQUFNLFdBRGUsRUFDRixNQUFNLE1BQU0sSUFEVixFQUNnQixJQUFJLHVCQUF1QixNQUF2QixHQUFnQyxLQURwRDtBQUVyQixnQkFBTSxFQUFFLFVBQVUsSUFBSSxJQUFKLENBQVMsUUFBckIsRUFBK0IsV0FBVyxhQUExQyxFQUF5RCxRQUFRLFVBQWpFO0FBRmUsU0FBdkI7O0FBS0E7QUFDQSxjQUFNLElBQU4sQ0FBVyxXQUFYLENBQXVCLGdCQUF2QixFQUF5QyxVQUFDLEtBQUQsRUFBVztBQUNsRCxrQkFBUSxHQUFSLENBQVkscUNBQVosRUFBbUQsS0FBbkQ7QUFDQSxjQUFJLE1BQU0sSUFBTixDQUFXLElBQVgsS0FBb0IsR0FBeEIsRUFBNkI7O0FBRTNCO0FBQ0Esa0JBQU0sSUFBTixDQUFXLFdBQVgsQ0FBdUI7QUFDckIsa0JBQUksSUFBSSxFQURhLEVBQ1QsTUFBTSxVQURHLEVBQ1MsTUFBTSxJQUFJLEVBRG5CLEVBQ3VCLElBQUksVUFEM0I7QUFFckIsb0JBQU0sRUFBRSxNQUFNLEdBQVIsRUFBYSxtQkFBbUIsU0FBaEMsRUFBMkMsUUFBUSxJQUFJLElBQUosQ0FBUyxNQUE1RCxFQUFvRSxVQUFVLElBQUksSUFBSixDQUFTLFFBQXZGO0FBRmUsYUFBdkI7O0FBS0E7QUFDQSxnQkFBSSxrQkFBa0I7QUFDcEIsb0JBQU0sV0FEYyxFQUNELE1BQU0sTUFBTSxJQURYLEVBQ2lCLElBQUksa0JBRHJCO0FBRXBCLG9CQUFNLEVBQUUsVUFBVSxpQkFBaUIsSUFBakIsQ0FBc0IsUUFBbEMsRUFBNEMsWUFBWSxVQUF4RDtBQUZjLGFBQXRCOztBQUtBO0FBQ0Esa0JBQU0sSUFBTixDQUFXLFdBQVgsQ0FBdUIsZUFBdkIsRUFBd0MsVUFBQyxLQUFELEVBQVc7QUFDakQsc0JBQVEsR0FBUixDQUFZLG1DQUFaLEVBQWlELEtBQWpEO0FBQ0Esa0JBQUksTUFBTSxJQUFOLENBQVcsSUFBWCxLQUFvQixHQUF4QixFQUE2Qjs7QUFFM0Isb0JBQUksV0FBVyxNQUFNLFVBQU4sQ0FBaUIsTUFBakIsQ0FBZjtBQUNBLG9CQUFJLENBQUMsUUFBTCxFQUFlO0FBQ2IsNkJBQVcsNkJBQW1CLEtBQW5CLEVBQTBCLE1BQTFCLEVBQWtDLFNBQWxDLENBQVg7QUFDQSx3QkFBTSxVQUFOLENBQWlCLE1BQWpCLElBQTJCLFFBQTNCO0FBQ0Q7O0FBRUQsb0JBQUksSUFBSSxJQUFKLENBQVMsY0FBVCxDQUF3QixPQUF4QixLQUFvQyxJQUFJLElBQUosQ0FBUyxLQUFqRCxFQUF3RDtBQUN0RDtBQUNBLHNCQUFJLGdCQUFKO0FBQ0Esc0JBQUksSUFBSSxJQUFKLENBQVMsY0FBVCxDQUF3QixVQUF4QixLQUF1QyxJQUFJLElBQUosQ0FBUyxRQUFULENBQWtCLFdBQWxCLENBQThCLE9BQXpFLEVBQWtGO0FBQ2hGLDhCQUFVLElBQUksSUFBSixDQUFTLFFBQVQsQ0FBa0IsV0FBbEIsQ0FBOEIsT0FBeEM7QUFDRDs7QUFFRCx3QkFBTSxpQkFBTixDQUF3QixHQUF4QixDQUE0QixNQUE1QixFQUFvQyxLQUFwQyxFQUEyQyxJQUFJLElBQUosQ0FBUyxNQUFwRCxFQUE0RCxJQUE1RCxFQUFrRSxFQUFsRSxFQUFzRSxVQUF0RSxFQUFrRixJQUFsRixFQUF3RixTQUF4RixFQUFtRyxPQUFuRztBQUNEOztBQUVEO0FBQ0EseUJBQVMsZUFBVCxDQUF5QixVQUF6Qjs7QUFFQTtBQUNBLHNCQUFNLEVBQU4sR0FBVyxJQUFJLEVBQWY7QUFDQSxzQkFBTSxJQUFOLEdBQWEsTUFBTSxJQUFuQjtBQUNBLHNCQUFNLEVBQU4sR0FBVyxVQUFYO0FBQ0Esc0JBQU0sSUFBTixDQUFXLE1BQVgsR0FBb0IsSUFBSSxJQUFKLENBQVMsTUFBN0I7QUFDQSxzQkFBTSxJQUFOLENBQVcsUUFBWCxHQUFzQixJQUFJLElBQUosQ0FBUyxRQUEvQjs7QUFFQSx3QkFBUSxHQUFSLENBQVksa0NBQVosRUFBZ0QsR0FBaEQsRUFBcUQsS0FBckQsRUFBNEQsUUFBNUQ7O0FBRUEsdUJBQUssSUFBTCxDQUFVLFdBQVYsQ0FBc0IsS0FBdEI7QUFFRDtBQUNGLGFBbkNEO0FBcUNELFdBcERELE1Bb0RPO0FBQ0w7QUFDQSxrQkFBTSxJQUFOLENBQVcsV0FBWCxDQUF1QjtBQUNyQixrQkFBSSxJQUFJLEVBRGEsRUFDVCxNQUFNLFVBREcsRUFDUyxNQUFNLElBQUksRUFEbkIsRUFDdUIsSUFBSSxVQUQzQjtBQUVyQixvQkFBTSxNQUFNO0FBRlMsYUFBdkI7QUFJRDtBQUNGLFNBN0REO0FBK0RELE9BL0VEO0FBaUZEOzs7d0NBRW1CLEcsRUFBSyxZLEVBQWM7QUFBQTs7QUFDckMsVUFBSSxTQUFTLGFBQWEsUUFBMUI7QUFDQSxVQUFJLFNBQVMsYUFBYSxNQUExQjs7QUFFQSxVQUFJLGFBQWEsSUFBSSxJQUFyQjtBQUNBLFVBQUkscUJBQXFCLFNBQVMsZUFBbEM7O0FBRUEsVUFBSSxlQUFlLFNBQVMsWUFBNUI7O0FBRUEsY0FBUSxHQUFSLENBQVksK0NBQVosRUFBNkQsTUFBN0QsRUFBcUUsWUFBckUsRUFBbUYsTUFBbkY7O0FBRUE7QUFDQSxXQUFLLFFBQUwsQ0FBYyx1QkFBZCxDQUFzQyxNQUF0QyxFQUE4QyxJQUE5QyxDQUFtRCxVQUFDLFVBQUQsRUFBZ0I7QUFDakUsWUFBSSxhQUFhLFdBQVcsYUFBWCxDQUF5QixVQUF6QixDQUFvQyxVQUFyRDtBQUNBLFlBQUksWUFBWSxXQUFXLFFBQVgsR0FBc0IsV0FBVyxRQUFYLENBQW9CLFFBQTFDLEdBQXFELEVBQXJFOztBQUVBO0FBQ0EsWUFBSSxnQkFBZ0IsRUFBcEI7QUFDQSxzQkFBYyxJQUFkLENBQW1CLFNBQVMsVUFBNUI7QUFDQSxrQkFBVSxPQUFWLENBQWtCLFVBQUMsS0FBRDtBQUFBLGlCQUFXLGNBQWMsSUFBZCxDQUFtQixlQUFlLEtBQWxDLENBQVg7QUFBQSxTQUFsQjs7QUFFQTtBQUNBLFlBQUksa0JBQWtCO0FBQ3BCLGdCQUFNLFdBRGMsRUFDRCxNQUFNLE9BQUssSUFEVixFQUNnQixJQUFJLGtCQURwQjtBQUVwQixnQkFBTSxFQUFFLFlBQVksVUFBZDtBQUZjLFNBQXRCOztBQUtBO0FBQ0EsZUFBSyxJQUFMLENBQVUsV0FBVixDQUFzQixlQUF0QixFQUF1QyxVQUFDLEtBQUQsRUFBVzs7QUFFaEQsY0FBSSxXQUFXLE9BQUssVUFBTCxDQUFnQixNQUFoQixDQUFmO0FBQ0EsY0FBSSxDQUFDLFFBQUwsRUFBZTtBQUNiLHVCQUFXLHFDQUF5QixNQUF6QixFQUFpQyxTQUFqQyxDQUFYO0FBQ0EsbUJBQUssVUFBTCxDQUFnQixNQUFoQixJQUEwQixRQUExQjtBQUNEOztBQUVEO0FBQ0EsbUJBQVMsZUFBVCxDQUF5QixVQUF6Qjs7QUFFQTtBQUNBLGNBQUksV0FBVztBQUNiLGdCQUFJLElBQUksRUFESyxFQUNELE1BQU0sT0FBSyxJQURWLEVBQ2dCLElBQUksVUFEcEIsRUFDZ0MsTUFBTSxVQUR0QztBQUViLGtCQUFNLE1BQU07QUFGQyxXQUFmOztBQUtBLG1CQUFTLElBQVQsQ0FBYyxNQUFkLEdBQXVCLE1BQXZCO0FBQ0EsbUJBQVMsSUFBVCxDQUFjLFFBQWQsR0FBeUIsTUFBekI7O0FBRUEsa0JBQVEsR0FBUixDQUFZLHFDQUFaLEVBQW1ELEdBQW5ELEVBQXdELEtBQXhELEVBQStELFFBQS9ELEVBQXlFLFFBQXpFOztBQUVBLGlCQUFLLElBQUwsQ0FBVSxXQUFWLENBQXNCLFFBQXRCO0FBRUQsU0F4QkQ7QUEwQkQsT0ExQ0Q7QUEyQ0Q7O0FBRUQ7Ozs7d0NBQ29CLEcsRUFBSztBQUN2QixVQUFJLFFBQVEsSUFBWjs7QUFFQSxVQUFJLGFBQWEsSUFBSSxJQUFyQjtBQUNBLFVBQUksU0FBUyxJQUFJLElBQUosQ0FBUyxRQUF0Qjs7QUFFQSxVQUFJLFdBQVcsTUFBTSxVQUFOLENBQWlCLE1BQWpCLENBQWY7QUFDQSxVQUFJLFFBQUosRUFBYztBQUNaO0FBQ0EsaUJBQVMsa0JBQVQsQ0FBNEIsVUFBNUI7O0FBRUE7QUFDQSxjQUFNLElBQU4sQ0FBVyxXQUFYLENBQXVCO0FBQ3JCLGNBQUksSUFBSSxFQURhLEVBQ1QsTUFBTSxVQURHLEVBQ1MsTUFBTSxJQUFJLEVBRG5CLEVBQ3VCLElBQUksSUFBSSxJQUQvQjtBQUVyQixnQkFBTSxFQUFFLE1BQU0sR0FBUjtBQUZlLFNBQXZCOztBQUtBLGFBQUssaUJBQUwsQ0FBdUIsTUFBdkIsQ0FBOEIsTUFBOUIsRUFBc0MsZUFBdEMsRUFBdUQsVUFBdkQ7O0FBRUE7QUFDQTtBQUNEO0FBQ0Y7Ozt3QkEvYlM7QUFBRSxhQUFPLEtBQUssSUFBWjtBQUFtQjs7O0tBOUZqQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tCQWlpQmUsYzs7Ozs7Ozs7Ozs7Ozs7UUMvaEJDLGdCLEdBQUEsZ0I7O0FBRmhCOzs7Ozs7QUFFTyxTQUFTLGdCQUFULENBQTBCLE1BQTFCLEVBQWtDLFVBQWxDLEVBQThDLEtBQTlDLEVBQXFEOztBQUUxRCxVQUFRLEdBQVIsQ0FBWSxVQUFaLEVBQXdCLE1BQXhCOztBQUVBO0FBQ0EsVUFBUSxHQUFSLENBQVksOEJBQVo7QUFDQSxNQUFJO0FBQ0YsUUFBSSxNQUFNLEtBQVY7QUFDQSxRQUFJLFNBQVMsV0FBVyxhQUFYLENBQXlCLFVBQXRDOztBQUVBO0FBQ0EsaUJBQUksU0FBSixDQUFjLE9BQU8sRUFBckIsRUFBeUIsTUFBekI7O0FBRUE7QUFDQSxRQUFJLFNBQVMsYUFBSSxnQkFBSixDQUFxQixHQUFyQixFQUEwQixNQUExQixDQUFiOztBQUVBO0FBQ0EsV0FBTyxNQUFQLENBQWMsT0FBZCxDQUFzQixVQUFDLEtBQUQsRUFBVztBQUMvQixhQUFPLE1BQU0sS0FBYjtBQUNELEtBRkQ7O0FBSUE7QUFDQSxRQUFJLENBQUMsT0FBTyxLQUFSLElBQWtCLE9BQU8sT0FBUCxDQUFlLE1BQWYsR0FBd0IsQ0FBOUMsRUFBa0Q7QUFDaEQsY0FBUSxJQUFSLENBQWEsd0JBQXdCLE9BQU8sS0FBUCxHQUFlLDZDQUFmLEdBQStELFNBQXZGLENBQWIsRUFBZ0gseUJBQWUsTUFBZixFQUF1QixJQUF2QixFQUE2QixDQUE3QixDQUFoSDtBQUNBLGNBQVEsS0FBUixDQUFjLFNBQWQsRUFBeUIseUJBQWUsR0FBZixFQUFvQixJQUFwQixFQUEwQixDQUExQixDQUF6QixFQUF1RCxhQUF2RCxFQUFzRSx5QkFBZSxNQUFmLEVBQXVCLElBQXZCLEVBQTZCLENBQTdCLENBQXRFO0FBQ0QsS0FIRCxNQUdPO0FBQ0wsY0FBUSxHQUFSLENBQVksNkJBQVo7QUFDRDtBQUNGLEdBdEJELENBc0JFLE9BQU8sQ0FBUCxFQUFVO0FBQ1YsWUFBUSxJQUFSLENBQWEsaUNBQWIsRUFBZ0QsQ0FBaEQ7QUFDRDtBQUVGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xDRDs7Ozs7Ozs7QUFRQTtBQUNBLElBQUksZUFBSixFQUFrQjtBQUNkLFdBQU8sSUFBUCxHQUFlLFlBQVk7QUFDdkIsWUFBSSxpQkFBaUIsT0FBTyxTQUFQLENBQWlCLGNBQXRDO0FBQUEsWUFDSSxpQkFBaUIsQ0FBRSxFQUFDLFVBQVUsSUFBWCxFQUFELENBQW1CLG9CQUFuQixDQUF3QyxVQUF4QyxDQUR0QjtBQUFBLFlBRUksWUFBWSxDQUNSLFVBRFEsRUFFUixnQkFGUSxFQUdSLFNBSFEsRUFJUixnQkFKUSxFQUtSLGVBTFEsRUFNUixzQkFOUSxFQU9SLGFBUFEsQ0FGaEI7QUFBQSxZQVdJLGtCQUFrQixVQUFVLE1BWGhDOztBQWFBLGVBQU8sVUFBVSxHQUFWLEVBQWU7QUFDbEIsZ0JBQUksUUFBTyxHQUFQLHVEQUFPLEdBQVAsT0FBZSxRQUFmLElBQTJCLE9BQU8sR0FBUCxLQUFlLFVBQTFDLElBQXdELFFBQVEsSUFBcEUsRUFBMEU7QUFDdEUsc0JBQU0sSUFBSSxTQUFKLENBQWMsa0NBQWQsQ0FBTjtBQUNIOztBQUVELGdCQUFJLFNBQVMsRUFBYjs7QUFFQSxpQkFBSyxJQUFJLElBQVQsSUFBaUIsR0FBakIsRUFBc0I7QUFDbEIsb0JBQUksZUFBZSxJQUFmLENBQW9CLEdBQXBCLEVBQXlCLElBQXpCLENBQUosRUFBb0M7QUFDaEMsMkJBQU8sSUFBUCxDQUFZLElBQVo7QUFDSDtBQUNKOztBQUVELGdCQUFJLGNBQUosRUFBb0I7QUFDaEIscUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxlQUFwQixFQUFxQyxHQUFyQyxFQUEwQztBQUN0Qyx3QkFBSSxlQUFlLElBQWYsQ0FBb0IsR0FBcEIsRUFBeUIsVUFBVSxDQUFWLENBQXpCLENBQUosRUFBNEM7QUFDeEMsK0JBQU8sSUFBUCxDQUFZLFVBQVUsQ0FBVixDQUFaO0FBQ0g7QUFDSjtBQUNKO0FBQ0QsbUJBQU8sTUFBUDtBQUNILFNBckJEO0FBc0JILEtBcENhLEVBQWQ7QUFxQ0g7QUFDRDtBQUNBLElBQUksaUJBQUosRUFBb0I7QUFDaEIsV0FBTyxNQUFQLEdBQWlCLFlBQVk7QUFDekIsaUJBQVMsQ0FBVCxHQUFhLENBQ1o7O0FBRUQsZUFBTyxVQUFVLENBQVYsRUFBYTtBQUNoQixnQkFBSSxVQUFVLE1BQVYsS0FBcUIsQ0FBekIsRUFBNEI7QUFDeEIsc0JBQU0sSUFBSSxLQUFKLENBQVUsMERBQVYsQ0FBTjtBQUNIO0FBQ0QsY0FBRSxTQUFGLEdBQWMsQ0FBZDtBQUNBLG1CQUFPLElBQUksQ0FBSixFQUFQO0FBQ0gsU0FORDtBQU9ILEtBWGUsRUFBaEI7QUFZSDtBQUNEO0FBQ0EsSUFBSSxDQUFDLE1BQU0sT0FBWCxFQUFvQjtBQUNoQixVQUFNLE9BQU4sR0FBZ0IsVUFBVSxJQUFWLEVBQWdCO0FBQzVCLGVBQU8sT0FBTyxTQUFQLENBQWlCLFFBQWpCLENBQTBCLElBQTFCLENBQStCLElBQS9CLE1BQXlDLGdCQUFoRDtBQUNILEtBRkQ7QUFHSDtBQUNEO0FBQ0EsSUFBSSxDQUFDLE1BQU0sU0FBTixDQUFnQixPQUFyQixFQUE4QjtBQUMxQixVQUFNLFNBQU4sQ0FBZ0IsT0FBaEIsR0FBMEIsVUFBVSxhQUFWLENBQXdCLGdCQUF4QixFQUEwQztBQUNoRSxZQUFJLFNBQVMsSUFBYixFQUFtQjtBQUNmLGtCQUFNLElBQUksU0FBSixFQUFOO0FBQ0g7QUFDRCxZQUFJLElBQUksT0FBTyxJQUFQLENBQVI7QUFDQSxZQUFJLE1BQU0sRUFBRSxNQUFGLEtBQWEsQ0FBdkI7O0FBRUEsWUFBSSxRQUFRLENBQVosRUFBZTtBQUNYLG1CQUFPLENBQUMsQ0FBUjtBQUNIO0FBQ0QsWUFBSSxJQUFJLENBQVI7QUFDQSxZQUFJLFVBQVUsTUFBVixHQUFtQixDQUF2QixFQUEwQjtBQUN0QixnQkFBSSxPQUFPLFVBQVUsQ0FBVixDQUFQLENBQUo7QUFDQSxnQkFBSSxNQUFNLENBQVYsRUFBYTtBQUFFO0FBQ1gsb0JBQUksQ0FBSjtBQUNILGFBRkQsTUFFTyxJQUFJLE1BQU0sQ0FBTixJQUFXLE1BQU0sUUFBakIsSUFBNkIsTUFBTSxDQUFDLFFBQXhDLEVBQWtEO0FBQ3JELG9CQUFJLENBQUMsSUFBSSxDQUFKLElBQVMsQ0FBQyxDQUFYLElBQWdCLEtBQUssS0FBTCxDQUFXLEtBQUssR0FBTCxDQUFTLENBQVQsQ0FBWCxDQUFwQjtBQUNIO0FBQ0o7QUFDRCxZQUFJLEtBQUssR0FBVCxFQUFjO0FBQ1YsbUJBQU8sQ0FBQyxDQUFSO0FBQ0g7QUFDRCxZQUFJLElBQUksS0FBSyxDQUFMLEdBQVMsQ0FBVCxHQUFhLEtBQUssR0FBTCxDQUFTLE1BQU0sS0FBSyxHQUFMLENBQVMsQ0FBVCxDQUFmLEVBQTRCLENBQTVCLENBQXJCO0FBQ0EsZUFBTyxJQUFJLEdBQVgsRUFBZ0IsR0FBaEIsRUFBcUI7QUFDakIsZ0JBQUksS0FBSyxDQUFMLElBQVUsRUFBRSxDQUFGLE1BQVMsYUFBdkIsRUFBc0M7QUFDbEMsdUJBQU8sQ0FBUDtBQUNIO0FBQ0o7QUFDRCxlQUFPLENBQUMsQ0FBUjtBQUNILEtBN0JEO0FBOEJIOztBQUVEO0FBQ0EsSUFBSSxtQkFBSixFQUFzQjtBQUNsQixXQUFPLFFBQVAsR0FBa0IsVUFBVSxHQUFWLEVBQWU7QUFDN0IsWUFBSSxNQUFNLHFCQUFWO0FBQ0EsZUFBTyxJQUFJLGNBQUosQ0FBbUIsR0FBbkIsQ0FBUCxFQUFnQztBQUM1QixtQkFBTyxLQUFLLE1BQUwsRUFBUDtBQUNIO0FBQ0QsWUFBSTtBQUNBLGdCQUFJLEdBQUosSUFBVyxJQUFYO0FBQ0EsbUJBQU8sSUFBSSxHQUFKLENBQVA7QUFDQSxtQkFBTyxLQUFQO0FBQ0gsU0FKRCxDQUlFLE9BQU8sQ0FBUCxFQUFVO0FBQ1IsbUJBQU8sSUFBUDtBQUNIO0FBQ0osS0FaRDtBQWFIO0FBQ0Q7O0FBRUEsSUFBSSw2QkFBNkI7QUFDN0IsU0FBSyxJQUR3QjtBQUU3QixTQUFLLElBRndCO0FBRzdCLFNBQUssSUFId0I7QUFJN0IsU0FBSyxJQUp3QjtBQUs3QixTQUFLLElBTHdCO0FBTTdCLFNBQUssSUFOd0I7QUFPN0IsU0FBSztBQVB3QixDQUFqQztBQVNBLElBQUksc0JBQXNCO0FBQ3RCLFNBQUs7QUFEaUIsQ0FBMUI7O0FBSUEsU0FBUyxzQkFBVCxDQUFnQyxNQUFoQyxFQUF3QztBQUNwQyxXQUFPLFVBQVUsTUFBVixFQUFrQixPQUFsQixDQUEwQixnQkFBMUIsRUFBNEMsVUFBVSxhQUFWLEVBQXlCO0FBQ3hFLGVBQU8sTUFBTSxjQUFjLFNBQWQsQ0FBd0IsQ0FBeEIsQ0FBYjtBQUNILEtBRk0sQ0FBUDtBQUdIOztBQUVELFNBQVMsdUJBQVQsQ0FBaUMsSUFBakMsRUFBdUM7QUFDbkMsUUFBSSxXQUFXLEVBQWY7QUFDQSxRQUFJLDJCQUEyQixLQUFLLE1BQUwsQ0FBWSxDQUFaLENBQTNCLENBQUosRUFBZ0Q7QUFDNUMsbUJBQVcsS0FBSyxNQUFMLENBQVksQ0FBWixDQUFYO0FBQ0EsZUFBTyxLQUFLLFNBQUwsQ0FBZSxDQUFmLENBQVA7QUFDSDtBQUNELFFBQUksWUFBWSxFQUFoQjtBQUNBLFFBQUksU0FBUyxFQUFiO0FBQ0EsUUFBSSxlQUFlLElBQW5CO0FBQ0EsUUFBSSxnQkFBZ0IsS0FBcEI7QUFDQSxRQUFJLGtCQUFrQixLQUF0QjtBQUNBLFFBQUksYUFBYSxHQUFqQixFQUFzQjtBQUNsQix1QkFBZSxLQUFmO0FBQ0gsS0FGRCxNQUVPLElBQUksYUFBYSxHQUFqQixFQUFzQjtBQUN6QixpQkFBUyxHQUFUO0FBQ0Esb0JBQVksR0FBWjtBQUNILEtBSE0sTUFHQSxJQUFJLGFBQWEsR0FBakIsRUFBc0I7QUFDekIsaUJBQVMsR0FBVDtBQUNBLG9CQUFZLEdBQVo7QUFDSCxLQUhNLE1BR0EsSUFBSSxhQUFhLEdBQWpCLEVBQXNCO0FBQ3pCLGlCQUFTLEdBQVQ7QUFDQSx1QkFBZSxLQUFmO0FBQ0gsS0FITSxNQUdBLElBQUksYUFBYSxHQUFqQixFQUFzQjtBQUN6QixpQkFBUyxHQUFUO0FBQ0Esb0JBQVksR0FBWjtBQUNBLHdCQUFnQixJQUFoQjtBQUNBLDBCQUFrQixJQUFsQjtBQUNILEtBTE0sTUFLQSxJQUFJLGFBQWEsR0FBakIsRUFBc0I7QUFDekIsaUJBQVMsR0FBVDtBQUNBLG9CQUFZLEdBQVo7QUFDQSx3QkFBZ0IsSUFBaEI7QUFDSCxLQUpNLE1BSUEsSUFBSSxhQUFhLEdBQWpCLEVBQXNCO0FBQ3pCLGlCQUFTLEdBQVQ7QUFDQSxvQkFBWSxHQUFaO0FBQ0Esd0JBQWdCLElBQWhCO0FBQ0g7O0FBRUQsUUFBSSxXQUFXLEVBQWY7QUFDQSxRQUFJLFVBQVUsS0FBSyxLQUFMLENBQVcsR0FBWCxDQUFkO0FBQ0EsUUFBSSxXQUFXLEVBQWY7QUFDQSxRQUFJLGFBQWEsRUFBakI7QUFDQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksUUFBUSxNQUE1QixFQUFvQyxHQUFwQyxFQUF5QztBQUNyQyxZQUFJLFVBQVUsUUFBUSxDQUFSLENBQWQ7QUFDQSxZQUFJLFdBQVcsSUFBZjtBQUNBLFlBQUksUUFBUSxPQUFSLENBQWdCLEdBQWhCLE1BQXlCLENBQUMsQ0FBOUIsRUFBaUM7QUFDN0IsZ0JBQUksUUFBUSxRQUFRLEtBQVIsQ0FBYyxHQUFkLENBQVo7QUFDQSxzQkFBVSxNQUFNLENBQU4sQ0FBVjtBQUNBLHVCQUFXLFNBQVMsTUFBTSxDQUFOLENBQVQsRUFBbUIsRUFBbkIsQ0FBWDtBQUNIO0FBQ0QsWUFBSSxXQUFXLEVBQWY7QUFDQSxlQUFPLG9CQUFvQixRQUFRLE1BQVIsQ0FBZSxRQUFRLE1BQVIsR0FBaUIsQ0FBaEMsQ0FBcEIsQ0FBUCxFQUFnRTtBQUM1RCxxQkFBUyxRQUFRLE1BQVIsQ0FBZSxRQUFRLE1BQVIsR0FBaUIsQ0FBaEMsQ0FBVCxJQUErQyxJQUEvQztBQUNBLHNCQUFVLFFBQVEsU0FBUixDQUFrQixDQUFsQixFQUFxQixRQUFRLE1BQVIsR0FBaUIsQ0FBdEMsQ0FBVjtBQUNIO0FBQ0QsWUFBSSxVQUFVO0FBQ1Ysc0JBQVUsUUFEQTtBQUVWLGtCQUFNLE9BRkk7QUFHVixzQkFBVTtBQUhBLFNBQWQ7QUFLQSxpQkFBUyxJQUFULENBQWMsT0FBZDtBQUNBLG1CQUFXLE9BQVgsSUFBc0IsT0FBdEI7QUFDQSxpQkFBUyxJQUFULENBQWMsT0FBZDtBQUNIO0FBQ0QsUUFBSSxjQUFjLFNBQWQsV0FBYyxDQUFVLGFBQVYsRUFBeUI7QUFDdkMsWUFBSSxTQUFTLEVBQWI7QUFDQSxZQUFJLGFBQWEsQ0FBakI7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksU0FBUyxNQUE3QixFQUFxQyxHQUFyQyxFQUEwQztBQUN0QyxnQkFBSSxVQUFVLFNBQVMsQ0FBVCxDQUFkO0FBQ0EsZ0JBQUksUUFBUSxjQUFjLFFBQVEsSUFBdEIsQ0FBWjtBQUNBLGdCQUFJLFVBQVUsSUFBVixJQUFrQixVQUFVLFNBQTVCLElBQTBDLE1BQU0sT0FBTixDQUFjLEtBQWQsS0FBd0IsTUFBTSxNQUFOLEtBQWlCLENBQW5GLElBQTBGLFFBQU8sS0FBUCx1REFBTyxLQUFQLE9BQWlCLFFBQWpCLElBQTZCLG9CQUFZLEtBQVosRUFBbUIsTUFBbkIsS0FBOEIsQ0FBekosRUFBNko7QUFDeko7QUFDQTtBQUNIO0FBQ0QsZ0JBQUksTUFBTSxVQUFWLEVBQXNCO0FBQ2xCLDBCQUFVLE1BQVY7QUFDSCxhQUZELE1BRU87QUFDSCwwQkFBVyxhQUFhLEdBQXhCO0FBQ0g7QUFDRCxnQkFBSSxNQUFNLE9BQU4sQ0FBYyxLQUFkLENBQUosRUFBMEI7QUFDdEIsb0JBQUksYUFBSixFQUFtQjtBQUNmLDhCQUFVLFFBQVEsSUFBUixHQUFlLEdBQXpCO0FBQ0g7QUFDRCxxQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE1BQU0sTUFBMUIsRUFBa0MsR0FBbEMsRUFBdUM7QUFDbkMsd0JBQUksSUFBSSxDQUFSLEVBQVc7QUFDUCxrQ0FBVSxRQUFRLFFBQVIsQ0FBaUIsR0FBakIsSUFBeUIsYUFBYSxHQUF0QyxHQUE2QyxHQUF2RDtBQUNBLDRCQUFJLFFBQVEsUUFBUixDQUFpQixHQUFqQixLQUF5QixhQUE3QixFQUE0QztBQUN4QyxzQ0FBVSxRQUFRLElBQVIsR0FBZSxHQUF6QjtBQUNIO0FBQ0o7QUFDRCw4QkFBVSxlQUFlLG1CQUFtQixNQUFNLENBQU4sQ0FBbkIsRUFBNkIsT0FBN0IsQ0FBcUMsSUFBckMsRUFBMkMsS0FBM0MsQ0FBZixHQUFtRSx1QkFBdUIsTUFBTSxDQUFOLENBQXZCLENBQTdFO0FBQ0g7QUFDSixhQWJELE1BYU8sSUFBSSxRQUFPLEtBQVAsdURBQU8sS0FBUCxPQUFpQixRQUFyQixFQUErQjtBQUNsQyxvQkFBSSxpQkFBaUIsQ0FBQyxRQUFRLFFBQVIsQ0FBaUIsR0FBakIsQ0FBdEIsRUFBNkM7QUFDekMsOEJBQVUsUUFBUSxJQUFSLEdBQWUsR0FBekI7QUFDSDtBQUNELG9CQUFJLFFBQVEsSUFBWjtBQUNBLHFCQUFLLElBQUksR0FBVCxJQUFnQixLQUFoQixFQUF1QjtBQUNuQix3QkFBSSxDQUFDLEtBQUwsRUFBWTtBQUNSLGtDQUFVLFFBQVEsUUFBUixDQUFpQixHQUFqQixJQUF5QixhQUFhLEdBQXRDLEdBQTZDLEdBQXZEO0FBQ0g7QUFDRCw0QkFBUSxLQUFSO0FBQ0EsOEJBQVUsZUFBZSxtQkFBbUIsR0FBbkIsRUFBd0IsT0FBeEIsQ0FBZ0MsSUFBaEMsRUFBc0MsS0FBdEMsQ0FBZixHQUE4RCx1QkFBdUIsR0FBdkIsQ0FBeEU7QUFDQSw4QkFBVSxRQUFRLFFBQVIsQ0FBaUIsR0FBakIsSUFBd0IsR0FBeEIsR0FBOEIsR0FBeEM7QUFDQSw4QkFBVSxlQUFlLG1CQUFtQixNQUFNLEdBQU4sQ0FBbkIsRUFBK0IsT0FBL0IsQ0FBdUMsSUFBdkMsRUFBNkMsS0FBN0MsQ0FBZixHQUFxRSx1QkFBdUIsTUFBTSxHQUFOLENBQXZCLENBQS9FO0FBQ0g7QUFDSixhQWRNLE1BY0E7QUFDSCxvQkFBSSxhQUFKLEVBQW1CO0FBQ2YsOEJBQVUsUUFBUSxJQUFsQjtBQUNBLHdCQUFJLENBQUMsZUFBRCxJQUFvQixVQUFVLEVBQWxDLEVBQXNDO0FBQ2xDLGtDQUFVLEdBQVY7QUFDSDtBQUNKO0FBQ0Qsb0JBQUksUUFBUSxRQUFSLElBQW9CLElBQXhCLEVBQThCO0FBQzFCLDRCQUFRLE1BQU0sU0FBTixDQUFnQixDQUFoQixFQUFtQixRQUFRLFFBQTNCLENBQVI7QUFDSDtBQUNELDBCQUFVLGVBQWUsbUJBQW1CLEtBQW5CLEVBQTBCLE9BQTFCLENBQWtDLElBQWxDLEVBQXdDLEtBQXhDLENBQWYsR0FBZ0UsdUJBQXVCLEtBQXZCLENBQTFFO0FBQ0g7QUFDSjtBQUNELGVBQU8sTUFBUDtBQUNILEtBeEREO0FBeURBLGdCQUFZLFFBQVosR0FBdUIsUUFBdkI7QUFDQSxXQUFPO0FBQ0gsZ0JBQVEsTUFETDtBQUVILHNCQUFjO0FBRlgsS0FBUDtBQUlIOztBQUVELFNBQVMsV0FBVCxDQUFxQixRQUFyQixFQUErQjtBQUMzQixRQUFJLEVBQUUsZ0JBQWdCLFdBQWxCLENBQUosRUFBb0M7QUFDaEMsZUFBTyxJQUFJLFdBQUosQ0FBZ0IsUUFBaEIsQ0FBUDtBQUNIO0FBQ0QsUUFBSSxRQUFRLFNBQVMsS0FBVCxDQUFlLEdBQWYsQ0FBWjtBQUNBLFFBQUksWUFBWSxDQUFDLE1BQU0sS0FBTixFQUFELENBQWhCO0FBQ0EsUUFBSSxXQUFXLEVBQWY7QUFDQSxRQUFJLGdCQUFnQixFQUFwQjtBQUNBLFFBQUksV0FBVyxFQUFmO0FBQ0EsV0FBTyxNQUFNLE1BQU4sR0FBZSxDQUF0QixFQUF5QjtBQUNyQixZQUFJLE9BQU8sTUFBTSxLQUFOLEVBQVg7QUFDQSxZQUFJLE9BQU8sS0FBSyxLQUFMLENBQVcsR0FBWCxFQUFnQixDQUFoQixDQUFYO0FBQ0EsWUFBSSxZQUFZLEtBQUssU0FBTCxDQUFlLEtBQUssTUFBTCxHQUFjLENBQTdCLENBQWhCO0FBQ0EsWUFBSSxRQUFRLHdCQUF3QixJQUF4QixDQUFaO0FBQ0Esc0JBQWMsSUFBZCxDQUFtQixNQUFNLFlBQXpCO0FBQ0EsaUJBQVMsSUFBVCxDQUFjLE1BQU0sTUFBcEI7QUFDQSxrQkFBVSxJQUFWLENBQWUsU0FBZjtBQUNBLG1CQUFXLFNBQVMsTUFBVCxDQUFnQixNQUFNLFlBQU4sQ0FBbUIsUUFBbkMsQ0FBWDtBQUNIO0FBQ0QsU0FBSyxJQUFMLEdBQVksVUFBVSxhQUFWLEVBQXlCO0FBQ2pDLFlBQUksU0FBUyxVQUFVLENBQVYsQ0FBYjtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxjQUFjLE1BQWxDLEVBQTBDLEdBQTFDLEVBQStDO0FBQzNDLGdCQUFJLGVBQWUsY0FBYyxDQUFkLENBQW5CO0FBQ0Esc0JBQVUsYUFBYSxhQUFiLENBQVY7QUFDQSxzQkFBVSxVQUFVLElBQUksQ0FBZCxDQUFWO0FBQ0g7QUFDRCxlQUFPLE1BQVA7QUFDSCxLQVJEO0FBU0EsU0FBSyxRQUFMLEdBQWdCLFFBQWhCO0FBQ0EsU0FBSyxRQUFMLEdBQWdCLFFBQWhCO0FBQ0g7O0FBRUQsWUFBWSxTQUFaLEdBQXdCO0FBQ3BCLGNBQVUsb0JBQVk7QUFDbEIsZUFBTyxLQUFLLFFBQVo7QUFDSCxLQUhtQjtBQUlwQixvQkFBZ0Isd0JBQVUsR0FBVixFQUFlO0FBQzNCLGVBQU8sS0FBSyxJQUFMLENBQVUsVUFBVSxPQUFWLEVBQW1CO0FBQ2hDLG1CQUFPLElBQUksT0FBSixDQUFQO0FBQ0gsU0FGTSxDQUFQO0FBR0g7QUFSbUIsQ0FBeEI7QUFVQSxJQUFJLG1CQUFtQixTQUFTLGdCQUFULENBQTBCLE1BQTFCLEVBQWtDLGVBQWxDLEVBQW1ELGFBQW5ELEVBQWtFLGNBQWxFLEVBQWtGLHNCQUFsRixFQUEwRztBQUM3SCxTQUFLLE9BQUwsR0FBZSxFQUFmO0FBQ0EsU0FBSyxVQUFMLEdBQWtCLEVBQWxCO0FBQ0EsU0FBSyxnQkFBTCxHQUF3QixTQUFTLHNCQUFjLE9BQU8sZ0JBQXJCLENBQVQsR0FBa0QsRUFBMUU7QUFDQSxTQUFLLE9BQUwsR0FBZSxTQUFTLHNCQUFjLE9BQU8sT0FBckIsQ0FBVCxHQUF5QyxFQUF4RDtBQUNBLFNBQUssZUFBTCxHQUF1QixlQUF2QjtBQUNBLFNBQUssTUFBTCxHQUFjLEVBQWQ7QUFDQSxTQUFLLFdBQUwsR0FBbUIsa0JBQWtCLEtBQUssWUFBdkIsR0FBc0MsS0FBSyxXQUE5RDtBQUNBLFFBQUksY0FBSixFQUFvQjtBQUNoQixhQUFLLGNBQUwsR0FBc0IsSUFBdEI7QUFDQSxhQUFLLE9BQUwsR0FBZSxFQUFmO0FBQ0EsYUFBSyxhQUFMLEdBQXFCLEVBQXJCO0FBQ0EsYUFBSyxvQkFBTCxHQUE0QixFQUE1QjtBQUNBLGFBQUssNkJBQUwsR0FBcUMsRUFBckM7QUFDQSxhQUFLLG1CQUFMLEdBQTJCLG1CQUEzQjtBQUNBLGFBQUssbUJBQUwsR0FBMkIsMEJBQTNCO0FBQ0g7QUFDRCxRQUFJLHNCQUFKLEVBQTRCO0FBQ3hCLGFBQUssc0JBQUwsR0FBOEIsSUFBOUI7QUFDQSxhQUFLLGtCQUFMLEdBQTBCLEVBQTFCO0FBQ0EsYUFBSyxvQkFBTCxHQUE0QixFQUE1QjtBQUNIO0FBQ0QsU0FBSyxhQUFMLEdBQXFCLGlCQUFpQixxQkFBcUIsSUFBckIsQ0FBdEM7QUFDQSxRQUFJLE9BQU8sS0FBSyxhQUFaLEtBQThCLFFBQWxDLEVBQTRDO0FBQ3hDLGNBQU0sSUFBSSxLQUFKLENBQVUsT0FBVixDQUFOO0FBQ0g7QUFDRCxTQUFLLGVBQUwsR0FBdUIsRUFBdkI7QUFDQSxRQUFJLE1BQUosRUFBWTtBQUNSLGFBQUssSUFBSSxHQUFULElBQWdCLE9BQU8sZUFBdkIsRUFBd0M7QUFDcEMsaUJBQUssZUFBTCxDQUFxQixHQUFyQixJQUE0QixPQUFPLGVBQVAsQ0FBdUIsR0FBdkIsRUFBNEIsS0FBNUIsQ0FBa0MsQ0FBbEMsQ0FBNUI7QUFDSDtBQUNKO0FBQ0osQ0FoQ0Q7QUFpQ0EsaUJBQWlCLFNBQWpCLENBQTJCLGFBQTNCLEdBQTJDLFVBQVUsT0FBVixFQUFtQixlQUFuQixFQUFvQztBQUMzRSxTQUFLLGVBQUwsQ0FBcUIsT0FBckIsSUFBZ0MsS0FBSyxlQUFMLENBQXFCLE9BQXJCLEtBQWlDLEVBQWpFO0FBQ0EsU0FBSyxlQUFMLENBQXFCLE9BQXJCLEVBQThCLElBQTlCLENBQW1DLGVBQW5DO0FBQ0gsQ0FIRDtBQUlBLGlCQUFpQixTQUFqQixDQUEyQixXQUEzQixHQUF5QyxVQUFVLElBQVYsRUFBZ0IsYUFBaEIsRUFBK0IsUUFBL0IsRUFBeUMsVUFBekMsRUFBcUQsU0FBckQsRUFBZ0UsSUFBaEUsRUFBc0UsTUFBdEUsRUFBOEU7QUFDbkgsUUFBSSxRQUFRLElBQUksZUFBSixDQUFvQixJQUFwQixFQUEwQixhQUExQixFQUF5QyxRQUF6QyxFQUFtRCxVQUFuRCxFQUErRCxTQUEvRCxDQUFaO0FBQ0EsVUFBTSxPQUFOLEdBQWdCLEtBQUssYUFBTCxDQUFtQixLQUFuQixFQUEwQixJQUExQixFQUFnQyxNQUFoQyxDQUFoQjtBQUNBLFdBQU8sS0FBUDtBQUNILENBSkQ7QUFLQSxpQkFBaUIsU0FBakIsQ0FBMkIsV0FBM0IsR0FBeUMsVUFBVSxLQUFWLEVBQWlCO0FBQ3RELFdBQU8sS0FBUDtBQUNILENBRkQ7QUFHQSxpQkFBaUIsU0FBakIsQ0FBMkIsWUFBM0IsR0FBMEMsVUFBVSxLQUFWLEVBQWlCO0FBQ3ZELFFBQUksS0FBSixFQUFXO0FBQ1AsYUFBSyxNQUFMLENBQVksSUFBWixDQUFpQixLQUFqQjtBQUNIO0FBQ0QsV0FBTyxJQUFQO0FBQ0gsQ0FMRDtBQU1BLGlCQUFpQixTQUFqQixDQUEyQixZQUEzQixHQUEwQyxVQUFVLFVBQVYsRUFBc0IsUUFBdEIsRUFBZ0MsVUFBaEMsRUFBNEM7QUFDbEYsU0FBSyxJQUFJLElBQUksVUFBYixFQUF5QixJQUFJLEtBQUssTUFBTCxDQUFZLE1BQXpDLEVBQWlELEdBQWpELEVBQXNEO0FBQ2xELGFBQUssTUFBTCxDQUFZLENBQVosSUFBaUIsS0FBSyxNQUFMLENBQVksQ0FBWixFQUFlLFVBQWYsQ0FBMEIsUUFBMUIsRUFBb0MsVUFBcEMsQ0FBakI7QUFDSDtBQUNELFdBQU8sSUFBUDtBQUNILENBTEQ7QUFNQSxpQkFBaUIsU0FBakIsQ0FBMkIsb0JBQTNCLEdBQWtELFVBQVUsSUFBVixFQUFnQixNQUFoQixFQUF3QjtBQUN0RSxTQUFLLElBQUksV0FBVCxJQUF3QixLQUFLLG9CQUE3QixFQUFtRDtBQUMvQyxZQUFJLFFBQVEsS0FBSyxXQUFMLENBQWlCLFdBQVcsZ0JBQTVCLEVBQThDLEVBQUMsTUFBTSxXQUFQLEVBQTlDLEVBQW1FLFdBQW5FLEVBQWdGLEVBQWhGLEVBQW9GLElBQXBGLEVBQTBGLElBQTFGLEVBQWdHLE1BQWhHLENBQVo7QUFDQSxZQUFJLFNBQVMsS0FBSyxXQUFMLENBQWlCLEtBQWpCLENBQWI7QUFDQSxZQUFJLE1BQUosRUFBWTtBQUNSLG1CQUFPLE1BQVA7QUFDSDtBQUNKO0FBQ0QsV0FBTyxJQUFQO0FBQ0gsQ0FURDs7QUFXQSxpQkFBaUIsU0FBakIsQ0FBMkIsU0FBM0IsR0FBdUMsVUFBVSxNQUFWLEVBQWtCLFNBQWxCLEVBQTZCO0FBQ2hFLFFBQUksUUFBTyxNQUFQLHVEQUFPLE1BQVAsT0FBa0IsUUFBdEIsRUFBZ0M7QUFDNUIsYUFBSyxJQUFJLEdBQVQsSUFBZ0IsTUFBaEIsRUFBd0I7QUFDcEIsaUJBQUssU0FBTCxDQUFlLEdBQWYsRUFBb0IsT0FBTyxHQUFQLENBQXBCO0FBQ0g7QUFDRCxlQUFPLElBQVA7QUFDSDtBQUNELFNBQUssZ0JBQUwsQ0FBc0IsTUFBdEIsSUFBZ0MsU0FBaEM7QUFDSCxDQVJEO0FBU0EsaUJBQWlCLFNBQWpCLENBQTJCLFdBQTNCLEdBQXlDLFVBQVUsTUFBVixFQUFrQixVQUFsQixFQUE4QjtBQUNuRSxRQUFJLE9BQU8sTUFBUCxNQUFtQixTQUF2QixFQUFrQztBQUM5QixxQkFBYSxjQUFjLEVBQTNCO0FBQ0EsWUFBSSxXQUFXLE9BQU8sTUFBUCxDQUFYLENBQUosRUFBZ0M7QUFDNUIsbUJBQU8sS0FBSyxXQUFMLENBQWlCLFdBQVcsa0JBQTVCLEVBQWdELEVBQUMsTUFBTSxvQkFBWSxVQUFaLEVBQXdCLElBQXhCLENBQTZCLElBQTdCLENBQVAsRUFBaEQsRUFBNEYsRUFBNUYsRUFBZ0csRUFBaEcsRUFBb0csSUFBcEcsRUFBMEcsU0FBMUcsRUFBcUgsTUFBckgsQ0FBUDtBQUNIO0FBQ0QsbUJBQVcsT0FBTyxNQUFQLENBQVgsSUFBNkIsSUFBN0I7QUFDQSxpQkFBUyxLQUFLLFNBQUwsQ0FBZSxPQUFPLE1BQVAsQ0FBZixFQUErQixVQUEvQixDQUFUO0FBQ0g7QUFDRCxXQUFPLE1BQVA7QUFDSCxDQVZEO0FBV0EsaUJBQWlCLFNBQWpCLENBQTJCLFNBQTNCLEdBQXVDLFVBQVUsR0FBVixFQUFlLFVBQWYsRUFBMkI7QUFDOUQsUUFBSSxNQUFKO0FBQ0EsUUFBSSxLQUFLLE9BQUwsQ0FBYSxHQUFiLE1BQXNCLFNBQTFCLEVBQXFDO0FBQ2pDLGlCQUFTLEtBQUssT0FBTCxDQUFhLEdBQWIsQ0FBVDtBQUNBLGVBQU8sS0FBSyxXQUFMLENBQWlCLE1BQWpCLEVBQXlCLFVBQXpCLENBQVA7QUFDSDtBQUNELFFBQUksVUFBVSxHQUFkO0FBQ0EsUUFBSSxXQUFXLEVBQWY7QUFDQSxRQUFJLElBQUksT0FBSixDQUFZLEdBQVosTUFBcUIsQ0FBQyxDQUExQixFQUE2QjtBQUN6QixtQkFBVyxJQUFJLFNBQUosQ0FBYyxJQUFJLE9BQUosQ0FBWSxHQUFaLElBQW1CLENBQWpDLENBQVg7QUFDQSxrQkFBVSxJQUFJLFNBQUosQ0FBYyxDQUFkLEVBQWlCLElBQUksT0FBSixDQUFZLEdBQVosQ0FBakIsQ0FBVjtBQUNIO0FBQ0QsUUFBSSxzQkFBTyxLQUFLLE9BQUwsQ0FBYSxPQUFiLENBQVAsTUFBaUMsUUFBckMsRUFBK0M7QUFDM0MsaUJBQVMsS0FBSyxPQUFMLENBQWEsT0FBYixDQUFUO0FBQ0EsWUFBSSxjQUFjLG1CQUFtQixRQUFuQixDQUFsQjtBQUNBLFlBQUksZ0JBQWdCLEVBQXBCLEVBQXdCO0FBQ3BCLG1CQUFPLEtBQUssV0FBTCxDQUFpQixNQUFqQixFQUF5QixVQUF6QixDQUFQO0FBQ0gsU0FGRCxNQUVPLElBQUksWUFBWSxNQUFaLENBQW1CLENBQW5CLE1BQTBCLEdBQTlCLEVBQW1DO0FBQ3RDLG1CQUFPLFNBQVA7QUFDSDtBQUNELFlBQUksUUFBUSxZQUFZLEtBQVosQ0FBa0IsR0FBbEIsRUFBdUIsS0FBdkIsQ0FBNkIsQ0FBN0IsQ0FBWjtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxNQUFNLE1BQTFCLEVBQWtDLEdBQWxDLEVBQXVDO0FBQ25DLGdCQUFJLFlBQVksTUFBTSxDQUFOLEVBQVMsT0FBVCxDQUFpQixLQUFqQixFQUF3QixHQUF4QixFQUE2QixPQUE3QixDQUFxQyxLQUFyQyxFQUE0QyxHQUE1QyxDQUFoQjtBQUNBLGdCQUFJLE9BQU8sU0FBUCxNQUFzQixTQUExQixFQUFxQztBQUNqQyx5QkFBUyxTQUFUO0FBQ0E7QUFDSDtBQUNELHFCQUFTLE9BQU8sU0FBUCxDQUFUO0FBQ0g7QUFDRCxZQUFJLFdBQVcsU0FBZixFQUEwQjtBQUN0QixtQkFBTyxLQUFLLFdBQUwsQ0FBaUIsTUFBakIsRUFBeUIsVUFBekIsQ0FBUDtBQUNIO0FBQ0o7QUFDRCxRQUFJLEtBQUssT0FBTCxDQUFhLE9BQWIsTUFBMEIsU0FBOUIsRUFBeUM7QUFDckMsYUFBSyxPQUFMLENBQWEsSUFBYixDQUFrQixPQUFsQjtBQUNBLGFBQUssT0FBTCxDQUFhLE9BQWIsSUFBd0IsT0FBeEI7QUFDQSxhQUFLLFVBQUwsQ0FBZ0IsT0FBaEIsSUFBMkIsT0FBM0I7QUFDSDtBQUNKLENBdENEO0FBdUNBLGlCQUFpQixTQUFqQixDQUEyQixhQUEzQixHQUEyQyxVQUFVLE1BQVYsRUFBa0IsR0FBbEIsRUFBdUI7QUFDOUQsUUFBSSxNQUFNLE9BQU4sQ0FBYyxNQUFkLENBQUosRUFBMkI7QUFDdkIsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE9BQU8sTUFBM0IsRUFBbUMsR0FBbkMsRUFBd0M7QUFDcEMsaUJBQUssYUFBTCxDQUFtQixPQUFPLENBQVAsQ0FBbkIsRUFBOEIsR0FBOUI7QUFDSDtBQUNKLEtBSkQsTUFJTyxJQUFJLFVBQVUsUUFBTyxNQUFQLHVEQUFPLE1BQVAsT0FBa0IsUUFBaEMsRUFBMEM7QUFDN0MsWUFBSSxPQUFPLE9BQU8sRUFBZCxLQUFxQixRQUF6QixFQUFtQztBQUMvQixnQkFBSSxhQUFhLEdBQWIsRUFBa0IsT0FBTyxFQUF6QixDQUFKLEVBQWtDO0FBQzlCLG9CQUFJLEtBQUssT0FBTCxDQUFhLE9BQU8sRUFBcEIsTUFBNEIsU0FBaEMsRUFBMkM7QUFDdkMseUJBQUssT0FBTCxDQUFhLE9BQU8sRUFBcEIsSUFBMEIsTUFBMUI7QUFDSDtBQUNKO0FBQ0o7QUFDRCxhQUFLLElBQUksR0FBVCxJQUFnQixNQUFoQixFQUF3QjtBQUNwQixnQkFBSSxRQUFRLE1BQVosRUFBb0I7QUFDaEIsb0JBQUksc0JBQU8sT0FBTyxHQUFQLENBQVAsTUFBdUIsUUFBM0IsRUFBcUM7QUFDakMseUJBQUssYUFBTCxDQUFtQixPQUFPLEdBQVAsQ0FBbkIsRUFBZ0MsR0FBaEM7QUFDSCxpQkFGRCxNQUVPLElBQUksUUFBUSxNQUFaLEVBQW9CO0FBQ3ZCLHdCQUFJLE1BQU0sZUFBZSxPQUFPLEdBQVAsQ0FBZixDQUFWO0FBQ0Esd0JBQUksT0FBTyxLQUFLLE9BQUwsQ0FBYSxHQUFiLE1BQXNCLFNBQTdCLElBQTBDLEtBQUssVUFBTCxDQUFnQixHQUFoQixNQUF5QixTQUF2RSxFQUFrRjtBQUM5RSw2QkFBSyxVQUFMLENBQWdCLEdBQWhCLElBQXVCLEdBQXZCO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7QUFDSjtBQUNKLENBMUJEO0FBMkJBLGlCQUFpQixTQUFqQixDQUEyQixTQUEzQixHQUF1QyxVQUFVLEdBQVYsRUFBZSxNQUFmLEVBQXVCO0FBQzFEO0FBQ0EsUUFBSSxPQUFPLEdBQVAsS0FBZSxRQUFmLElBQTJCLE9BQU8sTUFBUCxLQUFrQixXQUFqRCxFQUE4RDtBQUMxRCxZQUFJLFFBQU8sR0FBUCx1REFBTyxHQUFQLE9BQWUsUUFBZixJQUEyQixPQUFPLElBQUksRUFBWCxLQUFrQixRQUFqRCxFQUEyRDtBQUN2RCxxQkFBUyxHQUFUO0FBQ0Esa0JBQU0sT0FBTyxFQUFiO0FBQ0gsU0FIRCxNQUlLO0FBQ0Q7QUFDSDtBQUNKO0FBQ0QsUUFBSSxRQUFRLGVBQWUsR0FBZixJQUFzQixHQUFsQyxFQUF1QztBQUNuQztBQUNBLGNBQU0sZUFBZSxHQUFmLENBQU47QUFDSDtBQUNELFNBQUssT0FBTCxDQUFhLEdBQWIsSUFBb0IsTUFBcEI7QUFDQSxXQUFPLEtBQUssVUFBTCxDQUFnQixHQUFoQixDQUFQO0FBQ0EsZUFBVyxNQUFYLEVBQW1CLEdBQW5CO0FBQ0EsU0FBSyxhQUFMLENBQW1CLE1BQW5CLEVBQTJCLEdBQTNCO0FBQ0gsQ0FuQkQ7O0FBcUJBLGlCQUFpQixTQUFqQixDQUEyQixZQUEzQixHQUEwQyxZQUFZO0FBQ2xELFFBQUksTUFBTSxFQUFWO0FBQ0EsU0FBSyxJQUFJLEdBQVQsSUFBZ0IsS0FBSyxPQUFyQixFQUE4QjtBQUMxQixZQUFJLEdBQUosSUFBVyxLQUFLLE9BQUwsQ0FBYSxHQUFiLENBQVg7QUFDSDtBQUNELFdBQU8sR0FBUDtBQUNILENBTkQ7O0FBUUEsaUJBQWlCLFNBQWpCLENBQTJCLGFBQTNCLEdBQTJDLFVBQVUsWUFBVixFQUF3QjtBQUMvRCxRQUFJLE9BQU8sRUFBWDtBQUNBLFNBQUssSUFBSSxHQUFULElBQWdCLEtBQUssT0FBckIsRUFBOEI7QUFDMUIsWUFBSSxDQUFDLFlBQUQsSUFBaUIsYUFBYSxJQUFiLENBQWtCLEdBQWxCLENBQXJCLEVBQTZDO0FBQ3pDLGlCQUFLLElBQUwsQ0FBVSxHQUFWO0FBQ0g7QUFDSjtBQUNELFdBQU8sSUFBUDtBQUNILENBUkQ7O0FBVUEsaUJBQWlCLFNBQWpCLENBQTJCLGNBQTNCLEdBQTRDLFVBQVUsWUFBVixFQUF3QjtBQUNoRSxRQUFJLE9BQU8sRUFBWDtBQUNBLFNBQUssSUFBSSxHQUFULElBQWdCLEtBQUssVUFBckIsRUFBaUM7QUFDN0IsWUFBSSxDQUFDLFlBQUQsSUFBaUIsYUFBYSxJQUFiLENBQWtCLEdBQWxCLENBQXJCLEVBQTZDO0FBQ3pDLGlCQUFLLElBQUwsQ0FBVSxHQUFWO0FBQ0g7QUFDSjtBQUNELFdBQU8sSUFBUDtBQUNILENBUkQ7O0FBVUEsaUJBQWlCLFNBQWpCLENBQTJCLFdBQTNCLEdBQXlDLFlBQVk7QUFDakQsU0FBSyxPQUFMLEdBQWUsRUFBZjtBQUNBLFNBQUssS0FBTDtBQUNILENBSEQ7QUFJQSxpQkFBaUIsU0FBakIsQ0FBMkIsS0FBM0IsR0FBbUMsWUFBWTtBQUMzQyxTQUFLLE9BQUwsR0FBZSxFQUFmO0FBQ0EsU0FBSyxVQUFMLEdBQWtCLEVBQWxCO0FBQ0EsU0FBSyxNQUFMLEdBQWMsRUFBZDtBQUNILENBSkQ7O0FBTUEsaUJBQWlCLFNBQWpCLENBQTJCLFdBQTNCLEdBQXlDLFVBQVUsSUFBVixFQUFnQixNQUFoQixFQUF3QixhQUF4QixFQUF1QyxlQUF2QyxFQUF3RCxlQUF4RCxFQUF5RTtBQUM5RyxRQUFJLFFBQUo7QUFDQSxhQUFTLEtBQUssV0FBTCxDQUFpQixNQUFqQixDQUFUO0FBQ0EsUUFBSSxDQUFDLE1BQUwsRUFBYTtBQUNULGVBQU8sSUFBUDtBQUNILEtBRkQsTUFFTyxJQUFJLGtCQUFrQixlQUF0QixFQUF1QztBQUMxQyxhQUFLLE1BQUwsQ0FBWSxJQUFaLENBQWlCLE1BQWpCO0FBQ0EsZUFBTyxNQUFQO0FBQ0g7O0FBRUQsUUFBSSxrQkFBa0IsS0FBSyxNQUFMLENBQVksTUFBbEM7QUFDQSxRQUFJLFdBQUo7QUFBQSxRQUFpQiwyQkFBMkIsSUFBNUM7QUFBQSxRQUFrRCxzQkFBc0IsSUFBeEU7QUFDQSxRQUFJLEtBQUssY0FBTCxJQUF1QixJQUF2QixJQUErQixRQUFPLElBQVAsdURBQU8sSUFBUCxPQUFnQixRQUFuRCxFQUE2RDtBQUN6RCxtQkFBVyxDQUFDLEtBQUssT0FBTCxDQUFhLE1BQXpCO0FBQ0EsWUFBSSxLQUFLLEtBQUssbUJBQVYsQ0FBSixFQUFvQztBQUNoQyxnQkFBSSxjQUFjLEtBQUssS0FBSyxtQkFBVixFQUErQixPQUEvQixDQUF1QyxNQUF2QyxDQUFsQjtBQUNBLGdCQUFJLGdCQUFnQixDQUFDLENBQXJCLEVBQXdCO0FBQ3BCLHFCQUFLLE1BQUwsR0FBYyxLQUFLLE1BQUwsQ0FBWSxNQUFaLENBQW1CLEtBQUssS0FBSyxtQkFBVixFQUErQixXQUEvQixDQUFuQixDQUFkO0FBQ0EsdUJBQU8sSUFBUDtBQUNIO0FBQ0o7QUFDRCxZQUFJLHdCQUFnQixJQUFoQixDQUFKLEVBQTJCO0FBQ3ZCLDBCQUFjLEtBQUssYUFBTCxDQUFtQixPQUFuQixDQUEyQixJQUEzQixDQUFkO0FBQ0EsZ0JBQUksZ0JBQWdCLENBQUMsQ0FBckIsRUFBd0I7QUFDcEIsb0JBQUksb0JBQW9CLEtBQUssb0JBQUwsQ0FBMEIsV0FBMUIsRUFBdUMsT0FBdkMsQ0FBK0MsTUFBL0MsQ0FBeEI7QUFDQSxvQkFBSSxzQkFBc0IsQ0FBQyxDQUEzQixFQUE4QjtBQUMxQix5QkFBSyxNQUFMLEdBQWMsS0FBSyxNQUFMLENBQVksTUFBWixDQUFtQixLQUFLLDZCQUFMLENBQW1DLFdBQW5DLEVBQWdELGlCQUFoRCxDQUFuQixDQUFkO0FBQ0EsMkJBQU8sSUFBUDtBQUNIO0FBQ0o7QUFDSjtBQUNELGFBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0IsSUFBbEI7QUFDQSxZQUFJLHdCQUFnQixJQUFoQixDQUFKLEVBQTJCO0FBQ3ZCLGdCQUFJLGdCQUFnQixDQUFDLENBQXJCLEVBQXdCO0FBQ3BCLDhCQUFjLEtBQUssYUFBTCxDQUFtQixNQUFqQztBQUNBLHFCQUFLLGFBQUwsQ0FBbUIsSUFBbkIsQ0FBd0IsSUFBeEI7QUFDQSxxQkFBSyxvQkFBTCxDQUEwQixJQUExQixDQUErQixFQUEvQjtBQUNIO0FBQ0QsdUNBQTJCLEtBQUssb0JBQUwsQ0FBMEIsV0FBMUIsRUFBdUMsTUFBbEU7QUFDQSxpQkFBSyxvQkFBTCxDQUEwQixXQUExQixFQUF1Qyx3QkFBdkMsSUFBbUUsTUFBbkU7QUFDQSxpQkFBSyw2QkFBTCxDQUFtQyxXQUFuQyxFQUFnRCx3QkFBaEQsSUFBNEUsRUFBNUU7QUFDSCxTQVRELE1BU087QUFDSCxnQkFBSSxDQUFDLEtBQUssS0FBSyxtQkFBVixDQUFMLEVBQXFDO0FBQ2pDLG9CQUFJO0FBQ0Esa0RBQXNCLElBQXRCLEVBQTRCLEtBQUssbUJBQWpDLEVBQXNEO0FBQ2xELCtCQUFPLEVBRDJDO0FBRWxELHNDQUFjO0FBRm9DLHFCQUF0RDtBQUlBLGtEQUFzQixJQUF0QixFQUE0QixLQUFLLG1CQUFqQyxFQUFzRDtBQUNsRCwrQkFBTyxFQUQyQztBQUVsRCxzQ0FBYztBQUZvQyxxQkFBdEQ7QUFJSCxpQkFURCxDQVNFLE9BQU8sQ0FBUCxFQUFVO0FBQ1I7QUFDQSx5QkFBSyxLQUFLLG1CQUFWLElBQWlDLEVBQWpDO0FBQ0EseUJBQUssS0FBSyxtQkFBVixJQUFpQyxFQUFqQztBQUNIO0FBQ0o7QUFDRCxrQ0FBc0IsS0FBSyxLQUFLLG1CQUFWLEVBQStCLE1BQXJEO0FBQ0EsaUJBQUssS0FBSyxtQkFBVixFQUErQixtQkFBL0IsSUFBc0QsTUFBdEQ7QUFDQSxpQkFBSyxLQUFLLG1CQUFWLEVBQStCLG1CQUEvQixJQUFzRCxFQUF0RDtBQUNIO0FBQ0o7O0FBRUQsUUFBSSxhQUFhLEtBQUssTUFBTCxDQUFZLE1BQTdCO0FBQ0EsUUFBSSxRQUFRLEtBQUssYUFBTCxDQUFtQixJQUFuQixFQUF5QixNQUF6QixFQUFpQyxlQUFqQyxLQUNMLEtBQUssZUFBTCxDQUFxQixJQUFyQixFQUEyQixNQUEzQixFQUFtQyxlQUFuQyxDQURLLElBRUwsS0FBSyxjQUFMLENBQW9CLElBQXBCLEVBQTBCLE1BQTFCLEVBQWtDLGVBQWxDLENBRkssSUFHTCxLQUFLLGFBQUwsQ0FBbUIsSUFBbkIsRUFBeUIsTUFBekIsRUFBaUMsZUFBakMsQ0FISyxJQUlMLEtBQUssY0FBTCxDQUFvQixJQUFwQixFQUEwQixNQUExQixFQUFrQyxlQUFsQyxDQUpLLElBS0wsS0FBSyxvQkFBTCxDQUEwQixJQUExQixFQUFnQyxNQUFoQyxFQUF3QyxlQUF4QyxDQUxLLElBTUwsS0FBSyxrQkFBTCxDQUF3QixJQUF4QixFQUE4QixNQUE5QixFQUFzQyxlQUF0QyxDQU5LLElBT0wsS0FBSyxjQUFMLENBQW9CLElBQXBCLEVBQTBCLE1BQTFCLEVBQWtDLGVBQWxDLENBUEssSUFRTCxLQUFLLHVCQUFMLENBQTZCLElBQTdCLEVBQW1DLE1BQW5DLEVBQTJDLGVBQTNDLENBUkssSUFTTCxJQVRQOztBQVdBLFFBQUksUUFBSixFQUFjO0FBQ1YsZUFBTyxLQUFLLE9BQUwsQ0FBYSxNQUFwQixFQUE0QjtBQUN4QixnQkFBSSxPQUFPLEtBQUssT0FBTCxDQUFhLEdBQWIsRUFBWDtBQUNBLG1CQUFPLEtBQUssS0FBSyxtQkFBVixDQUFQO0FBQ0g7QUFDRCxhQUFLLGFBQUwsR0FBcUIsRUFBckI7QUFDQSxhQUFLLG9CQUFMLEdBQTRCLEVBQTVCO0FBQ0g7O0FBRUQsUUFBSSxTQUFTLGVBQWUsS0FBSyxNQUFMLENBQVksTUFBeEMsRUFBZ0Q7QUFDNUMsZUFBUSxpQkFBaUIsY0FBYyxNQUFoQyxJQUE0QyxtQkFBbUIsZ0JBQWdCLE1BQXRGLEVBQStGO0FBQzNGLGdCQUFJLFdBQVksaUJBQWlCLGNBQWMsTUFBaEMsR0FBMEMsS0FBSyxjQUFjLEdBQWQsRUFBL0MsR0FBcUUsSUFBcEY7QUFDQSxnQkFBSSxhQUFjLG1CQUFtQixnQkFBZ0IsTUFBcEMsR0FBOEMsS0FBSyxnQkFBZ0IsR0FBaEIsRUFBbkQsR0FBMkUsSUFBNUY7QUFDQSxnQkFBSSxLQUFKLEVBQVc7QUFDUCx3QkFBUSxNQUFNLFVBQU4sQ0FBaUIsUUFBakIsRUFBMkIsVUFBM0IsQ0FBUjtBQUNIO0FBQ0QsaUJBQUssWUFBTCxDQUFrQixVQUFsQixFQUE4QixRQUE5QixFQUF3QyxVQUF4QztBQUNIO0FBQ0o7O0FBRUQsUUFBSSw2QkFBNkIsSUFBakMsRUFBdUM7QUFDbkMsYUFBSyw2QkFBTCxDQUFtQyxXQUFuQyxFQUFnRCx3QkFBaEQsSUFBNEUsS0FBSyxNQUFMLENBQVksS0FBWixDQUFrQixlQUFsQixDQUE1RTtBQUNILEtBRkQsTUFFTyxJQUFJLHdCQUF3QixJQUE1QixFQUFrQztBQUNyQyxhQUFLLEtBQUssbUJBQVYsRUFBK0IsbUJBQS9CLElBQXNELEtBQUssTUFBTCxDQUFZLEtBQVosQ0FBa0IsZUFBbEIsQ0FBdEQ7QUFDSDs7QUFFRCxXQUFPLEtBQUssV0FBTCxDQUFpQixLQUFqQixDQUFQO0FBQ0gsQ0F2R0Q7QUF3R0EsaUJBQWlCLFNBQWpCLENBQTJCLGNBQTNCLEdBQTRDLFVBQVUsSUFBVixFQUFnQixNQUFoQixFQUF3QjtBQUNoRSxRQUFJLE9BQU8sT0FBTyxNQUFkLEtBQXlCLFFBQXpCLElBQXFDLENBQUMsS0FBSyxnQkFBTCxDQUFzQixPQUFPLE1BQTdCLENBQTFDLEVBQWdGO0FBQzVFLGVBQU8sSUFBUDtBQUNIO0FBQ0QsUUFBSSxlQUFlLEtBQUssZ0JBQUwsQ0FBc0IsT0FBTyxNQUE3QixFQUFxQyxJQUFyQyxDQUEwQyxJQUExQyxFQUFnRCxJQUFoRCxFQUFzRCxNQUF0RCxDQUFuQjtBQUNBLFFBQUksT0FBTyxZQUFQLEtBQXdCLFFBQXhCLElBQW9DLE9BQU8sWUFBUCxLQUF3QixRQUFoRSxFQUEwRTtBQUN0RSxlQUFPLEtBQUssV0FBTCxDQUFpQixXQUFXLGFBQTVCLEVBQTJDLEVBQUMsU0FBUyxZQUFWLEVBQTNDLEVBQW9FLEVBQXBFLEVBQXdFLFNBQXhFLEVBQW1GLElBQW5GLEVBQXlGLElBQXpGLEVBQStGLE1BQS9GLENBQVA7QUFDSCxLQUZELE1BRU8sSUFBSSxnQkFBZ0IsUUFBTyxZQUFQLHVEQUFPLFlBQVAsT0FBd0IsUUFBNUMsRUFBc0Q7QUFDekQsZUFBTyxLQUFLLFdBQUwsQ0FBaUIsV0FBVyxhQUE1QixFQUEyQyxFQUFDLFNBQVMsYUFBYSxPQUFiLElBQXdCLEdBQWxDLEVBQTNDLEVBQW1GLGFBQWEsUUFBYixJQUF5QixFQUE1RyxFQUFnSCxhQUFhLFVBQWIsSUFBMkIsU0FBM0ksRUFBc0osSUFBdEosRUFBNEosSUFBNUosRUFBa0ssTUFBbEssQ0FBUDtBQUNIO0FBQ0QsV0FBTyxJQUFQO0FBQ0gsQ0FYRDtBQVlBLGlCQUFpQixTQUFqQixDQUEyQix1QkFBM0IsR0FBcUQsVUFBVSxJQUFWLEVBQWdCLE1BQWhCLEVBQXdCLGVBQXhCLEVBQXlDO0FBQzFGLFNBQUssSUFBSSxHQUFULElBQWdCLEtBQUssZUFBckIsRUFBc0M7QUFDbEMsWUFBSSxPQUFPLE9BQU8sR0FBUCxDQUFQLEtBQXVCLFdBQTNCLEVBQXdDO0FBQ3BDO0FBQ0g7QUFDRCxZQUFJLHNCQUFzQixLQUFLLGVBQUwsQ0FBcUIsR0FBckIsQ0FBMUI7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksb0JBQW9CLE1BQXhDLEVBQWdELEdBQWhELEVBQXFEO0FBQ2pELGdCQUFJLE9BQU8sb0JBQW9CLENBQXBCLENBQVg7QUFDQSxnQkFBSSxTQUFTLEtBQUssSUFBTCxFQUFXLE9BQU8sR0FBUCxDQUFYLEVBQXdCLE1BQXhCLEVBQWdDLGVBQWhDLENBQWI7QUFDQSxnQkFBSSxPQUFPLE1BQVAsS0FBa0IsUUFBbEIsSUFBOEIsT0FBTyxNQUFQLEtBQWtCLFFBQXBELEVBQThEO0FBQzFELHVCQUFPLEtBQUssV0FBTCxDQUFpQixXQUFXLGNBQTVCLEVBQTRDO0FBQy9DLHlCQUFLLEdBRDBDO0FBRS9DLDZCQUFTO0FBRnNDLGlCQUE1QyxFQUdKLEVBSEksRUFHQSxFQUhBLEVBR0ksSUFISixFQUdVLElBSFYsRUFHZ0IsTUFIaEIsRUFHd0IsVUFIeEIsQ0FHbUMsSUFIbkMsRUFHeUMsR0FIekMsQ0FBUDtBQUlILGFBTEQsTUFLTyxJQUFJLFVBQVUsUUFBTyxNQUFQLHVEQUFPLE1BQVAsT0FBa0IsUUFBaEMsRUFBMEM7QUFDN0Msb0JBQUksT0FBTyxPQUFPLElBQWxCO0FBQ0Esb0JBQUksT0FBTyxJQUFQLEtBQWdCLFFBQXBCLEVBQThCO0FBQzFCLHdCQUFJLENBQUMsV0FBVyxJQUFYLENBQUwsRUFBdUI7QUFDbkIsOEJBQU0sSUFBSSxLQUFKLENBQVUsNkNBQTZDLElBQXZELENBQU47QUFDSDtBQUNELDJCQUFPLFdBQVcsSUFBWCxDQUFQO0FBQ0gsaUJBTEQsTUFLTyxJQUFJLE9BQU8sSUFBUCxLQUFnQixRQUFwQixFQUE4QjtBQUNqQywyQkFBTyxXQUFXLGNBQWxCO0FBQ0g7QUFDRCxvQkFBSSxnQkFBaUIsc0JBQU8sT0FBTyxPQUFkLE1BQTBCLFFBQTNCLEdBQXVDLE9BQU8sT0FBOUMsR0FBd0Q7QUFDeEUseUJBQUssR0FEbUU7QUFFeEUsNkJBQVMsT0FBTyxPQUFQLElBQWtCO0FBRjZDLGlCQUE1RTtBQUlBLG9CQUFJLGFBQWEsT0FBTyxVQUFQLElBQXNCLE1BQU0sSUFBSSxPQUFKLENBQVksSUFBWixFQUFrQixJQUFsQixFQUF3QixPQUF4QixDQUFnQyxLQUFoQyxFQUF1QyxJQUF2QyxDQUE3QztBQUNBLHVCQUFPLEtBQUssV0FBTCxDQUFpQixJQUFqQixFQUF1QixhQUF2QixFQUFzQyxPQUFPLFFBQVAsSUFBbUIsSUFBekQsRUFBK0QsVUFBL0QsRUFBMkUsSUFBM0UsRUFBaUYsSUFBakYsRUFBdUYsTUFBdkYsQ0FBUDtBQUNIO0FBQ0o7QUFDSjtBQUNELFdBQU8sSUFBUDtBQUNILENBbENEOztBQW9DQSxTQUFTLGdCQUFULENBQTBCLENBQTFCLEVBQTZCLENBQTdCLEVBQWdDO0FBQzVCLFFBQUksTUFBTSxDQUFWLEVBQWE7QUFDVCxlQUFPLElBQVA7QUFDSDtBQUNELFFBQUksS0FBSyxDQUFMLElBQVUsUUFBTyxDQUFQLHVEQUFPLENBQVAsT0FBYSxRQUF2QixJQUFtQyxRQUFPLENBQVAsdURBQU8sQ0FBUCxPQUFhLFFBQXBELEVBQThEO0FBQzFELFlBQUksTUFBTSxPQUFOLENBQWMsQ0FBZCxNQUFxQixNQUFNLE9BQU4sQ0FBYyxDQUFkLENBQXpCLEVBQTJDO0FBQ3ZDLG1CQUFPLEtBQVA7QUFDSCxTQUZELE1BRU8sSUFBSSxNQUFNLE9BQU4sQ0FBYyxDQUFkLENBQUosRUFBc0I7QUFDekIsZ0JBQUksRUFBRSxNQUFGLEtBQWEsRUFBRSxNQUFuQixFQUEyQjtBQUN2Qix1QkFBTyxLQUFQO0FBQ0g7QUFDRCxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEVBQUUsTUFBdEIsRUFBOEIsR0FBOUIsRUFBbUM7QUFDL0Isb0JBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFGLENBQWpCLEVBQXVCLEVBQUUsQ0FBRixDQUF2QixDQUFMLEVBQW1DO0FBQy9CLDJCQUFPLEtBQVA7QUFDSDtBQUNKO0FBQ0osU0FUTSxNQVNBO0FBQ0gsZ0JBQUksR0FBSjtBQUNBLGlCQUFLLEdBQUwsSUFBWSxDQUFaLEVBQWU7QUFDWCxvQkFBSSxFQUFFLEdBQUYsTUFBVyxTQUFYLElBQXdCLEVBQUUsR0FBRixNQUFXLFNBQXZDLEVBQWtEO0FBQzlDLDJCQUFPLEtBQVA7QUFDSDtBQUNKO0FBQ0QsaUJBQUssR0FBTCxJQUFZLENBQVosRUFBZTtBQUNYLG9CQUFJLEVBQUUsR0FBRixNQUFXLFNBQVgsSUFBd0IsRUFBRSxHQUFGLE1BQVcsU0FBdkMsRUFBa0Q7QUFDOUMsMkJBQU8sS0FBUDtBQUNIO0FBQ0o7QUFDRCxpQkFBSyxHQUFMLElBQVksQ0FBWixFQUFlO0FBQ1gsb0JBQUksQ0FBQyxpQkFBaUIsRUFBRSxHQUFGLENBQWpCLEVBQXlCLEVBQUUsR0FBRixDQUF6QixDQUFMLEVBQXVDO0FBQ25DLDJCQUFPLEtBQVA7QUFDSDtBQUNKO0FBQ0o7QUFDRCxlQUFPLElBQVA7QUFDSDtBQUNELFdBQU8sS0FBUDtBQUNIOztBQUVELGlCQUFpQixTQUFqQixDQUEyQixhQUEzQixHQUEyQyxTQUFTLGFBQVQsQ0FBdUIsSUFBdkIsRUFBNkIsTUFBN0IsRUFBcUMsZUFBckMsRUFBc0Q7QUFDN0YsUUFBSSxLQUFKO0FBQ0EsUUFBSSxRQUFRLEtBQUssWUFBTCxDQUFrQixJQUFsQixFQUF3QixNQUF4QixFQUFnQyxlQUFoQyxDQUFaLEVBQThEO0FBQzFELGVBQU8sTUFBTSxVQUFOLENBQWlCLElBQWpCLEVBQXVCLE1BQXZCLENBQVA7QUFDSDtBQUNELFFBQUksUUFBUSxLQUFLLFlBQUwsQ0FBa0IsSUFBbEIsRUFBd0IsTUFBeEIsRUFBZ0MsZUFBaEMsQ0FBWixFQUE4RDtBQUMxRCxlQUFPLE1BQU0sVUFBTixDQUFpQixJQUFqQixFQUF1QixNQUF2QixDQUFQO0FBQ0g7QUFDRCxXQUFPLElBQVA7QUFDSCxDQVREOztBQVdBLGlCQUFpQixTQUFqQixDQUEyQixZQUEzQixHQUEwQyxTQUFTLFlBQVQsQ0FBc0IsSUFBdEIsRUFBNEIsTUFBNUIsRUFBb0M7QUFDMUUsUUFBSSxPQUFPLElBQVAsS0FBZ0IsU0FBcEIsRUFBK0I7QUFDM0IsZUFBTyxJQUFQO0FBQ0g7QUFDRCxRQUFJLGtCQUFrQixJQUFsQix1REFBa0IsSUFBbEIsQ0FBSjtBQUNBLFFBQUksU0FBUyxJQUFiLEVBQW1CO0FBQ2YsbUJBQVcsTUFBWDtBQUNILEtBRkQsTUFFTyxJQUFJLE1BQU0sT0FBTixDQUFjLElBQWQsQ0FBSixFQUF5QjtBQUM1QixtQkFBVyxPQUFYO0FBQ0g7QUFDRCxRQUFJLGVBQWUsT0FBTyxJQUExQjtBQUNBLFFBQUksQ0FBQyxNQUFNLE9BQU4sQ0FBYyxZQUFkLENBQUwsRUFBa0M7QUFDOUIsdUJBQWUsQ0FBQyxZQUFELENBQWY7QUFDSDs7QUFFRCxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksYUFBYSxNQUFqQyxFQUF5QyxHQUF6QyxFQUE4QztBQUMxQyxZQUFJLE9BQU8sYUFBYSxDQUFiLENBQVg7QUFDQSxZQUFJLFNBQVMsUUFBVCxJQUFzQixTQUFTLFNBQVQsSUFBc0IsYUFBYSxRQUFuQyxJQUFnRCxPQUFPLENBQVAsS0FBYSxDQUF2RixFQUE0RjtBQUN4RixtQkFBTyxJQUFQO0FBQ0g7QUFDSjtBQUNELFdBQU8sS0FBSyxXQUFMLENBQWlCLFdBQVcsWUFBNUIsRUFBMEM7QUFDN0MsY0FBTSxRQUR1QztBQUU3QyxrQkFBVSxhQUFhLElBQWIsQ0FBa0IsR0FBbEI7QUFGbUMsS0FBMUMsRUFHSixFQUhJLEVBR0EsRUFIQSxFQUdJLElBSEosRUFHVSxJQUhWLEVBR2dCLE1BSGhCLENBQVA7QUFJSCxDQXpCRDs7QUEyQkEsaUJBQWlCLFNBQWpCLENBQTJCLFlBQTNCLEdBQTBDLFNBQVMsWUFBVCxDQUFzQixJQUF0QixFQUE0QixNQUE1QixFQUFvQztBQUMxRSxRQUFJLE9BQU8sTUFBUCxNQUFtQixTQUF2QixFQUFrQztBQUM5QixlQUFPLElBQVA7QUFDSDtBQUNELFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxPQUFPLE1BQVAsRUFBZSxNQUFuQyxFQUEyQyxHQUEzQyxFQUFnRDtBQUM1QyxZQUFJLFVBQVUsT0FBTyxNQUFQLEVBQWUsQ0FBZixDQUFkO0FBQ0EsWUFBSSxpQkFBaUIsSUFBakIsRUFBdUIsT0FBdkIsQ0FBSixFQUFxQztBQUNqQyxtQkFBTyxJQUFQO0FBQ0g7QUFDSjtBQUNELFdBQU8sS0FBSyxXQUFMLENBQWlCLFdBQVcsYUFBNUIsRUFBMkMsRUFBQyxPQUFRLE9BQU8sSUFBUCxLQUFnQixXQUFqQixHQUFnQyx5QkFBZSxJQUFmLENBQWhDLEdBQXVELElBQS9ELEVBQTNDLEVBQWlILEVBQWpILEVBQXFILEVBQXJILEVBQXlILElBQXpILEVBQStILElBQS9ILEVBQXFJLE1BQXJJLENBQVA7QUFDSCxDQVhEOztBQWFBLGlCQUFpQixTQUFqQixDQUEyQixlQUEzQixHQUE2QyxTQUFTLGVBQVQsQ0FBeUIsSUFBekIsRUFBK0IsTUFBL0IsRUFBdUMsZUFBdkMsRUFBd0Q7QUFDakcsV0FBTyxLQUFLLGtCQUFMLENBQXdCLElBQXhCLEVBQThCLE1BQTlCLEVBQXNDLGVBQXRDLEtBQ0EsS0FBSyxjQUFMLENBQW9CLElBQXBCLEVBQTBCLE1BQTFCLEVBQWtDLGVBQWxDLENBREEsSUFFQSxLQUFLLFdBQUwsQ0FBaUIsSUFBakIsRUFBdUIsTUFBdkIsRUFBK0IsZUFBL0IsQ0FGQSxJQUdBLElBSFA7QUFJSCxDQUxEOztBQU9BLElBQUksbUJBQW1CLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxDQUFDLEVBQWIsQ0FBdkI7QUFDQSxJQUFJLG9CQUFvQixJQUFJLGdCQUE1QjtBQUNBLGlCQUFpQixTQUFqQixDQUEyQixrQkFBM0IsR0FBZ0QsU0FBUyxrQkFBVCxDQUE0QixJQUE1QixFQUFrQyxNQUFsQyxFQUEwQztBQUN0RixRQUFJLGFBQWEsT0FBTyxVQUFQLElBQXFCLE9BQU8sV0FBN0M7QUFDQSxRQUFJLGVBQWUsU0FBbkIsRUFBOEI7QUFDMUIsZUFBTyxJQUFQO0FBQ0g7QUFDRCxRQUFJLE9BQU8sSUFBUCxLQUFnQixRQUFwQixFQUE4QjtBQUMxQixZQUFJLFlBQWEsT0FBTyxVQUFSLEdBQXNCLENBQXRDO0FBQ0EsWUFBSSxhQUFhLGdCQUFiLElBQWlDLFlBQVksaUJBQWpELEVBQW9FO0FBQ2hFLG1CQUFPLEtBQUssV0FBTCxDQUFpQixXQUFXLGtCQUE1QixFQUFnRDtBQUNuRCx1QkFBTyxJQUQ0QztBQUVuRCw0QkFBWTtBQUZ1QyxhQUFoRCxFQUdKLEVBSEksRUFHQSxFQUhBLEVBR0ksSUFISixFQUdVLElBSFYsRUFHZ0IsTUFIaEIsQ0FBUDtBQUlIO0FBQ0o7QUFDRCxXQUFPLElBQVA7QUFDSCxDQWZEOztBQWlCQSxpQkFBaUIsU0FBakIsQ0FBMkIsY0FBM0IsR0FBNEMsU0FBUyxjQUFULENBQXdCLElBQXhCLEVBQThCLE1BQTlCLEVBQXNDO0FBQzlFLFFBQUksT0FBTyxJQUFQLEtBQWdCLFFBQXBCLEVBQThCO0FBQzFCLGVBQU8sSUFBUDtBQUNIO0FBQ0QsUUFBSSxPQUFPLE9BQVAsS0FBbUIsU0FBdkIsRUFBa0M7QUFDOUIsWUFBSSxPQUFPLE9BQU8sT0FBbEIsRUFBMkI7QUFDdkIsbUJBQU8sS0FBSyxXQUFMLENBQWlCLFdBQVcsY0FBNUIsRUFBNEM7QUFDL0MsdUJBQU8sSUFEd0M7QUFFL0MseUJBQVMsT0FBTztBQUYrQixhQUE1QyxFQUdKLEVBSEksRUFHQSxVQUhBLEVBR1ksSUFIWixFQUdrQixJQUhsQixFQUd3QixNQUh4QixDQUFQO0FBSUg7QUFDRCxZQUFJLE9BQU8sZ0JBQVAsSUFBMkIsU0FBUyxPQUFPLE9BQS9DLEVBQXdEO0FBQ3BELG1CQUFPLEtBQUssV0FBTCxDQUFpQixXQUFXLHdCQUE1QixFQUFzRDtBQUN6RCx1QkFBTyxJQURrRDtBQUV6RCx5QkFBUyxPQUFPO0FBRnlDLGFBQXRELEVBR0osRUFISSxFQUdBLG1CQUhBLEVBR3FCLElBSHJCLEVBRzJCLElBSDNCLEVBR2lDLE1BSGpDLENBQVA7QUFJSDtBQUNKO0FBQ0QsUUFBSSxPQUFPLE9BQVAsS0FBbUIsU0FBdkIsRUFBa0M7QUFDOUIsWUFBSSxPQUFPLE9BQU8sT0FBbEIsRUFBMkI7QUFDdkIsbUJBQU8sS0FBSyxXQUFMLENBQWlCLFdBQVcsY0FBNUIsRUFBNEM7QUFDL0MsdUJBQU8sSUFEd0M7QUFFL0MseUJBQVMsT0FBTztBQUYrQixhQUE1QyxFQUdKLEVBSEksRUFHQSxVQUhBLEVBR1ksSUFIWixFQUdrQixJQUhsQixFQUd3QixNQUh4QixDQUFQO0FBSUg7QUFDRCxZQUFJLE9BQU8sZ0JBQVAsSUFBMkIsU0FBUyxPQUFPLE9BQS9DLEVBQXdEO0FBQ3BELG1CQUFPLEtBQUssV0FBTCxDQUFpQixXQUFXLHdCQUE1QixFQUFzRDtBQUN6RCx1QkFBTyxJQURrRDtBQUV6RCx5QkFBUyxPQUFPO0FBRnlDLGFBQXRELEVBR0osRUFISSxFQUdBLG1CQUhBLEVBR3FCLElBSHJCLEVBRzJCLElBSDNCLEVBR2lDLE1BSGpDLENBQVA7QUFJSDtBQUNKO0FBQ0QsV0FBTyxJQUFQO0FBQ0gsQ0FqQ0Q7O0FBbUNBLGlCQUFpQixTQUFqQixDQUEyQixXQUEzQixHQUF5QyxTQUFTLFdBQVQsQ0FBcUIsSUFBckIsRUFBMkIsTUFBM0IsRUFBbUM7QUFDeEUsUUFBSSxPQUFPLElBQVAsS0FBZ0IsUUFBcEIsRUFBOEI7QUFDMUIsZUFBTyxJQUFQO0FBQ0g7QUFDRCxRQUFJLE1BQU0sSUFBTixNQUFnQixJQUFoQixJQUF3QixTQUFTLFFBQWpDLElBQTZDLFNBQVMsQ0FBQyxRQUEzRCxFQUFxRTtBQUNqRSxlQUFPLEtBQUssV0FBTCxDQUFpQixXQUFXLG1CQUE1QixFQUFpRCxFQUFDLE9BQU8sSUFBUixFQUFqRCxFQUFnRSxFQUFoRSxFQUFvRSxPQUFwRSxFQUE2RSxJQUE3RSxFQUFtRixJQUFuRixFQUF5RixNQUF6RixDQUFQO0FBQ0g7QUFDRCxXQUFPLElBQVA7QUFDSCxDQVJEOztBQVVBLGlCQUFpQixTQUFqQixDQUEyQixjQUEzQixHQUE0QyxTQUFTLGNBQVQsQ0FBd0IsSUFBeEIsRUFBOEIsTUFBOUIsRUFBc0MsZUFBdEMsRUFBdUQ7QUFDL0YsV0FBTyxLQUFLLG9CQUFMLENBQTBCLElBQTFCLEVBQWdDLE1BQWhDLEVBQXdDLGVBQXhDLEtBQ0EsS0FBSyxxQkFBTCxDQUEyQixJQUEzQixFQUFpQyxNQUFqQyxFQUF5QyxlQUF6QyxDQURBLElBRUEsSUFGUDtBQUdILENBSkQ7O0FBTUEsaUJBQWlCLFNBQWpCLENBQTJCLG9CQUEzQixHQUFrRCxTQUFTLG9CQUFULENBQThCLElBQTlCLEVBQW9DLE1BQXBDLEVBQTRDO0FBQzFGLFFBQUksT0FBTyxJQUFQLEtBQWdCLFFBQXBCLEVBQThCO0FBQzFCLGVBQU8sSUFBUDtBQUNIO0FBQ0QsUUFBSSxPQUFPLFNBQVAsS0FBcUIsU0FBekIsRUFBb0M7QUFDaEMsWUFBSSxLQUFLLE1BQUwsR0FBYyxPQUFPLFNBQXpCLEVBQW9DO0FBQ2hDLG1CQUFPLEtBQUssV0FBTCxDQUFpQixXQUFXLG1CQUE1QixFQUFpRDtBQUNwRCx3QkFBUSxLQUFLLE1BRHVDO0FBRXBELHlCQUFTLE9BQU87QUFGb0MsYUFBakQsRUFHSixFQUhJLEVBR0EsWUFIQSxFQUdjLElBSGQsRUFHb0IsSUFIcEIsRUFHMEIsTUFIMUIsQ0FBUDtBQUlIO0FBQ0o7QUFDRCxRQUFJLE9BQU8sU0FBUCxLQUFxQixTQUF6QixFQUFvQztBQUNoQyxZQUFJLEtBQUssTUFBTCxHQUFjLE9BQU8sU0FBekIsRUFBb0M7QUFDaEMsbUJBQU8sS0FBSyxXQUFMLENBQWlCLFdBQVcsa0JBQTVCLEVBQWdEO0FBQ25ELHdCQUFRLEtBQUssTUFEc0M7QUFFbkQseUJBQVMsT0FBTztBQUZtQyxhQUFoRCxFQUdKLEVBSEksRUFHQSxZQUhBLEVBR2MsSUFIZCxFQUdvQixJQUhwQixFQUcwQixNQUgxQixDQUFQO0FBSUg7QUFDSjtBQUNELFdBQU8sSUFBUDtBQUNILENBckJEOztBQXVCQSxpQkFBaUIsU0FBakIsQ0FBMkIscUJBQTNCLEdBQW1ELFNBQVMscUJBQVQsQ0FBK0IsSUFBL0IsRUFBcUMsTUFBckMsRUFBNkM7QUFDNUYsUUFBSSxPQUFPLElBQVAsS0FBZ0IsUUFBaEIsSUFBNkIsT0FBTyxPQUFPLE9BQWQsS0FBMEIsUUFBMUIsSUFBc0MsRUFBRSxPQUFPLE9BQVAsWUFBMEIsTUFBNUIsQ0FBdkUsRUFBNkc7QUFDekcsZUFBTyxJQUFQO0FBQ0g7QUFDRCxRQUFJLE1BQUo7QUFDQSxRQUFJLE9BQU8sT0FBUCxZQUEwQixNQUE5QixFQUFzQztBQUNsQyxpQkFBUyxPQUFPLE9BQWhCO0FBQ0gsS0FGRCxNQUdLO0FBQ0QsWUFBSSxJQUFKO0FBQUEsWUFBVSxRQUFRLEVBQWxCO0FBQ0E7QUFDQTtBQUNBLFlBQUksVUFBVSxPQUFPLE9BQVAsQ0FBZSxLQUFmLENBQXFCLG9CQUFyQixDQUFkO0FBQ0EsWUFBSSxPQUFKLEVBQWE7QUFDVCxtQkFBTyxRQUFRLENBQVIsQ0FBUDtBQUNBLG9CQUFRLFFBQVEsQ0FBUixDQUFSO0FBQ0gsU0FIRCxNQUlLO0FBQ0QsbUJBQU8sT0FBTyxPQUFkO0FBQ0g7QUFDRCxpQkFBUyxJQUFJLE1BQUosQ0FBVyxJQUFYLEVBQWlCLEtBQWpCLENBQVQ7QUFDSDtBQUNELFFBQUksQ0FBQyxPQUFPLElBQVAsQ0FBWSxJQUFaLENBQUwsRUFBd0I7QUFDcEIsZUFBTyxLQUFLLFdBQUwsQ0FBaUIsV0FBVyxjQUE1QixFQUE0QyxFQUFDLFNBQVMsT0FBTyxPQUFqQixFQUE1QyxFQUF1RSxFQUF2RSxFQUEyRSxVQUEzRSxFQUF1RixJQUF2RixFQUE2RixJQUE3RixFQUFtRyxNQUFuRyxDQUFQO0FBQ0g7QUFDRCxXQUFPLElBQVA7QUFDSCxDQTFCRDs7QUE0QkEsaUJBQWlCLFNBQWpCLENBQTJCLGFBQTNCLEdBQTJDLFNBQVMsYUFBVCxDQUF1QixJQUF2QixFQUE2QixNQUE3QixFQUFxQyxlQUFyQyxFQUFzRDtBQUM3RixRQUFJLENBQUMsTUFBTSxPQUFOLENBQWMsSUFBZCxDQUFMLEVBQTBCO0FBQ3RCLGVBQU8sSUFBUDtBQUNIO0FBQ0QsV0FBTyxLQUFLLG1CQUFMLENBQXlCLElBQXpCLEVBQStCLE1BQS9CLEVBQXVDLGVBQXZDLEtBQ0EsS0FBSyx3QkFBTCxDQUE4QixJQUE5QixFQUFvQyxNQUFwQyxFQUE0QyxlQUE1QyxDQURBLElBRUEsS0FBSyxrQkFBTCxDQUF3QixJQUF4QixFQUE4QixNQUE5QixFQUFzQyxlQUF0QyxDQUZBLElBR0EsSUFIUDtBQUlILENBUkQ7O0FBVUEsaUJBQWlCLFNBQWpCLENBQTJCLG1CQUEzQixHQUFpRCxTQUFTLG1CQUFULENBQTZCLElBQTdCLEVBQW1DLE1BQW5DLEVBQTJDO0FBQ3hGLFFBQUksS0FBSjtBQUNBLFFBQUksT0FBTyxRQUFQLEtBQW9CLFNBQXhCLEVBQW1DO0FBQy9CLFlBQUksS0FBSyxNQUFMLEdBQWMsT0FBTyxRQUF6QixFQUFtQztBQUMvQixvQkFBUSxLQUFLLFdBQUwsQ0FBaUIsV0FBVyxrQkFBNUIsRUFBZ0Q7QUFDcEQsd0JBQVEsS0FBSyxNQUR1QztBQUVwRCx5QkFBUyxPQUFPO0FBRm9DLGFBQWhELEVBR0wsRUFISyxFQUdELFdBSEMsRUFHWSxJQUhaLEVBR2tCLElBSGxCLEVBR3dCLE1BSHhCLENBQVI7QUFJQSxnQkFBSSxLQUFLLFdBQUwsQ0FBaUIsS0FBakIsQ0FBSixFQUE2QjtBQUN6Qix1QkFBTyxLQUFQO0FBQ0g7QUFDSjtBQUNKO0FBQ0QsUUFBSSxPQUFPLFFBQVAsS0FBb0IsU0FBeEIsRUFBbUM7QUFDL0IsWUFBSSxLQUFLLE1BQUwsR0FBYyxPQUFPLFFBQXpCLEVBQW1DO0FBQy9CLG9CQUFRLEtBQUssV0FBTCxDQUFpQixXQUFXLGlCQUE1QixFQUErQztBQUNuRCx3QkFBUSxLQUFLLE1BRHNDO0FBRW5ELHlCQUFTLE9BQU87QUFGbUMsYUFBL0MsRUFHTCxFQUhLLEVBR0QsV0FIQyxFQUdZLElBSFosRUFHa0IsSUFIbEIsRUFHd0IsTUFIeEIsQ0FBUjtBQUlBLGdCQUFJLEtBQUssV0FBTCxDQUFpQixLQUFqQixDQUFKLEVBQTZCO0FBQ3pCLHVCQUFPLEtBQVA7QUFDSDtBQUNKO0FBQ0o7QUFDRCxXQUFPLElBQVA7QUFDSCxDQXpCRDs7QUEyQkEsaUJBQWlCLFNBQWpCLENBQTJCLHdCQUEzQixHQUFzRCxTQUFTLHdCQUFULENBQWtDLElBQWxDLEVBQXdDLE1BQXhDLEVBQWdEO0FBQ2xHLFFBQUksT0FBTyxXQUFYLEVBQXdCO0FBQ3BCLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLE1BQXpCLEVBQWlDLEdBQWpDLEVBQXNDO0FBQ2xDLGlCQUFLLElBQUksSUFBSSxJQUFJLENBQWpCLEVBQW9CLElBQUksS0FBSyxNQUE3QixFQUFxQyxHQUFyQyxFQUEwQztBQUN0QyxvQkFBSSxpQkFBaUIsS0FBSyxDQUFMLENBQWpCLEVBQTBCLEtBQUssQ0FBTCxDQUExQixDQUFKLEVBQXdDO0FBQ3BDLHdCQUFJLFFBQVEsS0FBSyxXQUFMLENBQWlCLFdBQVcsWUFBNUIsRUFBMEM7QUFDbEQsZ0NBQVEsQ0FEMEM7QUFFbEQsZ0NBQVE7QUFGMEMscUJBQTFDLEVBR1QsRUFIUyxFQUdMLGNBSEssRUFHVyxJQUhYLEVBR2lCLElBSGpCLEVBR3VCLE1BSHZCLENBQVo7QUFJQSx3QkFBSSxLQUFLLFdBQUwsQ0FBaUIsS0FBakIsQ0FBSixFQUE2QjtBQUN6QiwrQkFBTyxLQUFQO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7QUFDSjtBQUNELFdBQU8sSUFBUDtBQUNILENBakJEOztBQW1CQSxpQkFBaUIsU0FBakIsQ0FBMkIsa0JBQTNCLEdBQWdELFNBQVMsa0JBQVQsQ0FBNEIsSUFBNUIsRUFBa0MsTUFBbEMsRUFBMEMsZUFBMUMsRUFBMkQ7QUFDdkcsUUFBSSxPQUFPLEtBQVAsS0FBaUIsU0FBckIsRUFBZ0M7QUFDNUIsZUFBTyxJQUFQO0FBQ0g7QUFDRCxRQUFJLEtBQUosRUFBVyxDQUFYO0FBQ0EsUUFBSSxNQUFNLE9BQU4sQ0FBYyxPQUFPLEtBQXJCLENBQUosRUFBaUM7QUFDN0IsYUFBSyxJQUFJLENBQVQsRUFBWSxJQUFJLEtBQUssTUFBckIsRUFBNkIsR0FBN0IsRUFBa0M7QUFDOUIsZ0JBQUksSUFBSSxPQUFPLEtBQVAsQ0FBYSxNQUFyQixFQUE2QjtBQUN6QixvQkFBSSxRQUFRLEtBQUssV0FBTCxDQUFpQixLQUFLLENBQUwsQ0FBakIsRUFBMEIsT0FBTyxLQUFQLENBQWEsQ0FBYixDQUExQixFQUEyQyxDQUFDLENBQUQsQ0FBM0MsRUFBZ0QsQ0FBQyxPQUFELEVBQVUsQ0FBVixDQUFoRCxFQUE4RCxrQkFBa0IsR0FBbEIsR0FBd0IsQ0FBdEYsQ0FBWixFQUFzRztBQUNsRywyQkFBTyxLQUFQO0FBQ0g7QUFDSixhQUpELE1BSU8sSUFBSSxPQUFPLGVBQVAsS0FBMkIsU0FBL0IsRUFBMEM7QUFDN0Msb0JBQUksT0FBTyxPQUFPLGVBQWQsS0FBa0MsU0FBdEMsRUFBaUQ7QUFDN0Msd0JBQUksQ0FBQyxPQUFPLGVBQVosRUFBNkI7QUFDekIsZ0NBQVMsS0FBSyxXQUFMLENBQWlCLFdBQVcsc0JBQTVCLEVBQW9ELEVBQXBELEVBQXdELE1BQU0sQ0FBOUQsRUFBaUUsa0JBQWpFLEVBQXFGLElBQXJGLEVBQTJGLElBQTNGLEVBQWlHLE1BQWpHLENBQVQ7QUFDQSw0QkFBSSxLQUFLLFdBQUwsQ0FBaUIsS0FBakIsQ0FBSixFQUE2QjtBQUN6QixtQ0FBTyxLQUFQO0FBQ0g7QUFDSjtBQUNKLGlCQVBELE1BT08sSUFBSSxRQUFRLEtBQUssV0FBTCxDQUFpQixLQUFLLENBQUwsQ0FBakIsRUFBMEIsT0FBTyxlQUFqQyxFQUFrRCxDQUFDLENBQUQsQ0FBbEQsRUFBdUQsQ0FBQyxpQkFBRCxDQUF2RCxFQUE0RSxrQkFBa0IsR0FBbEIsR0FBd0IsQ0FBcEcsQ0FBWixFQUFvSDtBQUN2SCwyQkFBTyxLQUFQO0FBQ0g7QUFDSjtBQUNKO0FBQ0osS0FuQkQsTUFtQk87QUFDSCxhQUFLLElBQUksQ0FBVCxFQUFZLElBQUksS0FBSyxNQUFyQixFQUE2QixHQUE3QixFQUFrQztBQUM5QixnQkFBSSxRQUFRLEtBQUssV0FBTCxDQUFpQixLQUFLLENBQUwsQ0FBakIsRUFBMEIsT0FBTyxLQUFqQyxFQUF3QyxDQUFDLENBQUQsQ0FBeEMsRUFBNkMsQ0FBQyxPQUFELENBQTdDLEVBQXdELGtCQUFrQixHQUFsQixHQUF3QixDQUFoRixDQUFaLEVBQWdHO0FBQzVGLHVCQUFPLEtBQVA7QUFDSDtBQUNKO0FBQ0o7QUFDRCxXQUFPLElBQVA7QUFDSCxDQWhDRDs7QUFrQ0EsaUJBQWlCLFNBQWpCLENBQTJCLGNBQTNCLEdBQTRDLFNBQVMsY0FBVCxDQUF3QixJQUF4QixFQUE4QixNQUE5QixFQUFzQyxlQUF0QyxFQUF1RDtBQUMvRixRQUFJLFFBQU8sSUFBUCx1REFBTyxJQUFQLE9BQWdCLFFBQWhCLElBQTRCLFNBQVMsSUFBckMsSUFBNkMsTUFBTSxPQUFOLENBQWMsSUFBZCxDQUFqRCxFQUFzRTtBQUNsRSxlQUFPLElBQVA7QUFDSDtBQUNELFdBQU8sS0FBSyw4QkFBTCxDQUFvQyxJQUFwQyxFQUEwQyxNQUExQyxFQUFrRCxlQUFsRCxLQUNBLEtBQUssZ0NBQUwsQ0FBc0MsSUFBdEMsRUFBNEMsTUFBNUMsRUFBb0QsZUFBcEQsQ0FEQSxJQUVBLEtBQUssd0JBQUwsQ0FBOEIsSUFBOUIsRUFBb0MsTUFBcEMsRUFBNEMsZUFBNUMsQ0FGQSxJQUdBLEtBQUssMEJBQUwsQ0FBZ0MsSUFBaEMsRUFBc0MsTUFBdEMsRUFBOEMsZUFBOUMsQ0FIQSxJQUlBLElBSlA7QUFLSCxDQVREOztBQVdBLGlCQUFpQixTQUFqQixDQUEyQiw4QkFBM0IsR0FBNEQsU0FBUyw4QkFBVCxDQUF3QyxJQUF4QyxFQUE4QyxNQUE5QyxFQUFzRDtBQUM5RyxRQUFJLE9BQU8sb0JBQVksSUFBWixDQUFYO0FBQ0EsUUFBSSxLQUFKO0FBQ0EsUUFBSSxPQUFPLGFBQVAsS0FBeUIsU0FBN0IsRUFBd0M7QUFDcEMsWUFBSSxLQUFLLE1BQUwsR0FBYyxPQUFPLGFBQXpCLEVBQXdDO0FBQ3BDLG9CQUFRLEtBQUssV0FBTCxDQUFpQixXQUFXLHlCQUE1QixFQUF1RDtBQUMzRCwrQkFBZSxLQUFLLE1BRHVDO0FBRTNELHlCQUFTLE9BQU87QUFGMkMsYUFBdkQsRUFHTCxFQUhLLEVBR0QsZ0JBSEMsRUFHaUIsSUFIakIsRUFHdUIsSUFIdkIsRUFHNkIsTUFIN0IsQ0FBUjtBQUlBLGdCQUFJLEtBQUssV0FBTCxDQUFpQixLQUFqQixDQUFKLEVBQTZCO0FBQ3pCLHVCQUFPLEtBQVA7QUFDSDtBQUNKO0FBQ0o7QUFDRCxRQUFJLE9BQU8sYUFBUCxLQUF5QixTQUE3QixFQUF3QztBQUNwQyxZQUFJLEtBQUssTUFBTCxHQUFjLE9BQU8sYUFBekIsRUFBd0M7QUFDcEMsb0JBQVEsS0FBSyxXQUFMLENBQWlCLFdBQVcseUJBQTVCLEVBQXVEO0FBQzNELCtCQUFlLEtBQUssTUFEdUM7QUFFM0QseUJBQVMsT0FBTztBQUYyQyxhQUF2RCxFQUdMLEVBSEssRUFHRCxnQkFIQyxFQUdpQixJQUhqQixFQUd1QixJQUh2QixFQUc2QixNQUg3QixDQUFSO0FBSUEsZ0JBQUksS0FBSyxXQUFMLENBQWlCLEtBQWpCLENBQUosRUFBNkI7QUFDekIsdUJBQU8sS0FBUDtBQUNIO0FBQ0o7QUFDSjtBQUNELFdBQU8sSUFBUDtBQUNILENBMUJEOztBQTRCQSxpQkFBaUIsU0FBakIsQ0FBMkIsZ0NBQTNCLEdBQThELFNBQVMsZ0NBQVQsQ0FBMEMsSUFBMUMsRUFBZ0QsTUFBaEQsRUFBd0Q7QUFDbEgsUUFBSSxPQUFPLFFBQVAsS0FBb0IsU0FBeEIsRUFBbUM7QUFDL0IsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE9BQU8sUUFBUCxDQUFnQixNQUFwQyxFQUE0QyxHQUE1QyxFQUFpRDtBQUM3QyxnQkFBSSxNQUFNLE9BQU8sUUFBUCxDQUFnQixDQUFoQixDQUFWO0FBQ0EsZ0JBQUksS0FBSyxHQUFMLE1BQWMsU0FBbEIsRUFBNkI7QUFDekIsb0JBQUksUUFBUSxLQUFLLFdBQUwsQ0FBaUIsV0FBVyxlQUE1QixFQUE2QyxFQUFDLEtBQUssR0FBTixFQUE3QyxFQUF5RCxFQUF6RCxFQUE2RCxlQUFlLENBQTVFLEVBQStFLElBQS9FLEVBQXFGLElBQXJGLEVBQTJGLE1BQTNGLENBQVo7QUFDQSxvQkFBSSxLQUFLLFdBQUwsQ0FBaUIsS0FBakIsQ0FBSixFQUE2QjtBQUN6QiwyQkFBTyxLQUFQO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7QUFDRCxXQUFPLElBQVA7QUFDSCxDQWJEOztBQWVBLGlCQUFpQixTQUFqQixDQUEyQix3QkFBM0IsR0FBc0QsU0FBUyx3QkFBVCxDQUFrQyxJQUFsQyxFQUF3QyxNQUF4QyxFQUFnRCxlQUFoRCxFQUFpRTtBQUNuSCxRQUFJLEtBQUo7QUFDQSxTQUFLLElBQUksR0FBVCxJQUFnQixJQUFoQixFQUFzQjtBQUNsQixZQUFJLGlCQUFpQixrQkFBa0IsR0FBbEIsR0FBd0IsSUFBSSxPQUFKLENBQVksSUFBWixFQUFrQixJQUFsQixFQUF3QixPQUF4QixDQUFnQyxLQUFoQyxFQUF1QyxJQUF2QyxDQUE3QztBQUNBLFlBQUksYUFBYSxLQUFqQjtBQUNBLFlBQUksT0FBTyxVQUFQLEtBQXNCLFNBQXRCLElBQW1DLE9BQU8sVUFBUCxDQUFrQixHQUFsQixNQUEyQixTQUFsRSxFQUE2RTtBQUN6RSx5QkFBYSxJQUFiO0FBQ0EsZ0JBQUksUUFBUSxLQUFLLFdBQUwsQ0FBaUIsS0FBSyxHQUFMLENBQWpCLEVBQTRCLE9BQU8sVUFBUCxDQUFrQixHQUFsQixDQUE1QixFQUFvRCxDQUFDLEdBQUQsQ0FBcEQsRUFBMkQsQ0FBQyxZQUFELEVBQWUsR0FBZixDQUEzRCxFQUFnRixjQUFoRixDQUFaLEVBQTZHO0FBQ3pHLHVCQUFPLEtBQVA7QUFDSDtBQUNKO0FBQ0QsWUFBSSxPQUFPLGlCQUFQLEtBQTZCLFNBQWpDLEVBQTRDO0FBQ3hDLGlCQUFLLElBQUksVUFBVCxJQUF1QixPQUFPLGlCQUE5QixFQUFpRDtBQUM3QyxvQkFBSSxTQUFTLElBQUksTUFBSixDQUFXLFVBQVgsQ0FBYjtBQUNBLG9CQUFJLE9BQU8sSUFBUCxDQUFZLEdBQVosQ0FBSixFQUFzQjtBQUNsQixpQ0FBYSxJQUFiO0FBQ0Esd0JBQUksUUFBUSxLQUFLLFdBQUwsQ0FBaUIsS0FBSyxHQUFMLENBQWpCLEVBQTRCLE9BQU8saUJBQVAsQ0FBeUIsVUFBekIsQ0FBNUIsRUFBa0UsQ0FBQyxHQUFELENBQWxFLEVBQXlFLENBQUMsbUJBQUQsRUFBc0IsVUFBdEIsQ0FBekUsRUFBNEcsY0FBNUcsQ0FBWixFQUF5STtBQUNySSwrQkFBTyxLQUFQO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7QUFDRCxZQUFJLENBQUMsVUFBTCxFQUFpQjtBQUNiLGdCQUFJLE9BQU8sb0JBQVAsS0FBZ0MsU0FBcEMsRUFBK0M7QUFDM0Msb0JBQUksS0FBSyxzQkFBVCxFQUFpQztBQUM3Qix5QkFBSyxrQkFBTCxDQUF3QixjQUF4QixJQUEwQyxJQUExQztBQUNBLDJCQUFPLEtBQUssb0JBQUwsQ0FBMEIsY0FBMUIsQ0FBUDtBQUNIO0FBQ0Qsb0JBQUksT0FBTyxPQUFPLG9CQUFkLEtBQXVDLFNBQTNDLEVBQXNEO0FBQ2xELHdCQUFJLENBQUMsT0FBTyxvQkFBWixFQUFrQztBQUM5QixnQ0FBUSxLQUFLLFdBQUwsQ0FBaUIsV0FBVyw0QkFBNUIsRUFBMEQsRUFBQyxLQUFLLEdBQU4sRUFBMUQsRUFBc0UsRUFBdEUsRUFBMEUsdUJBQTFFLEVBQW1HLElBQW5HLEVBQXlHLElBQXpHLEVBQStHLE1BQS9HLEVBQXVILFVBQXZILENBQWtJLEdBQWxJLEVBQXVJLElBQXZJLENBQVI7QUFDQSw0QkFBSSxLQUFLLFdBQUwsQ0FBaUIsS0FBakIsQ0FBSixFQUE2QjtBQUN6QixtQ0FBTyxLQUFQO0FBQ0g7QUFDSjtBQUNKLGlCQVBELE1BT087QUFDSCx3QkFBSSxRQUFRLEtBQUssV0FBTCxDQUFpQixLQUFLLEdBQUwsQ0FBakIsRUFBNEIsT0FBTyxvQkFBbkMsRUFBeUQsQ0FBQyxHQUFELENBQXpELEVBQWdFLENBQUMsc0JBQUQsQ0FBaEUsRUFBMEYsY0FBMUYsQ0FBWixFQUF1SDtBQUNuSCwrQkFBTyxLQUFQO0FBQ0g7QUFDSjtBQUNKLGFBakJELE1BaUJPLElBQUksS0FBSyxzQkFBTCxJQUErQixDQUFDLEtBQUssa0JBQUwsQ0FBd0IsY0FBeEIsQ0FBcEMsRUFBNkU7QUFDaEYscUJBQUssb0JBQUwsQ0FBMEIsY0FBMUIsSUFBNEMsSUFBNUM7QUFDSDtBQUNKLFNBckJELE1BcUJPLElBQUksS0FBSyxzQkFBVCxFQUFpQztBQUNwQyxpQkFBSyxrQkFBTCxDQUF3QixjQUF4QixJQUEwQyxJQUExQztBQUNBLG1CQUFPLEtBQUssb0JBQUwsQ0FBMEIsY0FBMUIsQ0FBUDtBQUNIO0FBQ0o7QUFDRCxXQUFPLElBQVA7QUFDSCxDQWpERDs7QUFtREEsaUJBQWlCLFNBQWpCLENBQTJCLDBCQUEzQixHQUF3RCxTQUFTLDBCQUFULENBQW9DLElBQXBDLEVBQTBDLE1BQTFDLEVBQWtELGVBQWxELEVBQW1FO0FBQ3ZILFFBQUksS0FBSjtBQUNBLFFBQUksT0FBTyxZQUFQLEtBQXdCLFNBQTVCLEVBQXVDO0FBQ25DLGFBQUssSUFBSSxNQUFULElBQW1CLE9BQU8sWUFBMUIsRUFBd0M7QUFDcEMsZ0JBQUksS0FBSyxNQUFMLE1BQWlCLFNBQXJCLEVBQWdDO0FBQzVCLG9CQUFJLE1BQU0sT0FBTyxZQUFQLENBQW9CLE1BQXBCLENBQVY7QUFDQSxvQkFBSSxPQUFPLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUN6Qix3QkFBSSxLQUFLLEdBQUwsTUFBYyxTQUFsQixFQUE2QjtBQUN6QixnQ0FBUSxLQUFLLFdBQUwsQ0FBaUIsV0FBVyxxQkFBNUIsRUFBbUQ7QUFDdkQsaUNBQUssTUFEa0Q7QUFFdkQscUNBQVM7QUFGOEMseUJBQW5ELEVBR0wsRUFISyxFQUdELEVBSEMsRUFHRyxJQUhILEVBR1MsSUFIVCxFQUdlLE1BSGYsRUFHdUIsVUFIdkIsQ0FHa0MsSUFIbEMsRUFHd0MsTUFIeEMsRUFHZ0QsVUFIaEQsQ0FHMkQsSUFIM0QsRUFHaUUsY0FIakUsQ0FBUjtBQUlBLDRCQUFJLEtBQUssV0FBTCxDQUFpQixLQUFqQixDQUFKLEVBQTZCO0FBQ3pCLG1DQUFPLEtBQVA7QUFDSDtBQUNKO0FBQ0osaUJBVkQsTUFVTyxJQUFJLE1BQU0sT0FBTixDQUFjLEdBQWQsQ0FBSixFQUF3QjtBQUMzQix5QkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLElBQUksTUFBeEIsRUFBZ0MsR0FBaEMsRUFBcUM7QUFDakMsNEJBQUksY0FBYyxJQUFJLENBQUosQ0FBbEI7QUFDQSw0QkFBSSxLQUFLLFdBQUwsTUFBc0IsU0FBMUIsRUFBcUM7QUFDakMsb0NBQVEsS0FBSyxXQUFMLENBQWlCLFdBQVcscUJBQTVCLEVBQW1EO0FBQ3ZELHFDQUFLLE1BRGtEO0FBRXZELHlDQUFTO0FBRjhDLDZCQUFuRCxFQUdMLEVBSEssRUFHRCxNQUFNLENBSEwsRUFHUSxJQUhSLEVBR2MsSUFIZCxFQUdvQixNQUhwQixFQUc0QixVQUg1QixDQUd1QyxJQUh2QyxFQUc2QyxNQUg3QyxFQUdxRCxVQUhyRCxDQUdnRSxJQUhoRSxFQUdzRSxjQUh0RSxDQUFSO0FBSUEsZ0NBQUksS0FBSyxXQUFMLENBQWlCLEtBQWpCLENBQUosRUFBNkI7QUFDekIsdUNBQU8sS0FBUDtBQUNIO0FBQ0o7QUFDSjtBQUNKLGlCQWJNLE1BYUE7QUFDSCx3QkFBSSxRQUFRLEtBQUssV0FBTCxDQUFpQixJQUFqQixFQUF1QixHQUF2QixFQUE0QixFQUE1QixFQUFnQyxDQUFDLGNBQUQsRUFBaUIsTUFBakIsQ0FBaEMsRUFBMEQsZUFBMUQsQ0FBWixFQUF3RjtBQUNwRiwrQkFBTyxLQUFQO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7QUFDSjtBQUNELFdBQU8sSUFBUDtBQUNILENBdENEOztBQXdDQSxpQkFBaUIsU0FBakIsQ0FBMkIsb0JBQTNCLEdBQWtELFNBQVMsb0JBQVQsQ0FBOEIsSUFBOUIsRUFBb0MsTUFBcEMsRUFBNEMsZUFBNUMsRUFBNkQ7QUFDM0csV0FBTyxLQUFLLGFBQUwsQ0FBbUIsSUFBbkIsRUFBeUIsTUFBekIsRUFBaUMsZUFBakMsS0FDQSxLQUFLLGFBQUwsQ0FBbUIsSUFBbkIsRUFBeUIsTUFBekIsRUFBaUMsZUFBakMsQ0FEQSxJQUVBLEtBQUssYUFBTCxDQUFtQixJQUFuQixFQUF5QixNQUF6QixFQUFpQyxlQUFqQyxDQUZBLElBR0EsS0FBSyxXQUFMLENBQWlCLElBQWpCLEVBQXVCLE1BQXZCLEVBQStCLGVBQS9CLENBSEEsSUFJQSxJQUpQO0FBS0gsQ0FORDs7QUFRQSxpQkFBaUIsU0FBakIsQ0FBMkIsYUFBM0IsR0FBMkMsU0FBUyxhQUFULENBQXVCLElBQXZCLEVBQTZCLE1BQTdCLEVBQXFDLGVBQXJDLEVBQXNEO0FBQzdGLFFBQUksT0FBTyxLQUFQLEtBQWlCLFNBQXJCLEVBQWdDO0FBQzVCLGVBQU8sSUFBUDtBQUNIO0FBQ0QsUUFBSSxLQUFKO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE9BQU8sS0FBUCxDQUFhLE1BQWpDLEVBQXlDLEdBQXpDLEVBQThDO0FBQzFDLFlBQUksWUFBWSxPQUFPLEtBQVAsQ0FBYSxDQUFiLENBQWhCO0FBQ0EsWUFBSSxRQUFRLEtBQUssV0FBTCxDQUFpQixJQUFqQixFQUF1QixTQUF2QixFQUFrQyxFQUFsQyxFQUFzQyxDQUFDLE9BQUQsRUFBVSxDQUFWLENBQXRDLEVBQW9ELGVBQXBELENBQVosRUFBa0Y7QUFDOUUsbUJBQU8sS0FBUDtBQUNIO0FBQ0o7QUFDRCxXQUFPLElBQVA7QUFDSCxDQVpEOztBQWNBLGlCQUFpQixTQUFqQixDQUEyQixhQUEzQixHQUEyQyxTQUFTLGFBQVQsQ0FBdUIsSUFBdkIsRUFBNkIsTUFBN0IsRUFBcUMsZUFBckMsRUFBc0Q7QUFDN0YsUUFBSSxPQUFPLEtBQVAsS0FBaUIsU0FBckIsRUFBZ0M7QUFDNUIsZUFBTyxJQUFQO0FBQ0g7QUFDRCxRQUFJLFNBQVMsRUFBYjtBQUNBLFFBQUksa0JBQWtCLEtBQUssTUFBTCxDQUFZLE1BQWxDO0FBQ0EsUUFBSSx1QkFBSixFQUE2QixxQkFBN0I7QUFDQSxRQUFJLEtBQUssc0JBQVQsRUFBaUM7QUFDN0Isa0NBQTBCLEtBQUssb0JBQS9CO0FBQ0EsZ0NBQXdCLEtBQUssa0JBQTdCO0FBQ0g7QUFDRCxRQUFJLGFBQWEsSUFBakI7QUFDQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksT0FBTyxLQUFQLENBQWEsTUFBakMsRUFBeUMsR0FBekMsRUFBOEM7QUFDMUMsWUFBSSxLQUFLLHNCQUFULEVBQWlDO0FBQzdCLGlCQUFLLG9CQUFMLEdBQTRCLEVBQTVCO0FBQ0EsaUJBQUssa0JBQUwsR0FBMEIsRUFBMUI7QUFDSDtBQUNELFlBQUksWUFBWSxPQUFPLEtBQVAsQ0FBYSxDQUFiLENBQWhCOztBQUVBLFlBQUksYUFBYSxLQUFLLE1BQUwsQ0FBWSxNQUE3QjtBQUNBLFlBQUksUUFBUSxLQUFLLFdBQUwsQ0FBaUIsSUFBakIsRUFBdUIsU0FBdkIsRUFBa0MsRUFBbEMsRUFBc0MsQ0FBQyxPQUFELEVBQVUsQ0FBVixDQUF0QyxFQUFvRCxlQUFwRCxDQUFaOztBQUVBLFlBQUksVUFBVSxJQUFWLElBQWtCLGVBQWUsS0FBSyxNQUFMLENBQVksTUFBakQsRUFBeUQ7QUFDckQsaUJBQUssTUFBTCxHQUFjLEtBQUssTUFBTCxDQUFZLEtBQVosQ0FBa0IsQ0FBbEIsRUFBcUIsZUFBckIsQ0FBZDs7QUFFQSxnQkFBSSxLQUFLLHNCQUFULEVBQWlDO0FBQzdCLHFCQUFLLElBQUksUUFBVCxJQUFxQixLQUFLLGtCQUExQixFQUE4QztBQUMxQywwQ0FBc0IsUUFBdEIsSUFBa0MsSUFBbEM7QUFDQSwyQkFBTyx3QkFBd0IsUUFBeEIsQ0FBUDtBQUNIO0FBQ0QscUJBQUssSUFBSSxVQUFULElBQXVCLEtBQUssb0JBQTVCLEVBQWtEO0FBQzlDLHdCQUFJLENBQUMsc0JBQXNCLFVBQXRCLENBQUwsRUFBd0M7QUFDcEMsZ0RBQXdCLFVBQXhCLElBQXNDLElBQXRDO0FBQ0g7QUFDSjtBQUNEO0FBQ0EsNkJBQWEsS0FBYjtBQUNBO0FBQ0g7O0FBRUQsbUJBQU8sSUFBUDtBQUNIO0FBQ0QsWUFBSSxLQUFKLEVBQVc7QUFDUCxtQkFBTyxJQUFQLENBQVksTUFBTSxVQUFOLENBQWlCLElBQWpCLEVBQXVCLEtBQUssQ0FBNUIsRUFBK0IsVUFBL0IsQ0FBMEMsSUFBMUMsRUFBZ0QsT0FBaEQsQ0FBWjtBQUNIO0FBQ0o7QUFDRCxRQUFJLEtBQUssc0JBQVQsRUFBaUM7QUFDN0IsYUFBSyxvQkFBTCxHQUE0Qix1QkFBNUI7QUFDQSxhQUFLLGtCQUFMLEdBQTBCLHFCQUExQjtBQUNIO0FBQ0QsUUFBSSxVQUFKLEVBQWdCO0FBQ1osaUJBQVMsT0FBTyxNQUFQLENBQWMsS0FBSyxNQUFMLENBQVksS0FBWixDQUFrQixlQUFsQixDQUFkLENBQVQ7QUFDQSxhQUFLLE1BQUwsR0FBYyxLQUFLLE1BQUwsQ0FBWSxLQUFaLENBQWtCLENBQWxCLEVBQXFCLGVBQXJCLENBQWQ7QUFDQSxlQUFPLEtBQUssV0FBTCxDQUFpQixXQUFXLGNBQTVCLEVBQTRDLEVBQTVDLEVBQWdELEVBQWhELEVBQW9ELFFBQXBELEVBQThELE1BQTlELEVBQXNFLElBQXRFLEVBQTRFLE1BQTVFLENBQVA7QUFDSDtBQUNKLENBdkREOztBQXlEQSxpQkFBaUIsU0FBakIsQ0FBMkIsYUFBM0IsR0FBMkMsU0FBUyxhQUFULENBQXVCLElBQXZCLEVBQTZCLE1BQTdCLEVBQXFDLGVBQXJDLEVBQXNEO0FBQzdGLFFBQUksT0FBTyxLQUFQLEtBQWlCLFNBQXJCLEVBQWdDO0FBQzVCLGVBQU8sSUFBUDtBQUNIO0FBQ0QsUUFBSSxhQUFhLElBQWpCO0FBQ0EsUUFBSSxTQUFTLEVBQWI7QUFDQSxRQUFJLGtCQUFrQixLQUFLLE1BQUwsQ0FBWSxNQUFsQztBQUNBLFFBQUksdUJBQUosRUFBNkIscUJBQTdCO0FBQ0EsUUFBSSxLQUFLLHNCQUFULEVBQWlDO0FBQzdCLGtDQUEwQixLQUFLLG9CQUEvQjtBQUNBLGdDQUF3QixLQUFLLGtCQUE3QjtBQUNIO0FBQ0QsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE9BQU8sS0FBUCxDQUFhLE1BQWpDLEVBQXlDLEdBQXpDLEVBQThDO0FBQzFDLFlBQUksS0FBSyxzQkFBVCxFQUFpQztBQUM3QixpQkFBSyxvQkFBTCxHQUE0QixFQUE1QjtBQUNBLGlCQUFLLGtCQUFMLEdBQTBCLEVBQTFCO0FBQ0g7QUFDRCxZQUFJLFlBQVksT0FBTyxLQUFQLENBQWEsQ0FBYixDQUFoQjs7QUFFQSxZQUFJLGFBQWEsS0FBSyxNQUFMLENBQVksTUFBN0I7QUFDQSxZQUFJLFFBQVEsS0FBSyxXQUFMLENBQWlCLElBQWpCLEVBQXVCLFNBQXZCLEVBQWtDLEVBQWxDLEVBQXNDLENBQUMsT0FBRCxFQUFVLENBQVYsQ0FBdEMsRUFBb0QsZUFBcEQsQ0FBWjs7QUFFQSxZQUFJLFVBQVUsSUFBVixJQUFrQixlQUFlLEtBQUssTUFBTCxDQUFZLE1BQWpELEVBQXlEO0FBQ3JELGdCQUFJLGVBQWUsSUFBbkIsRUFBeUI7QUFDckIsNkJBQWEsQ0FBYjtBQUNILGFBRkQsTUFFTztBQUNILHFCQUFLLE1BQUwsR0FBYyxLQUFLLE1BQUwsQ0FBWSxLQUFaLENBQWtCLENBQWxCLEVBQXFCLGVBQXJCLENBQWQ7QUFDQSx1QkFBTyxLQUFLLFdBQUwsQ0FBaUIsV0FBVyxlQUE1QixFQUE2QztBQUNoRCw0QkFBUSxVQUR3QztBQUVoRCw0QkFBUTtBQUZ3QyxpQkFBN0MsRUFHSixFQUhJLEVBR0EsUUFIQSxFQUdVLElBSFYsRUFHZ0IsSUFIaEIsRUFHc0IsTUFIdEIsQ0FBUDtBQUlIO0FBQ0QsZ0JBQUksS0FBSyxzQkFBVCxFQUFpQztBQUM3QixxQkFBSyxJQUFJLFFBQVQsSUFBcUIsS0FBSyxrQkFBMUIsRUFBOEM7QUFDMUMsMENBQXNCLFFBQXRCLElBQWtDLElBQWxDO0FBQ0EsMkJBQU8sd0JBQXdCLFFBQXhCLENBQVA7QUFDSDtBQUNELHFCQUFLLElBQUksVUFBVCxJQUF1QixLQUFLLG9CQUE1QixFQUFrRDtBQUM5Qyx3QkFBSSxDQUFDLHNCQUFzQixVQUF0QixDQUFMLEVBQXdDO0FBQ3BDLGdEQUF3QixVQUF4QixJQUFzQyxJQUF0QztBQUNIO0FBQ0o7QUFDSjtBQUNKLFNBckJELE1BcUJPLElBQUksS0FBSixFQUFXO0FBQ2QsbUJBQU8sSUFBUCxDQUFZLEtBQVo7QUFDSDtBQUNKO0FBQ0QsUUFBSSxLQUFLLHNCQUFULEVBQWlDO0FBQzdCLGFBQUssb0JBQUwsR0FBNEIsdUJBQTVCO0FBQ0EsYUFBSyxrQkFBTCxHQUEwQixxQkFBMUI7QUFDSDtBQUNELFFBQUksZUFBZSxJQUFuQixFQUF5QjtBQUNyQixpQkFBUyxPQUFPLE1BQVAsQ0FBYyxLQUFLLE1BQUwsQ0FBWSxLQUFaLENBQWtCLGVBQWxCLENBQWQsQ0FBVDtBQUNBLGFBQUssTUFBTCxHQUFjLEtBQUssTUFBTCxDQUFZLEtBQVosQ0FBa0IsQ0FBbEIsRUFBcUIsZUFBckIsQ0FBZDtBQUNBLGVBQU8sS0FBSyxXQUFMLENBQWlCLFdBQVcsY0FBNUIsRUFBNEMsRUFBNUMsRUFBZ0QsRUFBaEQsRUFBb0QsUUFBcEQsRUFBOEQsTUFBOUQsRUFBc0UsSUFBdEUsRUFBNEUsTUFBNUUsQ0FBUDtBQUNILEtBSkQsTUFJTztBQUNILGFBQUssTUFBTCxHQUFjLEtBQUssTUFBTCxDQUFZLEtBQVosQ0FBa0IsQ0FBbEIsRUFBcUIsZUFBckIsQ0FBZDtBQUNIO0FBQ0QsV0FBTyxJQUFQO0FBQ0gsQ0EzREQ7O0FBNkRBLGlCQUFpQixTQUFqQixDQUEyQixXQUEzQixHQUF5QyxTQUFTLFdBQVQsQ0FBcUIsSUFBckIsRUFBMkIsTUFBM0IsRUFBbUMsZUFBbkMsRUFBb0Q7QUFDekYsUUFBSSxPQUFPLEdBQVAsS0FBZSxTQUFuQixFQUE4QjtBQUMxQixlQUFPLElBQVA7QUFDSDtBQUNELFFBQUksZ0JBQWdCLEtBQUssTUFBTCxDQUFZLE1BQWhDO0FBQ0EsUUFBSSx1QkFBSixFQUE2QixxQkFBN0I7QUFDQSxRQUFJLEtBQUssc0JBQVQsRUFBaUM7QUFDN0Isa0NBQTBCLEtBQUssb0JBQS9CO0FBQ0EsZ0NBQXdCLEtBQUssa0JBQTdCO0FBQ0EsYUFBSyxvQkFBTCxHQUE0QixFQUE1QjtBQUNBLGFBQUssa0JBQUwsR0FBMEIsRUFBMUI7QUFDSDtBQUNELFFBQUksUUFBUSxLQUFLLFdBQUwsQ0FBaUIsSUFBakIsRUFBdUIsT0FBTyxHQUE5QixFQUFtQyxJQUFuQyxFQUF5QyxJQUF6QyxFQUErQyxlQUEvQyxDQUFaO0FBQ0EsUUFBSSxZQUFZLEtBQUssTUFBTCxDQUFZLEtBQVosQ0FBa0IsYUFBbEIsQ0FBaEI7QUFDQSxTQUFLLE1BQUwsR0FBYyxLQUFLLE1BQUwsQ0FBWSxLQUFaLENBQWtCLENBQWxCLEVBQXFCLGFBQXJCLENBQWQ7QUFDQSxRQUFJLEtBQUssc0JBQVQsRUFBaUM7QUFDN0IsYUFBSyxvQkFBTCxHQUE0Qix1QkFBNUI7QUFDQSxhQUFLLGtCQUFMLEdBQTBCLHFCQUExQjtBQUNIO0FBQ0QsUUFBSSxVQUFVLElBQVYsSUFBa0IsVUFBVSxNQUFWLEtBQXFCLENBQTNDLEVBQThDO0FBQzFDLGVBQU8sS0FBSyxXQUFMLENBQWlCLFdBQVcsVUFBNUIsRUFBd0MsRUFBeEMsRUFBNEMsRUFBNUMsRUFBZ0QsTUFBaEQsRUFBd0QsSUFBeEQsRUFBOEQsSUFBOUQsRUFBb0UsTUFBcEUsQ0FBUDtBQUNIO0FBQ0QsV0FBTyxJQUFQO0FBQ0gsQ0F2QkQ7O0FBeUJBLGlCQUFpQixTQUFqQixDQUEyQixrQkFBM0IsR0FBZ0QsU0FBUyxvQkFBVCxDQUE4QixJQUE5QixFQUFvQyxNQUFwQyxFQUE0QyxlQUE1QyxFQUE2RDtBQUN6RyxRQUFJLENBQUMsT0FBTyxLQUFaLEVBQW1CO0FBQ2YsZUFBTyxJQUFQO0FBQ0g7QUFDRCxRQUFJLEtBQUo7QUFDQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksT0FBTyxLQUFQLENBQWEsTUFBakMsRUFBeUMsR0FBekMsRUFBOEM7QUFDMUMsWUFBSSxNQUFNLE9BQU8sS0FBUCxDQUFhLENBQWIsQ0FBVjtBQUNBLFlBQUksSUFBSSxHQUFKLEtBQVksYUFBaEIsRUFBK0I7QUFDM0IsZ0JBQUksV0FBVyxJQUFJLFdBQUosQ0FBZ0IsSUFBSSxJQUFwQixDQUFmO0FBQ0EsZ0JBQUksYUFBYSxJQUFqQjtBQUNBLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksU0FBUyxRQUFULENBQWtCLE1BQXRDLEVBQThDLEdBQTlDLEVBQW1EO0FBQy9DLG9CQUFJLEVBQUUsU0FBUyxRQUFULENBQWtCLENBQWxCLEtBQXdCLElBQTFCLENBQUosRUFBcUM7QUFDakMsaUNBQWEsS0FBYjtBQUNBO0FBQ0g7QUFDSjtBQUNELGdCQUFJLFVBQUosRUFBZ0I7QUFDWixvQkFBSSxZQUFZLFNBQVMsY0FBVCxDQUF3QixJQUF4QixDQUFoQjtBQUNBLG9CQUFJLFlBQVksRUFBQyxRQUFRLFNBQVQsRUFBaEI7QUFDQSxvQkFBSSxRQUFRLEtBQUssV0FBTCxDQUFpQixJQUFqQixFQUF1QixTQUF2QixFQUFrQyxFQUFsQyxFQUFzQyxDQUFDLE9BQUQsRUFBVSxDQUFWLENBQXRDLEVBQW9ELGVBQXBELENBQVosRUFBa0Y7QUFDOUUsMkJBQU8sS0FBUDtBQUNIO0FBQ0o7QUFDSjtBQUNKO0FBQ0osQ0F6QkQ7O0FBMkJBO0FBQ0E7O0FBRUEsU0FBUyxRQUFULENBQWtCLEdBQWxCLEVBQXVCO0FBQ25CLFFBQUksSUFBSSxPQUFPLEdBQVAsRUFBWSxPQUFaLENBQW9CLFlBQXBCLEVBQWtDLEVBQWxDLEVBQXNDLEtBQXRDLENBQTRDLG9HQUE1QyxDQUFSO0FBQ0E7QUFDQSxXQUFRLElBQUk7QUFDUixjQUFNLEVBQUUsQ0FBRixLQUFRLEVBRE47QUFFUixrQkFBVSxFQUFFLENBQUYsS0FBUSxFQUZWO0FBR1IsbUJBQVcsRUFBRSxDQUFGLEtBQVEsRUFIWDtBQUlSLGNBQU0sRUFBRSxDQUFGLEtBQVEsRUFKTjtBQUtSLGtCQUFVLEVBQUUsQ0FBRixLQUFRLEVBTFY7QUFNUixjQUFNLEVBQUUsQ0FBRixLQUFRLEVBTk47QUFPUixrQkFBVSxFQUFFLENBQUYsS0FBUSxFQVBWO0FBUVIsZ0JBQVEsRUFBRSxDQUFGLEtBQVEsRUFSUjtBQVNSLGNBQU0sRUFBRSxDQUFGLEtBQVE7QUFUTixLQUFKLEdBVUosSUFWSjtBQVdIOztBQUVELFNBQVMsVUFBVCxDQUFvQixJQUFwQixFQUEwQixJQUExQixFQUFnQztBQUFDOztBQUU3QixhQUFTLGlCQUFULENBQTJCLEtBQTNCLEVBQWtDO0FBQzlCLFlBQUksU0FBUyxFQUFiO0FBQ0EsY0FBTSxPQUFOLENBQWMsaUJBQWQsRUFBaUMsRUFBakMsRUFDSyxPQURMLENBQ2EsZ0JBRGIsRUFDK0IsR0FEL0IsRUFFSyxPQUZMLENBRWEsU0FGYixFQUV3QixNQUZ4QixFQUdLLE9BSEwsQ0FHYSxZQUhiLEVBRzJCLFVBQVUsQ0FBVixFQUFhO0FBQ2hDLGdCQUFJLE1BQU0sS0FBVixFQUFpQjtBQUNiLHVCQUFPLEdBQVA7QUFDSCxhQUZELE1BRU87QUFDSCx1QkFBTyxJQUFQLENBQVksQ0FBWjtBQUNIO0FBQ0osU0FUTDtBQVVBLGVBQU8sT0FBTyxJQUFQLENBQVksRUFBWixFQUFnQixPQUFoQixDQUF3QixLQUF4QixFQUErQixNQUFNLE1BQU4sQ0FBYSxDQUFiLE1BQW9CLEdBQXBCLEdBQTBCLEdBQTFCLEdBQWdDLEVBQS9ELENBQVA7QUFDSDs7QUFFRCxXQUFPLFNBQVMsUUFBUSxFQUFqQixDQUFQO0FBQ0EsV0FBTyxTQUFTLFFBQVEsRUFBakIsQ0FBUDs7QUFFQSxXQUFPLENBQUMsSUFBRCxJQUFTLENBQUMsSUFBVixHQUFpQixJQUFqQixHQUF3QixDQUFDLEtBQUssUUFBTCxJQUFpQixLQUFLLFFBQXZCLEtBQzlCLEtBQUssUUFBTCxJQUFpQixLQUFLLFNBQXRCLEdBQWtDLEtBQUssU0FBdkMsR0FBbUQsS0FBSyxTQUQxQixJQUUvQixrQkFBa0IsS0FBSyxRQUFMLElBQWlCLEtBQUssU0FBdEIsSUFBbUMsS0FBSyxRQUFMLENBQWMsTUFBZCxDQUFxQixDQUFyQixNQUE0QixHQUEvRCxHQUFxRSxLQUFLLFFBQTFFLEdBQXNGLEtBQUssUUFBTCxHQUFpQixDQUFDLEtBQUssU0FBTCxJQUFrQixDQUFDLEtBQUssUUFBeEIsR0FBbUMsR0FBbkMsR0FBeUMsRUFBMUMsSUFBZ0QsS0FBSyxRQUFMLENBQWMsS0FBZCxDQUFvQixDQUFwQixFQUF1QixLQUFLLFFBQUwsQ0FBYyxXQUFkLENBQTBCLEdBQTFCLElBQWlDLENBQXhELENBQWhELEdBQTZHLEtBQUssUUFBbkksR0FBK0ksS0FBSyxRQUE1UCxDQUYrQixJQUc5QixLQUFLLFFBQUwsSUFBaUIsS0FBSyxTQUF0QixJQUFtQyxLQUFLLFFBQXhDLEdBQW1ELEtBQUssTUFBeEQsR0FBa0UsS0FBSyxNQUFMLElBQWUsS0FBSyxNQUh4RCxJQUkvQixLQUFLLElBSkw7QUFLSDs7QUFFRCxTQUFTLGNBQVQsQ0FBd0IsR0FBeEIsRUFBNkI7QUFDekIsV0FBTyxJQUFJLEtBQUosQ0FBVSxHQUFWLEVBQWUsQ0FBZixDQUFQO0FBQ0g7O0FBRUQsU0FBUyxVQUFULENBQW9CLE1BQXBCLEVBQTRCLE9BQTVCLEVBQXFDO0FBQ2pDLFFBQUksVUFBVSxRQUFPLE1BQVAsdURBQU8sTUFBUCxPQUFrQixRQUFoQyxFQUEwQztBQUN0QyxZQUFJLFlBQVksU0FBaEIsRUFBMkI7QUFDdkIsc0JBQVUsT0FBTyxFQUFqQjtBQUNILFNBRkQsTUFFTyxJQUFJLE9BQU8sT0FBTyxFQUFkLEtBQXFCLFFBQXpCLEVBQW1DO0FBQ3RDLHNCQUFVLFdBQVcsT0FBWCxFQUFvQixPQUFPLEVBQTNCLENBQVY7QUFDQSxtQkFBTyxFQUFQLEdBQVksT0FBWjtBQUNIO0FBQ0QsWUFBSSxNQUFNLE9BQU4sQ0FBYyxNQUFkLENBQUosRUFBMkI7QUFDdkIsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxPQUFPLE1BQTNCLEVBQW1DLEdBQW5DLEVBQXdDO0FBQ3BDLDJCQUFXLE9BQU8sQ0FBUCxDQUFYLEVBQXNCLE9BQXRCO0FBQ0g7QUFDSixTQUpELE1BSU87QUFDSCxnQkFBSSxPQUFPLE9BQU8sTUFBUCxDQUFQLEtBQTBCLFFBQTlCLEVBQXdDO0FBQ3BDLHVCQUFPLE1BQVAsSUFBaUIsV0FBVyxPQUFYLEVBQW9CLE9BQU8sTUFBUCxDQUFwQixDQUFqQjtBQUNIO0FBQ0QsaUJBQUssSUFBSSxHQUFULElBQWdCLE1BQWhCLEVBQXdCO0FBQ3BCLG9CQUFJLFFBQVEsTUFBWixFQUFvQjtBQUNoQiwrQkFBVyxPQUFPLEdBQVAsQ0FBWCxFQUF3QixPQUF4QjtBQUNIO0FBQ0o7QUFDSjtBQUNKO0FBQ0o7O0FBRUQsU0FBUyxvQkFBVCxDQUE4QixRQUE5QixFQUF3QztBQUNwQyxlQUFXLFlBQVksSUFBdkI7O0FBRUEsUUFBSSxnQkFBZ0IsVUFBVSxRQUFWLENBQXBCOztBQUVBLFdBQU8sVUFBVSxLQUFWLEVBQWlCO0FBQ3BCLFlBQUksa0JBQWtCLGNBQWMsTUFBTSxJQUFwQixLQUE2QixxQkFBcUIsTUFBTSxJQUEzQixDQUFuRDtBQUNBLFlBQUksT0FBTyxlQUFQLEtBQTJCLFFBQS9CLEVBQXlDO0FBQ3JDLG1CQUFPLHdCQUF3QixNQUFNLElBQTlCLEdBQXFDLElBQXJDLEdBQTRDLHlCQUFlLE1BQU0sYUFBckIsQ0FBbkQ7QUFDSDtBQUNELFlBQUksZ0JBQWdCLE1BQU0sTUFBMUI7QUFDQTtBQUNBLGVBQU8sZ0JBQWdCLE9BQWhCLENBQXdCLGVBQXhCLEVBQXlDLFVBQVUsS0FBVixFQUFpQixPQUFqQixFQUEwQjtBQUN0RSxnQkFBSSxXQUFXLGNBQWMsT0FBZCxDQUFmO0FBQ0EsbUJBQU8sT0FBTyxRQUFQLEtBQW9CLFFBQXBCLElBQWdDLE9BQU8sUUFBUCxLQUFvQixRQUFwRCxHQUErRCxRQUEvRCxHQUEwRSxLQUFqRjtBQUNILFNBSE0sQ0FBUDtBQUlILEtBWEQ7QUFZSDs7QUFFRCxJQUFJLGFBQWE7QUFDYixrQkFBYyxDQUREO0FBRWIsbUJBQWUsQ0FGRjtBQUdiLG9CQUFnQixFQUhIO0FBSWIsb0JBQWdCLEVBSkg7QUFLYixxQkFBaUIsRUFMSjtBQU1iLGdCQUFZLEVBTkM7QUFPYjtBQUNBLHdCQUFvQixHQVJQO0FBU2Isb0JBQWdCLEdBVEg7QUFVYiw4QkFBMEIsR0FWYjtBQVdiLG9CQUFnQixHQVhIO0FBWWIsOEJBQTBCLEdBWmI7QUFhYix5QkFBcUIsR0FiUjtBQWNiO0FBQ0EseUJBQXFCLEdBZlI7QUFnQmIsd0JBQW9CLEdBaEJQO0FBaUJiLG9CQUFnQixHQWpCSDtBQWtCYjtBQUNBLCtCQUEyQixHQW5CZDtBQW9CYiwrQkFBMkIsR0FwQmQ7QUFxQmIscUJBQWlCLEdBckJKO0FBc0JiLGtDQUE4QixHQXRCakI7QUF1QmIsMkJBQXVCLEdBdkJWO0FBd0JiO0FBQ0Esd0JBQW9CLEdBekJQO0FBMEJiLHVCQUFtQixHQTFCTjtBQTJCYixrQkFBYyxHQTNCRDtBQTRCYiw0QkFBd0IsR0E1Qlg7QUE2QmI7QUFDQSxtQkFBZSxHQTlCRjtBQStCYixvQkFBZ0IsR0EvQkg7QUFnQ2I7QUFDQSx3QkFBb0IsR0FqQ1A7QUFrQ2I7QUFDQSxzQkFBa0I7QUFuQ0wsQ0FBakI7QUFxQ0EsSUFBSSxrQkFBa0IsRUFBdEI7QUFDQSxLQUFLLElBQUksR0FBVCxJQUFnQixVQUFoQixFQUE0QjtBQUN4QixvQkFBZ0IsV0FBVyxHQUFYLENBQWhCLElBQW1DLEdBQW5DO0FBQ0g7QUFDRCxJQUFJLHVCQUF1QjtBQUN2QixrQkFBYyw0Q0FEUztBQUV2QixtQkFBZSw0QkFGUTtBQUd2QixvQkFBZ0IsZ0RBSE87QUFJdkIsb0JBQWdCLGdEQUpPO0FBS3ZCLHFCQUFpQiwwRkFMTTtBQU12QixnQkFBWSxrQ0FOVztBQU92QjtBQUNBLHdCQUFvQixpREFSRztBQVN2QixvQkFBZ0IsOENBVE87QUFVdkIsOEJBQTBCLHVEQVZIO0FBV3ZCLG9CQUFnQixpREFYTztBQVl2Qiw4QkFBMEIsdURBWkg7QUFhdkIseUJBQXFCLHFDQWJFO0FBY3ZCO0FBQ0EseUJBQXFCLHlEQWZFO0FBZ0J2Qix3QkFBb0Isd0RBaEJHO0FBaUJ2QixvQkFBZ0IsMENBakJPO0FBa0J2QjtBQUNBLCtCQUEyQixpRUFuQko7QUFvQnZCLCtCQUEyQixrRUFwQko7QUFxQnZCLHFCQUFpQixrQ0FyQk07QUFzQnZCLGtDQUE4QixtQ0F0QlA7QUF1QnZCLDJCQUF1QixtRUF2QkE7QUF3QnZCO0FBQ0Esd0JBQW9CLGtEQXpCRztBQTBCdkIsdUJBQW1CLGlEQTFCSTtBQTJCdkIsa0JBQWMsNERBM0JTO0FBNEJ2Qiw0QkFBd0IsOEJBNUJEO0FBNkJ2QjtBQUNBLG1CQUFlLHNDQTlCUTtBQStCdkIsb0JBQWdCLG1DQS9CTztBQWdDdkI7QUFDQSx3QkFBb0Isd0JBakNHO0FBa0N2QjtBQUNBLHNCQUFrQjtBQW5DSyxDQUEzQjs7QUFzQ0EsU0FBUyxlQUFULENBQXlCLElBQXpCLEVBQStCLE1BQS9CLEVBQXVDLFFBQXZDLEVBQWlELFVBQWpELEVBQTZELFNBQTdELEVBQXdFO0FBQ3BFLFVBQU0sSUFBTixDQUFXLElBQVg7QUFDQSxRQUFJLFNBQVMsU0FBYixFQUF3QjtBQUNwQixjQUFNLElBQUksS0FBSixDQUFVLDZCQUE2QixVQUF2QyxDQUFOO0FBQ0g7QUFDRCxTQUFLLE9BQUwsR0FBZSxFQUFmO0FBQ0EsU0FBSyxNQUFMLEdBQWMsTUFBZDtBQUNBLFNBQUssSUFBTCxHQUFZLElBQVo7QUFDQSxTQUFLLFFBQUwsR0FBZ0IsWUFBWSxFQUE1QjtBQUNBLFNBQUssVUFBTCxHQUFrQixjQUFjLEVBQWhDO0FBQ0EsU0FBSyxTQUFMLEdBQWlCLGFBQWEsSUFBOUI7O0FBRUEsUUFBSSxNQUFNLElBQUksS0FBSixDQUFVLEtBQUssT0FBZixDQUFWO0FBQ0EsU0FBSyxLQUFMLEdBQWEsSUFBSSxLQUFKLElBQWEsSUFBSSxVQUE5QjtBQUNBLFFBQUksQ0FBQyxLQUFLLEtBQVYsRUFBaUI7QUFDYixZQUFJO0FBQ0Esa0JBQU0sR0FBTjtBQUNILFNBRkQsQ0FHQSxPQUFPLEdBQVAsRUFBWTtBQUNSLGlCQUFLLEtBQUwsR0FBYSxJQUFJLEtBQUosSUFBYSxJQUFJLFVBQTlCO0FBQ0g7QUFDSjtBQUNKOztBQUVELGdCQUFnQixTQUFoQixHQUE0QixzQkFBYyxNQUFNLFNBQXBCLENBQTVCO0FBQ0EsZ0JBQWdCLFNBQWhCLENBQTBCLFdBQTFCLEdBQXdDLGVBQXhDO0FBQ0EsZ0JBQWdCLFNBQWhCLENBQTBCLElBQTFCLEdBQWlDLGlCQUFqQzs7QUFFQSxnQkFBZ0IsU0FBaEIsQ0FBMEIsVUFBMUIsR0FBdUMsVUFBVSxVQUFWLEVBQXNCLFlBQXRCLEVBQW9DO0FBQ3ZFLFFBQUksZUFBZSxJQUFuQixFQUF5QjtBQUNyQixxQkFBYSxXQUFXLE9BQVgsQ0FBbUIsSUFBbkIsRUFBeUIsSUFBekIsRUFBK0IsT0FBL0IsQ0FBdUMsS0FBdkMsRUFBOEMsSUFBOUMsQ0FBYjtBQUNBLGFBQUssUUFBTCxHQUFnQixNQUFNLFVBQU4sR0FBbUIsS0FBSyxRQUF4QztBQUNIO0FBQ0QsUUFBSSxpQkFBaUIsSUFBckIsRUFBMkI7QUFDdkIsdUJBQWUsYUFBYSxPQUFiLENBQXFCLElBQXJCLEVBQTJCLElBQTNCLEVBQWlDLE9BQWpDLENBQXlDLEtBQXpDLEVBQWdELElBQWhELENBQWY7QUFDQSxhQUFLLFVBQUwsR0FBa0IsTUFBTSxZQUFOLEdBQXFCLEtBQUssVUFBNUM7QUFDSDtBQUNELFFBQUksS0FBSyxTQUFMLEtBQW1CLElBQXZCLEVBQTZCO0FBQ3pCLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLFNBQUwsQ0FBZSxNQUFuQyxFQUEyQyxHQUEzQyxFQUFnRDtBQUM1QyxpQkFBSyxTQUFMLENBQWUsQ0FBZixFQUFrQixVQUFsQixDQUE2QixVQUE3QixFQUF5QyxZQUF6QztBQUNIO0FBQ0o7QUFDRCxXQUFPLElBQVA7QUFDSCxDQWZEOztBQWlCQSxTQUFTLFlBQVQsQ0FBc0IsT0FBdEIsRUFBK0IsT0FBL0IsRUFBd0M7QUFDcEMsUUFBSSxRQUFRLFNBQVIsQ0FBa0IsQ0FBbEIsRUFBcUIsUUFBUSxNQUE3QixNQUF5QyxPQUE3QyxFQUFzRDtBQUNsRCxZQUFJLFlBQVksUUFBUSxTQUFSLENBQWtCLFFBQVEsTUFBMUIsQ0FBaEI7QUFDQSxZQUFLLFFBQVEsTUFBUixHQUFpQixDQUFqQixJQUFzQixRQUFRLE1BQVIsQ0FBZSxRQUFRLE1BQVIsR0FBaUIsQ0FBaEMsTUFBdUMsR0FBOUQsSUFDRyxVQUFVLE1BQVYsQ0FBaUIsQ0FBakIsTUFBd0IsR0FEM0IsSUFFRyxVQUFVLE1BQVYsQ0FBaUIsQ0FBakIsTUFBd0IsR0FGL0IsRUFFb0M7QUFDaEMsbUJBQU8sSUFBUDtBQUNIO0FBQ0o7QUFDRCxXQUFPLEtBQVA7QUFDSDs7QUFFRCxJQUFJLFlBQVksRUFBaEI7O0FBRUEsU0FBUyxTQUFULENBQW1CLFFBQW5CLEVBQTZCO0FBQ3pCLFFBQUksZ0JBQWdCLElBQUksZ0JBQUosRUFBcEI7QUFDQSxRQUFJLGVBQUo7QUFDQSxRQUFJLG1CQUFKO0FBQ0EsUUFBSSxNQUFNO0FBQ04sMEJBQWtCLDBCQUFVLFFBQVYsRUFBb0I7QUFDbEMsZ0JBQUksT0FBTyxRQUFQLEtBQW9CLFFBQXhCLEVBQWtDO0FBQzlCLHVCQUFPLEtBQUssUUFBTCxDQUFjLFFBQWQsQ0FBUDtBQUNIO0FBQ0Qsa0NBQXNCLFFBQXRCO0FBQ0EsbUJBQU8sSUFBUDtBQUNILFNBUEs7QUFRTixtQkFBVyxxQkFBWTtBQUNuQiwwQkFBYyxTQUFkLENBQXdCLEtBQXhCLENBQThCLGFBQTlCLEVBQTZDLFNBQTdDO0FBQ0gsU0FWSztBQVdOLGtCQUFVLGtCQUFVLElBQVYsRUFBZ0I7QUFDdEIsZ0JBQUksQ0FBQyxJQUFMLEVBQVc7QUFDUCx1QkFBTyxlQUFQO0FBQ0g7QUFDRCxnQkFBSSxDQUFDLFVBQVUsSUFBVixDQUFMLEVBQXNCO0FBQ2xCLHVCQUFPLEtBQUssS0FBTCxDQUFXLEdBQVgsRUFBZ0IsQ0FBaEIsQ0FBUCxDQURrQixDQUNTO0FBQzlCO0FBQ0QsZ0JBQUksVUFBVSxJQUFWLENBQUosRUFBcUI7QUFDakIsa0NBQWtCLElBQWxCO0FBQ0EsdUJBQU8sSUFBUCxDQUZpQixDQUVKO0FBQ2hCO0FBQ0QsbUJBQU8sS0FBUDtBQUNILFNBdkJLO0FBd0JOLHFCQUFhLHFCQUFVLElBQVYsRUFBZ0IsVUFBaEIsRUFBNEI7QUFDckMsZ0JBQUksR0FBSjtBQUNBLGlCQUFLLEdBQUwsSUFBWSxVQUFaLEVBQXdCO0FBQ3BCLG9CQUFJLFdBQVcsR0FBWCxLQUFtQixDQUFDLFdBQVcsV0FBVyxHQUFYLENBQVgsQ0FBeEIsRUFBcUQ7QUFDakQsK0JBQVcsV0FBVyxHQUFYLENBQVgsSUFBOEIsV0FBVyxHQUFYLENBQTlCO0FBQ0g7QUFDSjtBQUNELGdCQUFJLFdBQVcsS0FBSyxLQUFMLENBQVcsR0FBWCxFQUFnQixDQUFoQixDQUFmO0FBQ0EsZ0JBQUksQ0FBQyxVQUFVLFFBQVYsQ0FBTCxFQUEwQjtBQUFFO0FBQ3hCLDBCQUFVLElBQVYsSUFBa0IsVUFBbEI7QUFDQSwwQkFBVSxRQUFWLElBQXNCLFVBQXRCO0FBQ0gsYUFIRCxNQUdPO0FBQ0gsMEJBQVUsSUFBVixJQUFrQixzQkFBYyxVQUFVLFFBQVYsQ0FBZCxDQUFsQjtBQUNBLHFCQUFLLEdBQUwsSUFBWSxVQUFaLEVBQXdCO0FBQ3BCLHdCQUFJLE9BQU8sVUFBVSxRQUFWLEVBQW9CLEdBQXBCLENBQVAsS0FBb0MsV0FBeEMsRUFBcUQ7QUFDakQsa0NBQVUsUUFBVixFQUFvQixHQUFwQixJQUEyQixXQUFXLEdBQVgsQ0FBM0I7QUFDSDtBQUNELDhCQUFVLElBQVYsRUFBZ0IsR0FBaEIsSUFBdUIsV0FBVyxHQUFYLENBQXZCO0FBQ0g7QUFDSjtBQUNELG1CQUFPLElBQVA7QUFDSCxTQTdDSztBQThDTixrQkFBVSxrQkFBVSxRQUFWLEVBQW9CO0FBQzFCLGdCQUFJLFNBQVMsV0FBYjtBQUNBLGdCQUFJLFFBQUosRUFBYztBQUNWLHVCQUFPLFFBQVAsQ0FBZ0IsUUFBaEI7QUFDSDtBQUNELG1CQUFPLE1BQVA7QUFDSCxTQXBESztBQXFETixrQkFBVSxrQkFBVSxJQUFWLEVBQWdCLE1BQWhCLEVBQXdCLGNBQXhCLEVBQXdDLG9CQUF4QyxFQUE4RDtBQUNwRSxnQkFBSSxNQUFNLHFCQUFxQixlQUFyQixDQUFWO0FBQ0EsZ0JBQUksZ0JBQWdCLHNCQUFzQixVQUFVLEtBQVYsRUFBaUIsSUFBakIsRUFBdUIsTUFBdkIsRUFBK0I7QUFDckUsdUJBQU8sb0JBQW9CLEtBQXBCLEVBQTJCLElBQTNCLEVBQWlDLE1BQWpDLEtBQTRDLElBQUksS0FBSixFQUFXLElBQVgsRUFBaUIsTUFBakIsQ0FBbkQ7QUFDSCxhQUZtQixHQUVoQixHQUZKO0FBR0EsZ0JBQUksVUFBVSxJQUFJLGdCQUFKLENBQXFCLGFBQXJCLEVBQW9DLEtBQXBDLEVBQTJDLGFBQTNDLEVBQTBELGNBQTFELEVBQTBFLG9CQUExRSxDQUFkO0FBQ0EsZ0JBQUksT0FBTyxNQUFQLEtBQWtCLFFBQXRCLEVBQWdDO0FBQzVCLHlCQUFTLEVBQUMsUUFBUSxNQUFULEVBQVQ7QUFDSDtBQUNELG9CQUFRLFNBQVIsQ0FBa0IsRUFBbEIsRUFBc0IsTUFBdEI7QUFDQSxnQkFBSSxRQUFRLFFBQVEsV0FBUixDQUFvQixJQUFwQixFQUEwQixNQUExQixFQUFrQyxJQUFsQyxFQUF3QyxJQUF4QyxFQUE4QyxFQUE5QyxDQUFaO0FBQ0EsZ0JBQUksQ0FBQyxLQUFELElBQVUsb0JBQWQsRUFBb0M7QUFDaEMsd0JBQVEsUUFBUSxvQkFBUixDQUE2QixJQUE3QixFQUFtQyxNQUFuQyxDQUFSO0FBQ0g7QUFDRCxpQkFBSyxLQUFMLEdBQWEsS0FBYjtBQUNBLGlCQUFLLE9BQUwsR0FBZSxRQUFRLE9BQXZCO0FBQ0EsaUJBQUssS0FBTCxHQUFjLFVBQVUsSUFBeEI7QUFDQSxtQkFBTyxLQUFLLEtBQVo7QUFDSCxTQXZFSztBQXdFTix3QkFBZ0IsMEJBQVk7QUFDeEIsZ0JBQUksU0FBUyxFQUFiO0FBQ0EsaUJBQUssUUFBTCxDQUFjLEtBQWQsQ0FBb0IsTUFBcEIsRUFBNEIsU0FBNUI7QUFDQSxtQkFBTyxNQUFQO0FBQ0gsU0E1RUs7QUE2RU4sMEJBQWtCLDBCQUFVLElBQVYsRUFBZ0IsTUFBaEIsRUFBd0IsY0FBeEIsRUFBd0Msb0JBQXhDLEVBQThEO0FBQzVFLGdCQUFJLE1BQU0scUJBQXFCLGVBQXJCLENBQVY7QUFDQSxnQkFBSSxnQkFBZ0Isc0JBQXNCLFVBQVUsS0FBVixFQUFpQixJQUFqQixFQUF1QixNQUF2QixFQUErQjtBQUNyRSx1QkFBTyxvQkFBb0IsS0FBcEIsRUFBMkIsSUFBM0IsRUFBaUMsTUFBakMsS0FBNEMsSUFBSSxLQUFKLEVBQVcsSUFBWCxFQUFpQixNQUFqQixDQUFuRDtBQUNILGFBRm1CLEdBRWhCLEdBRko7QUFHQSxnQkFBSSxVQUFVLElBQUksZ0JBQUosQ0FBcUIsYUFBckIsRUFBb0MsSUFBcEMsRUFBMEMsYUFBMUMsRUFBeUQsY0FBekQsRUFBeUUsb0JBQXpFLENBQWQ7QUFDQSxnQkFBSSxPQUFPLE1BQVAsS0FBa0IsUUFBdEIsRUFBZ0M7QUFDNUIseUJBQVMsRUFBQyxRQUFRLE1BQVQsRUFBVDtBQUNIO0FBQ0Qsb0JBQVEsU0FBUixDQUFrQixFQUFsQixFQUFzQixNQUF0QjtBQUNBLG9CQUFRLFdBQVIsQ0FBb0IsSUFBcEIsRUFBMEIsTUFBMUIsRUFBa0MsSUFBbEMsRUFBd0MsSUFBeEMsRUFBOEMsRUFBOUM7QUFDQSxnQkFBSSxvQkFBSixFQUEwQjtBQUN0Qix3QkFBUSxvQkFBUixDQUE2QixJQUE3QixFQUFtQyxNQUFuQztBQUNIO0FBQ0QsZ0JBQUksU0FBUyxFQUFiO0FBQ0EsbUJBQU8sTUFBUCxHQUFnQixRQUFRLE1BQXhCO0FBQ0EsbUJBQU8sT0FBUCxHQUFpQixRQUFRLE9BQXpCO0FBQ0EsbUJBQU8sS0FBUCxHQUFnQixPQUFPLE1BQVAsQ0FBYyxNQUFkLEtBQXlCLENBQXpDO0FBQ0EsbUJBQU8sTUFBUDtBQUNILFNBaEdLO0FBaUdOLG1CQUFXLHFCQUFZO0FBQ25CLG1CQUFPLGNBQWMsU0FBZCxDQUF3QixLQUF4QixDQUE4QixhQUE5QixFQUE2QyxTQUE3QyxDQUFQO0FBQ0gsU0FuR0s7QUFvR04sbUJBQVcscUJBQVk7QUFDbkIsbUJBQU8sY0FBYyxTQUFkLENBQXdCLEtBQXhCLENBQThCLGFBQTlCLEVBQTZDLFNBQTdDLENBQVA7QUFDSCxTQXRHSztBQXVHTixzQkFBYyx3QkFBWTtBQUN0QixtQkFBTyxjQUFjLFlBQWQsQ0FBMkIsS0FBM0IsQ0FBaUMsYUFBakMsRUFBZ0QsU0FBaEQsQ0FBUDtBQUNILFNBekdLO0FBMEdOLHVCQUFlLHlCQUFZO0FBQ3ZCLG1CQUFPLGNBQWMsYUFBZCxDQUE0QixLQUE1QixDQUFrQyxhQUFsQyxFQUFpRCxTQUFqRCxDQUFQO0FBQ0gsU0E1R0s7QUE2R04sd0JBQWdCLDBCQUFZO0FBQ3hCLG1CQUFPLGNBQWMsY0FBZCxDQUE2QixLQUE3QixDQUFtQyxhQUFuQyxFQUFrRCxTQUFsRCxDQUFQO0FBQ0gsU0EvR0s7QUFnSE4scUJBQWEsdUJBQVk7QUFDckIsMEJBQWMsV0FBZCxDQUEwQixLQUExQixDQUFnQyxhQUFoQyxFQUErQyxTQUEvQztBQUNILFNBbEhLO0FBbUhOLHVCQUFlLHlCQUFZO0FBQ3ZCLDBCQUFjLGFBQWQsQ0FBNEIsS0FBNUIsQ0FBa0MsYUFBbEMsRUFBaUQsU0FBakQ7QUFDSCxTQXJISztBQXNITixxQkFBYSxxQkFBVSxRQUFWLEVBQW9CLFVBQXBCLEVBQWdDLGNBQWhDLEVBQWdEO0FBQ3pELGdCQUFJLE9BQU8sUUFBUCxLQUFvQixRQUFwQixJQUFnQyxDQUFDLHFCQUFxQixJQUFyQixDQUEwQixRQUExQixDQUFyQyxFQUEwRTtBQUN0RSxzQkFBTSxJQUFJLEtBQUosQ0FBVSwyREFBVixDQUFOO0FBQ0g7QUFDRCxnQkFBSSxPQUFPLFVBQVAsS0FBc0IsUUFBdEIsSUFBa0MsYUFBYSxDQUFiLEtBQW1CLENBQXJELElBQTBELGFBQWEsS0FBM0UsRUFBa0Y7QUFDOUUsc0JBQU0sSUFBSSxLQUFKLENBQVUsd0NBQVYsQ0FBTjtBQUNIO0FBQ0QsZ0JBQUksT0FBTyxXQUFXLFFBQVgsQ0FBUCxLQUFnQyxXQUFwQyxFQUFpRDtBQUM3QyxzQkFBTSxJQUFJLEtBQUosQ0FBVSw0QkFBNEIsUUFBNUIsR0FBdUMsTUFBdkMsR0FBZ0QsV0FBVyxRQUFYLENBQTFELENBQU47QUFDSDtBQUNELGdCQUFJLE9BQU8sZ0JBQWdCLFVBQWhCLENBQVAsS0FBdUMsV0FBM0MsRUFBd0Q7QUFDcEQsc0JBQU0sSUFBSSxLQUFKLENBQVUsOEJBQThCLGdCQUFnQixVQUFoQixDQUE5QixHQUE0RCxNQUE1RCxHQUFxRSxVQUEvRSxDQUFOO0FBQ0g7QUFDRCx1QkFBVyxRQUFYLElBQXVCLFVBQXZCO0FBQ0EsNEJBQWdCLFVBQWhCLElBQThCLFFBQTlCO0FBQ0EsaUNBQXFCLFFBQXJCLElBQWlDLHFCQUFxQixVQUFyQixJQUFtQyxjQUFwRTtBQUNBLGlCQUFLLElBQUksUUFBVCxJQUFxQixTQUFyQixFQUFnQztBQUM1QixvQkFBSSxXQUFXLFVBQVUsUUFBVixDQUFmO0FBQ0Esb0JBQUksU0FBUyxRQUFULENBQUosRUFBd0I7QUFDcEIsNkJBQVMsVUFBVCxJQUF1QixTQUFTLFVBQVQsS0FBd0IsU0FBUyxRQUFULENBQS9DO0FBQ0g7QUFDSjtBQUNKLFNBNUlLO0FBNklOLGVBQU8saUJBQVk7QUFDZiwwQkFBYyxLQUFkO0FBQ0EsaUJBQUssS0FBTCxHQUFhLElBQWI7QUFDQSxpQkFBSyxPQUFMLEdBQWUsRUFBZjtBQUNBLGlCQUFLLEtBQUwsR0FBYSxJQUFiO0FBQ0gsU0FsSks7QUFtSk4saUJBQVMsRUFuSkg7QUFvSk4sZUFBTyxJQXBKRDtBQXFKTixlQUFPLElBckpEO0FBc0pOLG9CQUFZLFVBdEpOO0FBdUpOLG9CQUFZLFVBdkpOO0FBd0pOLHdCQUFnQixjQXhKVjtBQXlKTixvQkFBWTtBQXpKTixLQUFWO0FBMkpBLFFBQUksUUFBSixDQUFhLFlBQVksSUFBekI7QUFDQSxXQUFPLEdBQVA7QUFDSDs7QUFFRDtBQUNBLElBQUksTUFBTSxXQUFWO0FBQ0EsSUFBSSxXQUFKLENBQWdCLE9BQWhCLEVBQXlCLG9CQUF6Qjs7QUFFQTtBQUNBLElBQUksR0FBSixHQUFVLEdBQVY7QUFDQTtrQkFDZSxHO0FBQ2Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUNscERnQixTLEdBQUEsUztRQXdCQSxXLEdBQUEsVztRQWdCQSxXLEdBQUEsVztRQVNBLFMsR0FBQSxTO1FBS0EsaUIsR0FBQSxpQjtRQVVBLG1CLEdBQUEsbUI7UUFVQSxtQixHQUFBLG1CO1FBV0EsZ0IsR0FBQSxnQjtRQW1CQSxlLEdBQUEsZTtRQWVBLHlCLEdBQUEseUI7UUFnQkEsUSxHQUFBLFE7UUE0QkEsWSxHQUFBLFk7Ozs7QUEzTWhCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JBOzs7OztBQUtBOzs7Ozs7OztBQVFBOzs7OztBQUtPLFNBQVMsU0FBVCxDQUFtQixHQUFuQixFQUF3Qjs7QUFFN0IsTUFBSSxDQUFDLEdBQUwsRUFBVSxNQUFNLE1BQU0sd0JBQU4sQ0FBTjs7QUFFVjtBQUNBLE1BQUksS0FBSyxzRkFBVDtBQUNBLE1BQUksUUFBUSxVQUFaO0FBQ0EsTUFBSSxRQUFRLElBQUksT0FBSixDQUFZLEVBQVosRUFBZ0IsS0FBaEIsRUFBdUIsS0FBdkIsQ0FBNkIsR0FBN0IsQ0FBWjs7QUFFQTtBQUNBLE1BQUksTUFBTSxDQUFOLE1BQWEsR0FBakIsRUFBc0I7QUFDcEIsVUFBTSxDQUFOLElBQVcsT0FBWDtBQUNBLFVBQU0sQ0FBTixJQUFXLEdBQVg7QUFDRDs7QUFFRCxNQUFJLFNBQVM7QUFDWCxVQUFNLE1BQU0sQ0FBTixDQURLO0FBRVgsWUFBUSxNQUFNLENBQU4sQ0FGRztBQUdYLGNBQVUsTUFBTSxDQUFOO0FBSEMsR0FBYjs7QUFNQSxTQUFPLE1BQVA7QUFDRDs7QUFFTSxTQUFTLFdBQVQsQ0FBcUIsS0FBckIsRUFBNEI7QUFDakMsTUFBSSxZQUFZLE1BQU0sT0FBTixDQUFjLEdBQWQsQ0FBaEI7O0FBRUEsTUFBSSxTQUFTO0FBQ1gsY0FBVSxNQUFNLFNBQU4sQ0FBZ0IsQ0FBaEIsRUFBbUIsU0FBbkIsQ0FEQztBQUVYLFlBQVEsTUFBTSxTQUFOLENBQWdCLFlBQVksQ0FBNUIsRUFBK0IsTUFBTSxNQUFyQztBQUZHLEdBQWI7O0FBS0EsU0FBTyxNQUFQO0FBQ0Q7O0FBRUQ7Ozs7O0FBS08sU0FBUyxXQUFULENBQXFCLE1BQXJCLEVBQTZCO0FBQ2xDLFNBQU8sb0JBQVksTUFBWixFQUFvQixNQUFwQixHQUE2QixDQUE3QixHQUFpQyxLQUFqQyxHQUF5QyxJQUFoRDtBQUNEOztBQUVEOzs7OztBQUtPLFNBQVMsU0FBVCxDQUFtQixHQUFuQixFQUF3QjtBQUM3QjtBQUNBLE1BQUksR0FBSixFQUFTLE9BQU8sS0FBSyxLQUFMLENBQVcseUJBQWUsR0FBZixDQUFYLENBQVA7QUFDVjs7QUFFTSxTQUFTLGlCQUFULENBQTJCLEdBQTNCLEVBQWdDO0FBQ3JDLE1BQUksV0FBVyxJQUFJLEtBQUosQ0FBVSxHQUFWLENBQWY7QUFDQSxTQUFPLFNBQVMsQ0FBVCxJQUFjLElBQWQsR0FBcUIsU0FBUyxDQUFULENBQXJCLEdBQW1DLEdBQW5DLEdBQXlDLFNBQVMsQ0FBVCxDQUFoRDtBQUNEOztBQUVEOzs7OztBQUtPLFNBQVMsbUJBQVQsQ0FBNkIsU0FBN0IsRUFBd0M7QUFDN0MsTUFBSSxZQUFZLFVBQVUsT0FBVixDQUFrQixHQUFsQixDQUFoQjtBQUNBLFNBQU8sWUFBWSxVQUFVLFNBQVYsQ0FBb0IsWUFBWSxDQUFoQyxFQUFtQyxVQUFVLE1BQTdDLENBQVosR0FBbUUsR0FBbkUsR0FBeUUsVUFBVSxTQUFWLENBQW9CLENBQXBCLEVBQXVCLFNBQXZCLENBQWhGO0FBQ0Q7O0FBRUQ7Ozs7O0FBS08sU0FBUyxtQkFBVCxDQUE2QixPQUE3QixFQUFzQztBQUMzQyxNQUFJLE1BQU0sVUFBVSxPQUFWLENBQVY7QUFDQSxTQUFPLElBQUksUUFBSixDQUFhLE9BQWIsQ0FBcUIsR0FBckIsRUFBMEIsRUFBMUIsSUFBZ0MsR0FBaEMsR0FBc0MsSUFBSSxNQUFqRCxDQUYyQyxDQUVjO0FBQzFEOztBQUdEOzs7OztBQUtPLFNBQVMsZ0JBQVQsQ0FBMEIsVUFBMUIsRUFBc0M7O0FBRTNDO0FBQ0EsTUFBSSxXQUFXLFNBQVgsQ0FBcUIsQ0FBckIsRUFBd0IsQ0FBeEIsTUFBK0IsU0FBbkMsRUFBOEM7QUFDNUMsUUFBSSxhQUFhLFVBQVUsVUFBVixDQUFqQjs7QUFFQTtBQUNBLFFBQUksV0FBVyxNQUFYLElBQXFCLFdBQVcsUUFBcEMsRUFBOEM7QUFDNUMsYUFBTyxVQUFQO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsWUFBTSwyQkFBTjtBQUNEOztBQUVIO0FBQ0MsR0FYRCxNQVdPO0FBQ0wsV0FBTyxvQkFBb0IsVUFBcEIsQ0FBUDtBQUNEO0FBQ0Y7O0FBRU0sU0FBUyxlQUFULENBQXlCLEdBQXpCLEVBQThCO0FBQ25DLE1BQUksa0JBQWtCLENBQUMsWUFBRCxFQUFlLFNBQWYsRUFBMEIsUUFBMUIsRUFBb0MsU0FBcEMsQ0FBdEI7QUFDQSxNQUFJLFdBQVksR0FBRCxDQUFNLEtBQU4sQ0FBWSxLQUFaLENBQWY7QUFDQSxNQUFJLFlBQVksU0FBUyxDQUFULENBQWhCOztBQUVBLFNBQU8sZ0JBQWdCLE9BQWhCLENBQXdCLFNBQXhCLE1BQXVDLENBQUMsQ0FBL0M7QUFDRDs7QUFFRDs7Ozs7OztBQU9PLFNBQVMseUJBQVQsQ0FBbUMsYUFBbkMsRUFBa0QsU0FBbEQsRUFBNkQsUUFBN0QsRUFBdUU7QUFDNUUsTUFBSSxpQkFBaUIsY0FBYyxTQUFkLENBQXJCO0FBQ0EsTUFBSSxlQUFlLGVBQWUsUUFBZixDQUFuQjs7QUFFQSxTQUFPLFlBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7O0FBU08sU0FBUyxRQUFULENBQWtCLGFBQWxCLEVBQWlDLFNBQWpDLEVBQTRDLFFBQTVDLEVBQXNELElBQXRELEVBQWlGO0FBQUEsTUFBckIsV0FBcUIsdUVBQVAsS0FBTzs7QUFDdEYsTUFBSSxpQkFBaUIsY0FBYyxTQUFkLENBQXJCO0FBQ0EsTUFBSSxZQUFKOztBQUVBLE1BQUksQ0FBQyxlQUFlLGNBQWYsQ0FBOEIsUUFBOUIsQ0FBTCxFQUE4QztBQUM1QyxVQUFNLE1BQU0sdUJBQXVCLHlCQUFlLGNBQWYsRUFBK0IsRUFBL0IsRUFBbUMsQ0FBbkMsQ0FBdkIsR0FBK0QsbUJBQS9ELEdBQXFGLFFBQXJGLEdBQWdHLCtCQUF0RyxDQUFOO0FBQ0Q7O0FBRUQsTUFBSSxlQUFlLGVBQWUsUUFBZixDQUFuQjs7QUFFQSxNQUFJLElBQUosRUFBVTtBQUNSLFVBQU0sYUFBYSxNQUFiLEdBQXNCLGNBQWMsTUFBcEMsR0FBNkMsYUFBYSxNQUExRCxHQUFtRSxJQUF6RTtBQUNBLFFBQUksYUFBYSxjQUFiLENBQTRCLFVBQTVCLEtBQTJDLFdBQS9DLEVBQTREO0FBQzFELFVBQUksYUFBYSxRQUFiLENBQXNCLE9BQXRCLENBQThCLFVBQTlCLENBQUosRUFBK0M7QUFDN0MsY0FBTSxhQUFhLFFBQWIsQ0FBc0IsT0FBdEIsQ0FBOEIsYUFBOUIsRUFBNkMsY0FBYyxNQUEzRCxJQUFxRSxJQUEzRTtBQUNELE9BRkQsTUFFTztBQUNMLGNBQU0sYUFBYSxRQUFiLEdBQXdCLElBQTlCO0FBQ0Q7QUFDRjtBQUNGLEdBVEQsTUFTTztBQUNMLFVBQU0sYUFBYSxNQUFiLEdBQXNCLGNBQWMsTUFBcEMsR0FBNkMsYUFBYSxNQUFoRTtBQUNEOztBQUVEOztBQUVBLFNBQU8sR0FBUDtBQUNEOztBQUVNLFNBQVMsWUFBVCxHQUF3Qjs7QUFFN0IsV0FBUyxFQUFULEdBQWM7QUFDWixXQUFPLEtBQUssS0FBTCxDQUFXLENBQUMsSUFBSSxLQUFLLE1BQUwsRUFBTCxJQUFzQixPQUFqQyxFQUNKLFFBREksQ0FDSyxFQURMLEVBRUosU0FGSSxDQUVNLENBRk4sQ0FBUDtBQUdEOztBQUVELFNBQU8sT0FBTyxJQUFQLEdBQWMsR0FBZCxHQUFvQixJQUFwQixHQUEyQixHQUEzQixHQUFpQyxJQUFqQyxHQUF3QyxHQUF4QyxHQUE4QyxJQUE5QyxHQUFxRCxHQUFyRCxHQUEyRCxJQUEzRCxHQUFrRSxJQUFsRSxHQUF5RSxJQUFoRjtBQUVEIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIlwidXNlIHN0cmljdFwiO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9zaGltXCIpO1xuXG5yZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9mbi9yZWdleHAvZXNjYXBlXCIpO1xuXG5pZiAoZ2xvYmFsLl9iYWJlbFBvbHlmaWxsKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIm9ubHkgb25lIGluc3RhbmNlIG9mIGJhYmVsLXBvbHlmaWxsIGlzIGFsbG93ZWRcIik7XG59XG5nbG9iYWwuX2JhYmVsUG9seWZpbGwgPSB0cnVlO1xuXG52YXIgREVGSU5FX1BST1BFUlRZID0gXCJkZWZpbmVQcm9wZXJ0eVwiO1xuZnVuY3Rpb24gZGVmaW5lKE8sIGtleSwgdmFsdWUpIHtcbiAgT1trZXldIHx8IE9iamVjdFtERUZJTkVfUFJPUEVSVFldKE8sIGtleSwge1xuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSk7XG59XG5cbmRlZmluZShTdHJpbmcucHJvdG90eXBlLCBcInBhZExlZnRcIiwgXCJcIi5wYWRTdGFydCk7XG5kZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgXCJwYWRSaWdodFwiLCBcIlwiLnBhZEVuZCk7XG5cblwicG9wLHJldmVyc2Usc2hpZnQsa2V5cyx2YWx1ZXMsZW50cmllcyxpbmRleE9mLGV2ZXJ5LHNvbWUsZm9yRWFjaCxtYXAsZmlsdGVyLGZpbmQsZmluZEluZGV4LGluY2x1ZGVzLGpvaW4sc2xpY2UsY29uY2F0LHB1c2gsc3BsaWNlLHVuc2hpZnQsc29ydCxsYXN0SW5kZXhPZixyZWR1Y2UscmVkdWNlUmlnaHQsY29weVdpdGhpbixmaWxsXCIuc3BsaXQoXCIsXCIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBbXVtrZXldICYmIGRlZmluZShBcnJheSwga2V5LCBGdW5jdGlvbi5jYWxsLmJpbmQoW11ba2V5XSkpO1xufSk7IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2FycmF5L2Zyb21cIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnblwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZlwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvaXMtZnJvemVuXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9rZXlzXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2VcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIik7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmaW5lUHJvcGVydHkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCIpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpO1xuXG52YXIgX2dldE93blByb3BlcnR5RGVzY3JpcHRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuICB2YXIgZGVzYyA9ICgwLCBfZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yMi5kZWZhdWx0KShvYmplY3QsIHByb3BlcnR5KTtcblxuICBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHBhcmVudCA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKG9iamVjdCk7XG5cbiAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHtcbiAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7XG5cbiAgICBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTtcbiAgfVxufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9zZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpO1xuXG52YXIgX3NldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NldFByb3RvdHlwZU9mKTtcblxudmFyIF9jcmVhdGUgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvY3JlYXRlXCIpO1xuXG52YXIgX2NyZWF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGUpO1xuXG52YXIgX3R5cGVvZjIgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgKHR5cGVvZiBzdXBlckNsYXNzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShzdXBlckNsYXNzKSkpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gKDAsIF9jcmVhdGUyLmRlZmF1bHQpKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQgPyAoMCwgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0KShzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YyID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKCh0eXBlb2YgY2FsbCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoY2FsbCkpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2l0ZXJhdG9yID0gcmVxdWlyZShcIi4uL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yXCIpO1xuXG52YXIgX2l0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2l0ZXJhdG9yKTtcblxudmFyIF9zeW1ib2wgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9zeW1ib2xcIik7XG5cbnZhciBfc3ltYm9sMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N5bWJvbCk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgX2l0ZXJhdG9yMi5kZWZhdWx0ID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCAmJiBvYmogIT09IF9zeW1ib2wyLmRlZmF1bHQucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgX3R5cGVvZihfaXRlcmF0b3IyLmRlZmF1bHQpID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaik7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaik7XG59OyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvY29yZS5yZWdleHAuZXNjYXBlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5SZWdFeHAuZXNjYXBlOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuYXJyYXkuZnJvbScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuQXJyYXkuZnJvbTsiLCJ2YXIgY29yZSAgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJylcbiAgLCAkSlNPTiA9IGNvcmUuSlNPTiB8fCAoY29yZS5KU09OID0ge3N0cmluZ2lmeTogSlNPTi5zdHJpbmdpZnl9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RyaW5naWZ5KGl0KXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICByZXR1cm4gJEpTT04uc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmd1bWVudHMpO1xufTsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3QuYXNzaWduOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUnKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlKFAsIEQpe1xuICByZXR1cm4gJE9iamVjdC5jcmVhdGUoUCwgRCk7XG59OyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyl7XG4gIHJldHVybiAkT2JqZWN0LmRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpO1xufTsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KXtcbiAgcmV0dXJuICRPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpO1xufTsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmdldFByb3RvdHlwZU9mOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1mcm96ZW4nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5pc0Zyb3plbjsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmtleXM7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5zZXRQcm90b3R5cGVPZjsiLCJyZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYucHJvbWlzZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL19jb3JlJykuUHJvbWlzZTsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zeW1ib2wnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLlN5bWJvbDsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL193a3MtZXh0JykuZignaXRlcmF0b3InKTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKXtcbiAgaWYoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSB8fCAoZm9yYmlkZGVuRmllbGQgIT09IHVuZGVmaW5lZCAmJiBmb3JiaWRkZW5GaWVsZCBpbiBpdCkpe1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTsiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZighaXNPYmplY3QoaXQpKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTsiLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvTGVuZ3RoICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgdG9JbmRleCAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oSVNfSU5DTFVERVMpe1xuICByZXR1cm4gZnVuY3Rpb24oJHRoaXMsIGVsLCBmcm9tSW5kZXgpe1xuICAgIHZhciBPICAgICAgPSB0b0lPYmplY3QoJHRoaXMpXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSB0b0luZGV4KGZyb21JbmRleCwgbGVuZ3RoKVxuICAgICAgLCB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgaWYoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpd2hpbGUobGVuZ3RoID4gaW5kZXgpe1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgaWYodmFsdWUgIT0gdmFsdWUpcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjdG9JbmRleCBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pe1xuICAgICAgaWYoT1tpbmRleF0gPT09IGVsKXJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07IiwiLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKVxuICAsIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpXG4gIC8vIEVTMyB3cm9uZyBoZXJlXG4gICwgQVJHID0gY29mKGZ1bmN0aW9uKCl7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24oaXQsIGtleSl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTsiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59OyIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7dmVyc2lvbjogJzIuNC4wJ307XG5pZih0eXBlb2YgX19lID09ICdudW1iZXInKV9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWYiLCIndXNlIHN0cmljdCc7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBjcmVhdGVEZXNjICAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBpbmRleCwgdmFsdWUpe1xuICBpZihpbmRleCBpbiBvYmplY3QpJGRlZmluZVByb3BlcnR5LmYob2JqZWN0LCBpbmRleCwgY3JlYXRlRGVzYygwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcbn07IiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgdGhhdCwgbGVuZ3RoKXtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYodGhhdCA9PT0gdW5kZWZpbmVkKXJldHVybiBmbjtcbiAgc3dpdGNoKGxlbmd0aCl7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24oYSl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTsiLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKGl0ID09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07IiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7IiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50XG4gIC8vIGluIG9sZCBJRSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0J1xuICAsIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59OyIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpOyIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BTICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKVxuICAsIHBJRSAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIHJlc3VsdCAgICAgPSBnZXRLZXlzKGl0KVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYoZ2V0U3ltYm9scyl7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KVxuICAgICAgLCBpc0VudW0gID0gcElFLmZcbiAgICAgICwgaSAgICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKHN5bWJvbHMubGVuZ3RoID4gaSlpZihpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSlyZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59OyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIGN0eCAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgaGlkZSAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgc291cmNlKXtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkZcbiAgICAsIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0LkdcbiAgICAsIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlNcbiAgICAsIElTX1BST1RPICA9IHR5cGUgJiAkZXhwb3J0LlBcbiAgICAsIElTX0JJTkQgICA9IHR5cGUgJiAkZXhwb3J0LkJcbiAgICAsIElTX1dSQVAgICA9IHR5cGUgJiAkZXhwb3J0LldcbiAgICAsIGV4cG9ydHMgICA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pXG4gICAgLCBleHBQcm90byAgPSBleHBvcnRzW1BST1RPVFlQRV1cbiAgICAsIHRhcmdldCAgICA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV1cbiAgICAsIGtleSwgb3duLCBvdXQ7XG4gIGlmKElTX0dMT0JBTClzb3VyY2UgPSBuYW1lO1xuICBmb3Ioa2V5IGluIHNvdXJjZSl7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICBpZihvd24gJiYga2V5IGluIGV4cG9ydHMpY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XG4gICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbihDKXtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICAgIGlmKHRoaXMgaW5zdGFuY2VvZiBDKXtcbiAgICAgICAgICBzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQztcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDKGEpO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEMoYSwgYik7XG4gICAgICAgICAgfSByZXR1cm4gbmV3IEMoYSwgYiwgYyk7XG4gICAgICAgIH0gcmV0dXJuIEMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgICBGW1BST1RPVFlQRV0gPSBDW1BST1RPVFlQRV07XG4gICAgICByZXR1cm4gRjtcbiAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcbiAgICB9KShvdXQpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLm1ldGhvZHMuJU5BTUUlXG4gICAgaWYoSVNfUFJPVE8pe1xuICAgICAgKGV4cG9ydHMudmlydHVhbCB8fCAoZXhwb3J0cy52aXJ0dWFsID0ge30pKVtrZXldID0gb3V0O1xuICAgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLnByb3RvdHlwZS4lTkFNRSVcbiAgICAgIGlmKHR5cGUgJiAkZXhwb3J0LlIgJiYgZXhwUHJvdG8gJiYgIWV4cFByb3RvW2tleV0paGlkZShleHBQcm90bywga2V5LCBvdXQpO1xuICAgIH1cbiAgfVxufTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWAgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07IiwidmFyIGN0eCAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBjYWxsICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpXG4gICwgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJylcbiAgLCBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9MZW5ndGggICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGdldEl0ZXJGbiAgID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKVxuICAsIEJSRUFLICAgICAgID0ge31cbiAgLCBSRVRVUk4gICAgICA9IHt9O1xudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCwgSVRFUkFUT1Ipe1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbigpeyByZXR1cm4gaXRlcmFibGU7IH0gOiBnZXRJdGVyRm4oaXRlcmFibGUpXG4gICAgLCBmICAgICAgPSBjdHgoZm4sIHRoYXQsIGVudHJpZXMgPyAyIDogMSlcbiAgICAsIGluZGV4ICA9IDBcbiAgICAsIGxlbmd0aCwgc3RlcCwgaXRlcmF0b3IsIHJlc3VsdDtcbiAgaWYodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdGVyYWJsZSArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICAvLyBmYXN0IGNhc2UgZm9yIGFycmF5cyB3aXRoIGRlZmF1bHQgaXRlcmF0b3JcbiAgaWYoaXNBcnJheUl0ZXIoaXRlckZuKSlmb3IobGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4Kyspe1xuICAgIHJlc3VsdCA9IGVudHJpZXMgPyBmKGFuT2JqZWN0KHN0ZXAgPSBpdGVyYWJsZVtpbmRleF0pWzBdLCBzdGVwWzFdKSA6IGYoaXRlcmFibGVbaW5kZXhdKTtcbiAgICBpZihyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKXJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSBmb3IoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgKXtcbiAgICByZXN1bHQgPSBjYWxsKGl0ZXJhdG9yLCBmLCBzdGVwLnZhbHVlLCBlbnRyaWVzKTtcbiAgICBpZihyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKXJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5leHBvcnRzLkJSRUFLICA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZiIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59OyIsInZhciBkUCAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDsiLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pOyIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgYXJncywgdGhhdCl7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcbiAgc3dpdGNoKGFyZ3MubGVuZ3RoKXtcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgfSByZXR1cm4gICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTsiLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTsiLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgSVRFUkFUT1IgICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59OyIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpe1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59OyIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoKGUpe1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYocmV0ICE9PSB1bmRlZmluZWQpYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIGRlc2NyaXB0b3IgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCl7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwge25leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCl9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBoaWRlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBJdGVyYXRvcnMgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgJGl0ZXJDcmVhdGUgICAgPSByZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBJVEVSQVRPUiAgICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgQlVHR1kgICAgICAgICAgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSkgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuICAsIEZGX0lURVJBVE9SICAgID0gJ0BAaXRlcmF0b3InXG4gICwgS0VZUyAgICAgICAgICAgPSAna2V5cydcbiAgLCBWQUxVRVMgICAgICAgICA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCl7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uKGtpbmQpe1xuICAgIGlmKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKXJldHVybiBwcm90b1traW5kXTtcbiAgICBzd2l0Y2goa2luZCl7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyAgICAgICAgPSBOQU1FICsgJyBJdGVyYXRvcidcbiAgICAsIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFU1xuICAgICwgVkFMVUVTX0JVRyA9IGZhbHNlXG4gICAgLCBwcm90byAgICAgID0gQmFzZS5wcm90b3R5cGVcbiAgICAsICRuYXRpdmUgICAgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF1cbiAgICAsICRkZWZhdWx0ICAgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKVxuICAgICwgJGVudHJpZXMgICA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWRcbiAgICAsICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlXG4gICAgLCBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlO1xuICAvLyBGaXggbmF0aXZlXG4gIGlmKCRhbnlOYXRpdmUpe1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKSk7XG4gICAgaWYoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpe1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmKCFMSUJSQVJZICYmICFoYXMoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SKSloaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKXtcbiAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZigoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSl7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSAgPSByZXR1cm5UaGlzO1xuICBpZihERUZBVUxUKXtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiAgREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiAgICBJU19TRVQgICAgID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYoRk9SQ0VEKWZvcihrZXkgaW4gbWV0aG9kcyl7XG4gICAgICBpZighKGtleSBpbiBwcm90bykpcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTsiLCJ2YXIgSVRFUkFUT1IgICAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbigpeyBTQUZFX0NMT1NJTkcgPSB0cnVlOyB9O1xuICBBcnJheS5mcm9tKHJpdGVyLCBmdW5jdGlvbigpeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjLCBza2lwQ2xvc2luZyl7XG4gIGlmKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKXJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyICA9IFs3XVxuICAgICAgLCBpdGVyID0gYXJyW0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uKCl7IHJldHVybiB7ZG9uZTogc2FmZSA9IHRydWV9OyB9O1xuICAgIGFycltJVEVSQVRPUl0gPSBmdW5jdGlvbigpeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZG9uZSwgdmFsdWUpe1xuICByZXR1cm4ge3ZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lfTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7fTsiLCJ2YXIgZ2V0S2V5cyAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBlbCl7XG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICwga2V5cyAgID0gZ2V0S2V5cyhPKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGluZGV4ICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobGVuZ3RoID4gaW5kZXgpaWYoT1trZXkgPSBrZXlzW2luZGV4KytdXSA9PT0gZWwpcmV0dXJuIGtleTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSB0cnVlOyIsInZhciBNRVRBICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJylcbiAgLCBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgaGFzICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHNldERlc2MgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGlkICAgICAgID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uKGl0KXtcbiAgc2V0RGVzYyhpdCwgTUVUQSwge3ZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfX0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24oaXQsIGNyZWF0ZSl7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZighaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICBpZighaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmKCFjcmVhdGUpcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbihpdCl7XG4gIGlmKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSlzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogICAgICBNRVRBLFxuICBORUVEOiAgICAgZmFsc2UsXG4gIGZhc3RLZXk6ICBmYXN0S2V5LFxuICBnZXRXZWFrOiAgZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59OyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXRcbiAgLCBPYnNlcnZlciAgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlclxuICAsIHByb2Nlc3MgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgUHJvbWlzZSAgID0gZ2xvYmFsLlByb21pc2VcbiAgLCBpc05vZGUgICAgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXtcbiAgdmFyIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbigpe1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmKGlzTm9kZSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKXBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUoaGVhZCl7XG4gICAgICBmbiAgID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgaWYoaGVhZClub3RpZnkoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZihwYXJlbnQpcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gTm9kZS5qc1xuICBpZihpc05vZGUpe1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXJcbiAgfSBlbHNlIGlmKE9ic2VydmVyKXtcbiAgICB2YXIgdG9nZ2xlID0gdHJ1ZVxuICAgICAgLCBub2RlICAgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHtjaGFyYWN0ZXJEYXRhOiB0cnVlfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gICAgfTtcbiAgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2VcbiAgfSBlbHNlIGlmKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKXtcbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBwcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgICAgbWFjcm90YXNrLmNhbGwoZ2xvYmFsLCBmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihmbil7XG4gICAgdmFyIHRhc2sgPSB7Zm46IGZuLCBuZXh0OiB1bmRlZmluZWR9O1xuICAgIGlmKGxhc3QpbGFzdC5uZXh0ID0gdGFzaztcbiAgICBpZighaGVhZCl7XG4gICAgICBoZWFkID0gdGFzaztcbiAgICAgIG5vdGlmeSgpO1xuICAgIH0gbGFzdCA9IHRhc2s7XG4gIH07XG59OyIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BTICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBwSUUgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxuICAsIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBJT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsICRhc3NpZ24gID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgdmFyIEEgPSB7fVxuICAgICwgQiA9IHt9XG4gICAgLCBTID0gU3ltYm9sKClcbiAgICAsIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbihrKXsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCAgICAgPSB0b09iamVjdCh0YXJnZXQpXG4gICAgLCBhTGVuICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGluZGV4ID0gMVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZlxuICAgICwgaXNFbnVtICAgICA9IHBJRS5mO1xuICB3aGlsZShhTGVuID4gaW5kZXgpe1xuICAgIHZhciBTICAgICAgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSlcbiAgICAgICwga2V5cyAgID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKVxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgLCBqICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShsZW5ndGggPiBqKWlmKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247IiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGRQcyAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpXG4gICwgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJylcbiAgLCBJRV9QUk9UTyAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKVxuICAsIEVtcHR5ICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxuICAsIFBST1RPVFlQRSAgID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24oKXtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJylcbiAgICAsIGkgICAgICA9IGVudW1CdWdLZXlzLmxlbmd0aFxuICAgICwgbHQgICAgID0gJzwnXG4gICAgLCBndCAgICAgPSAnPidcbiAgICAsIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlKGktLSlkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcyl7XG4gIHZhciByZXN1bHQ7XG4gIGlmKE8gIT09IG51bGwpe1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuIiwidmFyIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZFAgICAgICAgICAgICAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKXtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIGlmKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcyl0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZigndmFsdWUnIGluIEF0dHJpYnV0ZXMpT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTsiLCJ2YXIgZFAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKXtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzICAgPSBnZXRLZXlzKFByb3BlcnRpZXMpXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICwgaSA9IDBcbiAgICAsIFA7XG4gIHdoaWxlKGxlbmd0aCA+IGkpZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59OyIsInZhciBwSUUgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxuICAsIGdPUEQgICAgICAgICAgID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCl7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZihoYXMoTywgUCkpcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTsiLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgZ09QTiAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICwgdG9TdHJpbmcgID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbihpdCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdPUE4oaXQpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XG59O1xuIiwiLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxudmFyICRrZXlzICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpXG4gICwgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKXtcbiAgcmV0dXJuICRrZXlzKE8sIGhpZGRlbktleXMpO1xufTsiLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzOyIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHRvT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBJRV9QUk9UTyAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKVxuICAsIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24oTyl7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYoaGFzKE8sIElFX1BST1RPKSlyZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3Ipe1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07IiwidmFyIGhhcyAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgdG9JT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSlcbiAgLCBJRV9QUk9UTyAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBuYW1lcyl7XG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICwgaSAgICAgID0gMFxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGtleTtcbiAgZm9yKGtleSBpbiBPKWlmKGtleSAhPSBJRV9QUk9UTyloYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaWYoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKXtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59OyIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTyl7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59OyIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlOyIsIi8vIG1vc3QgT2JqZWN0IG1ldGhvZHMgYnkgRVM2IHNob3VsZCBhY2NlcHQgcHJpbWl0aXZlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNvcmUgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBmYWlscyAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZLCBleGVjKXtcbiAgdmFyIGZuICA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXVxuICAgICwgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24oKXsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKXtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG4gIH07XG59OyIsInZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0YXJnZXQsIHNyYywgc2FmZSl7XG4gIGZvcih2YXIga2V5IGluIHNyYyl7XG4gICAgaWYoc2FmZSAmJiB0YXJnZXRba2V5XSl0YXJnZXRba2V5XSA9IHNyY1trZXldO1xuICAgIGVsc2UgaGlkZSh0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9IHJldHVybiB0YXJnZXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faGlkZScpOyIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uKE8sIHByb3RvKXtcbiAgYW5PYmplY3QoTyk7XG4gIGlmKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZnVuY3Rpb24odGVzdCwgYnVnZ3ksIHNldCl7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaChlKXsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pe1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmKGJ1Z2d5KU8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgZFAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKVxuICAsIFNQRUNJRVMgICAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVkpe1xuICB2YXIgQyA9IHR5cGVvZiBjb3JlW0tFWV0gPT0gJ2Z1bmN0aW9uJyA/IGNvcmVbS0VZXSA6IGdsb2JhbFtLRVldO1xuICBpZihERVNDUklQVE9SUyAmJiBDICYmICFDW1NQRUNJRVNdKWRQLmYoQywgU1BFQ0lFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9XG4gIH0pO1xufTsiLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIHRhZywgc3RhdCl7XG4gIGlmKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpZGVmKGl0LCBUQUcsIHtjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWd9KTtcbn07IiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJylcbiAgLCB1aWQgICAgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07IiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXydcbiAgLCBzdG9yZSAgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xufTsiLCIvLyA3LjMuMjAgU3BlY2llc0NvbnN0cnVjdG9yKE8sIGRlZmF1bHRDb25zdHJ1Y3RvcilcbnZhciBhbk9iamVjdCAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIFNQRUNJRVMgICA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE8sIEQpe1xuICB2YXIgQyA9IGFuT2JqZWN0KE8pLmNvbnN0cnVjdG9yLCBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IEQgOiBhRnVuY3Rpb24oUyk7XG59OyIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBkZWZpbmVkICAgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUT19TVFJJTkcpe1xuICByZXR1cm4gZnVuY3Rpb24odGhhdCwgcG9zKXtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKVxuICAgICAgLCBpID0gdG9JbnRlZ2VyKHBvcylcbiAgICAgICwgbCA9IHMubGVuZ3RoXG4gICAgICAsIGEsIGI7XG4gICAgaWYoaSA8IDAgfHwgaSA+PSBsKXJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59OyIsInZhciBjdHggICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGludm9rZSAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ludm9rZScpXG4gICwgaHRtbCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faHRtbCcpXG4gICwgY2VsICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpXG4gICwgZ2xvYmFsICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIHNldFRhc2sgICAgICAgICAgICA9IGdsb2JhbC5zZXRJbW1lZGlhdGVcbiAgLCBjbGVhclRhc2sgICAgICAgICAgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGVcbiAgLCBNZXNzYWdlQ2hhbm5lbCAgICAgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWxcbiAgLCBjb3VudGVyICAgICAgICAgICAgPSAwXG4gICwgcXVldWUgICAgICAgICAgICAgID0ge31cbiAgLCBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJ1xuICAsIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uKCl7XG4gIHZhciBpZCA9ICt0aGlzO1xuICBpZihxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpe1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCl7XG4gIHJ1bi5jYWxsKGV2ZW50LmRhdGEpO1xufTtcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmKCFzZXRUYXNrIHx8ICFjbGVhclRhc2spe1xuICBzZXRUYXNrID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKXtcbiAgICB2YXIgYXJncyA9IFtdLCBpID0gMTtcbiAgICB3aGlsZShhcmd1bWVudHMubGVuZ3RoID4gaSlhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbigpe1xuICAgICAgaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKXtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYocmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZihNZXNzYWdlQ2hhbm5lbCl7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbDtcbiAgICBwb3J0ICAgID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgJyonKTtcbiAgICB9O1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0Jykpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6ICAgc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTsiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWF4ICAgICAgID0gTWF0aC5tYXhcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCl7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59OyIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgID0gTWF0aC5jZWlsXG4gICwgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTsiLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59OyIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59OyIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTsiLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBTKXtcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZihTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTsiLCJ2YXIgaWQgPSAwXG4gICwgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTsiLCJ2YXIgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCB3a3NFeHQgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcy1leHQnKVxuICAsIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG4gIGlmKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwge3ZhbHVlOiB3a3NFeHQuZihuYW1lKX0pO1xufTsiLCJleHBvcnRzLmYgPSByZXF1aXJlKCcuL193a3MnKTsiLCJ2YXIgc3RvcmUgICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKVxuICAsIHVpZCAgICAgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIFN5bWJvbCAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2xcbiAgLCBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTsiLCJ2YXIgY2xhc3NvZiAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgSVRFUkFUT1IgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCAhPSB1bmRlZmluZWQpcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgY3R4ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgY2FsbCAgICAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKVxuICAsIGlzQXJyYXlJdGVyICAgID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpXG4gICwgdG9MZW5ndGggICAgICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5JylcbiAgLCBnZXRJdGVyRm4gICAgICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UvKiwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQqLyl7XG4gICAgdmFyIE8gICAgICAgPSB0b09iamVjdChhcnJheUxpa2UpXG4gICAgICAsIEMgICAgICAgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5XG4gICAgICAsIGFMZW4gICAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIG1hcGZuICAgPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZFxuICAgICAgLCBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZFxuICAgICAgLCBpbmRleCAgID0gMFxuICAgICAgLCBpdGVyRm4gID0gZ2V0SXRlckZuKE8pXG4gICAgICAsIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZihtYXBwaW5nKW1hcGZuID0gY3R4KG1hcGZuLCBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCwgMik7XG4gICAgLy8gaWYgb2JqZWN0IGlzbid0IGl0ZXJhYmxlIG9yIGl0J3MgYXJyYXkgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIHNpbXBsZSBjYXNlXG4gICAgaWYoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpe1xuICAgICAgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHJlc3VsdCA9IG5ldyBDOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4Kyspe1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gY2FsbChpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICAgIGZvcihyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKyl7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpXG4gICwgc3RlcCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpXG4gICwgSXRlcmF0b3JzICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgdG9JT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwga2luZCAgPSB0aGlzLl9rXG4gICAgLCBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpe1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpOyIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHthc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKX0pOyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jylcbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7Y3JlYXRlOiByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyl9KTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjQgLyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7ZGVmaW5lUHJvcGVydHk6IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZ9KTsiLCIvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG52YXIgdG9JT2JqZWN0ICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJywgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KXtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0b0lPYmplY3QoaXQpLCBrZXkpO1xuICB9O1xufSk7IiwiLy8gMTkuMS4yLjkgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgdG9PYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCAkZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0UHJvdG90eXBlT2YnLCBmdW5jdGlvbigpe1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoaXQpe1xuICAgIHJldHVybiAkZ2V0UHJvdG90eXBlT2YodG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMi4xMiBPYmplY3QuaXNGcm96ZW4oTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzRnJvemVuJywgZnVuY3Rpb24oJGlzRnJvemVuKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzRnJvemVuKGl0KXtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzRnJvemVuID8gJGlzRnJvemVuKGl0KSA6IGZhbHNlIDogdHJ1ZTtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMi4xNCBPYmplY3Qua2V5cyhPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCAka2V5cyAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgna2V5cycsIGZ1bmN0aW9uKCl7XG4gIHJldHVybiBmdW5jdGlvbiBrZXlzKGl0KXtcbiAgICByZXR1cm4gJGtleXModG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMy4xOSBPYmplY3Quc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7c2V0UHJvdG90eXBlT2Y6IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldH0pOyIsIiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZICAgICAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCBnbG9iYWwgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGN0eCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgY2xhc3NvZiAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgJGV4cG9ydCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBpc09iamVjdCAgICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiAgICAgICAgICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIGFuSW5zdGFuY2UgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCBmb3JPZiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKVxuICAsIHRhc2sgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXRcbiAgLCBtaWNyb3Rhc2sgICAgICAgICAgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpXG4gICwgUFJPTUlTRSAgICAgICAgICAgID0gJ1Byb21pc2UnXG4gICwgVHlwZUVycm9yICAgICAgICAgID0gZ2xvYmFsLlR5cGVFcnJvclxuICAsIHByb2Nlc3MgICAgICAgICAgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgJFByb21pc2UgICAgICAgICAgID0gZ2xvYmFsW1BST01JU0VdXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCBpc05vZGUgICAgICAgICAgICAgPSBjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJ1xuICAsIGVtcHR5ICAgICAgICAgICAgICA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH1cbiAgLCBJbnRlcm5hbCwgR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5LCBXcmFwcGVyO1xuXG52YXIgVVNFX05BVElWRSA9ICEhZnVuY3Rpb24oKXtcbiAgdHJ5IHtcbiAgICAvLyBjb3JyZWN0IHN1YmNsYXNzaW5nIHdpdGggQEBzcGVjaWVzIHN1cHBvcnRcbiAgICB2YXIgcHJvbWlzZSAgICAgPSAkUHJvbWlzZS5yZXNvbHZlKDEpXG4gICAgICAsIEZha2VQcm9taXNlID0gKHByb21pc2UuY29uc3RydWN0b3IgPSB7fSlbcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKV0gPSBmdW5jdGlvbihleGVjKXsgZXhlYyhlbXB0eSwgZW1wdHkpOyB9O1xuICAgIC8vIHVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgICByZXR1cm4gKGlzTm9kZSB8fCB0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50ID09ICdmdW5jdGlvbicpICYmIHByb21pc2UudGhlbihlbXB0eSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxufSgpO1xuXG4vLyBoZWxwZXJzXG52YXIgc2FtZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24oYSwgYil7XG4gIC8vIHdpdGggbGlicmFyeSB3cmFwcGVyIHNwZWNpYWwgY2FzZVxuICByZXR1cm4gYSA9PT0gYiB8fCBhID09PSAkUHJvbWlzZSAmJiBiID09PSBXcmFwcGVyO1xufTtcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiB0eXBlb2YgKHRoZW4gPSBpdC50aGVuKSA9PSAnZnVuY3Rpb24nID8gdGhlbiA6IGZhbHNlO1xufTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uKEMpe1xuICByZXR1cm4gc2FtZUNvbnN0cnVjdG9yKCRQcm9taXNlLCBDKVxuICAgID8gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgOiBuZXcgR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcbnZhciBQcm9taXNlQ2FwYWJpbGl0eSA9IEdlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uKEMpe1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbigkJHJlc29sdmUsICQkcmVqZWN0KXtcbiAgICBpZihyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ICA9ICQkcmVqZWN0O1xuICB9KTtcbiAgdGhpcy5yZXNvbHZlID0gYUZ1bmN0aW9uKHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCAgPSBhRnVuY3Rpb24ocmVqZWN0KTtcbn07XG52YXIgcGVyZm9ybSA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIGV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4ge2Vycm9yOiBlfTtcbiAgfVxufTtcbnZhciBub3RpZnkgPSBmdW5jdGlvbihwcm9taXNlLCBpc1JlamVjdCl7XG4gIGlmKHByb21pc2UuX24pcmV0dXJuO1xuICBwcm9taXNlLl9uID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYztcbiAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdlxuICAgICAgLCBvayAgICA9IHByb21pc2UuX3MgPT0gMVxuICAgICAgLCBpICAgICA9IDA7XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uKHJlYWN0aW9uKXtcbiAgICAgIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWxcbiAgICAgICAgLCByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZVxuICAgICAgICAsIHJlamVjdCAgPSByZWFjdGlvbi5yZWplY3RcbiAgICAgICAgLCBkb21haW4gID0gcmVhY3Rpb24uZG9tYWluXG4gICAgICAgICwgcmVzdWx0LCB0aGVuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYoaGFuZGxlcil7XG4gICAgICAgICAgaWYoIW9rKXtcbiAgICAgICAgICAgIGlmKHByb21pc2UuX2ggPT0gMilvbkhhbmRsZVVuaGFuZGxlZChwcm9taXNlKTtcbiAgICAgICAgICAgIHByb21pc2UuX2ggPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihoYW5kbGVyID09PSB0cnVlKXJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYoZG9tYWluKWRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgcmVzdWx0ID0gaGFuZGxlcih2YWx1ZSk7XG4gICAgICAgICAgICBpZihkb21haW4pZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYocmVzdWx0ID09PSByZWFjdGlvbi5wcm9taXNlKXtcbiAgICAgICAgICAgIHJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpe1xuICAgICAgICAgICAgdGhlbi5jYWxsKHJlc3VsdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2UgcmVqZWN0KHZhbHVlKTtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpcnVuKGNoYWluW2krK10pOyAvLyB2YXJpYWJsZSBsZW5ndGggLSBjYW4ndCB1c2UgZm9yRWFjaFxuICAgIHByb21pc2UuX2MgPSBbXTtcbiAgICBwcm9taXNlLl9uID0gZmFsc2U7XG4gICAgaWYoaXNSZWplY3QgJiYgIXByb21pc2UuX2gpb25VbmhhbmRsZWQocHJvbWlzZSk7XG4gIH0pO1xufTtcbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbigpe1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3ZcbiAgICAgICwgYWJydXB0LCBoYW5kbGVyLCBjb25zb2xlO1xuICAgIGlmKGlzVW5oYW5kbGVkKHByb21pc2UpKXtcbiAgICAgIGFicnVwdCA9IHBlcmZvcm0oZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoaXNOb2RlKXtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmKGhhbmRsZXIgPSBnbG9iYWwub251bmhhbmRsZWRyZWplY3Rpb24pe1xuICAgICAgICAgIGhhbmRsZXIoe3Byb21pc2U6IHByb21pc2UsIHJlYXNvbjogdmFsdWV9KTtcbiAgICAgICAgfSBlbHNlIGlmKChjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGUpICYmIGNvbnNvbGUuZXJyb3Ipe1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgcHJvbWlzZS5faCA9IGlzTm9kZSB8fCBpc1VuaGFuZGxlZChwcm9taXNlKSA/IDIgOiAxO1xuICAgIH0gcHJvbWlzZS5fYSA9IHVuZGVmaW5lZDtcbiAgICBpZihhYnJ1cHQpdGhyb3cgYWJydXB0LmVycm9yO1xuICB9KTtcbn07XG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbihwcm9taXNlKXtcbiAgaWYocHJvbWlzZS5faCA9PSAxKXJldHVybiBmYWxzZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYSB8fCBwcm9taXNlLl9jXG4gICAgLCBpICAgICA9IDBcbiAgICAsIHJlYWN0aW9uO1xuICB3aGlsZShjaGFpbi5sZW5ndGggPiBpKXtcbiAgICByZWFjdGlvbiA9IGNoYWluW2krK107XG4gICAgaWYocmVhY3Rpb24uZmFpbCB8fCAhaXNVbmhhbmRsZWQocmVhY3Rpb24ucHJvbWlzZSkpcmV0dXJuIGZhbHNlO1xuICB9IHJldHVybiB0cnVlO1xufTtcbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbigpe1xuICAgIHZhciBoYW5kbGVyO1xuICAgIGlmKGlzTm9kZSl7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgaWYoaGFuZGxlciA9IGdsb2JhbC5vbnJlamVjdGlvbmhhbmRsZWQpe1xuICAgICAgaGFuZGxlcih7cHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiBwcm9taXNlLl92fSk7XG4gICAgfVxuICB9KTtcbn07XG52YXIgJHJlamVjdCA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICBpZihwcm9taXNlLl9kKXJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICBwcm9taXNlLl92ID0gdmFsdWU7XG4gIHByb21pc2UuX3MgPSAyO1xuICBpZighcHJvbWlzZS5fYSlwcm9taXNlLl9hID0gcHJvbWlzZS5fYy5zbGljZSgpO1xuICBub3RpZnkocHJvbWlzZSwgdHJ1ZSk7XG59O1xudmFyICRyZXNvbHZlID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgcHJvbWlzZSA9IHRoaXNcbiAgICAsIHRoZW47XG4gIGlmKHByb21pc2UuX2QpcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHRyeSB7XG4gICAgaWYocHJvbWlzZSA9PT0gdmFsdWUpdGhyb3cgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG4gICAgaWYodGhlbiA9IGlzVGhlbmFibGUodmFsdWUpKXtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbigpe1xuICAgICAgICB2YXIgd3JhcHBlciA9IHtfdzogcHJvbWlzZSwgX2Q6IGZhbHNlfTsgLy8gd3JhcFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgY3R4KCRyZXNvbHZlLCB3cmFwcGVyLCAxKSwgY3R4KCRyZWplY3QsIHdyYXBwZXIsIDEpKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAkcmVqZWN0LmNhbGwod3JhcHBlciwgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlLl92ID0gdmFsdWU7XG4gICAgICBwcm9taXNlLl9zID0gMTtcbiAgICAgIG5vdGlmeShwcm9taXNlLCBmYWxzZSk7XG4gICAgfVxuICB9IGNhdGNoKGUpe1xuICAgICRyZWplY3QuY2FsbCh7X3c6IHByb21pc2UsIF9kOiBmYWxzZX0sIGUpOyAvLyB3cmFwXG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZighVVNFX05BVElWRSl7XG4gIC8vIDI1LjQuMy4xIFByb21pc2UoZXhlY3V0b3IpXG4gICRQcm9taXNlID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcil7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkUHJvbWlzZSwgUFJPTUlTRSwgJ19oJyk7XG4gICAgYUZ1bmN0aW9uKGV4ZWN1dG9yKTtcbiAgICBJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihjdHgoJHJlc29sdmUsIHRoaXMsIDEpLCBjdHgoJHJlamVjdCwgdGhpcywgMSkpO1xuICAgIH0gY2F0Y2goZXJyKXtcbiAgICAgICRyZWplY3QuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH1cbiAgfTtcbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKXtcbiAgICB0aGlzLl9jID0gW107ICAgICAgICAgICAgIC8vIDwtIGF3YWl0aW5nIHJlYWN0aW9uc1xuICAgIHRoaXMuX2EgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gY2hlY2tlZCBpbiBpc1VuaGFuZGxlZCByZWFjdGlvbnNcbiAgICB0aGlzLl9zID0gMDsgICAgICAgICAgICAgIC8vIDwtIHN0YXRlXG4gICAgdGhpcy5fZCA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBkb25lXG4gICAgdGhpcy5fdiA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSB2YWx1ZVxuICAgIHRoaXMuX2ggPSAwOyAgICAgICAgICAgICAgLy8gPC0gcmVqZWN0aW9uIHN0YXRlLCAwIC0gZGVmYXVsdCwgMSAtIGhhbmRsZWQsIDIgLSB1bmhhbmRsZWRcbiAgICB0aGlzLl9uID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIG5vdGlmeVxuICB9O1xuICBJbnRlcm5hbC5wcm90b3R5cGUgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKSgkUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpe1xuICAgICAgdmFyIHJlYWN0aW9uICAgID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsICRQcm9taXNlKSk7XG4gICAgICByZWFjdGlvbi5vayAgICAgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICAgIHJlYWN0aW9uLmZhaWwgICA9IHR5cGVvZiBvblJlamVjdGVkID09ICdmdW5jdGlvbicgJiYgb25SZWplY3RlZDtcbiAgICAgIHJlYWN0aW9uLmRvbWFpbiA9IGlzTm9kZSA/IHByb2Nlc3MuZG9tYWluIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fYy5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmKHRoaXMuX2EpdGhpcy5fYS5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmKHRoaXMuX3Mpbm90aWZ5KHRoaXMsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICAgIH0sXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcbiAgICAnY2F0Y2gnOiBmdW5jdGlvbihvblJlamVjdGVkKXtcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH0pO1xuICBQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHByb21pc2UgID0gbmV3IEludGVybmFsO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gY3R4KCRyZXNvbHZlLCBwcm9taXNlLCAxKTtcbiAgICB0aGlzLnJlamVjdCAgPSBjdHgoJHJlamVjdCwgcHJvbWlzZSwgMSk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHtQcm9taXNlOiAkUHJvbWlzZX0pO1xucmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKSgkUHJvbWlzZSwgUFJPTUlTRSk7XG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKFBST01JU0UpO1xuV3JhcHBlciA9IHJlcXVpcmUoJy4vX2NvcmUnKVtQUk9NSVNFXTtcblxuLy8gc3RhdGljc1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNSBQcm9taXNlLnJlamVjdChyKVxuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKXtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpXG4gICAgICAsICQkcmVqZWN0ICAgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICAkJHJlamVjdChyKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKExJQlJBUlkgfHwgIVVTRV9OQVRJVkUpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC42IFByb21pc2UucmVzb2x2ZSh4KVxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHgpe1xuICAgIC8vIGluc3RhbmNlb2YgaW5zdGVhZCBvZiBpbnRlcm5hbCBzbG90IGNoZWNrIGJlY2F1c2Ugd2Ugc2hvdWxkIGZpeCBpdCB3aXRob3V0IHJlcGxhY2VtZW50IG5hdGl2ZSBQcm9taXNlIGNvcmVcbiAgICBpZih4IGluc3RhbmNlb2YgJFByb21pc2UgJiYgc2FtZUNvbnN0cnVjdG9yKHguY29uc3RydWN0b3IsIHRoaXMpKXJldHVybiB4O1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcylcbiAgICAgICwgJCRyZXNvbHZlICA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICAkJHJlc29sdmUoeCk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoVVNFX05BVElWRSAmJiByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uKGl0ZXIpe1xuICAkUHJvbWlzZS5hbGwoaXRlcilbJ2NhdGNoJ10oZW1wdHkpO1xufSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSl7XG4gICAgdmFyIEMgICAgICAgICAgPSB0aGlzXG4gICAgICAsIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgLCByZXNvbHZlICAgID0gY2FwYWJpbGl0eS5yZXNvbHZlXG4gICAgICAsIHJlamVjdCAgICAgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgdmFyIHZhbHVlcyAgICA9IFtdXG4gICAgICAgICwgaW5kZXggICAgID0gMFxuICAgICAgICAsIHJlbWFpbmluZyA9IDE7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uKHByb21pc2Upe1xuICAgICAgICB2YXIgJGluZGV4ICAgICAgICA9IGluZGV4KytcbiAgICAgICAgICAsIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgICBpZihhbHJlYWR5Q2FsbGVkKXJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkICA9IHRydWU7XG4gICAgICAgICAgdmFsdWVzWyRpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZihhYnJ1cHQpcmVqZWN0KGFicnVwdC5lcnJvcik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfSxcbiAgLy8gMjUuNC40LjQgUHJvbWlzZS5yYWNlKGl0ZXJhYmxlKVxuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyAgICAgICAgICA9IHRoaXNcbiAgICAgICwgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICAsIHJlamVjdCAgICAgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbihwcm9taXNlKXtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYoYWJydXB0KXJlamVjdChhYnJ1cHQuZXJyb3IpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24oaXRlcmF0ZWQpe1xuICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4vLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBpbmRleCA9IHRoaXMuX2lcbiAgICAsIHBvaW50O1xuICBpZihpbmRleCA+PSBPLmxlbmd0aClyZXR1cm4ge3ZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWV9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4ge3ZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2V9O1xufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgREVTQ1JJUFRPUlMgICAgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIE1FVEEgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWVxuICAsICRmYWlscyAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIHNoYXJlZCAgICAgICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCB1aWQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgd2tzICAgICAgICAgICAgPSByZXF1aXJlKCcuL193a3MnKVxuICAsIHdrc0V4dCAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpXG4gICwgd2tzRGVmaW5lICAgICAgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJylcbiAgLCBrZXlPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vX2tleW9mJylcbiAgLCBlbnVtS2V5cyAgICAgICA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpXG4gICwgaXNBcnJheSAgICAgICAgPSByZXF1aXJlKCcuL19pcy1hcnJheScpXG4gICwgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgX2NyZWF0ZSAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBnT1BORXh0ICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpXG4gICwgJEdPUEQgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICwgJERQICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsICRrZXlzICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUEQgICAgICAgICAgID0gJEdPUEQuZlxuICAsIGRQICAgICAgICAgICAgID0gJERQLmZcbiAgLCBnT1BOICAgICAgICAgICA9IGdPUE5FeHQuZlxuICAsICRTeW1ib2wgICAgICAgID0gZ2xvYmFsLlN5bWJvbFxuICAsICRKU09OICAgICAgICAgID0gZ2xvYmFsLkpTT05cbiAgLCBfc3RyaW5naWZ5ICAgICA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeVxuICAsIFBST1RPVFlQRSAgICAgID0gJ3Byb3RvdHlwZSdcbiAgLCBISURERU4gICAgICAgICA9IHdrcygnX2hpZGRlbicpXG4gICwgVE9fUFJJTUlUSVZFICAgPSB3a3MoJ3RvUHJpbWl0aXZlJylcbiAgLCBpc0VudW0gICAgICAgICA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlXG4gICwgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpXG4gICwgQWxsU3ltYm9scyAgICAgPSBzaGFyZWQoJ3N5bWJvbHMnKVxuICAsIE9QU3ltYm9scyAgICAgID0gc2hhcmVkKCdvcC1zeW1ib2xzJylcbiAgLCBPYmplY3RQcm90byAgICA9IE9iamVjdFtQUk9UT1RZUEVdXG4gICwgVVNFX05BVElWRSAgICAgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nXG4gICwgUU9iamVjdCAgICAgICAgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIGRQKHRoaXMsICdhJywge3ZhbHVlOiA3fSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbihpdCwga2V5LCBEKXtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmKHByb3RvRGVzYylkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbih0YWcpe1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKXtcbiAgaWYoaXQgPT09IE9iamVjdFByb3RvKSRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmKGhhcyhBbGxTeW1ib2xzLCBrZXkpKXtcbiAgICBpZighRC5lbnVtZXJhYmxlKXtcbiAgICAgIGlmKCFoYXMoaXQsIEhJRERFTikpZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSlpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHtlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKX0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApe1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSlcbiAgICAsIGkgICAgPSAwXG4gICAgLCBsID0ga2V5cy5sZW5ndGhcbiAgICAsIGtleTtcbiAgd2hpbGUobCA+IGkpJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCl7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KXtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gIGl0ICA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSlyZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKUQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICB2YXIgbmFtZXMgID0gZ09QTih0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKXJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCl7XG4gIHZhciBJU19PUCAgPSBpdCA9PT0gT2JqZWN0UHJvdG9cbiAgICAsIG5hbWVzICA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKXJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYoIVVTRV9OQVRJVkUpe1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCl7XG4gICAgaWYodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBpZih0aGlzID09PSBPYmplY3RQcm90bykkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZihoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKXRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKXNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0fSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgICA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mICA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZihERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKXtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHdrc0V4dC5mID0gZnVuY3Rpb24obmFtZSl7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfVxufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7U3ltYm9sOiAkU3ltYm9sfSk7XG5cbmZvcih2YXIgc3ltYm9scyA9IChcbiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBpID0gMDsgc3ltYm9scy5sZW5ndGggPiBpOyApd2tzKHN5bWJvbHNbaSsrXSk7XG5cbmZvcih2YXIgc3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGkgPSAwOyBzeW1ib2xzLmxlbmd0aCA+IGk7ICl3a3NEZWZpbmUoc3ltYm9sc1tpKytdKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbihrZXkpe1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioa2V5KXtcbiAgICBpZihpc1N5bWJvbChrZXkpKXJldHVybiBrZXlPZihTeW1ib2xSZWdpc3RyeSwga2V5KTtcbiAgICB0aHJvdyBUeXBlRXJyb3Ioa2V5ICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24oKXsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbigpe1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7YTogU30pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCl7XG4gICAgaWYoaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgdmFyIGFyZ3MgPSBbaXRdXG4gICAgICAsIGkgICAgPSAxXG4gICAgICAsIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYodHlwZW9mIHJlcGxhY2VyID09ICdmdW5jdGlvbicpJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgaWYoJHJlcGxhY2VyIHx8ICFpc0FycmF5KHJlcGxhY2VyKSlyZXBsYWNlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICAgICAgaWYoJHJlcGxhY2VyKXZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZighaXNTeW1ib2wodmFsdWUpKXJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCByZXF1aXJlKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7IiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdhc3luY0l0ZXJhdG9yJyk7IiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdvYnNlcnZhYmxlJyk7IiwicmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBnbG9iYWwgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoaWRlICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgSXRlcmF0b3JzICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgVE9fU1RSSU5HX1RBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5mb3IodmFyIGNvbGxlY3Rpb25zID0gWydOb2RlTGlzdCcsICdET01Ub2tlbkxpc3QnLCAnTWVkaWFMaXN0JywgJ1N0eWxlU2hlZXRMaXN0JywgJ0NTU1J1bGVMaXN0J10sIGkgPSAwOyBpIDwgNTsgaSsrKXtcbiAgdmFyIE5BTUUgICAgICAgPSBjb2xsZWN0aW9uc1tpXVxuICAgICwgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXVxuICAgICwgcHJvdG8gICAgICA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIGlmKHByb3RvICYmICFwcm90b1tUT19TVFJJTkdfVEFHXSloaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgSXRlcmF0b3JzW05BTUVdID0gSXRlcmF0b3JzLkFycmF5O1xufSIsInZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIG1zZyl7XG4gIGlmKHR5cGVvZiBpdCAhPSAnbnVtYmVyJyAmJiBjb2YoaXQpICE9ICdOdW1iZXInKXRocm93IFR5cGVFcnJvcihtc2cpO1xuICByZXR1cm4gK2l0O1xufTsiLCIvLyAyMi4xLjMuMzEgQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG52YXIgVU5TQ09QQUJMRVMgPSByZXF1aXJlKCcuL193a3MnKSgndW5zY29wYWJsZXMnKVxuICAsIEFycmF5UHJvdG8gID0gQXJyYXkucHJvdG90eXBlO1xuaWYoQXJyYXlQcm90b1tVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKXJlcXVpcmUoJy4vX2hpZGUnKShBcnJheVByb3RvLCBVTlNDT1BBQkxFUywge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICBBcnJheVByb3RvW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07IiwiLy8gMjIuMS4zLjMgQXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCwgZW5kID0gdGhpcy5sZW5ndGgpXG4ndXNlIHN0cmljdCc7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvSW5kZXggID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAsIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gW10uY29weVdpdGhpbiB8fCBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldC8qPSAwKi8sIHN0YXJ0Lyo9IDAsIGVuZCA9IEBsZW5ndGgqLyl7XG4gIHZhciBPICAgICA9IHRvT2JqZWN0KHRoaXMpXG4gICAgLCBsZW4gICA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICwgdG8gICAgPSB0b0luZGV4KHRhcmdldCwgbGVuKVxuICAgICwgZnJvbSAgPSB0b0luZGV4KHN0YXJ0LCBsZW4pXG4gICAgLCBlbmQgICA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkXG4gICAgLCBjb3VudCA9IE1hdGgubWluKChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IHRvSW5kZXgoZW5kLCBsZW4pKSAtIGZyb20sIGxlbiAtIHRvKVxuICAgICwgaW5jICAgPSAxO1xuICBpZihmcm9tIDwgdG8gJiYgdG8gPCBmcm9tICsgY291bnQpe1xuICAgIGluYyAgPSAtMTtcbiAgICBmcm9tICs9IGNvdW50IC0gMTtcbiAgICB0byAgICs9IGNvdW50IC0gMTtcbiAgfVxuICB3aGlsZShjb3VudC0tID4gMCl7XG4gICAgaWYoZnJvbSBpbiBPKU9bdG9dID0gT1tmcm9tXTtcbiAgICBlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICB0byAgICs9IGluYztcbiAgICBmcm9tICs9IGluYztcbiAgfSByZXR1cm4gTztcbn07IiwiLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXG4ndXNlIHN0cmljdCc7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvSW5kZXggID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAsIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyosIHN0YXJ0ID0gMCwgZW5kID0gQGxlbmd0aCAqLyl7XG4gIHZhciBPICAgICAgPSB0b09iamVjdCh0aGlzKVxuICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgLCBhTGVuICAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBpbmRleCAgPSB0b0luZGV4KGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBsZW5ndGgpXG4gICAgLCBlbmQgICAgPSBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZFxuICAgICwgZW5kUG9zID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0luZGV4KGVuZCwgbGVuZ3RoKTtcbiAgd2hpbGUoZW5kUG9zID4gaW5kZXgpT1tpbmRleCsrXSA9IHZhbHVlO1xuICByZXR1cm4gTztcbn07IiwidmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXRlciwgSVRFUkFUT1Ipe1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvck9mKGl0ZXIsIGZhbHNlLCByZXN1bHQucHVzaCwgcmVzdWx0LCBJVEVSQVRPUik7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gMCAtPiBBcnJheSNmb3JFYWNoXG4vLyAxIC0+IEFycmF5I21hcFxuLy8gMiAtPiBBcnJheSNmaWx0ZXJcbi8vIDMgLT4gQXJyYXkjc29tZVxuLy8gNCAtPiBBcnJheSNldmVyeVxuLy8gNSAtPiBBcnJheSNmaW5kXG4vLyA2IC0+IEFycmF5I2ZpbmRJbmRleFxudmFyIGN0eCAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBJT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgYXNjICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUWVBFLCAkY3JlYXRlKXtcbiAgdmFyIElTX01BUCAgICAgICAgPSBUWVBFID09IDFcbiAgICAsIElTX0ZJTFRFUiAgICAgPSBUWVBFID09IDJcbiAgICAsIElTX1NPTUUgICAgICAgPSBUWVBFID09IDNcbiAgICAsIElTX0VWRVJZICAgICAgPSBUWVBFID09IDRcbiAgICAsIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDZcbiAgICAsIE5PX0hPTEVTICAgICAgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWFxuICAgICwgY3JlYXRlICAgICAgICA9ICRjcmVhdGUgfHwgYXNjO1xuICByZXR1cm4gZnVuY3Rpb24oJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQpe1xuICAgIHZhciBPICAgICAgPSB0b09iamVjdCgkdGhpcylcbiAgICAgICwgc2VsZiAgID0gSU9iamVjdChPKVxuICAgICAgLCBmICAgICAgPSBjdHgoY2FsbGJhY2tmbiwgdGhhdCwgMylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoc2VsZi5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IDBcbiAgICAgICwgcmVzdWx0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZFxuICAgICAgLCB2YWwsIHJlcztcbiAgICBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpe1xuICAgICAgdmFsID0gc2VsZltpbmRleF07XG4gICAgICByZXMgPSBmKHZhbCwgaW5kZXgsIE8pO1xuICAgICAgaWYoVFlQRSl7XG4gICAgICAgIGlmKElTX01BUClyZXN1bHRbaW5kZXhdID0gcmVzOyAgICAgICAgICAgIC8vIG1hcFxuICAgICAgICBlbHNlIGlmKHJlcylzd2l0Y2goVFlQRSl7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWw7ICAgICAgICAgICAgICAgICAgICAgLy8gZmluZFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHJlc3VsdC5wdXNoKHZhbCk7ICAgICAgICAgICAgICAgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBpZihJU19FVkVSWSlyZXR1cm4gZmFsc2U7ICAgICAgICAgIC8vIGV2ZXJ5XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiByZXN1bHQ7XG4gIH07XG59OyIsInZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCB0b09iamVjdCAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIElPYmplY3QgICA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIHRvTGVuZ3RoICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRoYXQsIGNhbGxiYWNrZm4sIGFMZW4sIG1lbW8sIGlzUmlnaHQpe1xuICBhRnVuY3Rpb24oY2FsbGJhY2tmbik7XG4gIHZhciBPICAgICAgPSB0b09iamVjdCh0aGF0KVxuICAgICwgc2VsZiAgID0gSU9iamVjdChPKVxuICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgLCBpbmRleCAgPSBpc1JpZ2h0ID8gbGVuZ3RoIC0gMSA6IDBcbiAgICAsIGkgICAgICA9IGlzUmlnaHQgPyAtMSA6IDE7XG4gIGlmKGFMZW4gPCAyKWZvcig7Oyl7XG4gICAgaWYoaW5kZXggaW4gc2VsZil7XG4gICAgICBtZW1vID0gc2VsZltpbmRleF07XG4gICAgICBpbmRleCArPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGluZGV4ICs9IGk7XG4gICAgaWYoaXNSaWdodCA/IGluZGV4IDwgMCA6IGxlbmd0aCA8PSBpbmRleCl7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICB9XG4gIH1cbiAgZm9yKDtpc1JpZ2h0ID8gaW5kZXggPj0gMCA6IGxlbmd0aCA+IGluZGV4OyBpbmRleCArPSBpKWlmKGluZGV4IGluIHNlbGYpe1xuICAgIG1lbW8gPSBjYWxsYmFja2ZuKG1lbW8sIHNlbGZbaW5kZXhdLCBpbmRleCwgTyk7XG4gIH1cbiAgcmV0dXJuIG1lbW87XG59OyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgaXNBcnJheSAgPSByZXF1aXJlKCcuL19pcy1hcnJheScpXG4gICwgU1BFQ0lFUyAgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsKXtcbiAgdmFyIEM7XG4gIGlmKGlzQXJyYXkob3JpZ2luYWwpKXtcbiAgICBDID0gb3JpZ2luYWwuY29uc3RydWN0b3I7XG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICBpZih0eXBlb2YgQyA9PSAnZnVuY3Rpb24nICYmIChDID09PSBBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpQyA9IHVuZGVmaW5lZDtcbiAgICBpZihpc09iamVjdChDKSl7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmKEMgPT09IG51bGwpQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQztcbn07IiwiLy8gOS40LjIuMyBBcnJheVNwZWNpZXNDcmVhdGUob3JpZ2luYWxBcnJheSwgbGVuZ3RoKVxudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcmlnaW5hbCwgbGVuZ3RoKXtcbiAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsKSkobGVuZ3RoKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFGdW5jdGlvbiAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBpc09iamVjdCAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBpbnZva2UgICAgID0gcmVxdWlyZSgnLi9faW52b2tlJylcbiAgLCBhcnJheVNsaWNlID0gW10uc2xpY2VcbiAgLCBmYWN0b3JpZXMgID0ge307XG5cbnZhciBjb25zdHJ1Y3QgPSBmdW5jdGlvbihGLCBsZW4sIGFyZ3Mpe1xuICBpZighKGxlbiBpbiBmYWN0b3JpZXMpKXtcbiAgICBmb3IodmFyIG4gPSBbXSwgaSA9IDA7IGkgPCBsZW47IGkrKyluW2ldID0gJ2FbJyArIGkgKyAnXSc7XG4gICAgZmFjdG9yaWVzW2xlbl0gPSBGdW5jdGlvbignRixhJywgJ3JldHVybiBuZXcgRignICsgbi5qb2luKCcsJykgKyAnKScpO1xuICB9IHJldHVybiBmYWN0b3JpZXNbbGVuXShGLCBhcmdzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24uYmluZCB8fCBmdW5jdGlvbiBiaW5kKHRoYXQgLyosIGFyZ3MuLi4gKi8pe1xuICB2YXIgZm4gICAgICAgPSBhRnVuY3Rpb24odGhpcylcbiAgICAsIHBhcnRBcmdzID0gYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBib3VuZCA9IGZ1bmN0aW9uKC8qIGFyZ3MuLi4gKi8pe1xuICAgIHZhciBhcmdzID0gcGFydEFyZ3MuY29uY2F0KGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGJvdW5kID8gY29uc3RydWN0KGZuLCBhcmdzLmxlbmd0aCwgYXJncykgOiBpbnZva2UoZm4sIGFyZ3MsIHRoYXQpO1xuICB9O1xuICBpZihpc09iamVjdChmbi5wcm90b3R5cGUpKWJvdW5kLnByb3RvdHlwZSA9IGZuLnByb3RvdHlwZTtcbiAgcmV0dXJuIGJvdW5kO1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgZFAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgY3JlYXRlICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpXG4gICwgY3R4ICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGFuSW5zdGFuY2UgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIGRlZmluZWQgICAgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpXG4gICwgZm9yT2YgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsICRpdGVyRGVmaW5lID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKVxuICAsIHN0ZXAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJylcbiAgLCBzZXRTcGVjaWVzICA9IHJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJylcbiAgLCBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCBmYXN0S2V5ICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5mYXN0S2V5XG4gICwgU0laRSAgICAgICAgPSBERVNDUklQVE9SUyA/ICdfcycgOiAnc2l6ZSc7XG5cbnZhciBnZXRFbnRyeSA9IGZ1bmN0aW9uKHRoYXQsIGtleSl7XG4gIC8vIGZhc3QgY2FzZVxuICB2YXIgaW5kZXggPSBmYXN0S2V5KGtleSksIGVudHJ5O1xuICBpZihpbmRleCAhPT0gJ0YnKXJldHVybiB0aGF0Ll9pW2luZGV4XTtcbiAgLy8gZnJvemVuIG9iamVjdCBjYXNlXG4gIGZvcihlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pe1xuICAgIGlmKGVudHJ5LmsgPT0ga2V5KXJldHVybiBlbnRyeTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKXtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24odGhhdCwgaXRlcmFibGUpe1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX2kgPSBjcmVhdGUobnVsbCk7IC8vIGluZGV4XG4gICAgICB0aGF0Ll9mID0gdW5kZWZpbmVkOyAgICAvLyBmaXJzdCBlbnRyeVxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgICAgLy8gbGFzdCBlbnRyeVxuICAgICAgdGhhdFtTSVpFXSA9IDA7ICAgICAgICAgLy8gc2l6ZVxuICAgICAgaWYoaXRlcmFibGUgIT0gdW5kZWZpbmVkKWZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMS4zLjEgTWFwLnByb3RvdHlwZS5jbGVhcigpXG4gICAgICAvLyAyMy4yLjMuMiBTZXQucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpe1xuICAgICAgICBmb3IodmFyIHRoYXQgPSB0aGlzLCBkYXRhID0gdGhhdC5faSwgZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKXtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZihlbnRyeS5wKWVudHJ5LnAgPSBlbnRyeS5wLm4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZGVsZXRlIGRhdGFbZW50cnkuaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5fZiA9IHRoYXQuX2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoYXRbU0laRV0gPSAwO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy4zIE1hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjIuMy40IFNldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uKGtleSl7XG4gICAgICAgIHZhciB0aGF0ICA9IHRoaXNcbiAgICAgICAgICAsIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICAgICAgaWYoZW50cnkpe1xuICAgICAgICAgIHZhciBuZXh0ID0gZW50cnkublxuICAgICAgICAgICAgLCBwcmV2ID0gZW50cnkucDtcbiAgICAgICAgICBkZWxldGUgdGhhdC5faVtlbnRyeS5pXTtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZihwcmV2KXByZXYubiA9IG5leHQ7XG4gICAgICAgICAgaWYobmV4dCluZXh0LnAgPSBwcmV2O1xuICAgICAgICAgIGlmKHRoYXQuX2YgPT0gZW50cnkpdGhhdC5fZiA9IG5leHQ7XG4gICAgICAgICAgaWYodGhhdC5fbCA9PSBlbnRyeSl0aGF0Ll9sID0gcHJldjtcbiAgICAgICAgICB0aGF0W1NJWkVdLS07XG4gICAgICAgIH0gcmV0dXJuICEhZW50cnk7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMi4zLjYgU2V0LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICAvLyAyMy4xLjMuNSBNYXAucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XG4gICAgICAgIGFuSW5zdGFuY2UodGhpcywgQywgJ2ZvckVhY2gnKTtcbiAgICAgICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIDMpXG4gICAgICAgICAgLCBlbnRyeTtcbiAgICAgICAgd2hpbGUoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGlzLl9mKXtcbiAgICAgICAgICBmKGVudHJ5LnYsIGVudHJ5LmssIHRoaXMpO1xuICAgICAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjcgTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuMi4zLjcgU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpe1xuICAgICAgICByZXR1cm4gISFnZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmKERFU0NSSVBUT1JTKWRQKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIGRlZmluZWQodGhpc1tTSVpFXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24odGhhdCwga2V5LCB2YWx1ZSl7XG4gICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KVxuICAgICAgLCBwcmV2LCBpbmRleDtcbiAgICAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcbiAgICBpZihlbnRyeSl7XG4gICAgICBlbnRyeS52ID0gdmFsdWU7XG4gICAgLy8gY3JlYXRlIG5ldyBlbnRyeVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGF0Ll9sID0gZW50cnkgPSB7XG4gICAgICAgIGk6IGluZGV4ID0gZmFzdEtleShrZXksIHRydWUpLCAvLyA8LSBpbmRleFxuICAgICAgICBrOiBrZXksICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0ga2V5XG4gICAgICAgIHY6IHZhbHVlLCAgICAgICAgICAgICAgICAgICAgICAvLyA8LSB2YWx1ZVxuICAgICAgICBwOiBwcmV2ID0gdGhhdC5fbCwgICAgICAgICAgICAgLy8gPC0gcHJldmlvdXMgZW50cnlcbiAgICAgICAgbjogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgIC8vIDwtIG5leHQgZW50cnlcbiAgICAgICAgcjogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHJlbW92ZWRcbiAgICAgIH07XG4gICAgICBpZighdGhhdC5fZil0aGF0Ll9mID0gZW50cnk7XG4gICAgICBpZihwcmV2KXByZXYubiA9IGVudHJ5O1xuICAgICAgdGhhdFtTSVpFXSsrO1xuICAgICAgLy8gYWRkIHRvIGluZGV4XG4gICAgICBpZihpbmRleCAhPT0gJ0YnKXRoYXQuX2lbaW5kZXhdID0gZW50cnk7XG4gICAgfSByZXR1cm4gdGhhdDtcbiAgfSxcbiAgZ2V0RW50cnk6IGdldEVudHJ5LFxuICBzZXRTdHJvbmc6IGZ1bmN0aW9uKEMsIE5BTUUsIElTX01BUCl7XG4gICAgLy8gYWRkIC5rZXlzLCAudmFsdWVzLCAuZW50cmllcywgW0BAaXRlcmF0b3JdXG4gICAgLy8gMjMuMS4zLjQsIDIzLjEuMy44LCAyMy4xLjMuMTEsIDIzLjEuMy4xMiwgMjMuMi4zLjUsIDIzLjIuMy44LCAyMy4yLjMuMTAsIDIzLjIuMy4xMVxuICAgICRpdGVyRGVmaW5lKEMsIE5BTUUsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcbiAgICAgIHRoaXMuX3QgPSBpdGVyYXRlZDsgIC8vIHRhcmdldFxuICAgICAgdGhpcy5fayA9IGtpbmQ7ICAgICAgLy8ga2luZFxuICAgICAgdGhpcy5fbCA9IHVuZGVmaW5lZDsgLy8gcHJldmlvdXNcbiAgICB9LCBmdW5jdGlvbigpe1xuICAgICAgdmFyIHRoYXQgID0gdGhpc1xuICAgICAgICAsIGtpbmQgID0gdGhhdC5fa1xuICAgICAgICAsIGVudHJ5ID0gdGhhdC5fbDtcbiAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgd2hpbGUoZW50cnkgJiYgZW50cnkucillbnRyeSA9IGVudHJ5LnA7XG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxuICAgICAgaWYoIXRoYXQuX3QgfHwgISh0aGF0Ll9sID0gZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGF0Ll90Ll9mKSl7XG4gICAgICAgIC8vIG9yIGZpbmlzaCB0aGUgaXRlcmF0aW9uXG4gICAgICAgIHRoYXQuX3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBzdGVwKDEpO1xuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxuICAgICAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBlbnRyeS5rKTtcbiAgICAgIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIHN0ZXAoMCwgZW50cnkudik7XG4gICAgICByZXR1cm4gc3RlcCgwLCBbZW50cnkuaywgZW50cnkudl0pO1xuICAgIH0sIElTX01BUCA/ICdlbnRyaWVzJyA6ICd2YWx1ZXMnICwgIUlTX01BUCwgdHJ1ZSk7XG5cbiAgICAvLyBhZGQgW0BAc3BlY2llc10sIDIzLjEuMi4yLCAyMy4yLjIuMlxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG4gIH1cbn07IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCBmcm9tICAgID0gcmVxdWlyZSgnLi9fYXJyYXktZnJvbS1pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihOQU1FKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRvSlNPTigpe1xuICAgIGlmKGNsYXNzb2YodGhpcykgIT0gTkFNRSl0aHJvdyBUeXBlRXJyb3IoTkFNRSArIFwiI3RvSlNPTiBpc24ndCBnZW5lcmljXCIpO1xuICAgIHJldHVybiBmcm9tKHRoaXMpO1xuICB9O1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgcmVkZWZpbmVBbGwgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIGdldFdlYWsgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLmdldFdlYWtcbiAgLCBhbk9iamVjdCAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgaXNPYmplY3QgICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFuSW5zdGFuY2UgICAgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIGZvck9mICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZm9yLW9mJylcbiAgLCBjcmVhdGVBcnJheU1ldGhvZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKVxuICAsICRoYXMgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBhcnJheUZpbmQgICAgICAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDUpXG4gICwgYXJyYXlGaW5kSW5kZXggICAgPSBjcmVhdGVBcnJheU1ldGhvZCg2KVxuICAsIGlkICAgICAgICAgICAgICAgID0gMDtcblxuLy8gZmFsbGJhY2sgZm9yIHVuY2F1Z2h0IGZyb3plbiBrZXlzXG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uKHRoYXQpe1xuICByZXR1cm4gdGhhdC5fbCB8fCAodGhhdC5fbCA9IG5ldyBVbmNhdWdodEZyb3plblN0b3JlKTtcbn07XG52YXIgVW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuYSA9IFtdO1xufTtcbnZhciBmaW5kVW5jYXVnaHRGcm96ZW4gPSBmdW5jdGlvbihzdG9yZSwga2V5KXtcbiAgcmV0dXJuIGFycmF5RmluZChzdG9yZS5hLCBmdW5jdGlvbihpdCl7XG4gICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gIH0pO1xufTtcblVuY2F1Z2h0RnJvemVuU3RvcmUucHJvdG90eXBlID0ge1xuICBnZXQ6IGZ1bmN0aW9uKGtleSl7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYoZW50cnkpcmV0dXJuIGVudHJ5WzFdO1xuICB9LFxuICBoYXM6IGZ1bmN0aW9uKGtleSl7XG4gICAgcmV0dXJuICEhZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYoZW50cnkpZW50cnlbMV0gPSB2YWx1ZTtcbiAgICBlbHNlIHRoaXMuYS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0sXG4gICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xuICAgIHZhciBpbmRleCA9IGFycmF5RmluZEluZGV4KHRoaXMuYSwgZnVuY3Rpb24oaXQpe1xuICAgICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gICAgfSk7XG4gICAgaWYofmluZGV4KXRoaXMuYS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiAhIX5pbmRleDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKXtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24odGhhdCwgaXRlcmFibGUpe1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX2kgPSBpZCsrOyAgICAgIC8vIGNvbGxlY3Rpb24gaWRcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7IC8vIGxlYWsgc3RvcmUgZm9yIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RzXG4gICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4zLjMuMiBXZWFrTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuNC4zLjMgV2Vha1NldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uKGtleSl7XG4gICAgICAgIGlmKCFpc09iamVjdChrZXkpKXJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICAgIGlmKGRhdGEgPT09IHRydWUpcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodGhpcylbJ2RlbGV0ZSddKGtleSk7XG4gICAgICAgIHJldHVybiBkYXRhICYmICRoYXMoZGF0YSwgdGhpcy5faSkgJiYgZGVsZXRlIGRhdGFbdGhpcy5faV07XG4gICAgICB9LFxuICAgICAgLy8gMjMuMy4zLjQgV2Vha01hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjQuMy40IFdlYWtTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSl7XG4gICAgICAgIGlmKCFpc09iamVjdChrZXkpKXJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICAgIGlmKGRhdGEgPT09IHRydWUpcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodGhpcykuaGFzKGtleSk7XG4gICAgICAgIHJldHVybiBkYXRhICYmICRoYXMoZGF0YSwgdGhpcy5faSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24odGhhdCwga2V5LCB2YWx1ZSl7XG4gICAgdmFyIGRhdGEgPSBnZXRXZWFrKGFuT2JqZWN0KGtleSksIHRydWUpO1xuICAgIGlmKGRhdGEgPT09IHRydWUpdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGF0KS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgZWxzZSBkYXRhW3RoYXQuX2ldID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIHVmc3RvcmU6IHVuY2F1Z2h0RnJvemVuU3RvcmVcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCAkZXhwb3J0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgcmVkZWZpbmVBbGwgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIG1ldGEgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpXG4gICwgZm9yT2YgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsIGFuSW5zdGFuY2UgICAgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIGlzT2JqZWN0ICAgICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBmYWlscyAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCAkaXRlckRldGVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JylcbiAgLCBzZXRUb1N0cmluZ1RhZyAgICA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSyl7XG4gIHZhciBCYXNlICA9IGdsb2JhbFtOQU1FXVxuICAgICwgQyAgICAgPSBCYXNlXG4gICAgLCBBRERFUiA9IElTX01BUCA/ICdzZXQnIDogJ2FkZCdcbiAgICAsIHByb3RvID0gQyAmJiBDLnByb3RvdHlwZVxuICAgICwgTyAgICAgPSB7fTtcbiAgdmFyIGZpeE1ldGhvZCA9IGZ1bmN0aW9uKEtFWSl7XG4gICAgdmFyIGZuID0gcHJvdG9bS0VZXTtcbiAgICByZWRlZmluZShwcm90bywgS0VZLFxuICAgICAgS0VZID09ICdkZWxldGUnID8gZnVuY3Rpb24oYSl7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnaGFzJyA/IGZ1bmN0aW9uIGhhcyhhKXtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gZmFsc2UgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdnZXQnID8gZnVuY3Rpb24gZ2V0KGEpe1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyB1bmRlZmluZWQgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdhZGQnID8gZnVuY3Rpb24gYWRkKGEpeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7IHJldHVybiB0aGlzOyB9XG4gICAgICAgIDogZnVuY3Rpb24gc2V0KGEsIGIpeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSwgYik7IHJldHVybiB0aGlzOyB9XG4gICAgKTtcbiAgfTtcbiAgaWYodHlwZW9mIEMgIT0gJ2Z1bmN0aW9uJyB8fCAhKElTX1dFQUsgfHwgcHJvdG8uZm9yRWFjaCAmJiAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBuZXcgQygpLmVudHJpZXMoKS5uZXh0KCk7XG4gIH0pKSl7XG4gICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAgICBDID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgICBtZXRhLk5FRUQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBpbnN0YW5jZSAgICAgICAgICAgICA9IG5ldyBDXG4gICAgICAvLyBlYXJseSBpbXBsZW1lbnRhdGlvbnMgbm90IHN1cHBvcnRzIGNoYWluaW5nXG4gICAgICAsIEhBU05UX0NIQUlOSU5HICAgICAgID0gaW5zdGFuY2VbQURERVJdKElTX1dFQUsgPyB7fSA6IC0wLCAxKSAhPSBpbnN0YW5jZVxuICAgICAgLy8gVjggfiAgQ2hyb21pdW0gNDAtIHdlYWstY29sbGVjdGlvbnMgdGhyb3dzIG9uIHByaW1pdGl2ZXMsIGJ1dCBzaG91bGQgcmV0dXJuIGZhbHNlXG4gICAgICAsIFRIUk9XU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24oKXsgaW5zdGFuY2UuaGFzKDEpOyB9KVxuICAgICAgLy8gbW9zdCBlYXJseSBpbXBsZW1lbnRhdGlvbnMgZG9lc24ndCBzdXBwb3J0cyBpdGVyYWJsZXMsIG1vc3QgbW9kZXJuIC0gbm90IGNsb3NlIGl0IGNvcnJlY3RseVxuICAgICAgLCBBQ0NFUFRfSVRFUkFCTEVTICAgICA9ICRpdGVyRGV0ZWN0KGZ1bmN0aW9uKGl0ZXIpeyBuZXcgQyhpdGVyKTsgfSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIC8vIGZvciBlYXJseSBpbXBsZW1lbnRhdGlvbnMgLTAgYW5kICswIG5vdCB0aGUgc2FtZVxuICAgICAgLCBCVUdHWV9aRVJPID0gIUlTX1dFQUsgJiYgZmFpbHMoZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gVjggfiBDaHJvbWl1bSA0Mi0gZmFpbHMgb25seSB3aXRoIDUrIGVsZW1lbnRzXG4gICAgICAgIHZhciAkaW5zdGFuY2UgPSBuZXcgQygpXG4gICAgICAgICAgLCBpbmRleCAgICAgPSA1O1xuICAgICAgICB3aGlsZShpbmRleC0tKSRpbnN0YW5jZVtBRERFUl0oaW5kZXgsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuICEkaW5zdGFuY2UuaGFzKC0wKTtcbiAgICAgIH0pO1xuICAgIGlmKCFBQ0NFUFRfSVRFUkFCTEVTKXsgXG4gICAgICBDID0gd3JhcHBlcihmdW5jdGlvbih0YXJnZXQsIGl0ZXJhYmxlKXtcbiAgICAgICAgYW5JbnN0YW5jZSh0YXJnZXQsIEMsIE5BTUUpO1xuICAgICAgICB2YXIgdGhhdCA9IGluaGVyaXRJZlJlcXVpcmVkKG5ldyBCYXNlLCB0YXJnZXQsIEMpO1xuICAgICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICAgIH0pO1xuICAgICAgQy5wcm90b3R5cGUgPSBwcm90bztcbiAgICAgIHByb3RvLmNvbnN0cnVjdG9yID0gQztcbiAgICB9XG4gICAgaWYoVEhST1dTX09OX1BSSU1JVElWRVMgfHwgQlVHR1lfWkVSTyl7XG4gICAgICBmaXhNZXRob2QoJ2RlbGV0ZScpO1xuICAgICAgZml4TWV0aG9kKCdoYXMnKTtcbiAgICAgIElTX01BUCAmJiBmaXhNZXRob2QoJ2dldCcpO1xuICAgIH1cbiAgICBpZihCVUdHWV9aRVJPIHx8IEhBU05UX0NIQUlOSU5HKWZpeE1ldGhvZChBRERFUik7XG4gICAgLy8gd2VhayBjb2xsZWN0aW9ucyBzaG91bGQgbm90IGNvbnRhaW5zIC5jbGVhciBtZXRob2RcbiAgICBpZihJU19XRUFLICYmIHByb3RvLmNsZWFyKWRlbGV0ZSBwcm90by5jbGVhcjtcbiAgfVxuXG4gIHNldFRvU3RyaW5nVGFnKEMsIE5BTUUpO1xuXG4gIE9bTkFNRV0gPSBDO1xuICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChDICE9IEJhc2UpLCBPKTtcblxuICBpZighSVNfV0VBSyljb21tb24uc2V0U3Ryb25nKEMsIE5BTUUsIElTX01BUCk7XG5cbiAgcmV0dXJuIEM7XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIE5VTUJFUiAgICAgID0gJ251bWJlcic7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGludCl7XG4gIGlmKGhpbnQgIT09ICdzdHJpbmcnICYmIGhpbnQgIT09IE5VTUJFUiAmJiBoaW50ICE9PSAnZGVmYXVsdCcpdGhyb3cgVHlwZUVycm9yKCdJbmNvcnJlY3QgaGludCcpO1xuICByZXR1cm4gdG9QcmltaXRpdmUoYW5PYmplY3QodGhpcyksIGhpbnQgIT0gTlVNQkVSKTtcbn07IiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgaGlkZSAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgcmVkZWZpbmUgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIGN0eCAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgc291cmNlKXtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkZcbiAgICAsIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0LkdcbiAgICAsIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlNcbiAgICAsIElTX1BST1RPICA9IHR5cGUgJiAkZXhwb3J0LlBcbiAgICAsIElTX0JJTkQgICA9IHR5cGUgJiAkZXhwb3J0LkJcbiAgICAsIHRhcmdldCAgICA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSB8fCAoZ2xvYmFsW25hbWVdID0ge30pIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxuICAgICwgZXhwb3J0cyAgID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSlcbiAgICAsIGV4cFByb3RvICA9IGV4cG9ydHNbUFJPVE9UWVBFXSB8fCAoZXhwb3J0c1tQUk9UT1RZUEVdID0ge30pXG4gICAgLCBrZXksIG93biwgb3V0LCBleHA7XG4gIGlmKElTX0dMT0JBTClzb3VyY2UgPSBuYW1lO1xuICBmb3Ioa2V5IGluIHNvdXJjZSl7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IChvd24gPyB0YXJnZXQgOiBzb3VyY2UpW2tleV07XG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICBleHAgPSBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgaWYodGFyZ2V0KXJlZGVmaW5lKHRhcmdldCwga2V5LCBvdXQsIHR5cGUgJiAkZXhwb3J0LlUpO1xuICAgIC8vIGV4cG9ydFxuICAgIGlmKGV4cG9ydHNba2V5XSAhPSBvdXQpaGlkZShleHBvcnRzLCBrZXksIGV4cCk7XG4gICAgaWYoSVNfUFJPVE8gJiYgZXhwUHJvdG9ba2V5XSAhPSBvdXQpZXhwUHJvdG9ba2V5XSA9IG91dDtcbiAgfVxufTtcbmdsb2JhbC5jb3JlID0gY29yZTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWAgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7IiwidmFyIE1BVENIID0gcmVxdWlyZSgnLi9fd2tzJykoJ21hdGNoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSl7XG4gIHZhciByZSA9IC8uLztcbiAgdHJ5IHtcbiAgICAnLy4vJ1tLRVldKHJlKTtcbiAgfSBjYXRjaChlKXtcbiAgICB0cnkge1xuICAgICAgcmVbTUFUQ0hdID0gZmFsc2U7XG4gICAgICByZXR1cm4gIScvLi8nW0tFWV0ocmUpO1xuICAgIH0gY2F0Y2goZil7IC8qIGVtcHR5ICovIH1cbiAgfSByZXR1cm4gdHJ1ZTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGhpZGUgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgZmFpbHMgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgZGVmaW5lZCAgPSByZXF1aXJlKCcuL19kZWZpbmVkJylcbiAgLCB3a3MgICAgICA9IHJlcXVpcmUoJy4vX3drcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSwgbGVuZ3RoLCBleGVjKXtcbiAgdmFyIFNZTUJPTCAgID0gd2tzKEtFWSlcbiAgICAsIGZucyAgICAgID0gZXhlYyhkZWZpbmVkLCBTWU1CT0wsICcnW0tFWV0pXG4gICAgLCBzdHJmbiAgICA9IGZuc1swXVxuICAgICwgcnhmbiAgICAgPSBmbnNbMV07XG4gIGlmKGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgdmFyIE8gPSB7fTtcbiAgICBPW1NZTUJPTF0gPSBmdW5jdGlvbigpeyByZXR1cm4gNzsgfTtcbiAgICByZXR1cm4gJydbS0VZXShPKSAhPSA3O1xuICB9KSl7XG4gICAgcmVkZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgS0VZLCBzdHJmbik7XG4gICAgaGlkZShSZWdFeHAucHJvdG90eXBlLCBTWU1CT0wsIGxlbmd0aCA9PSAyXG4gICAgICAvLyAyMS4yLjUuOCBSZWdFeHAucHJvdG90eXBlW0BAcmVwbGFjZV0oc3RyaW5nLCByZXBsYWNlVmFsdWUpXG4gICAgICAvLyAyMS4yLjUuMTEgUmVnRXhwLnByb3RvdHlwZVtAQHNwbGl0XShzdHJpbmcsIGxpbWl0KVxuICAgICAgPyBmdW5jdGlvbihzdHJpbmcsIGFyZyl7IHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzLCBhcmcpOyB9XG4gICAgICAvLyAyMS4yLjUuNiBSZWdFeHAucHJvdG90eXBlW0BAbWF0Y2hdKHN0cmluZylcbiAgICAgIC8vIDIxLjIuNS45IFJlZ0V4cC5wcm90b3R5cGVbQEBzZWFyY2hdKHN0cmluZylcbiAgICAgIDogZnVuY3Rpb24oc3RyaW5nKXsgcmV0dXJuIHJ4Zm4uY2FsbChzdHJpbmcsIHRoaXMpOyB9XG4gICAgKTtcbiAgfVxufTsiLCIndXNlIHN0cmljdCc7XG4vLyAyMS4yLjUuMyBnZXQgUmVnRXhwLnByb3RvdHlwZS5mbGFnc1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7XG4gIHZhciB0aGF0ICAgPSBhbk9iamVjdCh0aGlzKVxuICAgICwgcmVzdWx0ID0gJyc7XG4gIGlmKHRoYXQuZ2xvYmFsKSAgICAgcmVzdWx0ICs9ICdnJztcbiAgaWYodGhhdC5pZ25vcmVDYXNlKSByZXN1bHQgKz0gJ2knO1xuICBpZih0aGF0Lm11bHRpbGluZSkgIHJlc3VsdCArPSAnbSc7XG4gIGlmKHRoYXQudW5pY29kZSkgICAgcmVzdWx0ICs9ICd1JztcbiAgaWYodGhhdC5zdGlja3kpICAgICByZXN1bHQgKz0gJ3knO1xuICByZXR1cm4gcmVzdWx0O1xufTsiLCJ2YXIgaXNPYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0aGF0LCB0YXJnZXQsIEMpe1xuICB2YXIgUCwgUyA9IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgaWYoUyAhPT0gQyAmJiB0eXBlb2YgUyA9PSAnZnVuY3Rpb24nICYmIChQID0gUy5wcm90b3R5cGUpICE9PSBDLnByb3RvdHlwZSAmJiBpc09iamVjdChQKSAmJiBzZXRQcm90b3R5cGVPZil7XG4gICAgc2V0UHJvdG90eXBlT2YodGhhdCwgUCk7XG4gIH0gcmV0dXJuIHRoYXQ7XG59OyIsIi8vIDIwLjEuMi4zIE51bWJlci5pc0ludGVnZXIobnVtYmVyKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBmbG9vciAgICA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzSW50ZWdlcihpdCl7XG4gIHJldHVybiAhaXNPYmplY3QoaXQpICYmIGlzRmluaXRlKGl0KSAmJiBmbG9vcihpdCkgPT09IGl0O1xufTsiLCIvLyA3LjIuOCBJc1JlZ0V4cChhcmd1bWVudClcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgY29mICAgICAgPSByZXF1aXJlKCcuL19jb2YnKVxuICAsIE1BVENIICAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ21hdGNoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSF0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY29mKGl0KSA9PSAnUmVnRXhwJyk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZmFsc2U7IiwiLy8gMjAuMi4yLjE0IE1hdGguZXhwbTEoeClcbnZhciAkZXhwbTEgPSBNYXRoLmV4cG0xO1xubW9kdWxlLmV4cG9ydHMgPSAoISRleHBtMVxuICAvLyBPbGQgRkYgYnVnXG4gIHx8ICRleHBtMSgxMCkgPiAyMjAyNS40NjU3OTQ4MDY3MTkgfHwgJGV4cG0xKDEwKSA8IDIyMDI1LjQ2NTc5NDgwNjcxNjUxNjhcbiAgLy8gVG9yIEJyb3dzZXIgYnVnXG4gIHx8ICRleHBtMSgtMmUtMTcpICE9IC0yZS0xN1xuKSA/IGZ1bmN0aW9uIGV4cG0xKHgpe1xuICByZXR1cm4gKHggPSAreCkgPT0gMCA/IHggOiB4ID4gLTFlLTYgJiYgeCA8IDFlLTYgPyB4ICsgeCAqIHggLyAyIDogTWF0aC5leHAoeCkgLSAxO1xufSA6ICRleHBtMTsiLCIvLyAyMC4yLjIuMjAgTWF0aC5sb2cxcCh4KVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLmxvZzFwIHx8IGZ1bmN0aW9uIGxvZzFwKHgpe1xuICByZXR1cm4gKHggPSAreCkgPiAtMWUtOCAmJiB4IDwgMWUtOCA/IHggLSB4ICogeCAvIDIgOiBNYXRoLmxvZygxICsgeCk7XG59OyIsIi8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcbm1vZHVsZS5leHBvcnRzID0gTWF0aC5zaWduIHx8IGZ1bmN0aW9uIHNpZ24oeCl7XG4gIHJldHVybiAoeCA9ICt4KSA9PSAwIHx8IHggIT0geCA/IHggOiB4IDwgMCA/IC0xIDogMTtcbn07IiwidmFyIE1hcCAgICAgPSByZXF1aXJlKCcuL2VzNi5tYXAnKVxuICAsICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHNoYXJlZCAgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnbWV0YWRhdGEnKVxuICAsIHN0b3JlICAgPSBzaGFyZWQuc3RvcmUgfHwgKHNoYXJlZC5zdG9yZSA9IG5ldyAocmVxdWlyZSgnLi9lczYud2Vhay1tYXAnKSkpO1xuXG52YXIgZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCA9IGZ1bmN0aW9uKHRhcmdldCwgdGFyZ2V0S2V5LCBjcmVhdGUpe1xuICB2YXIgdGFyZ2V0TWV0YWRhdGEgPSBzdG9yZS5nZXQodGFyZ2V0KTtcbiAgaWYoIXRhcmdldE1ldGFkYXRhKXtcbiAgICBpZighY3JlYXRlKXJldHVybiB1bmRlZmluZWQ7XG4gICAgc3RvcmUuc2V0KHRhcmdldCwgdGFyZ2V0TWV0YWRhdGEgPSBuZXcgTWFwKTtcbiAgfVxuICB2YXIga2V5TWV0YWRhdGEgPSB0YXJnZXRNZXRhZGF0YS5nZXQodGFyZ2V0S2V5KTtcbiAgaWYoIWtleU1ldGFkYXRhKXtcbiAgICBpZighY3JlYXRlKXJldHVybiB1bmRlZmluZWQ7XG4gICAgdGFyZ2V0TWV0YWRhdGEuc2V0KHRhcmdldEtleSwga2V5TWV0YWRhdGEgPSBuZXcgTWFwKTtcbiAgfSByZXR1cm4ga2V5TWV0YWRhdGE7XG59O1xudmFyIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBmdW5jdGlvbihNZXRhZGF0YUtleSwgTywgUCl7XG4gIHZhciBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgZmFsc2UpO1xuICByZXR1cm4gbWV0YWRhdGFNYXAgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogbWV0YWRhdGFNYXAuaGFzKE1ldGFkYXRhS2V5KTtcbn07XG52YXIgb3JkaW5hcnlHZXRPd25NZXRhZGF0YSA9IGZ1bmN0aW9uKE1ldGFkYXRhS2V5LCBPLCBQKXtcbiAgdmFyIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCBmYWxzZSk7XG4gIHJldHVybiBtZXRhZGF0YU1hcCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogbWV0YWRhdGFNYXAuZ2V0KE1ldGFkYXRhS2V5KTtcbn07XG52YXIgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSA9IGZ1bmN0aW9uKE1ldGFkYXRhS2V5LCBNZXRhZGF0YVZhbHVlLCBPLCBQKXtcbiAgZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCB0cnVlKS5zZXQoTWV0YWRhdGFLZXksIE1ldGFkYXRhVmFsdWUpO1xufTtcbnZhciBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyA9IGZ1bmN0aW9uKHRhcmdldCwgdGFyZ2V0S2V5KXtcbiAgdmFyIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCh0YXJnZXQsIHRhcmdldEtleSwgZmFsc2UpXG4gICAgLCBrZXlzICAgICAgICA9IFtdO1xuICBpZihtZXRhZGF0YU1hcCltZXRhZGF0YU1hcC5mb3JFYWNoKGZ1bmN0aW9uKF8sIGtleSl7IGtleXMucHVzaChrZXkpOyB9KTtcbiAgcmV0dXJuIGtleXM7XG59O1xudmFyIHRvTWV0YUtleSA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiBTdHJpbmcoaXQpO1xufTtcbnZhciBleHAgPSBmdW5jdGlvbihPKXtcbiAgJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0JywgTyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3RvcmU6IHN0b3JlLFxuICBtYXA6IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAsXG4gIGhhczogb3JkaW5hcnlIYXNPd25NZXRhZGF0YSxcbiAgZ2V0OiBvcmRpbmFyeUdldE93bk1ldGFkYXRhLFxuICBzZXQ6IG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEsXG4gIGtleXM6IG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzLFxuICBrZXk6IHRvTWV0YUtleSxcbiAgZXhwOiBleHBcbn07IiwiLy8gRm9yY2VkIHJlcGxhY2VtZW50IHByb3RvdHlwZSBhY2Nlc3NvcnMgbWV0aG9kc1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyl8fCAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICB2YXIgSyA9IE1hdGgucmFuZG9tKCk7XG4gIC8vIEluIEZGIHRocm93cyBvbmx5IGRlZmluZSBtZXRob2RzXG4gIF9fZGVmaW5lU2V0dGVyX18uY2FsbChudWxsLCBLLCBmdW5jdGlvbigpeyAvKiBlbXB0eSAqL30pO1xuICBkZWxldGUgcmVxdWlyZSgnLi9fZ2xvYmFsJylbS107XG59KTsiLCJ2YXIgZ2V0S2V5cyAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGlzRW51bSAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc0VudHJpZXMpe1xuICByZXR1cm4gZnVuY3Rpb24oaXQpe1xuICAgIHZhciBPICAgICAgPSB0b0lPYmplY3QoaXQpXG4gICAgICAsIGtleXMgICA9IGdldEtleXMoTylcbiAgICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAgICwgaSAgICAgID0gMFxuICAgICAgLCByZXN1bHQgPSBbXVxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUobGVuZ3RoID4gaSlpZihpc0VudW0uY2FsbChPLCBrZXkgPSBrZXlzW2krK10pKXtcbiAgICAgIHJlc3VsdC5wdXNoKGlzRW50cmllcyA/IFtrZXksIE9ba2V5XV0gOiBPW2tleV0pO1xuICAgIH0gcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn07IiwiLy8gYWxsIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9sc1xudmFyIGdPUE4gICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKVxuICAsIGdPUFMgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBSZWZsZWN0ICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IFJlZmxlY3QgJiYgUmVmbGVjdC5vd25LZXlzIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpe1xuICB2YXIga2V5cyAgICAgICA9IGdPUE4uZihhbk9iamVjdChpdCkpXG4gICAgLCBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICByZXR1cm4gZ2V0U3ltYm9scyA/IGtleXMuY29uY2F0KGdldFN5bWJvbHMoaXQpKSA6IGtleXM7XG59OyIsInZhciAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnBhcnNlRmxvYXRcbiAgLCAkdHJpbSAgICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbTtcblxubW9kdWxlLmV4cG9ydHMgPSAxIC8gJHBhcnNlRmxvYXQocmVxdWlyZSgnLi9fc3RyaW5nLXdzJykgKyAnLTAnKSAhPT0gLUluZmluaXR5ID8gZnVuY3Rpb24gcGFyc2VGbG9hdChzdHIpe1xuICB2YXIgc3RyaW5nID0gJHRyaW0oU3RyaW5nKHN0ciksIDMpXG4gICAgLCByZXN1bHQgPSAkcGFyc2VGbG9hdChzdHJpbmcpO1xuICByZXR1cm4gcmVzdWx0ID09PSAwICYmIHN0cmluZy5jaGFyQXQoMCkgPT0gJy0nID8gLTAgOiByZXN1bHQ7XG59IDogJHBhcnNlRmxvYXQ7IiwidmFyICRwYXJzZUludCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnBhcnNlSW50XG4gICwgJHRyaW0gICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltXG4gICwgd3MgICAgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXdzJylcbiAgLCBoZXggICAgICAgPSAvXltcXC0rXT8wW3hYXS87XG5cbm1vZHVsZS5leHBvcnRzID0gJHBhcnNlSW50KHdzICsgJzA4JykgIT09IDggfHwgJHBhcnNlSW50KHdzICsgJzB4MTYnKSAhPT0gMjIgPyBmdW5jdGlvbiBwYXJzZUludChzdHIsIHJhZGl4KXtcbiAgdmFyIHN0cmluZyA9ICR0cmltKFN0cmluZyhzdHIpLCAzKTtcbiAgcmV0dXJuICRwYXJzZUludChzdHJpbmcsIChyYWRpeCA+Pj4gMCkgfHwgKGhleC50ZXN0KHN0cmluZykgPyAxNiA6IDEwKSk7XG59IDogJHBhcnNlSW50OyIsIid1c2Ugc3RyaWN0JztcbnZhciBwYXRoICAgICAgPSByZXF1aXJlKCcuL19wYXRoJylcbiAgLCBpbnZva2UgICAgPSByZXF1aXJlKCcuL19pbnZva2UnKVxuICAsIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oLyogLi4ucGFyZ3MgKi8pe1xuICB2YXIgZm4gICAgID0gYUZ1bmN0aW9uKHRoaXMpXG4gICAgLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBwYXJncyAgPSBBcnJheShsZW5ndGgpXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBfICAgICAgPSBwYXRoLl9cbiAgICAsIGhvbGRlciA9IGZhbHNlO1xuICB3aGlsZShsZW5ndGggPiBpKWlmKChwYXJnc1tpXSA9IGFyZ3VtZW50c1tpKytdKSA9PT0gXylob2xkZXIgPSB0cnVlO1xuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgICAsIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIGogPSAwLCBrID0gMCwgYXJncztcbiAgICBpZighaG9sZGVyICYmICFhTGVuKXJldHVybiBpbnZva2UoZm4sIHBhcmdzLCB0aGF0KTtcbiAgICBhcmdzID0gcGFyZ3Muc2xpY2UoKTtcbiAgICBpZihob2xkZXIpZm9yKDtsZW5ndGggPiBqOyBqKyspaWYoYXJnc1tqXSA9PT0gXylhcmdzW2pdID0gYXJndW1lbnRzW2srK107XG4gICAgd2hpbGUoYUxlbiA+IGspYXJncy5wdXNoKGFyZ3VtZW50c1trKytdKTtcbiAgICByZXR1cm4gaW52b2tlKGZuLCBhcmdzLCB0aGF0KTtcbiAgfTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19nbG9iYWwnKTsiLCJ2YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0YXJnZXQsIHNyYywgc2FmZSl7XG4gIGZvcih2YXIga2V5IGluIHNyYylyZWRlZmluZSh0YXJnZXQsIGtleSwgc3JjW2tleV0sIHNhZmUpO1xuICByZXR1cm4gdGFyZ2V0O1xufTsiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoaWRlICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBoYXMgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIFNSQyAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpKCdzcmMnKVxuICAsIFRPX1NUUklORyA9ICd0b1N0cmluZydcbiAgLCAkdG9TdHJpbmcgPSBGdW5jdGlvbltUT19TVFJJTkddXG4gICwgVFBMICAgICAgID0gKCcnICsgJHRvU3RyaW5nKS5zcGxpdChUT19TVFJJTkcpO1xuXG5yZXF1aXJlKCcuL19jb3JlJykuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuICR0b1N0cmluZy5jYWxsKGl0KTtcbn07XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE8sIGtleSwgdmFsLCBzYWZlKXtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgdmFsID09ICdmdW5jdGlvbic7XG4gIGlmKGlzRnVuY3Rpb24paGFzKHZhbCwgJ25hbWUnKSB8fCBoaWRlKHZhbCwgJ25hbWUnLCBrZXkpO1xuICBpZihPW2tleV0gPT09IHZhbClyZXR1cm47XG4gIGlmKGlzRnVuY3Rpb24paGFzKHZhbCwgU1JDKSB8fCBoaWRlKHZhbCwgU1JDLCBPW2tleV0gPyAnJyArIE9ba2V5XSA6IFRQTC5qb2luKFN0cmluZyhrZXkpKSk7XG4gIGlmKE8gPT09IGdsb2JhbCl7XG4gICAgT1trZXldID0gdmFsO1xuICB9IGVsc2Uge1xuICAgIGlmKCFzYWZlKXtcbiAgICAgIGRlbGV0ZSBPW2tleV07XG4gICAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoT1trZXldKU9ba2V5XSA9IHZhbDtcbiAgICAgIGVsc2UgaGlkZShPLCBrZXksIHZhbCk7XG4gICAgfVxuICB9XG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcbn0pKEZ1bmN0aW9uLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICByZXR1cm4gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzW1NSQ10gfHwgJHRvU3RyaW5nLmNhbGwodGhpcyk7XG59KTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHJlZ0V4cCwgcmVwbGFjZSl7XG4gIHZhciByZXBsYWNlciA9IHJlcGxhY2UgPT09IE9iamVjdChyZXBsYWNlKSA/IGZ1bmN0aW9uKHBhcnQpe1xuICAgIHJldHVybiByZXBsYWNlW3BhcnRdO1xuICB9IDogcmVwbGFjZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGl0KXtcbiAgICByZXR1cm4gU3RyaW5nKGl0KS5yZXBsYWNlKHJlZ0V4cCwgcmVwbGFjZXIpO1xuICB9O1xufTsiLCIvLyA3LjIuOSBTYW1lVmFsdWUoeCwgeSlcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmlzIHx8IGZ1bmN0aW9uIGlzKHgsIHkpe1xuICByZXR1cm4geCA9PT0geSA/IHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5IDogeCAhPSB4ICYmIHkgIT0geTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBkUCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgU1BFQ0lFUyAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSl7XG4gIHZhciBDID0gZ2xvYmFsW0tFWV07XG4gIGlmKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pZFAuZihDLCBTUEVDSUVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59OyIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obWV0aG9kLCBhcmcpe1xuICByZXR1cm4gISFtZXRob2QgJiYgZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBhcmcgPyBtZXRob2QuY2FsbChudWxsLCBmdW5jdGlvbigpe30sIDEpIDogbWV0aG9kLmNhbGwobnVsbCk7XG4gIH0pO1xufTsiLCIvLyBoZWxwZXIgZm9yIFN0cmluZyN7c3RhcnRzV2l0aCwgZW5kc1dpdGgsIGluY2x1ZGVzfVxudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJylcbiAgLCBkZWZpbmVkICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0aGF0LCBzZWFyY2hTdHJpbmcsIE5BTUUpe1xuICBpZihpc1JlZ0V4cChzZWFyY2hTdHJpbmcpKXRocm93IFR5cGVFcnJvcignU3RyaW5nIycgKyBOQU1FICsgXCIgZG9lc24ndCBhY2NlcHQgcmVnZXghXCIpO1xuICByZXR1cm4gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xufTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZmFpbHMgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpXG4gICwgcXVvdCAgICA9IC9cIi9nO1xuLy8gQi4yLjMuMi4xIENyZWF0ZUhUTUwoc3RyaW5nLCB0YWcsIGF0dHJpYnV0ZSwgdmFsdWUpXG52YXIgY3JlYXRlSFRNTCA9IGZ1bmN0aW9uKHN0cmluZywgdGFnLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gIHZhciBTICA9IFN0cmluZyhkZWZpbmVkKHN0cmluZykpXG4gICAgLCBwMSA9ICc8JyArIHRhZztcbiAgaWYoYXR0cmlidXRlICE9PSAnJylwMSArPSAnICcgKyBhdHRyaWJ1dGUgKyAnPVwiJyArIFN0cmluZyh2YWx1ZSkucmVwbGFjZShxdW90LCAnJnF1b3Q7JykgKyAnXCInO1xuICByZXR1cm4gcDEgKyAnPicgKyBTICsgJzwvJyArIHRhZyArICc+Jztcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5BTUUsIGV4ZWMpe1xuICB2YXIgTyA9IHt9O1xuICBPW05BTUVdID0gZXhlYyhjcmVhdGVIVE1MKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbigpe1xuICAgIHZhciB0ZXN0ID0gJydbTkFNRV0oJ1wiJyk7XG4gICAgcmV0dXJuIHRlc3QgIT09IHRlc3QudG9Mb3dlckNhc2UoKSB8fCB0ZXN0LnNwbGl0KCdcIicpLmxlbmd0aCA+IDM7XG4gIH0pLCAnU3RyaW5nJywgTyk7XG59OyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIHJlcGVhdCAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXJlcGVhdCcpXG4gICwgZGVmaW5lZCAgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGhhdCwgbWF4TGVuZ3RoLCBmaWxsU3RyaW5nLCBsZWZ0KXtcbiAgdmFyIFMgICAgICAgICAgICA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKVxuICAgICwgc3RyaW5nTGVuZ3RoID0gUy5sZW5ndGhcbiAgICAsIGZpbGxTdHIgICAgICA9IGZpbGxTdHJpbmcgPT09IHVuZGVmaW5lZCA/ICcgJyA6IFN0cmluZyhmaWxsU3RyaW5nKVxuICAgICwgaW50TWF4TGVuZ3RoID0gdG9MZW5ndGgobWF4TGVuZ3RoKTtcbiAgaWYoaW50TWF4TGVuZ3RoIDw9IHN0cmluZ0xlbmd0aCB8fCBmaWxsU3RyID09ICcnKXJldHVybiBTO1xuICB2YXIgZmlsbExlbiA9IGludE1heExlbmd0aCAtIHN0cmluZ0xlbmd0aFxuICAgICwgc3RyaW5nRmlsbGVyID0gcmVwZWF0LmNhbGwoZmlsbFN0ciwgTWF0aC5jZWlsKGZpbGxMZW4gLyBmaWxsU3RyLmxlbmd0aCkpO1xuICBpZihzdHJpbmdGaWxsZXIubGVuZ3RoID4gZmlsbExlbilzdHJpbmdGaWxsZXIgPSBzdHJpbmdGaWxsZXIuc2xpY2UoMCwgZmlsbExlbik7XG4gIHJldHVybiBsZWZ0ID8gc3RyaW5nRmlsbGVyICsgUyA6IFMgKyBzdHJpbmdGaWxsZXI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIGRlZmluZWQgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXBlYXQoY291bnQpe1xuICB2YXIgc3RyID0gU3RyaW5nKGRlZmluZWQodGhpcykpXG4gICAgLCByZXMgPSAnJ1xuICAgICwgbiAgID0gdG9JbnRlZ2VyKGNvdW50KTtcbiAgaWYobiA8IDAgfHwgbiA9PSBJbmZpbml0eSl0aHJvdyBSYW5nZUVycm9yKFwiQ291bnQgY2FuJ3QgYmUgbmVnYXRpdmVcIik7XG4gIGZvcig7biA+IDA7IChuID4+Pj0gMSkgJiYgKHN0ciArPSBzdHIpKWlmKG4gJiAxKXJlcyArPSBzdHI7XG4gIHJldHVybiByZXM7XG59OyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpXG4gICwgZmFpbHMgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBzcGFjZXMgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXdzJylcbiAgLCBzcGFjZSAgID0gJ1snICsgc3BhY2VzICsgJ10nXG4gICwgbm9uICAgICA9ICdcXHUyMDBiXFx1MDA4NSdcbiAgLCBsdHJpbSAgID0gUmVnRXhwKCdeJyArIHNwYWNlICsgc3BhY2UgKyAnKicpXG4gICwgcnRyaW0gICA9IFJlZ0V4cChzcGFjZSArIHNwYWNlICsgJyokJyk7XG5cbnZhciBleHBvcnRlciA9IGZ1bmN0aW9uKEtFWSwgZXhlYywgQUxJQVMpe1xuICB2YXIgZXhwICAgPSB7fTtcbiAgdmFyIEZPUkNFID0gZmFpbHMoZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gISFzcGFjZXNbS0VZXSgpIHx8IG5vbltLRVldKCkgIT0gbm9uO1xuICB9KTtcbiAgdmFyIGZuID0gZXhwW0tFWV0gPSBGT1JDRSA/IGV4ZWModHJpbSkgOiBzcGFjZXNbS0VZXTtcbiAgaWYoQUxJQVMpZXhwW0FMSUFTXSA9IGZuO1xuICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIEZPUkNFLCAnU3RyaW5nJywgZXhwKTtcbn07XG5cbi8vIDEgLT4gU3RyaW5nI3RyaW1MZWZ0XG4vLyAyIC0+IFN0cmluZyN0cmltUmlnaHRcbi8vIDMgLT4gU3RyaW5nI3RyaW1cbnZhciB0cmltID0gZXhwb3J0ZXIudHJpbSA9IGZ1bmN0aW9uKHN0cmluZywgVFlQRSl7XG4gIHN0cmluZyA9IFN0cmluZyhkZWZpbmVkKHN0cmluZykpO1xuICBpZihUWVBFICYgMSlzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShsdHJpbSwgJycpO1xuICBpZihUWVBFICYgMilzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShydHJpbSwgJycpO1xuICByZXR1cm4gc3RyaW5nO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRlcjsiLCJtb2R1bGUuZXhwb3J0cyA9ICdcXHgwOVxceDBBXFx4MEJcXHgwQ1xceDBEXFx4MjBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwMycgK1xuICAnXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRic7IiwiJ3VzZSBzdHJpY3QnO1xuaWYocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSl7XG4gIHZhciBMSUJSQVJZICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICAgLCBnbG9iYWwgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgICAsIGZhaWxzICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICAgLCAkZXhwb3J0ICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgICAsICR0eXBlZCAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190eXBlZCcpXG4gICAgLCAkYnVmZmVyICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJylcbiAgICAsIGN0eCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAgICwgYW5JbnN0YW5jZSAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgICAsIHByb3BlcnR5RGVzYyAgICAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgICAsIGhpZGUgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgICAsIHJlZGVmaW5lQWxsICAgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAgICwgdG9JbnRlZ2VyICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAgICwgdG9MZW5ndGggICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICAgLCB0b0luZGV4ICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAgICwgdG9QcmltaXRpdmUgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICAgLCBoYXMgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgICAsIHNhbWUgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19zYW1lLXZhbHVlJylcbiAgICAsIGNsYXNzb2YgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgICAsIGlzT2JqZWN0ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAgICwgdG9PYmplY3QgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICAgLCBpc0FycmF5SXRlciAgICAgICAgID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpXG4gICAgLCBjcmVhdGUgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICAgLCBnZXRQcm90b3R5cGVPZiAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICAgLCBnT1BOICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICAgLCBnZXRJdGVyRm4gICAgICAgICAgID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKVxuICAgICwgdWlkICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICAgLCB3a3MgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJylcbiAgICAsIGNyZWF0ZUFycmF5TWV0aG9kICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJylcbiAgICAsIGNyZWF0ZUFycmF5SW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpXG4gICAgLCBzcGVjaWVzQ29uc3RydWN0b3IgID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpXG4gICAgLCBBcnJheUl0ZXJhdG9ycyAgICAgID0gcmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKVxuICAgICwgSXRlcmF0b3JzICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICAgLCAkaXRlckRldGVjdCAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKVxuICAgICwgc2V0U3BlY2llcyAgICAgICAgICA9IHJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJylcbiAgICAsIGFycmF5RmlsbCAgICAgICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1maWxsJylcbiAgICAsIGFycmF5Q29weVdpdGhpbiAgICAgPSByZXF1aXJlKCcuL19hcnJheS1jb3B5LXdpdGhpbicpXG4gICAgLCAkRFAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgICAsICRHT1BEICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICAgLCBkUCAgICAgICAgICAgICAgICAgID0gJERQLmZcbiAgICAsIGdPUEQgICAgICAgICAgICAgICAgPSAkR09QRC5mXG4gICAgLCBSYW5nZUVycm9yICAgICAgICAgID0gZ2xvYmFsLlJhbmdlRXJyb3JcbiAgICAsIFR5cGVFcnJvciAgICAgICAgICAgPSBnbG9iYWwuVHlwZUVycm9yXG4gICAgLCBVaW50OEFycmF5ICAgICAgICAgID0gZ2xvYmFsLlVpbnQ4QXJyYXlcbiAgICAsIEFSUkFZX0JVRkZFUiAgICAgICAgPSAnQXJyYXlCdWZmZXInXG4gICAgLCBTSEFSRURfQlVGRkVSICAgICAgID0gJ1NoYXJlZCcgKyBBUlJBWV9CVUZGRVJcbiAgICAsIEJZVEVTX1BFUl9FTEVNRU5UICAgPSAnQllURVNfUEVSX0VMRU1FTlQnXG4gICAgLCBQUk9UT1RZUEUgICAgICAgICAgID0gJ3Byb3RvdHlwZSdcbiAgICAsIEFycmF5UHJvdG8gICAgICAgICAgPSBBcnJheVtQUk9UT1RZUEVdXG4gICAgLCAkQXJyYXlCdWZmZXIgICAgICAgID0gJGJ1ZmZlci5BcnJheUJ1ZmZlclxuICAgICwgJERhdGFWaWV3ICAgICAgICAgICA9ICRidWZmZXIuRGF0YVZpZXdcbiAgICAsIGFycmF5Rm9yRWFjaCAgICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCgwKVxuICAgICwgYXJyYXlGaWx0ZXIgICAgICAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDIpXG4gICAgLCBhcnJheVNvbWUgICAgICAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoMylcbiAgICAsIGFycmF5RXZlcnkgICAgICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCg0KVxuICAgICwgYXJyYXlGaW5kICAgICAgICAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDUpXG4gICAgLCBhcnJheUZpbmRJbmRleCAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoNilcbiAgICAsIGFycmF5SW5jbHVkZXMgICAgICAgPSBjcmVhdGVBcnJheUluY2x1ZGVzKHRydWUpXG4gICAgLCBhcnJheUluZGV4T2YgICAgICAgID0gY3JlYXRlQXJyYXlJbmNsdWRlcyhmYWxzZSlcbiAgICAsIGFycmF5VmFsdWVzICAgICAgICAgPSBBcnJheUl0ZXJhdG9ycy52YWx1ZXNcbiAgICAsIGFycmF5S2V5cyAgICAgICAgICAgPSBBcnJheUl0ZXJhdG9ycy5rZXlzXG4gICAgLCBhcnJheUVudHJpZXMgICAgICAgID0gQXJyYXlJdGVyYXRvcnMuZW50cmllc1xuICAgICwgYXJyYXlMYXN0SW5kZXhPZiAgICA9IEFycmF5UHJvdG8ubGFzdEluZGV4T2ZcbiAgICAsIGFycmF5UmVkdWNlICAgICAgICAgPSBBcnJheVByb3RvLnJlZHVjZVxuICAgICwgYXJyYXlSZWR1Y2VSaWdodCAgICA9IEFycmF5UHJvdG8ucmVkdWNlUmlnaHRcbiAgICAsIGFycmF5Sm9pbiAgICAgICAgICAgPSBBcnJheVByb3RvLmpvaW5cbiAgICAsIGFycmF5U29ydCAgICAgICAgICAgPSBBcnJheVByb3RvLnNvcnRcbiAgICAsIGFycmF5U2xpY2UgICAgICAgICAgPSBBcnJheVByb3RvLnNsaWNlXG4gICAgLCBhcnJheVRvU3RyaW5nICAgICAgID0gQXJyYXlQcm90by50b1N0cmluZ1xuICAgICwgYXJyYXlUb0xvY2FsZVN0cmluZyA9IEFycmF5UHJvdG8udG9Mb2NhbGVTdHJpbmdcbiAgICAsIElURVJBVE9SICAgICAgICAgICAgPSB3a3MoJ2l0ZXJhdG9yJylcbiAgICAsIFRBRyAgICAgICAgICAgICAgICAgPSB3a3MoJ3RvU3RyaW5nVGFnJylcbiAgICAsIFRZUEVEX0NPTlNUUlVDVE9SICAgPSB1aWQoJ3R5cGVkX2NvbnN0cnVjdG9yJylcbiAgICAsIERFRl9DT05TVFJVQ1RPUiAgICAgPSB1aWQoJ2RlZl9jb25zdHJ1Y3RvcicpXG4gICAgLCBBTExfQ09OU1RSVUNUT1JTICAgID0gJHR5cGVkLkNPTlNUUlxuICAgICwgVFlQRURfQVJSQVkgICAgICAgICA9ICR0eXBlZC5UWVBFRFxuICAgICwgVklFVyAgICAgICAgICAgICAgICA9ICR0eXBlZC5WSUVXXG4gICAgLCBXUk9OR19MRU5HVEggICAgICAgID0gJ1dyb25nIGxlbmd0aCEnO1xuXG4gIHZhciAkbWFwID0gY3JlYXRlQXJyYXlNZXRob2QoMSwgZnVuY3Rpb24oTywgbGVuZ3RoKXtcbiAgICByZXR1cm4gYWxsb2NhdGUoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSksIGxlbmd0aCk7XG4gIH0pO1xuXG4gIHZhciBMSVRUTEVfRU5ESUFOID0gZmFpbHMoZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQxNkFycmF5KFsxXSkuYnVmZmVyKVswXSA9PT0gMTtcbiAgfSk7XG5cbiAgdmFyIEZPUkNFRF9TRVQgPSAhIVVpbnQ4QXJyYXkgJiYgISFVaW50OEFycmF5W1BST1RPVFlQRV0uc2V0ICYmIGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgbmV3IFVpbnQ4QXJyYXkoMSkuc2V0KHt9KTtcbiAgfSk7XG5cbiAgdmFyIHN0cmljdFRvTGVuZ3RoID0gZnVuY3Rpb24oaXQsIFNBTUUpe1xuICAgIGlmKGl0ID09PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgdmFyIG51bWJlciA9ICtpdFxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChpdCk7XG4gICAgaWYoU0FNRSAmJiAhc2FtZShudW1iZXIsIGxlbmd0aCkpdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHJldHVybiBsZW5ndGg7XG4gIH07XG5cbiAgdmFyIHRvT2Zmc2V0ID0gZnVuY3Rpb24oaXQsIEJZVEVTKXtcbiAgICB2YXIgb2Zmc2V0ID0gdG9JbnRlZ2VyKGl0KTtcbiAgICBpZihvZmZzZXQgPCAwIHx8IG9mZnNldCAlIEJZVEVTKXRocm93IFJhbmdlRXJyb3IoJ1dyb25nIG9mZnNldCEnKTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSA9IGZ1bmN0aW9uKGl0KXtcbiAgICBpZihpc09iamVjdChpdCkgJiYgVFlQRURfQVJSQVkgaW4gaXQpcmV0dXJuIGl0O1xuICAgIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgdHlwZWQgYXJyYXkhJyk7XG4gIH07XG5cbiAgdmFyIGFsbG9jYXRlID0gZnVuY3Rpb24oQywgbGVuZ3RoKXtcbiAgICBpZighKGlzT2JqZWN0KEMpICYmIFRZUEVEX0NPTlNUUlVDVE9SIGluIEMpKXtcbiAgICAgIHRocm93IFR5cGVFcnJvcignSXQgaXMgbm90IGEgdHlwZWQgYXJyYXkgY29uc3RydWN0b3IhJyk7XG4gICAgfSByZXR1cm4gbmV3IEMobGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgc3BlY2llc0Zyb21MaXN0ID0gZnVuY3Rpb24oTywgbGlzdCl7XG4gICAgcmV0dXJuIGZyb21MaXN0KHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pLCBsaXN0KTtcbiAgfTtcblxuICB2YXIgZnJvbUxpc3QgPSBmdW5jdGlvbihDLCBsaXN0KXtcbiAgICB2YXIgaW5kZXggID0gMFxuICAgICAgLCBsZW5ndGggPSBsaXN0Lmxlbmd0aFxuICAgICAgLCByZXN1bHQgPSBhbGxvY2F0ZShDLCBsZW5ndGgpO1xuICAgIHdoaWxlKGxlbmd0aCA+IGluZGV4KXJlc3VsdFtpbmRleF0gPSBsaXN0W2luZGV4KytdO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIGFkZEdldHRlciA9IGZ1bmN0aW9uKGl0LCBrZXksIGludGVybmFsKXtcbiAgICBkUChpdCwga2V5LCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5fZFtpbnRlcm5hbF07IH19KTtcbiAgfTtcblxuICB2YXIgJGZyb20gPSBmdW5jdGlvbiBmcm9tKHNvdXJjZSAvKiwgbWFwZm4sIHRoaXNBcmcgKi8pe1xuICAgIHZhciBPICAgICAgID0gdG9PYmplY3Qoc291cmNlKVxuICAgICAgLCBhTGVuICAgID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBtYXBmbiAgID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWRcbiAgICAgICwgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWRcbiAgICAgICwgaXRlckZuICA9IGdldEl0ZXJGbihPKVxuICAgICAgLCBpLCBsZW5ndGgsIHZhbHVlcywgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZihpdGVyRm4gIT0gdW5kZWZpbmVkICYmICFpc0FycmF5SXRlcihpdGVyRm4pKXtcbiAgICAgIGZvcihpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCB2YWx1ZXMgPSBbXSwgaSA9IDA7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaSsrKXtcbiAgICAgICAgdmFsdWVzLnB1c2goc3RlcC52YWx1ZSk7XG4gICAgICB9IE8gPSB2YWx1ZXM7XG4gICAgfVxuICAgIGlmKG1hcHBpbmcgJiYgYUxlbiA+IDIpbWFwZm4gPSBjdHgobWFwZm4sIGFyZ3VtZW50c1syXSwgMik7XG4gICAgZm9yKGkgPSAwLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCksIHJlc3VsdCA9IGFsbG9jYXRlKHRoaXMsIGxlbmd0aCk7IGxlbmd0aCA+IGk7IGkrKyl7XG4gICAgICByZXN1bHRbaV0gPSBtYXBwaW5nID8gbWFwZm4oT1tpXSwgaSkgOiBPW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciAkb2YgPSBmdW5jdGlvbiBvZigvKi4uLml0ZW1zKi8pe1xuICAgIHZhciBpbmRleCAgPSAwXG4gICAgICAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgcmVzdWx0ID0gYWxsb2NhdGUodGhpcywgbGVuZ3RoKTtcbiAgICB3aGlsZShsZW5ndGggPiBpbmRleClyZXN1bHRbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4KytdO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gaU9TIFNhZmFyaSA2LnggZmFpbHMgaGVyZVxuICB2YXIgVE9fTE9DQUxFX0JVRyA9ICEhVWludDhBcnJheSAmJiBmYWlscyhmdW5jdGlvbigpeyBhcnJheVRvTG9jYWxlU3RyaW5nLmNhbGwobmV3IFVpbnQ4QXJyYXkoMSkpOyB9KTtcblxuICB2YXIgJHRvTG9jYWxlU3RyaW5nID0gZnVuY3Rpb24gdG9Mb2NhbGVTdHJpbmcoKXtcbiAgICByZXR1cm4gYXJyYXlUb0xvY2FsZVN0cmluZy5hcHBseShUT19MT0NBTEVfQlVHID8gYXJyYXlTbGljZS5jYWxsKHZhbGlkYXRlKHRoaXMpKSA6IHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHZhciBwcm90byA9IHtcbiAgICBjb3B5V2l0aGluOiBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldCwgc3RhcnQgLyosIGVuZCAqLyl7XG4gICAgICByZXR1cm4gYXJyYXlDb3B5V2l0aGluLmNhbGwodmFsaWRhdGUodGhpcyksIHRhcmdldCwgc3RhcnQsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuIC8qLCB0aGlzQXJnICovKXtcbiAgICAgIHJldHVybiBhcnJheUV2ZXJ5KHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmaWxsOiBmdW5jdGlvbiBmaWxsKHZhbHVlIC8qLCBzdGFydCwgZW5kICovKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5RmlsbC5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuIHNwZWNpZXNGcm9tTGlzdCh0aGlzLCBhcnJheUZpbHRlcih2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbixcbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpKTtcbiAgICB9LFxuICAgIGZpbmQ6IGZ1bmN0aW9uIGZpbmQocHJlZGljYXRlIC8qLCB0aGlzQXJnICovKXtcbiAgICAgIHJldHVybiBhcnJheUZpbmQodmFsaWRhdGUodGhpcyksIHByZWRpY2F0ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgocHJlZGljYXRlIC8qLCB0aGlzQXJnICovKXtcbiAgICAgIHJldHVybiBhcnJheUZpbmRJbmRleCh2YWxpZGF0ZSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyosIHRoaXNBcmcgKi8pe1xuICAgICAgYXJyYXlGb3JFYWNoKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnQgLyosIGZyb21JbmRleCAqLyl7XG4gICAgICByZXR1cm4gYXJyYXlJbmRleE9mKHZhbGlkYXRlKHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ICovKXtcbiAgICAgIHJldHVybiBhcnJheUluY2x1ZGVzKHZhbGlkYXRlKHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcil7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheUpvaW4uYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ICovKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5TGFzdEluZGV4T2YuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIG1hcChtYXBmbiAvKiwgdGhpc0FyZyAqLyl7XG4gICAgICByZXR1cm4gJG1hcCh2YWxpZGF0ZSh0aGlzKSwgbWFwZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyosIGluaXRpYWxWYWx1ZSAqLyl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheVJlZHVjZS5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHJlZHVjZVJpZ2h0OiBmdW5jdGlvbiByZWR1Y2VSaWdodChjYWxsYmFja2ZuIC8qLCBpbml0aWFsVmFsdWUgKi8peyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2VSaWdodC5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKXtcbiAgICAgIHZhciB0aGF0ICAgPSB0aGlzXG4gICAgICAgICwgbGVuZ3RoID0gdmFsaWRhdGUodGhhdCkubGVuZ3RoXG4gICAgICAgICwgbWlkZGxlID0gTWF0aC5mbG9vcihsZW5ndGggLyAyKVxuICAgICAgICAsIGluZGV4ICA9IDBcbiAgICAgICAgLCB2YWx1ZTtcbiAgICAgIHdoaWxlKGluZGV4IDwgbWlkZGxlKXtcbiAgICAgICAgdmFsdWUgICAgICAgICA9IHRoYXRbaW5kZXhdO1xuICAgICAgICB0aGF0W2luZGV4KytdID0gdGhhdFstLWxlbmd0aF07XG4gICAgICAgIHRoYXRbbGVuZ3RoXSAgPSB2YWx1ZTtcbiAgICAgIH0gcmV0dXJuIHRoYXQ7XG4gICAgfSxcbiAgICBzb21lOiBmdW5jdGlvbiBzb21lKGNhbGxiYWNrZm4gLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuIGFycmF5U29tZSh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pe1xuICAgICAgcmV0dXJuIGFycmF5U29ydC5jYWxsKHZhbGlkYXRlKHRoaXMpLCBjb21wYXJlZm4pO1xuICAgIH0sXG4gICAgc3ViYXJyYXk6IGZ1bmN0aW9uIHN1YmFycmF5KGJlZ2luLCBlbmQpe1xuICAgICAgdmFyIE8gICAgICA9IHZhbGlkYXRlKHRoaXMpXG4gICAgICAgICwgbGVuZ3RoID0gTy5sZW5ndGhcbiAgICAgICAgLCAkYmVnaW4gPSB0b0luZGV4KGJlZ2luLCBsZW5ndGgpO1xuICAgICAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSkpKFxuICAgICAgICBPLmJ1ZmZlcixcbiAgICAgICAgTy5ieXRlT2Zmc2V0ICsgJGJlZ2luICogTy5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgdG9MZW5ndGgoKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9JbmRleChlbmQsIGxlbmd0aCkpIC0gJGJlZ2luKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyICRzbGljZSA9IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpe1xuICAgIHJldHVybiBzcGVjaWVzRnJvbUxpc3QodGhpcywgYXJyYXlTbGljZS5jYWxsKHZhbGlkYXRlKHRoaXMpLCBzdGFydCwgZW5kKSk7XG4gIH07XG5cbiAgdmFyICRzZXQgPSBmdW5jdGlvbiBzZXQoYXJyYXlMaWtlIC8qLCBvZmZzZXQgKi8pe1xuICAgIHZhbGlkYXRlKHRoaXMpO1xuICAgIHZhciBvZmZzZXQgPSB0b09mZnNldChhcmd1bWVudHNbMV0sIDEpXG4gICAgICAsIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgICAsIHNyYyAgICA9IHRvT2JqZWN0KGFycmF5TGlrZSlcbiAgICAgICwgbGVuICAgID0gdG9MZW5ndGgoc3JjLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gMDtcbiAgICBpZihsZW4gKyBvZmZzZXQgPiBsZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHdoaWxlKGluZGV4IDwgbGVuKXRoaXNbb2Zmc2V0ICsgaW5kZXhdID0gc3JjW2luZGV4KytdO1xuICB9O1xuXG4gIHZhciAkaXRlcmF0b3JzID0ge1xuICAgIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoKXtcbiAgICAgIHJldHVybiBhcnJheUVudHJpZXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfSxcbiAgICBrZXlzOiBmdW5jdGlvbiBrZXlzKCl7XG4gICAgICByZXR1cm4gYXJyYXlLZXlzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH0sXG4gICAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoKXtcbiAgICAgIHJldHVybiBhcnJheVZhbHVlcy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzVEFJbmRleCA9IGZ1bmN0aW9uKHRhcmdldCwga2V5KXtcbiAgICByZXR1cm4gaXNPYmplY3QodGFyZ2V0KVxuICAgICAgJiYgdGFyZ2V0W1RZUEVEX0FSUkFZXVxuICAgICAgJiYgdHlwZW9mIGtleSAhPSAnc3ltYm9sJ1xuICAgICAgJiYga2V5IGluIHRhcmdldFxuICAgICAgJiYgU3RyaW5nKCtrZXkpID09IFN0cmluZyhrZXkpO1xuICB9O1xuICB2YXIgJGdldERlc2MgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpe1xuICAgIHJldHVybiBpc1RBSW5kZXgodGFyZ2V0LCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKVxuICAgICAgPyBwcm9wZXJ0eURlc2MoMiwgdGFyZ2V0W2tleV0pXG4gICAgICA6IGdPUEQodGFyZ2V0LCBrZXkpO1xuICB9O1xuICB2YXIgJHNldERlc2MgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzYyl7XG4gICAgaWYoaXNUQUluZGV4KHRhcmdldCwga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSlcbiAgICAgICYmIGlzT2JqZWN0KGRlc2MpXG4gICAgICAmJiBoYXMoZGVzYywgJ3ZhbHVlJylcbiAgICAgICYmICFoYXMoZGVzYywgJ2dldCcpXG4gICAgICAmJiAhaGFzKGRlc2MsICdzZXQnKVxuICAgICAgLy8gVE9ETzogYWRkIHZhbGlkYXRpb24gZGVzY3JpcHRvciB3L28gY2FsbGluZyBhY2Nlc3NvcnNcbiAgICAgICYmICFkZXNjLmNvbmZpZ3VyYWJsZVxuICAgICAgJiYgKCFoYXMoZGVzYywgJ3dyaXRhYmxlJykgfHwgZGVzYy53cml0YWJsZSlcbiAgICAgICYmICghaGFzKGRlc2MsICdlbnVtZXJhYmxlJykgfHwgZGVzYy5lbnVtZXJhYmxlKVxuICAgICl7XG4gICAgICB0YXJnZXRba2V5XSA9IGRlc2MudmFsdWU7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0gZWxzZSByZXR1cm4gZFAodGFyZ2V0LCBrZXksIGRlc2MpO1xuICB9O1xuXG4gIGlmKCFBTExfQ09OU1RSVUNUT1JTKXtcbiAgICAkR09QRC5mID0gJGdldERlc2M7XG4gICAgJERQLmYgICA9ICRzZXREZXNjO1xuICB9XG5cbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhQUxMX0NPTlNUUlVDVE9SUywgJ09iamVjdCcsIHtcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXREZXNjLFxuICAgIGRlZmluZVByb3BlcnR5OiAgICAgICAgICAgJHNldERlc2NcbiAgfSk7XG5cbiAgaWYoZmFpbHMoZnVuY3Rpb24oKXsgYXJyYXlUb1N0cmluZy5jYWxsKHt9KTsgfSkpe1xuICAgIGFycmF5VG9TdHJpbmcgPSBhcnJheVRvTG9jYWxlU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICAgIHJldHVybiBhcnJheUpvaW4uY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICB2YXIgJFR5cGVkQXJyYXlQcm90b3R5cGUkID0gcmVkZWZpbmVBbGwoe30sIHByb3RvKTtcbiAgcmVkZWZpbmVBbGwoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAkaXRlcmF0b3JzKTtcbiAgaGlkZSgkVHlwZWRBcnJheVByb3RvdHlwZSQsIElURVJBVE9SLCAkaXRlcmF0b3JzLnZhbHVlcyk7XG4gIHJlZGVmaW5lQWxsKCRUeXBlZEFycmF5UHJvdG90eXBlJCwge1xuICAgIHNsaWNlOiAgICAgICAgICAkc2xpY2UsXG4gICAgc2V0OiAgICAgICAgICAgICRzZXQsXG4gICAgY29uc3RydWN0b3I6ICAgIGZ1bmN0aW9uKCl7IC8qIG5vb3AgKi8gfSxcbiAgICB0b1N0cmluZzogICAgICAgYXJyYXlUb1N0cmluZyxcbiAgICB0b0xvY2FsZVN0cmluZzogJHRvTG9jYWxlU3RyaW5nXG4gIH0pO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnVmZmVyJywgJ2InKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J5dGVPZmZzZXQnLCAnbycpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnl0ZUxlbmd0aCcsICdsJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdsZW5ndGgnLCAnZScpO1xuICBkUCgkVHlwZWRBcnJheVByb3RvdHlwZSQsIFRBRywge1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXNbVFlQRURfQVJSQVldOyB9XG4gIH0pO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZLCBCWVRFUywgd3JhcHBlciwgQ0xBTVBFRCl7XG4gICAgQ0xBTVBFRCA9ICEhQ0xBTVBFRDtcbiAgICB2YXIgTkFNRSAgICAgICA9IEtFWSArIChDTEFNUEVEID8gJ0NsYW1wZWQnIDogJycpICsgJ0FycmF5J1xuICAgICAgLCBJU05UX1VJTlQ4ID0gTkFNRSAhPSAnVWludDhBcnJheSdcbiAgICAgICwgR0VUVEVSICAgICA9ICdnZXQnICsgS0VZXG4gICAgICAsIFNFVFRFUiAgICAgPSAnc2V0JyArIEtFWVxuICAgICAgLCBUeXBlZEFycmF5ID0gZ2xvYmFsW05BTUVdXG4gICAgICAsIEJhc2UgICAgICAgPSBUeXBlZEFycmF5IHx8IHt9XG4gICAgICAsIFRBQyAgICAgICAgPSBUeXBlZEFycmF5ICYmIGdldFByb3RvdHlwZU9mKFR5cGVkQXJyYXkpXG4gICAgICAsIEZPUkNFRCAgICAgPSAhVHlwZWRBcnJheSB8fCAhJHR5cGVkLkFCVlxuICAgICAgLCBPICAgICAgICAgID0ge31cbiAgICAgICwgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXkgJiYgVHlwZWRBcnJheVtQUk9UT1RZUEVdO1xuICAgIHZhciBnZXR0ZXIgPSBmdW5jdGlvbih0aGF0LCBpbmRleCl7XG4gICAgICB2YXIgZGF0YSA9IHRoYXQuX2Q7XG4gICAgICByZXR1cm4gZGF0YS52W0dFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEubywgTElUVExFX0VORElBTik7XG4gICAgfTtcbiAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24odGhhdCwgaW5kZXgsIHZhbHVlKXtcbiAgICAgIHZhciBkYXRhID0gdGhhdC5fZDtcbiAgICAgIGlmKENMQU1QRUQpdmFsdWUgPSAodmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlKSkgPCAwID8gMCA6IHZhbHVlID4gMHhmZiA/IDB4ZmYgOiB2YWx1ZSAmIDB4ZmY7XG4gICAgICBkYXRhLnZbU0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5vLCB2YWx1ZSwgTElUVExFX0VORElBTik7XG4gICAgfTtcbiAgICB2YXIgYWRkRWxlbWVudCA9IGZ1bmN0aW9uKHRoYXQsIGluZGV4KXtcbiAgICAgIGRQKHRoYXQsIGluZGV4LCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgICAgICByZXR1cm4gZ2V0dGVyKHRoaXMsIGluZGV4KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgICAgcmV0dXJuIHNldHRlcih0aGlzLCBpbmRleCwgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmKEZPUkNFRCl7XG4gICAgICBUeXBlZEFycmF5ID0gd3JhcHBlcihmdW5jdGlvbih0aGF0LCBkYXRhLCAkb2Zmc2V0LCAkbGVuZ3RoKXtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGF0LCBUeXBlZEFycmF5LCBOQU1FLCAnX2QnKTtcbiAgICAgICAgdmFyIGluZGV4ICA9IDBcbiAgICAgICAgICAsIG9mZnNldCA9IDBcbiAgICAgICAgICAsIGJ1ZmZlciwgYnl0ZUxlbmd0aCwgbGVuZ3RoLCBrbGFzcztcbiAgICAgICAgaWYoIWlzT2JqZWN0KGRhdGEpKXtcbiAgICAgICAgICBsZW5ndGggICAgID0gc3RyaWN0VG9MZW5ndGgoZGF0YSwgdHJ1ZSlcbiAgICAgICAgICBieXRlTGVuZ3RoID0gbGVuZ3RoICogQllURVM7XG4gICAgICAgICAgYnVmZmVyICAgICA9IG5ldyAkQXJyYXlCdWZmZXIoYnl0ZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZihkYXRhIGluc3RhbmNlb2YgJEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoZGF0YSkpID09IEFSUkFZX0JVRkZFUiB8fCBrbGFzcyA9PSBTSEFSRURfQlVGRkVSKXtcbiAgICAgICAgICBidWZmZXIgPSBkYXRhO1xuICAgICAgICAgIG9mZnNldCA9IHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKTtcbiAgICAgICAgICB2YXIgJGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICBpZigkbGVuZ3RoID09PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgaWYoJGxlbiAlIEJZVEVTKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSAkbGVuIC0gb2Zmc2V0O1xuICAgICAgICAgICAgaWYoYnl0ZUxlbmd0aCA8IDApdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gdG9MZW5ndGgoJGxlbmd0aCkgKiBCWVRFUztcbiAgICAgICAgICAgIGlmKGJ5dGVMZW5ndGggKyBvZmZzZXQgPiAkbGVuKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoID0gYnl0ZUxlbmd0aCAvIEJZVEVTO1xuICAgICAgICB9IGVsc2UgaWYoVFlQRURfQVJSQVkgaW4gZGF0YSl7XG4gICAgICAgICAgcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAkZnJvbS5jYWxsKFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGhpZGUodGhhdCwgJ19kJywge1xuICAgICAgICAgIGI6IGJ1ZmZlcixcbiAgICAgICAgICBvOiBvZmZzZXQsXG4gICAgICAgICAgbDogYnl0ZUxlbmd0aCxcbiAgICAgICAgICBlOiBsZW5ndGgsXG4gICAgICAgICAgdjogbmV3ICREYXRhVmlldyhidWZmZXIpXG4gICAgICAgIH0pO1xuICAgICAgICB3aGlsZShpbmRleCA8IGxlbmd0aClhZGRFbGVtZW50KHRoYXQsIGluZGV4KyspO1xuICAgICAgfSk7XG4gICAgICBUeXBlZEFycmF5UHJvdG90eXBlID0gVHlwZWRBcnJheVtQUk9UT1RZUEVdID0gY3JlYXRlKCRUeXBlZEFycmF5UHJvdG90eXBlJCk7XG4gICAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsIFR5cGVkQXJyYXkpO1xuICAgIH0gZWxzZSBpZighJGl0ZXJEZXRlY3QoZnVuY3Rpb24oaXRlcil7XG4gICAgICAvLyBWOCB3b3JrcyB3aXRoIGl0ZXJhdG9ycywgYnV0IGZhaWxzIGluIG1hbnkgb3RoZXIgY2FzZXNcbiAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00NTUyXG4gICAgICBuZXcgVHlwZWRBcnJheShudWxsKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIG5ldyBUeXBlZEFycmF5KGl0ZXIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIH0sIHRydWUpKXtcbiAgICAgIFR5cGVkQXJyYXkgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGRhdGEsICRvZmZzZXQsICRsZW5ndGgpe1xuICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFR5cGVkQXJyYXksIE5BTUUpO1xuICAgICAgICB2YXIga2xhc3M7XG4gICAgICAgIC8vIGB3c2AgbW9kdWxlIGJ1ZywgdGVtcG9yYXJpbHkgcmVtb3ZlIHZhbGlkYXRpb24gbGVuZ3RoIGZvciBVaW50OEFycmF5XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL3B1bGwvNjQ1XG4gICAgICAgIGlmKCFpc09iamVjdChkYXRhKSlyZXR1cm4gbmV3IEJhc2Uoc3RyaWN0VG9MZW5ndGgoZGF0YSwgSVNOVF9VSU5UOCkpO1xuICAgICAgICBpZihkYXRhIGluc3RhbmNlb2YgJEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoZGF0YSkpID09IEFSUkFZX0JVRkZFUiB8fCBrbGFzcyA9PSBTSEFSRURfQlVGRkVSKXtcbiAgICAgICAgICByZXR1cm4gJGxlbmd0aCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IG5ldyBCYXNlKGRhdGEsIHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKSwgJGxlbmd0aClcbiAgICAgICAgICAgIDogJG9mZnNldCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gbmV3IEJhc2UoZGF0YSwgdG9PZmZzZXQoJG9mZnNldCwgQllURVMpKVxuICAgICAgICAgICAgICA6IG5ldyBCYXNlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmKFRZUEVEX0FSUkFZIGluIGRhdGEpcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICByZXR1cm4gJGZyb20uY2FsbChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgIH0pO1xuICAgICAgYXJyYXlGb3JFYWNoKFRBQyAhPT0gRnVuY3Rpb24ucHJvdG90eXBlID8gZ09QTihCYXNlKS5jb25jYXQoZ09QTihUQUMpKSA6IGdPUE4oQmFzZSksIGZ1bmN0aW9uKGtleSl7XG4gICAgICAgIGlmKCEoa2V5IGluIFR5cGVkQXJyYXkpKWhpZGUoVHlwZWRBcnJheSwga2V5LCBCYXNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgICBUeXBlZEFycmF5W1BST1RPVFlQRV0gPSBUeXBlZEFycmF5UHJvdG90eXBlO1xuICAgICAgaWYoIUxJQlJBUlkpVHlwZWRBcnJheVByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFR5cGVkQXJyYXk7XG4gICAgfVxuICAgIHZhciAkbmF0aXZlSXRlcmF0b3IgICA9IFR5cGVkQXJyYXlQcm90b3R5cGVbSVRFUkFUT1JdXG4gICAgICAsIENPUlJFQ1RfSVRFUl9OQU1FID0gISEkbmF0aXZlSXRlcmF0b3IgJiYgKCRuYXRpdmVJdGVyYXRvci5uYW1lID09ICd2YWx1ZXMnIHx8ICRuYXRpdmVJdGVyYXRvci5uYW1lID09IHVuZGVmaW5lZClcbiAgICAgICwgJGl0ZXJhdG9yICAgICAgICAgPSAkaXRlcmF0b3JzLnZhbHVlcztcbiAgICBoaWRlKFR5cGVkQXJyYXksIFRZUEVEX0NPTlNUUlVDVE9SLCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRZUEVEX0FSUkFZLCBOQU1FKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIFZJRVcsIHRydWUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgREVGX0NPTlNUUlVDVE9SLCBUeXBlZEFycmF5KTtcblxuICAgIGlmKENMQU1QRUQgPyBuZXcgVHlwZWRBcnJheSgxKVtUQUddICE9IE5BTUUgOiAhKFRBRyBpbiBUeXBlZEFycmF5UHJvdG90eXBlKSl7XG4gICAgICBkUChUeXBlZEFycmF5UHJvdG90eXBlLCBUQUcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gTkFNRTsgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgT1tOQU1FXSA9IFR5cGVkQXJyYXk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChUeXBlZEFycmF5ICE9IEJhc2UpLCBPKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5TLCBOQU1FLCB7XG4gICAgICBCWVRFU19QRVJfRUxFTUVOVDogQllURVMsXG4gICAgICBmcm9tOiAkZnJvbSxcbiAgICAgIG9mOiAkb2ZcbiAgICB9KTtcblxuICAgIGlmKCEoQllURVNfUEVSX0VMRU1FTlQgaW4gVHlwZWRBcnJheVByb3RvdHlwZSkpaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBCWVRFU19QRVJfRUxFTUVOVCwgQllURVMpO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAsIE5BTUUsIHByb3RvKTtcblxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIEZPUkNFRF9TRVQsIE5BTUUsIHtzZXQ6ICRzZXR9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIUNPUlJFQ1RfSVRFUl9OQU1FLCBOQU1FLCAkaXRlcmF0b3JzKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKFR5cGVkQXJyYXlQcm90b3R5cGUudG9TdHJpbmcgIT0gYXJyYXlUb1N0cmluZyksIE5BTUUsIHt0b1N0cmluZzogYXJyYXlUb1N0cmluZ30pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbigpe1xuICAgICAgbmV3IFR5cGVkQXJyYXkoMSkuc2xpY2UoKTtcbiAgICB9KSwgTkFNRSwge3NsaWNlOiAkc2xpY2V9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gWzEsIDJdLnRvTG9jYWxlU3RyaW5nKCkgIT0gbmV3IFR5cGVkQXJyYXkoWzEsIDJdKS50b0xvY2FsZVN0cmluZygpXG4gICAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgICBUeXBlZEFycmF5UHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nLmNhbGwoWzEsIDJdKTtcbiAgICB9KSksIE5BTUUsIHt0b0xvY2FsZVN0cmluZzogJHRvTG9jYWxlU3RyaW5nfSk7XG5cbiAgICBJdGVyYXRvcnNbTkFNRV0gPSBDT1JSRUNUX0lURVJfTkFNRSA/ICRuYXRpdmVJdGVyYXRvciA6ICRpdGVyYXRvcjtcbiAgICBpZighTElCUkFSWSAmJiAhQ09SUkVDVF9JVEVSX05BTUUpaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBJVEVSQVRPUiwgJGl0ZXJhdG9yKTtcbiAgfTtcbn0gZWxzZSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBERVNDUklQVE9SUyAgICA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCBMSUJSQVJZICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsICR0eXBlZCAgICAgICAgID0gcmVxdWlyZSgnLi9fdHlwZWQnKVxuICAsIGhpZGUgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgcmVkZWZpbmVBbGwgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIGZhaWxzICAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGFuSW5zdGFuY2UgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIHRvSW50ZWdlciAgICAgID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgdG9MZW5ndGggICAgICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGdPUE4gICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICwgZFAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgYXJyYXlGaWxsICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1maWxsJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBBUlJBWV9CVUZGRVIgICA9ICdBcnJheUJ1ZmZlcidcbiAgLCBEQVRBX1ZJRVcgICAgICA9ICdEYXRhVmlldydcbiAgLCBQUk9UT1RZUEUgICAgICA9ICdwcm90b3R5cGUnXG4gICwgV1JPTkdfTEVOR1RIICAgPSAnV3JvbmcgbGVuZ3RoISdcbiAgLCBXUk9OR19JTkRFWCAgICA9ICdXcm9uZyBpbmRleCEnXG4gICwgJEFycmF5QnVmZmVyICAgPSBnbG9iYWxbQVJSQVlfQlVGRkVSXVxuICAsICREYXRhVmlldyAgICAgID0gZ2xvYmFsW0RBVEFfVklFV11cbiAgLCBNYXRoICAgICAgICAgICA9IGdsb2JhbC5NYXRoXG4gICwgUmFuZ2VFcnJvciAgICAgPSBnbG9iYWwuUmFuZ2VFcnJvclxuICAsIEluZmluaXR5ICAgICAgID0gZ2xvYmFsLkluZmluaXR5XG4gICwgQmFzZUJ1ZmZlciAgICAgPSAkQXJyYXlCdWZmZXJcbiAgLCBhYnMgICAgICAgICAgICA9IE1hdGguYWJzXG4gICwgcG93ICAgICAgICAgICAgPSBNYXRoLnBvd1xuICAsIGZsb29yICAgICAgICAgID0gTWF0aC5mbG9vclxuICAsIGxvZyAgICAgICAgICAgID0gTWF0aC5sb2dcbiAgLCBMTjIgICAgICAgICAgICA9IE1hdGguTE4yXG4gICwgQlVGRkVSICAgICAgICAgPSAnYnVmZmVyJ1xuICAsIEJZVEVfTEVOR1RIICAgID0gJ2J5dGVMZW5ndGgnXG4gICwgQllURV9PRkZTRVQgICAgPSAnYnl0ZU9mZnNldCdcbiAgLCAkQlVGRkVSICAgICAgICA9IERFU0NSSVBUT1JTID8gJ19iJyA6IEJVRkZFUlxuICAsICRMRU5HVEggICAgICAgID0gREVTQ1JJUFRPUlMgPyAnX2wnIDogQllURV9MRU5HVEhcbiAgLCAkT0ZGU0VUICAgICAgICA9IERFU0NSSVBUT1JTID8gJ19vJyA6IEJZVEVfT0ZGU0VUO1xuXG4vLyBJRUVFNzU0IGNvbnZlcnNpb25zIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvaWVlZTc1NFxudmFyIHBhY2tJRUVFNzU0ID0gZnVuY3Rpb24odmFsdWUsIG1MZW4sIG5CeXRlcyl7XG4gIHZhciBidWZmZXIgPSBBcnJheShuQnl0ZXMpXG4gICAgLCBlTGVuICAgPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgICAsIGVNYXggICA9ICgxIDw8IGVMZW4pIC0gMVxuICAgICwgZUJpYXMgID0gZU1heCA+PiAxXG4gICAgLCBydCAgICAgPSBtTGVuID09PSAyMyA/IHBvdygyLCAtMjQpIC0gcG93KDIsIC03NykgOiAwXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBzICAgICAgPSB2YWx1ZSA8IDAgfHwgdmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCA/IDEgOiAwXG4gICAgLCBlLCBtLCBjO1xuICB2YWx1ZSA9IGFicyh2YWx1ZSlcbiAgaWYodmFsdWUgIT0gdmFsdWUgfHwgdmFsdWUgPT09IEluZmluaXR5KXtcbiAgICBtID0gdmFsdWUgIT0gdmFsdWUgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gZmxvb3IobG9nKHZhbHVlKSAvIExOMik7XG4gICAgaWYodmFsdWUgKiAoYyA9IHBvdygyLCAtZSkpIDwgMSl7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmKGUgKyBlQmlhcyA+PSAxKXtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBwb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYodmFsdWUgKiBjID49IDIpe1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cbiAgICBpZihlICsgZUJpYXMgPj0gZU1heCl7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZihlICsgZUJpYXMgPj0gMSl7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogcG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogcG93KDIsIGVCaWFzIC0gMSkgKiBwb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cbiAgZm9yKDsgbUxlbiA+PSA4OyBidWZmZXJbaSsrXSA9IG0gJiAyNTUsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuICBlID0gZSA8PCBtTGVuIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IoOyBlTGVuID4gMDsgYnVmZmVyW2krK10gPSBlICYgMjU1LCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcbiAgYnVmZmVyWy0taV0gfD0gcyAqIDEyODtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG52YXIgdW5wYWNrSUVFRTc1NCA9IGZ1bmN0aW9uKGJ1ZmZlciwgbUxlbiwgbkJ5dGVzKXtcbiAgdmFyIGVMZW4gID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gICAgLCBlTWF4ICA9ICgxIDw8IGVMZW4pIC0gMVxuICAgICwgZUJpYXMgPSBlTWF4ID4+IDFcbiAgICAsIG5CaXRzID0gZUxlbiAtIDdcbiAgICAsIGkgICAgID0gbkJ5dGVzIC0gMVxuICAgICwgcyAgICAgPSBidWZmZXJbaS0tXVxuICAgICwgZSAgICAgPSBzICYgMTI3XG4gICAgLCBtO1xuICBzID4+PSA3O1xuICBmb3IoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW2ldLCBpLS0sIG5CaXRzIC09IDgpO1xuICBtID0gZSAmICgxIDw8IC1uQml0cykgLSAxO1xuICBlID4+PSAtbkJpdHM7XG4gIG5CaXRzICs9IG1MZW47XG4gIGZvcig7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbaV0sIGktLSwgbkJpdHMgLT0gOCk7XG4gIGlmKGUgPT09IDApe1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZihlID09PSBlTWF4KXtcbiAgICByZXR1cm4gbSA/IE5hTiA6IHMgPyAtSW5maW5pdHkgOiBJbmZpbml0eTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIHBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9IHJldHVybiAocyA/IC0xIDogMSkgKiBtICogcG93KDIsIGUgLSBtTGVuKTtcbn07XG5cbnZhciB1bnBhY2tJMzIgPSBmdW5jdGlvbihieXRlcyl7XG4gIHJldHVybiBieXRlc1szXSA8PCAyNCB8IGJ5dGVzWzJdIDw8IDE2IHwgYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdO1xufTtcbnZhciBwYWNrSTggPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBbaXQgJiAweGZmXTtcbn07XG52YXIgcGFja0kxNiA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIFtpdCAmIDB4ZmYsIGl0ID4+IDggJiAweGZmXTtcbn07XG52YXIgcGFja0kzMiA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIFtpdCAmIDB4ZmYsIGl0ID4+IDggJiAweGZmLCBpdCA+PiAxNiAmIDB4ZmYsIGl0ID4+IDI0ICYgMHhmZl07XG59O1xudmFyIHBhY2tGNjQgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBwYWNrSUVFRTc1NChpdCwgNTIsIDgpO1xufTtcbnZhciBwYWNrRjMyID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gcGFja0lFRUU3NTQoaXQsIDIzLCA0KTtcbn07XG5cbnZhciBhZGRHZXR0ZXIgPSBmdW5jdGlvbihDLCBrZXksIGludGVybmFsKXtcbiAgZFAoQ1tQUk9UT1RZUEVdLCBrZXksIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzW2ludGVybmFsXTsgfX0pO1xufTtcblxudmFyIGdldCA9IGZ1bmN0aW9uKHZpZXcsIGJ5dGVzLCBpbmRleCwgaXNMaXR0bGVFbmRpYW4pe1xuICB2YXIgbnVtSW5kZXggPSAraW5kZXhcbiAgICAsIGludEluZGV4ID0gdG9JbnRlZ2VyKG51bUluZGV4KTtcbiAgaWYobnVtSW5kZXggIT0gaW50SW5kZXggfHwgaW50SW5kZXggPCAwIHx8IGludEluZGV4ICsgYnl0ZXMgPiB2aWV3WyRMRU5HVEhdKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfSU5ERVgpO1xuICB2YXIgc3RvcmUgPSB2aWV3WyRCVUZGRVJdLl9iXG4gICAgLCBzdGFydCA9IGludEluZGV4ICsgdmlld1skT0ZGU0VUXVxuICAgICwgcGFjayAgPSBzdG9yZS5zbGljZShzdGFydCwgc3RhcnQgKyBieXRlcyk7XG4gIHJldHVybiBpc0xpdHRsZUVuZGlhbiA/IHBhY2sgOiBwYWNrLnJldmVyc2UoKTtcbn07XG52YXIgc2V0ID0gZnVuY3Rpb24odmlldywgYnl0ZXMsIGluZGV4LCBjb252ZXJzaW9uLCB2YWx1ZSwgaXNMaXR0bGVFbmRpYW4pe1xuICB2YXIgbnVtSW5kZXggPSAraW5kZXhcbiAgICAsIGludEluZGV4ID0gdG9JbnRlZ2VyKG51bUluZGV4KTtcbiAgaWYobnVtSW5kZXggIT0gaW50SW5kZXggfHwgaW50SW5kZXggPCAwIHx8IGludEluZGV4ICsgYnl0ZXMgPiB2aWV3WyRMRU5HVEhdKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfSU5ERVgpO1xuICB2YXIgc3RvcmUgPSB2aWV3WyRCVUZGRVJdLl9iXG4gICAgLCBzdGFydCA9IGludEluZGV4ICsgdmlld1skT0ZGU0VUXVxuICAgICwgcGFjayAgPSBjb252ZXJzaW9uKCt2YWx1ZSk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBieXRlczsgaSsrKXN0b3JlW3N0YXJ0ICsgaV0gPSBwYWNrW2lzTGl0dGxlRW5kaWFuID8gaSA6IGJ5dGVzIC0gaSAtIDFdO1xufTtcblxudmFyIHZhbGlkYXRlQXJyYXlCdWZmZXJBcmd1bWVudHMgPSBmdW5jdGlvbih0aGF0LCBsZW5ndGgpe1xuICBhbkluc3RhbmNlKHRoYXQsICRBcnJheUJ1ZmZlciwgQVJSQVlfQlVGRkVSKTtcbiAgdmFyIG51bWJlckxlbmd0aCA9ICtsZW5ndGhcbiAgICAsIGJ5dGVMZW5ndGggICA9IHRvTGVuZ3RoKG51bWJlckxlbmd0aCk7XG4gIGlmKG51bWJlckxlbmd0aCAhPSBieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgcmV0dXJuIGJ5dGVMZW5ndGg7XG59O1xuXG5pZighJHR5cGVkLkFCVil7XG4gICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCl7XG4gICAgdmFyIGJ5dGVMZW5ndGggPSB2YWxpZGF0ZUFycmF5QnVmZmVyQXJndW1lbnRzKHRoaXMsIGxlbmd0aCk7XG4gICAgdGhpcy5fYiAgICAgICA9IGFycmF5RmlsbC5jYWxsKEFycmF5KGJ5dGVMZW5ndGgpLCAwKTtcbiAgICB0aGlzWyRMRU5HVEhdID0gYnl0ZUxlbmd0aDtcbiAgfTtcblxuICAkRGF0YVZpZXcgPSBmdW5jdGlvbiBEYXRhVmlldyhidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpe1xuICAgIGFuSW5zdGFuY2UodGhpcywgJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuICAgIGFuSW5zdGFuY2UoYnVmZmVyLCAkQXJyYXlCdWZmZXIsIERBVEFfVklFVyk7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGJ1ZmZlclskTEVOR1RIXVxuICAgICAgLCBvZmZzZXQgICAgICAgPSB0b0ludGVnZXIoYnl0ZU9mZnNldCk7XG4gICAgaWYob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBidWZmZXJMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0IScpO1xuICAgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID09PSB1bmRlZmluZWQgPyBidWZmZXJMZW5ndGggLSBvZmZzZXQgOiB0b0xlbmd0aChieXRlTGVuZ3RoKTtcbiAgICBpZihvZmZzZXQgKyBieXRlTGVuZ3RoID4gYnVmZmVyTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICB0aGlzWyRCVUZGRVJdID0gYnVmZmVyO1xuICAgIHRoaXNbJE9GRlNFVF0gPSBvZmZzZXQ7XG4gICAgdGhpc1skTEVOR1RIXSA9IGJ5dGVMZW5ndGg7XG4gIH07XG5cbiAgaWYoREVTQ1JJUFRPUlMpe1xuICAgIGFkZEdldHRlcigkQXJyYXlCdWZmZXIsIEJZVEVfTEVOR1RILCAnX2wnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCVUZGRVIsICdfYicpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJZVEVfTEVOR1RILCAnX2wnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCWVRFX09GRlNFVCwgJ19vJyk7XG4gIH1cblxuICByZWRlZmluZUFsbCgkRGF0YVZpZXdbUFJPVE9UWVBFXSwge1xuICAgIGdldEludDg6IGZ1bmN0aW9uIGdldEludDgoYnl0ZU9mZnNldCl7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdIDw8IDI0ID4+IDI0O1xuICAgIH0sXG4gICAgZ2V0VWludDg6IGZ1bmN0aW9uIGdldFVpbnQ4KGJ5dGVPZmZzZXQpe1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXTtcbiAgICB9LFxuICAgIGdldEludDE2OiBmdW5jdGlvbiBnZXRJbnQxNihieXRlT2Zmc2V0IC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSk7XG4gICAgICByZXR1cm4gKGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXSkgPDwgMTYgPj4gMTY7XG4gICAgfSxcbiAgICBnZXRVaW50MTY6IGZ1bmN0aW9uIGdldFVpbnQxNihieXRlT2Zmc2V0IC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSk7XG4gICAgICByZXR1cm4gYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdO1xuICAgIH0sXG4gICAgZ2V0SW50MzI6IGZ1bmN0aW9uIGdldEludDMyKGJ5dGVPZmZzZXQgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICByZXR1cm4gdW5wYWNrSTMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pKTtcbiAgICB9LFxuICAgIGdldFVpbnQzMjogZnVuY3Rpb24gZ2V0VWludDMyKGJ5dGVPZmZzZXQgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICByZXR1cm4gdW5wYWNrSTMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pKSA+Pj4gMDtcbiAgICB9LFxuICAgIGdldEZsb2F0MzI6IGZ1bmN0aW9uIGdldEZsb2F0MzIoYnl0ZU9mZnNldCAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pLCAyMywgNCk7XG4gICAgfSxcbiAgICBnZXRGbG9hdDY0OiBmdW5jdGlvbiBnZXRGbG9hdDY0KGJ5dGVPZmZzZXQgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSwgNTIsIDgpO1xuICAgIH0sXG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSl7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0k4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpe1xuICAgICAgc2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQsIHBhY2tJOCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0SW50MTY6IGZ1bmN0aW9uIHNldEludDE2KGJ5dGVPZmZzZXQsIHZhbHVlIC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJMTYsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0VWludDE2OiBmdW5jdGlvbiBzZXRVaW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0kxNiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRJbnQzMjogZnVuY3Rpb24gc2V0SW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0kzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRVaW50MzI6IGZ1bmN0aW9uIHNldFVpbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSTMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEZsb2F0MzI6IGZ1bmN0aW9uIHNldEZsb2F0MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0YzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDY0OiBmdW5jdGlvbiBzZXRGbG9hdDY0KGJ5dGVPZmZzZXQsIHZhbHVlIC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgc2V0KHRoaXMsIDgsIGJ5dGVPZmZzZXQsIHBhY2tGNjQsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICBpZighZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBuZXcgJEFycmF5QnVmZmVyOyAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgbmV3ICRBcnJheUJ1ZmZlciguNSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gIH0pKXtcbiAgICAkQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiBBcnJheUJ1ZmZlcihsZW5ndGgpe1xuICAgICAgcmV0dXJuIG5ldyBCYXNlQnVmZmVyKHZhbGlkYXRlQXJyYXlCdWZmZXJBcmd1bWVudHModGhpcywgbGVuZ3RoKSk7XG4gICAgfTtcbiAgICB2YXIgQXJyYXlCdWZmZXJQcm90byA9ICRBcnJheUJ1ZmZlcltQUk9UT1RZUEVdID0gQmFzZUJ1ZmZlcltQUk9UT1RZUEVdO1xuICAgIGZvcih2YXIga2V5cyA9IGdPUE4oQmFzZUJ1ZmZlciksIGogPSAwLCBrZXk7IGtleXMubGVuZ3RoID4gajsgKXtcbiAgICAgIGlmKCEoKGtleSA9IGtleXNbaisrXSkgaW4gJEFycmF5QnVmZmVyKSloaWRlKCRBcnJheUJ1ZmZlciwga2V5LCBCYXNlQnVmZmVyW2tleV0pO1xuICAgIH07XG4gICAgaWYoIUxJQlJBUlkpQXJyYXlCdWZmZXJQcm90by5jb25zdHJ1Y3RvciA9ICRBcnJheUJ1ZmZlcjtcbiAgfVxuICAvLyBpT1MgU2FmYXJpIDcueCBidWdcbiAgdmFyIHZpZXcgPSBuZXcgJERhdGFWaWV3KG5ldyAkQXJyYXlCdWZmZXIoMikpXG4gICAgLCAkc2V0SW50OCA9ICREYXRhVmlld1tQUk9UT1RZUEVdLnNldEludDg7XG4gIHZpZXcuc2V0SW50OCgwLCAyMTQ3NDgzNjQ4KTtcbiAgdmlldy5zZXRJbnQ4KDEsIDIxNDc0ODM2NDkpO1xuICBpZih2aWV3LmdldEludDgoMCkgfHwgIXZpZXcuZ2V0SW50OCgxKSlyZWRlZmluZUFsbCgkRGF0YVZpZXdbUFJPVE9UWVBFXSwge1xuICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpe1xuICAgICAgJHNldEludDguY2FsbCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpe1xuICAgICAgJHNldEludDguY2FsbCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfVxuICB9LCB0cnVlKTtcbn1cbnNldFRvU3RyaW5nVGFnKCRBcnJheUJ1ZmZlciwgQVJSQVlfQlVGRkVSKTtcbnNldFRvU3RyaW5nVGFnKCREYXRhVmlldywgREFUQV9WSUVXKTtcbmhpZGUoJERhdGFWaWV3W1BST1RPVFlQRV0sICR0eXBlZC5WSUVXLCB0cnVlKTtcbmV4cG9ydHNbQVJSQVlfQlVGRkVSXSA9ICRBcnJheUJ1ZmZlcjtcbmV4cG9ydHNbREFUQV9WSUVXXSA9ICREYXRhVmlldzsiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoaWRlICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCB1aWQgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIFRZUEVEICA9IHVpZCgndHlwZWRfYXJyYXknKVxuICAsIFZJRVcgICA9IHVpZCgndmlldycpXG4gICwgQUJWICAgID0gISEoZ2xvYmFsLkFycmF5QnVmZmVyICYmIGdsb2JhbC5EYXRhVmlldylcbiAgLCBDT05TVFIgPSBBQlZcbiAgLCBpID0gMCwgbCA9IDksIFR5cGVkO1xuXG52YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9ycyA9IChcbiAgJ0ludDhBcnJheSxVaW50OEFycmF5LFVpbnQ4Q2xhbXBlZEFycmF5LEludDE2QXJyYXksVWludDE2QXJyYXksSW50MzJBcnJheSxVaW50MzJBcnJheSxGbG9hdDMyQXJyYXksRmxvYXQ2NEFycmF5J1xuKS5zcGxpdCgnLCcpO1xuXG53aGlsZShpIDwgbCl7XG4gIGlmKFR5cGVkID0gZ2xvYmFsW1R5cGVkQXJyYXlDb25zdHJ1Y3RvcnNbaSsrXV0pe1xuICAgIGhpZGUoVHlwZWQucHJvdG90eXBlLCBUWVBFRCwgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZC5wcm90b3R5cGUsIFZJRVcsIHRydWUpO1xuICB9IGVsc2UgQ09OU1RSID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBBQlY6ICAgIEFCVixcbiAgQ09OU1RSOiBDT05TVFIsXG4gIFRZUEVEOiAgVFlQRUQsXG4gIFZJRVc6ICAgVklFV1xufTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vYmVuamFtaW5nci9SZXhFeHAuZXNjYXBlXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHJlICAgICA9IHJlcXVpcmUoJy4vX3JlcGxhY2VyJykoL1tcXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVnRXhwJywge2VzY2FwZTogZnVuY3Rpb24gZXNjYXBlKGl0KXsgcmV0dXJuICRyZShpdCk7IH19KTtcbiIsIi8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtjb3B5V2l0aGluOiByZXF1aXJlKCcuL19hcnJheS1jb3B5LXdpdGhpbicpfSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdjb3B5V2l0aGluJyk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRldmVyeSAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNCk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5ldmVyeSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjUgLyAxNS40LjQuMTYgQXJyYXkucHJvdG90eXBlLmV2ZXJ5KGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLyl7XG4gICAgcmV0dXJuICRldmVyeSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTsiLCIvLyAyMi4xLjMuNiBBcnJheS5wcm90b3R5cGUuZmlsbCh2YWx1ZSwgc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7ZmlsbDogcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpfSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdmaWxsJyk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRmaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMik7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5maWx0ZXIsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy43IC8gMTUuNC40LjIwIEFycmF5LnByb3RvdHlwZS5maWx0ZXIoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pe1xuICAgIHJldHVybiAkZmlsdGVyKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy45IEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgocHJlZGljYXRlLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRmaW5kICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNilcbiAgLCBLRVkgICAgID0gJ2ZpbmRJbmRleCdcbiAgLCBmb3JjZWQgID0gdHJ1ZTtcbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZihLRVkgaW4gW10pQXJyYXkoMSlbS0VZXShmdW5jdGlvbigpeyBmb3JjZWQgPSBmYWxzZTsgfSk7XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZvcmNlZCwgJ0FycmF5Jywge1xuICBmaW5kSW5kZXg6IGZ1bmN0aW9uIGZpbmRJbmRleChjYWxsYmFja2ZuLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoS0VZKTsiLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuOCBBcnJheS5wcm90b3R5cGUuZmluZChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGZpbmQgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSg1KVxuICAsIEtFWSAgICAgPSAnZmluZCdcbiAgLCBmb3JjZWQgID0gdHJ1ZTtcbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZihLRVkgaW4gW10pQXJyYXkoMSlbS0VZXShmdW5jdGlvbigpeyBmb3JjZWQgPSBmYWxzZTsgfSk7XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZvcmNlZCwgJ0FycmF5Jywge1xuICBmaW5kOiBmdW5jdGlvbiBmaW5kKGNhbGxiYWNrZm4vKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XG4gICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKShLRVkpOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGZvckVhY2ggPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMClcbiAgLCBTVFJJQ1QgICA9IHJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5mb3JFYWNoLCB0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhU1RSSUNULCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xMCAvIDE1LjQuNC4xOCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKXtcbiAgICByZXR1cm4gJGZvckVhY2godGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRpbmRleE9mICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKVxuICAsICRuYXRpdmUgICAgICAgPSBbXS5pbmRleE9mXG4gICwgTkVHQVRJVkVfWkVSTyA9ICEhJG5hdGl2ZSAmJiAxIC8gWzFdLmluZGV4T2YoMSwgLTApIDwgMDtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoTkVHQVRJVkVfWkVSTyB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRuYXRpdmUpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTEgLyAxNS40LjQuMTQgQXJyYXkucHJvdG90eXBlLmluZGV4T2Yoc2VhcmNoRWxlbWVudCBbLCBmcm9tSW5kZXhdKVxuICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnQgLyosIGZyb21JbmRleCA9IDAgKi8pe1xuICAgIHJldHVybiBORUdBVElWRV9aRVJPXG4gICAgICAvLyBjb252ZXJ0IC0wIHRvICswXG4gICAgICA/ICRuYXRpdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCAwXG4gICAgICA6ICRpbmRleE9mKHRoaXMsIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pOyIsIi8vIDIyLjEuMi4yIC8gMTUuNC4zLjIgQXJyYXkuaXNBcnJheShhcmcpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ0FycmF5Jywge2lzQXJyYXk6IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyl9KTsiLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmpvaW4oc2VwYXJhdG9yKVxudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgYXJyYXlKb2luID0gW10uam9pbjtcblxuLy8gZmFsbGJhY2sgZm9yIG5vdCBhcnJheS1saWtlIHN0cmluZ3NcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKHJlcXVpcmUoJy4vX2lvYmplY3QnKSAhPSBPYmplY3QgfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShhcnJheUpvaW4pKSwgJ0FycmF5Jywge1xuICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcil7XG4gICAgcmV0dXJuIGFycmF5Sm9pbi5jYWxsKHRvSU9iamVjdCh0aGlzKSwgc2VwYXJhdG9yID09PSB1bmRlZmluZWQgPyAnLCcgOiBzZXBhcmF0b3IpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9JT2JqZWN0ICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvSW50ZWdlciAgICAgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCB0b0xlbmd0aCAgICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCAkbmF0aXZlICAgICAgID0gW10ubGFzdEluZGV4T2ZcbiAgLCBORUdBVElWRV9aRVJPID0gISEkbmF0aXZlICYmIDEgLyBbMV0ubGFzdEluZGV4T2YoMSwgLTApIDwgMDtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoTkVHQVRJVkVfWkVSTyB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRuYXRpdmUpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTQgLyAxNS40LjQuMTUgQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgWywgZnJvbUluZGV4XSlcbiAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgLyosIGZyb21JbmRleCA9IEBbKi0xXSAqLyl7XG4gICAgLy8gY29udmVydCAtMCB0byArMFxuICAgIGlmKE5FR0FUSVZFX1pFUk8pcmV0dXJuICRuYXRpdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCAwO1xuICAgIHZhciBPICAgICAgPSB0b0lPYmplY3QodGhpcylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IGxlbmd0aCAtIDE7XG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCA+IDEpaW5kZXggPSBNYXRoLm1pbihpbmRleCwgdG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSkpO1xuICAgIGlmKGluZGV4IDwgMClpbmRleCA9IGxlbmd0aCArIGluZGV4O1xuICAgIGZvcig7aW5kZXggPj0gMDsgaW5kZXgtLSlpZihpbmRleCBpbiBPKWlmKE9baW5kZXhdID09PSBzZWFyY2hFbGVtZW50KXJldHVybiBpbmRleCB8fCAwO1xuICAgIHJldHVybiAtMTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRtYXAgICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5tYXAsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xNSAvIDE1LjQuNC4xOSBBcnJheS5wcm90b3R5cGUubWFwKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIG1hcDogZnVuY3Rpb24gbWFwKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKXtcbiAgICByZXR1cm4gJG1hcCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG5cbi8vIFdlYktpdCBBcnJheS5vZiBpc24ndCBnZW5lcmljXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgZnVuY3Rpb24gRigpe31cbiAgcmV0dXJuICEoQXJyYXkub2YuY2FsbChGKSBpbnN0YW5jZW9mIEYpO1xufSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4yLjMgQXJyYXkub2YoIC4uLml0ZW1zKVxuICBvZjogZnVuY3Rpb24gb2YoLyogLi4uYXJncyAqLyl7XG4gICAgdmFyIGluZGV4ICA9IDBcbiAgICAgICwgYUxlbiAgID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCByZXN1bHQgPSBuZXcgKHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXkpKGFMZW4pO1xuICAgIHdoaWxlKGFMZW4gPiBpbmRleCljcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHJlc3VsdC5sZW5ndGggPSBhTGVuO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXktcmVkdWNlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5yZWR1Y2VSaWdodCwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE5IC8gMTUuNC40LjIyIEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodChjYWxsYmFja2ZuIFssIGluaXRpYWxWYWx1ZV0pXG4gIHJlZHVjZVJpZ2h0OiBmdW5jdGlvbiByZWR1Y2VSaWdodChjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKXtcbiAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHNbMV0sIHRydWUpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5LXJlZHVjZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10ucmVkdWNlLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTggLyAxNS40LjQuMjEgQXJyYXkucHJvdG90eXBlLnJlZHVjZShjYWxsYmFja2ZuIFssIGluaXRpYWxWYWx1ZV0pXG4gIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pe1xuICAgIHJldHVybiAkcmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3VtZW50c1sxXSwgZmFsc2UpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgaHRtbCAgICAgICA9IHJlcXVpcmUoJy4vX2h0bWwnKVxuICAsIGNvZiAgICAgICAgPSByZXF1aXJlKCcuL19jb2YnKVxuICAsIHRvSW5kZXggICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpXG4gICwgdG9MZW5ndGggICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgYXJyYXlTbGljZSA9IFtdLnNsaWNlO1xuXG4vLyBmYWxsYmFjayBmb3Igbm90IGFycmF5LWxpa2UgRVMzIHN0cmluZ3MgYW5kIERPTSBvYmplY3RzXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgaWYoaHRtbClhcnJheVNsaWNlLmNhbGwoaHRtbCk7XG59KSwgJ0FycmF5Jywge1xuICBzbGljZTogZnVuY3Rpb24gc2xpY2UoYmVnaW4sIGVuZCl7XG4gICAgdmFyIGxlbiAgID0gdG9MZW5ndGgodGhpcy5sZW5ndGgpXG4gICAgICAsIGtsYXNzID0gY29mKHRoaXMpO1xuICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogZW5kO1xuICAgIGlmKGtsYXNzID09ICdBcnJheScpcmV0dXJuIGFycmF5U2xpY2UuY2FsbCh0aGlzLCBiZWdpbiwgZW5kKTtcbiAgICB2YXIgc3RhcnQgID0gdG9JbmRleChiZWdpbiwgbGVuKVxuICAgICAgLCB1cFRvICAgPSB0b0luZGV4KGVuZCwgbGVuKVxuICAgICAgLCBzaXplICAgPSB0b0xlbmd0aCh1cFRvIC0gc3RhcnQpXG4gICAgICAsIGNsb25lZCA9IEFycmF5KHNpemUpXG4gICAgICAsIGkgICAgICA9IDA7XG4gICAgZm9yKDsgaSA8IHNpemU7IGkrKyljbG9uZWRbaV0gPSBrbGFzcyA9PSAnU3RyaW5nJ1xuICAgICAgPyB0aGlzLmNoYXJBdChzdGFydCArIGkpXG4gICAgICA6IHRoaXNbc3RhcnQgKyBpXTtcbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHNvbWUgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgzKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnNvbWUsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4yMyAvIDE1LjQuNC4xNyBBcnJheS5wcm90b3R5cGUuc29tZShjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBzb21lOiBmdW5jdGlvbiBzb21lKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKXtcbiAgICByZXR1cm4gJHNvbWUodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgdG9PYmplY3QgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBmYWlscyAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgJHNvcnQgICAgID0gW10uc29ydFxuICAsIHRlc3QgICAgICA9IFsxLCAyLCAzXTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoZmFpbHMoZnVuY3Rpb24oKXtcbiAgLy8gSUU4LVxuICB0ZXN0LnNvcnQodW5kZWZpbmVkKTtcbn0pIHx8ICFmYWlscyhmdW5jdGlvbigpe1xuICAvLyBWOCBidWdcbiAgdGVzdC5zb3J0KG51bGwpO1xuICAvLyBPbGQgV2ViS2l0XG59KSB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRzb3J0KSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjI1IEFycmF5LnByb3RvdHlwZS5zb3J0KGNvbXBhcmVmbilcbiAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pe1xuICAgIHJldHVybiBjb21wYXJlZm4gPT09IHVuZGVmaW5lZFxuICAgICAgPyAkc29ydC5jYWxsKHRvT2JqZWN0KHRoaXMpKVxuICAgICAgOiAkc29ydC5jYWxsKHRvT2JqZWN0KHRoaXMpLCBhRnVuY3Rpb24oY29tcGFyZWZuKSk7XG4gIH1cbn0pOyIsInJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ0FycmF5Jyk7IiwiLy8gMjAuMy4zLjEgLyAxNS45LjQuNCBEYXRlLm5vdygpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ0RhdGUnLCB7bm93OiBmdW5jdGlvbigpeyByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7IH19KTsiLCIndXNlIHN0cmljdCc7XG4vLyAyMC4zLjQuMzYgLyAxNS45LjUuNDMgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcoKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGZhaWxzICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgZ2V0VGltZSA9IERhdGUucHJvdG90eXBlLmdldFRpbWU7XG5cbnZhciBseiA9IGZ1bmN0aW9uKG51bSl7XG4gIHJldHVybiBudW0gPiA5ID8gbnVtIDogJzAnICsgbnVtO1xufTtcblxuLy8gUGhhbnRvbUpTIC8gb2xkIFdlYktpdCBoYXMgYSBicm9rZW4gaW1wbGVtZW50YXRpb25zXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChmYWlscyhmdW5jdGlvbigpe1xuICByZXR1cm4gbmV3IERhdGUoLTVlMTMgLSAxKS50b0lTT1N0cmluZygpICE9ICcwMzg1LTA3LTI1VDA3OjA2OjM5Ljk5OVonO1xufSkgfHwgIWZhaWxzKGZ1bmN0aW9uKCl7XG4gIG5ldyBEYXRlKE5hTikudG9JU09TdHJpbmcoKTtcbn0pKSwgJ0RhdGUnLCB7XG4gIHRvSVNPU3RyaW5nOiBmdW5jdGlvbiB0b0lTT1N0cmluZygpe1xuICAgIGlmKCFpc0Zpbml0ZShnZXRUaW1lLmNhbGwodGhpcykpKXRocm93IFJhbmdlRXJyb3IoJ0ludmFsaWQgdGltZSB2YWx1ZScpO1xuICAgIHZhciBkID0gdGhpc1xuICAgICAgLCB5ID0gZC5nZXRVVENGdWxsWWVhcigpXG4gICAgICAsIG0gPSBkLmdldFVUQ01pbGxpc2Vjb25kcygpXG4gICAgICAsIHMgPSB5IDwgMCA/ICctJyA6IHkgPiA5OTk5ID8gJysnIDogJyc7XG4gICAgcmV0dXJuIHMgKyAoJzAwMDAwJyArIE1hdGguYWJzKHkpKS5zbGljZShzID8gLTYgOiAtNCkgK1xuICAgICAgJy0nICsgbHooZC5nZXRVVENNb250aCgpICsgMSkgKyAnLScgKyBseihkLmdldFVUQ0RhdGUoKSkgK1xuICAgICAgJ1QnICsgbHooZC5nZXRVVENIb3VycygpKSArICc6JyArIGx6KGQuZ2V0VVRDTWludXRlcygpKSArXG4gICAgICAnOicgKyBseihkLmdldFVUQ1NlY29uZHMoKSkgKyAnLicgKyAobSA+IDk5ID8gbSA6ICcwJyArIGx6KG0pKSArICdaJztcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBuZXcgRGF0ZShOYU4pLnRvSlNPTigpICE9PSBudWxsIHx8IERhdGUucHJvdG90eXBlLnRvSlNPTi5jYWxsKHt0b0lTT1N0cmluZzogZnVuY3Rpb24oKXsgcmV0dXJuIDE7IH19KSAhPT0gMTtcbn0pLCAnRGF0ZScsIHtcbiAgdG9KU09OOiBmdW5jdGlvbiB0b0pTT04oa2V5KXtcbiAgICB2YXIgTyAgPSB0b09iamVjdCh0aGlzKVxuICAgICAgLCBwdiA9IHRvUHJpbWl0aXZlKE8pO1xuICAgIHJldHVybiB0eXBlb2YgcHYgPT0gJ251bWJlcicgJiYgIWlzRmluaXRlKHB2KSA/IG51bGwgOiBPLnRvSVNPU3RyaW5nKCk7XG4gIH1cbn0pOyIsInZhciBUT19QUklNSVRJVkUgPSByZXF1aXJlKCcuL193a3MnKSgndG9QcmltaXRpdmUnKVxuICAsIHByb3RvICAgICAgICA9IERhdGUucHJvdG90eXBlO1xuXG5pZighKFRPX1BSSU1JVElWRSBpbiBwcm90bykpcmVxdWlyZSgnLi9faGlkZScpKHByb3RvLCBUT19QUklNSVRJVkUsIHJlcXVpcmUoJy4vX2RhdGUtdG8tcHJpbWl0aXZlJykpOyIsInZhciBEYXRlUHJvdG8gICAgPSBEYXRlLnByb3RvdHlwZVxuICAsIElOVkFMSURfREFURSA9ICdJbnZhbGlkIERhdGUnXG4gICwgVE9fU1RSSU5HICAgID0gJ3RvU3RyaW5nJ1xuICAsICR0b1N0cmluZyAgICA9IERhdGVQcm90b1tUT19TVFJJTkddXG4gICwgZ2V0VGltZSAgICAgID0gRGF0ZVByb3RvLmdldFRpbWU7XG5pZihuZXcgRGF0ZShOYU4pICsgJycgIT0gSU5WQUxJRF9EQVRFKXtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShEYXRlUHJvdG8sIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICB2YXIgdmFsdWUgPSBnZXRUaW1lLmNhbGwodGhpcyk7XG4gICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/ICR0b1N0cmluZy5jYWxsKHRoaXMpIDogSU5WQUxJRF9EQVRFO1xuICB9KTtcbn0iLCIvLyAxOS4yLjMuMiAvIDE1LjMuNC41IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKHRoaXNBcmcsIGFyZ3MuLi4pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0Z1bmN0aW9uJywge2JpbmQ6IHJlcXVpcmUoJy4vX2JpbmQnKX0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciBpc09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBIQVNfSU5TVEFOQ0UgICA9IHJlcXVpcmUoJy4vX3drcycpKCdoYXNJbnN0YW5jZScpXG4gICwgRnVuY3Rpb25Qcm90byAgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4vLyAxOS4yLjMuNiBGdW5jdGlvbi5wcm90b3R5cGVbQEBoYXNJbnN0YW5jZV0oVilcbmlmKCEoSEFTX0lOU1RBTkNFIGluIEZ1bmN0aW9uUHJvdG8pKXJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYoRnVuY3Rpb25Qcm90bywgSEFTX0lOU1RBTkNFLCB7dmFsdWU6IGZ1bmN0aW9uKE8pe1xuICBpZih0eXBlb2YgdGhpcyAhPSAnZnVuY3Rpb24nIHx8ICFpc09iamVjdChPKSlyZXR1cm4gZmFsc2U7XG4gIGlmKCFpc09iamVjdCh0aGlzLnByb3RvdHlwZSkpcmV0dXJuIE8gaW5zdGFuY2VvZiB0aGlzO1xuICAvLyBmb3IgZW52aXJvbm1lbnQgdy9vIG5hdGl2ZSBgQEBoYXNJbnN0YW5jZWAgbG9naWMgZW5vdWdoIGBpbnN0YW5jZW9mYCwgYnV0IGFkZCB0aGlzOlxuICB3aGlsZShPID0gZ2V0UHJvdG90eXBlT2YoTykpaWYodGhpcy5wcm90b3R5cGUgPT09IE8pcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn19KTsiLCJ2YXIgZFAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgaGFzICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgRlByb3RvICAgICA9IEZ1bmN0aW9uLnByb3RvdHlwZVxuICAsIG5hbWVSRSAgICAgPSAvXlxccypmdW5jdGlvbiAoW14gKF0qKS9cbiAgLCBOQU1FICAgICAgID0gJ25hbWUnO1xuXG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbigpe1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIDE5LjIuNC4yIG5hbWVcbk5BTUUgaW4gRlByb3RvIHx8IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgZFAoRlByb3RvLCBOQU1FLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpe1xuICAgIHRyeSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAgICAgLCBuYW1lID0gKCcnICsgdGhhdCkubWF0Y2gobmFtZVJFKVsxXTtcbiAgICAgIGhhcyh0aGF0LCBOQU1FKSB8fCAhaXNFeHRlbnNpYmxlKHRoYXQpIHx8IGRQKHRoYXQsIE5BTUUsIGNyZWF0ZURlc2MoNSwgbmFtZSkpO1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXN0cm9uZycpO1xuXG4vLyAyMy4xIE1hcCBPYmplY3RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKSgnTWFwJywgZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIE1hcCgpeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMS4zLjYgTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpe1xuICAgIHZhciBlbnRyeSA9IHN0cm9uZy5nZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52O1xuICB9LFxuICAvLyAyMy4xLjMuOSBNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKXtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZywgdHJ1ZSk7IiwiLy8gMjAuMi4yLjMgTWF0aC5hY29zaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGxvZzFwICAgPSByZXF1aXJlKCcuL19tYXRoLWxvZzFwJylcbiAgLCBzcXJ0ICAgID0gTWF0aC5zcXJ0XG4gICwgJGFjb3NoICA9IE1hdGguYWNvc2g7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYWNvc2hcbiAgLy8gVjggYnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzUwOVxuICAmJiBNYXRoLmZsb29yKCRhY29zaChOdW1iZXIuTUFYX1ZBTFVFKSkgPT0gNzEwXG4gIC8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hY29zaChJbmZpbml0eSkgLT4gTmFOIFxuICAmJiAkYWNvc2goSW5maW5pdHkpID09IEluZmluaXR5XG4pLCAnTWF0aCcsIHtcbiAgYWNvc2g6IGZ1bmN0aW9uIGFjb3NoKHgpe1xuICAgIHJldHVybiAoeCA9ICt4KSA8IDEgPyBOYU4gOiB4ID4gOTQ5MDYyNjUuNjI0MjUxNTZcbiAgICAgID8gTWF0aC5sb2coeCkgKyBNYXRoLkxOMlxuICAgICAgOiBsb2cxcCh4IC0gMSArIHNxcnQoeCAtIDEpICogc3FydCh4ICsgMSkpO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuNSBNYXRoLmFzaW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGFzaW5oICA9IE1hdGguYXNpbmg7XG5cbmZ1bmN0aW9uIGFzaW5oKHgpe1xuICByZXR1cm4gIWlzRmluaXRlKHggPSAreCkgfHwgeCA9PSAwID8geCA6IHggPCAwID8gLWFzaW5oKC14KSA6IE1hdGgubG9nKHggKyBNYXRoLnNxcnQoeCAqIHggKyAxKSk7XG59XG5cbi8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hc2luaCgwKSAtPiAtMCBcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYXNpbmggJiYgMSAvICRhc2luaCgwKSA+IDApLCAnTWF0aCcsIHthc2luaDogYXNpbmh9KTsiLCIvLyAyMC4yLjIuNyBNYXRoLmF0YW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGF0YW5oICA9IE1hdGguYXRhbmg7XG5cbi8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hdGFuaCgtMCkgLT4gMCBcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYXRhbmggJiYgMSAvICRhdGFuaCgtMCkgPCAwKSwgJ01hdGgnLCB7XG4gIGF0YW5oOiBmdW5jdGlvbiBhdGFuaCh4KXtcbiAgICByZXR1cm4gKHggPSAreCkgPT0gMCA/IHggOiBNYXRoLmxvZygoMSArIHgpIC8gKDEgLSB4KSkgLyAyO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuOSBNYXRoLmNicnQoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBzaWduICAgID0gcmVxdWlyZSgnLi9fbWF0aC1zaWduJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY2JydDogZnVuY3Rpb24gY2JydCh4KXtcbiAgICByZXR1cm4gc2lnbih4ID0gK3gpICogTWF0aC5wb3coTWF0aC5hYnMoeCksIDEgLyAzKTtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjExIE1hdGguY2x6MzIoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY2x6MzI6IGZ1bmN0aW9uIGNsejMyKHgpe1xuICAgIHJldHVybiAoeCA+Pj49IDApID8gMzEgLSBNYXRoLmZsb29yKE1hdGgubG9nKHggKyAwLjUpICogTWF0aC5MT0cyRSkgOiAzMjtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjEyIE1hdGguY29zaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGV4cCAgICAgPSBNYXRoLmV4cDtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjb3NoOiBmdW5jdGlvbiBjb3NoKHgpe1xuICAgIHJldHVybiAoZXhwKHggPSAreCkgKyBleHAoLXgpKSAvIDI7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi4xNCBNYXRoLmV4cG0xKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGV4cG0xICA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoJGV4cG0xICE9IE1hdGguZXhwbTEpLCAnTWF0aCcsIHtleHBtMTogJGV4cG0xfSk7IiwiLy8gMjAuMi4yLjE2IE1hdGguZnJvdW5kKHgpXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBzaWduICAgICAgPSByZXF1aXJlKCcuL19tYXRoLXNpZ24nKVxuICAsIHBvdyAgICAgICA9IE1hdGgucG93XG4gICwgRVBTSUxPTiAgID0gcG93KDIsIC01MilcbiAgLCBFUFNJTE9OMzIgPSBwb3coMiwgLTIzKVxuICAsIE1BWDMyICAgICA9IHBvdygyLCAxMjcpICogKDIgLSBFUFNJTE9OMzIpXG4gICwgTUlOMzIgICAgID0gcG93KDIsIC0xMjYpO1xuXG52YXIgcm91bmRUaWVzVG9FdmVuID0gZnVuY3Rpb24obil7XG4gIHJldHVybiBuICsgMSAvIEVQU0lMT04gLSAxIC8gRVBTSUxPTjtcbn07XG5cblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBmcm91bmQ6IGZ1bmN0aW9uIGZyb3VuZCh4KXtcbiAgICB2YXIgJGFicyAgPSBNYXRoLmFicyh4KVxuICAgICAgLCAkc2lnbiA9IHNpZ24oeClcbiAgICAgICwgYSwgcmVzdWx0O1xuICAgIGlmKCRhYnMgPCBNSU4zMilyZXR1cm4gJHNpZ24gKiByb3VuZFRpZXNUb0V2ZW4oJGFicyAvIE1JTjMyIC8gRVBTSUxPTjMyKSAqIE1JTjMyICogRVBTSUxPTjMyO1xuICAgIGEgPSAoMSArIEVQU0lMT04zMiAvIEVQU0lMT04pICogJGFicztcbiAgICByZXN1bHQgPSBhIC0gKGEgLSAkYWJzKTtcbiAgICBpZihyZXN1bHQgPiBNQVgzMiB8fCByZXN1bHQgIT0gcmVzdWx0KXJldHVybiAkc2lnbiAqIEluZmluaXR5O1xuICAgIHJldHVybiAkc2lnbiAqIHJlc3VsdDtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjE3IE1hdGguaHlwb3QoW3ZhbHVlMVssIHZhbHVlMlssIOKApiBdXV0pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYWJzICAgICA9IE1hdGguYWJzO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGh5cG90OiBmdW5jdGlvbiBoeXBvdCh2YWx1ZTEsIHZhbHVlMil7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgc3VtICA9IDBcbiAgICAgICwgaSAgICA9IDBcbiAgICAgICwgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgbGFyZyA9IDBcbiAgICAgICwgYXJnLCBkaXY7XG4gICAgd2hpbGUoaSA8IGFMZW4pe1xuICAgICAgYXJnID0gYWJzKGFyZ3VtZW50c1tpKytdKTtcbiAgICAgIGlmKGxhcmcgPCBhcmcpe1xuICAgICAgICBkaXYgID0gbGFyZyAvIGFyZztcbiAgICAgICAgc3VtICA9IHN1bSAqIGRpdiAqIGRpdiArIDE7XG4gICAgICAgIGxhcmcgPSBhcmc7XG4gICAgICB9IGVsc2UgaWYoYXJnID4gMCl7XG4gICAgICAgIGRpdiAgPSBhcmcgLyBsYXJnO1xuICAgICAgICBzdW0gKz0gZGl2ICogZGl2O1xuICAgICAgfSBlbHNlIHN1bSArPSBhcmc7XG4gICAgfVxuICAgIHJldHVybiBsYXJnID09PSBJbmZpbml0eSA/IEluZmluaXR5IDogbGFyZyAqIE1hdGguc3FydChzdW0pO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMTggTWF0aC5pbXVsKHgsIHkpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGltdWwgICA9IE1hdGguaW11bDtcblxuLy8gc29tZSBXZWJLaXQgdmVyc2lvbnMgZmFpbHMgd2l0aCBiaWcgbnVtYmVycywgc29tZSBoYXMgd3JvbmcgYXJpdHlcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gJGltdWwoMHhmZmZmZmZmZiwgNSkgIT0gLTUgfHwgJGltdWwubGVuZ3RoICE9IDI7XG59KSwgJ01hdGgnLCB7XG4gIGltdWw6IGZ1bmN0aW9uIGltdWwoeCwgeSl7XG4gICAgdmFyIFVJTlQxNiA9IDB4ZmZmZlxuICAgICAgLCB4biA9ICt4XG4gICAgICAsIHluID0gK3lcbiAgICAgICwgeGwgPSBVSU5UMTYgJiB4blxuICAgICAgLCB5bCA9IFVJTlQxNiAmIHluO1xuICAgIHJldHVybiAwIHwgeGwgKiB5bCArICgoVUlOVDE2ICYgeG4gPj4+IDE2KSAqIHlsICsgeGwgKiAoVUlOVDE2ICYgeW4gPj4+IDE2KSA8PCAxNiA+Pj4gMCk7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi4yMSBNYXRoLmxvZzEwKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGxvZzEwOiBmdW5jdGlvbiBsb2cxMCh4KXtcbiAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMTA7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi4yMCBNYXRoLmxvZzFwKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7bG9nMXA6IHJlcXVpcmUoJy4vX21hdGgtbG9nMXAnKX0pOyIsIi8vIDIwLjIuMi4yMiBNYXRoLmxvZzIoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgbG9nMjogZnVuY3Rpb24gbG9nMih4KXtcbiAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMjtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge3NpZ246IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpfSk7IiwiLy8gMjAuMi4yLjMwIE1hdGguc2luaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGV4cG0xICAgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJylcbiAgLCBleHAgICAgID0gTWF0aC5leHA7XG5cbi8vIFY4IG5lYXIgQ2hyb21pdW0gMzggaGFzIGEgcHJvYmxlbSB3aXRoIHZlcnkgc21hbGwgbnVtYmVyc1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiAhTWF0aC5zaW5oKC0yZS0xNykgIT0gLTJlLTE3O1xufSksICdNYXRoJywge1xuICBzaW5oOiBmdW5jdGlvbiBzaW5oKHgpe1xuICAgIHJldHVybiBNYXRoLmFicyh4ID0gK3gpIDwgMVxuICAgICAgPyAoZXhwbTEoeCkgLSBleHBtMSgteCkpIC8gMlxuICAgICAgOiAoZXhwKHggLSAxKSAtIGV4cCgteCAtIDEpKSAqIChNYXRoLkUgLyAyKTtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjMzIE1hdGgudGFuaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGV4cG0xICAgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJylcbiAgLCBleHAgICAgID0gTWF0aC5leHA7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdGFuaDogZnVuY3Rpb24gdGFuaCh4KXtcbiAgICB2YXIgYSA9IGV4cG0xKHggPSAreClcbiAgICAgICwgYiA9IGV4cG0xKC14KTtcbiAgICByZXR1cm4gYSA9PSBJbmZpbml0eSA/IDEgOiBiID09IEluZmluaXR5ID8gLTEgOiAoYSAtIGIpIC8gKGV4cCh4KSArIGV4cCgteCkpO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMzQgTWF0aC50cnVuYyh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICB0cnVuYzogZnVuY3Rpb24gdHJ1bmMoaXQpe1xuICAgIHJldHVybiAoaXQgPiAwID8gTWF0aC5mbG9vciA6IE1hdGguY2VpbCkoaXQpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhhcyAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBjb2YgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJylcbiAgLCB0b1ByaW1pdGl2ZSAgICAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZmFpbHMgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgZ09QTiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgLCBnT1BEICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZlxuICAsIGRQICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsICR0cmltICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltXG4gICwgTlVNQkVSICAgICAgICAgICAgPSAnTnVtYmVyJ1xuICAsICROdW1iZXIgICAgICAgICAgID0gZ2xvYmFsW05VTUJFUl1cbiAgLCBCYXNlICAgICAgICAgICAgICA9ICROdW1iZXJcbiAgLCBwcm90byAgICAgICAgICAgICA9ICROdW1iZXIucHJvdG90eXBlXG4gIC8vIE9wZXJhIH4xMiBoYXMgYnJva2VuIE9iamVjdCN0b1N0cmluZ1xuICAsIEJST0tFTl9DT0YgICAgICAgID0gY29mKHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKShwcm90bykpID09IE5VTUJFUlxuICAsIFRSSU0gICAgICAgICAgICAgID0gJ3RyaW0nIGluIFN0cmluZy5wcm90b3R5cGU7XG5cbi8vIDcuMS4zIFRvTnVtYmVyKGFyZ3VtZW50KVxudmFyIHRvTnVtYmVyID0gZnVuY3Rpb24oYXJndW1lbnQpe1xuICB2YXIgaXQgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgZmFsc2UpO1xuICBpZih0eXBlb2YgaXQgPT0gJ3N0cmluZycgJiYgaXQubGVuZ3RoID4gMil7XG4gICAgaXQgPSBUUklNID8gaXQudHJpbSgpIDogJHRyaW0oaXQsIDMpO1xuICAgIHZhciBmaXJzdCA9IGl0LmNoYXJDb2RlQXQoMClcbiAgICAgICwgdGhpcmQsIHJhZGl4LCBtYXhDb2RlO1xuICAgIGlmKGZpcnN0ID09PSA0MyB8fCBmaXJzdCA9PT0gNDUpe1xuICAgICAgdGhpcmQgPSBpdC5jaGFyQ29kZUF0KDIpO1xuICAgICAgaWYodGhpcmQgPT09IDg4IHx8IHRoaXJkID09PSAxMjApcmV0dXJuIE5hTjsgLy8gTnVtYmVyKCcrMHgxJykgc2hvdWxkIGJlIE5hTiwgb2xkIFY4IGZpeFxuICAgIH0gZWxzZSBpZihmaXJzdCA9PT0gNDgpe1xuICAgICAgc3dpdGNoKGl0LmNoYXJDb2RlQXQoMSkpe1xuICAgICAgICBjYXNlIDY2IDogY2FzZSA5OCAgOiByYWRpeCA9IDI7IG1heENvZGUgPSA0OTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgL14wYlswMV0rJC9pXG4gICAgICAgIGNhc2UgNzkgOiBjYXNlIDExMSA6IHJhZGl4ID0gODsgbWF4Q29kZSA9IDU1OyBicmVhazsgLy8gZmFzdCBlcXVhbCAvXjBvWzAtN10rJC9pXG4gICAgICAgIGRlZmF1bHQgOiByZXR1cm4gK2l0O1xuICAgICAgfVxuICAgICAgZm9yKHZhciBkaWdpdHMgPSBpdC5zbGljZSgyKSwgaSA9IDAsIGwgPSBkaWdpdHMubGVuZ3RoLCBjb2RlOyBpIDwgbDsgaSsrKXtcbiAgICAgICAgY29kZSA9IGRpZ2l0cy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAvLyBwYXJzZUludCBwYXJzZXMgYSBzdHJpbmcgdG8gYSBmaXJzdCB1bmF2YWlsYWJsZSBzeW1ib2xcbiAgICAgICAgLy8gYnV0IFRvTnVtYmVyIHNob3VsZCByZXR1cm4gTmFOIGlmIGEgc3RyaW5nIGNvbnRhaW5zIHVuYXZhaWxhYmxlIHN5bWJvbHNcbiAgICAgICAgaWYoY29kZSA8IDQ4IHx8IGNvZGUgPiBtYXhDb2RlKXJldHVybiBOYU47XG4gICAgICB9IHJldHVybiBwYXJzZUludChkaWdpdHMsIHJhZGl4KTtcbiAgICB9XG4gIH0gcmV0dXJuICtpdDtcbn07XG5cbmlmKCEkTnVtYmVyKCcgMG8xJykgfHwgISROdW1iZXIoJzBiMScpIHx8ICROdW1iZXIoJysweDEnKSl7XG4gICROdW1iZXIgPSBmdW5jdGlvbiBOdW1iZXIodmFsdWUpe1xuICAgIHZhciBpdCA9IGFyZ3VtZW50cy5sZW5ndGggPCAxID8gMCA6IHZhbHVlXG4gICAgICAsIHRoYXQgPSB0aGlzO1xuICAgIHJldHVybiB0aGF0IGluc3RhbmNlb2YgJE51bWJlclxuICAgICAgLy8gY2hlY2sgb24gMS4uY29uc3RydWN0b3IoZm9vKSBjYXNlXG4gICAgICAmJiAoQlJPS0VOX0NPRiA/IGZhaWxzKGZ1bmN0aW9uKCl7IHByb3RvLnZhbHVlT2YuY2FsbCh0aGF0KTsgfSkgOiBjb2YodGhhdCkgIT0gTlVNQkVSKVxuICAgICAgICA/IGluaGVyaXRJZlJlcXVpcmVkKG5ldyBCYXNlKHRvTnVtYmVyKGl0KSksIHRoYXQsICROdW1iZXIpIDogdG9OdW1iZXIoaXQpO1xuICB9O1xuICBmb3IodmFyIGtleXMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QTihCYXNlKSA6IChcbiAgICAvLyBFUzM6XG4gICAgJ01BWF9WQUxVRSxNSU5fVkFMVUUsTmFOLE5FR0FUSVZFX0lORklOSVRZLFBPU0lUSVZFX0lORklOSVRZLCcgK1xuICAgIC8vIEVTNiAoaW4gY2FzZSwgaWYgbW9kdWxlcyB3aXRoIEVTNiBOdW1iZXIgc3RhdGljcyByZXF1aXJlZCBiZWZvcmUpOlxuICAgICdFUFNJTE9OLGlzRmluaXRlLGlzSW50ZWdlcixpc05hTixpc1NhZmVJbnRlZ2VyLE1BWF9TQUZFX0lOVEVHRVIsJyArXG4gICAgJ01JTl9TQUZFX0lOVEVHRVIscGFyc2VGbG9hdCxwYXJzZUludCxpc0ludGVnZXInXG4gICkuc3BsaXQoJywnKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOyBqKyspe1xuICAgIGlmKGhhcyhCYXNlLCBrZXkgPSBrZXlzW2pdKSAmJiAhaGFzKCROdW1iZXIsIGtleSkpe1xuICAgICAgZFAoJE51bWJlciwga2V5LCBnT1BEKEJhc2UsIGtleSkpO1xuICAgIH1cbiAgfVxuICAkTnVtYmVyLnByb3RvdHlwZSA9IHByb3RvO1xuICBwcm90by5jb25zdHJ1Y3RvciA9ICROdW1iZXI7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoZ2xvYmFsLCBOVU1CRVIsICROdW1iZXIpO1xufSIsIi8vIDIwLjEuMi4xIE51bWJlci5FUFNJTE9OXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtFUFNJTE9OOiBNYXRoLnBvdygyLCAtNTIpfSk7IiwiLy8gMjAuMS4yLjIgTnVtYmVyLmlzRmluaXRlKG51bWJlcilcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIF9pc0Zpbml0ZSA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmlzRmluaXRlO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNGaW5pdGU6IGZ1bmN0aW9uIGlzRmluaXRlKGl0KXtcbiAgICByZXR1cm4gdHlwZW9mIGl0ID09ICdudW1iZXInICYmIF9pc0Zpbml0ZShpdCk7XG4gIH1cbn0pOyIsIi8vIDIwLjEuMi4zIE51bWJlci5pc0ludGVnZXIobnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7aXNJbnRlZ2VyOiByZXF1aXJlKCcuL19pcy1pbnRlZ2VyJyl9KTsiLCIvLyAyMC4xLjIuNCBOdW1iZXIuaXNOYU4obnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzTmFOOiBmdW5jdGlvbiBpc05hTihudW1iZXIpe1xuICAgIHJldHVybiBudW1iZXIgIT0gbnVtYmVyO1xuICB9XG59KTsiLCIvLyAyMC4xLjIuNSBOdW1iZXIuaXNTYWZlSW50ZWdlcihudW1iZXIpXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBpc0ludGVnZXIgPSByZXF1aXJlKCcuL19pcy1pbnRlZ2VyJylcbiAgLCBhYnMgICAgICAgPSBNYXRoLmFicztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzU2FmZUludGVnZXI6IGZ1bmN0aW9uIGlzU2FmZUludGVnZXIobnVtYmVyKXtcbiAgICByZXR1cm4gaXNJbnRlZ2VyKG51bWJlcikgJiYgYWJzKG51bWJlcikgPD0gMHgxZmZmZmZmZmZmZmZmZjtcbiAgfVxufSk7IiwiLy8gMjAuMS4yLjYgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge01BWF9TQUZFX0lOVEVHRVI6IDB4MWZmZmZmZmZmZmZmZmZ9KTsiLCIvLyAyMC4xLjIuMTAgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVJcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge01JTl9TQUZFX0lOVEVHRVI6IC0weDFmZmZmZmZmZmZmZmZmfSk7IiwidmFyICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX3BhcnNlLWZsb2F0Jyk7XG4vLyAyMC4xLjIuMTIgTnVtYmVyLnBhcnNlRmxvYXQoc3RyaW5nKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTnVtYmVyLnBhcnNlRmxvYXQgIT0gJHBhcnNlRmxvYXQpLCAnTnVtYmVyJywge3BhcnNlRmxvYXQ6ICRwYXJzZUZsb2F0fSk7IiwidmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHBhcnNlSW50ID0gcmVxdWlyZSgnLi9fcGFyc2UtaW50Jyk7XG4vLyAyMC4xLjIuMTMgTnVtYmVyLnBhcnNlSW50KHN0cmluZywgcmFkaXgpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChOdW1iZXIucGFyc2VJbnQgIT0gJHBhcnNlSW50KSwgJ051bWJlcicsIHtwYXJzZUludDogJHBhcnNlSW50fSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9JbnRlZ2VyICAgID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgYU51bWJlclZhbHVlID0gcmVxdWlyZSgnLi9fYS1udW1iZXItdmFsdWUnKVxuICAsIHJlcGVhdCAgICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKVxuICAsICR0b0ZpeGVkICAgICA9IDEuLnRvRml4ZWRcbiAgLCBmbG9vciAgICAgICAgPSBNYXRoLmZsb29yXG4gICwgZGF0YSAgICAgICAgID0gWzAsIDAsIDAsIDAsIDAsIDBdXG4gICwgRVJST1IgICAgICAgID0gJ051bWJlci50b0ZpeGVkOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnXG4gICwgWkVSTyAgICAgICAgID0gJzAnO1xuXG52YXIgbXVsdGlwbHkgPSBmdW5jdGlvbihuLCBjKXtcbiAgdmFyIGkgID0gLTFcbiAgICAsIGMyID0gYztcbiAgd2hpbGUoKytpIDwgNil7XG4gICAgYzIgKz0gbiAqIGRhdGFbaV07XG4gICAgZGF0YVtpXSA9IGMyICUgMWU3O1xuICAgIGMyID0gZmxvb3IoYzIgLyAxZTcpO1xuICB9XG59O1xudmFyIGRpdmlkZSA9IGZ1bmN0aW9uKG4pe1xuICB2YXIgaSA9IDZcbiAgICAsIGMgPSAwO1xuICB3aGlsZSgtLWkgPj0gMCl7XG4gICAgYyArPSBkYXRhW2ldO1xuICAgIGRhdGFbaV0gPSBmbG9vcihjIC8gbik7XG4gICAgYyA9IChjICUgbikgKiAxZTc7XG4gIH1cbn07XG52YXIgbnVtVG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICB2YXIgaSA9IDZcbiAgICAsIHMgPSAnJztcbiAgd2hpbGUoLS1pID49IDApe1xuICAgIGlmKHMgIT09ICcnIHx8IGkgPT09IDAgfHwgZGF0YVtpXSAhPT0gMCl7XG4gICAgICB2YXIgdCA9IFN0cmluZyhkYXRhW2ldKTtcbiAgICAgIHMgPSBzID09PSAnJyA/IHQgOiBzICsgcmVwZWF0LmNhbGwoWkVSTywgNyAtIHQubGVuZ3RoKSArIHQ7XG4gICAgfVxuICB9IHJldHVybiBzO1xufTtcbnZhciBwb3cgPSBmdW5jdGlvbih4LCBuLCBhY2Mpe1xuICByZXR1cm4gbiA9PT0gMCA/IGFjYyA6IG4gJSAyID09PSAxID8gcG93KHgsIG4gLSAxLCBhY2MgKiB4KSA6IHBvdyh4ICogeCwgbiAvIDIsIGFjYyk7XG59O1xudmFyIGxvZyA9IGZ1bmN0aW9uKHgpe1xuICB2YXIgbiAgPSAwXG4gICAgLCB4MiA9IHg7XG4gIHdoaWxlKHgyID49IDQwOTYpe1xuICAgIG4gKz0gMTI7XG4gICAgeDIgLz0gNDA5NjtcbiAgfVxuICB3aGlsZSh4MiA+PSAyKXtcbiAgICBuICArPSAxO1xuICAgIHgyIC89IDI7XG4gIH0gcmV0dXJuIG47XG59O1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICghISR0b0ZpeGVkICYmIChcbiAgMC4wMDAwOC50b0ZpeGVkKDMpICE9PSAnMC4wMDAnIHx8XG4gIDAuOS50b0ZpeGVkKDApICE9PSAnMScgfHxcbiAgMS4yNTUudG9GaXhlZCgyKSAhPT0gJzEuMjUnIHx8XG4gIDEwMDAwMDAwMDAwMDAwMDAxMjguLnRvRml4ZWQoMCkgIT09ICcxMDAwMDAwMDAwMDAwMDAwMTI4J1xuKSB8fCAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICAvLyBWOCB+IEFuZHJvaWQgNC4zLVxuICAkdG9GaXhlZC5jYWxsKHt9KTtcbn0pKSwgJ051bWJlcicsIHtcbiAgdG9GaXhlZDogZnVuY3Rpb24gdG9GaXhlZChmcmFjdGlvbkRpZ2l0cyl7XG4gICAgdmFyIHggPSBhTnVtYmVyVmFsdWUodGhpcywgRVJST1IpXG4gICAgICAsIGYgPSB0b0ludGVnZXIoZnJhY3Rpb25EaWdpdHMpXG4gICAgICAsIHMgPSAnJ1xuICAgICAgLCBtID0gWkVST1xuICAgICAgLCBlLCB6LCBqLCBrO1xuICAgIGlmKGYgPCAwIHx8IGYgPiAyMCl0aHJvdyBSYW5nZUVycm9yKEVSUk9SKTtcbiAgICBpZih4ICE9IHgpcmV0dXJuICdOYU4nO1xuICAgIGlmKHggPD0gLTFlMjEgfHwgeCA+PSAxZTIxKXJldHVybiBTdHJpbmcoeCk7XG4gICAgaWYoeCA8IDApe1xuICAgICAgcyA9ICctJztcbiAgICAgIHggPSAteDtcbiAgICB9XG4gICAgaWYoeCA+IDFlLTIxKXtcbiAgICAgIGUgPSBsb2coeCAqIHBvdygyLCA2OSwgMSkpIC0gNjk7XG4gICAgICB6ID0gZSA8IDAgPyB4ICogcG93KDIsIC1lLCAxKSA6IHggLyBwb3coMiwgZSwgMSk7XG4gICAgICB6ICo9IDB4MTAwMDAwMDAwMDAwMDA7XG4gICAgICBlID0gNTIgLSBlO1xuICAgICAgaWYoZSA+IDApe1xuICAgICAgICBtdWx0aXBseSgwLCB6KTtcbiAgICAgICAgaiA9IGY7XG4gICAgICAgIHdoaWxlKGogPj0gNyl7XG4gICAgICAgICAgbXVsdGlwbHkoMWU3LCAwKTtcbiAgICAgICAgICBqIC09IDc7XG4gICAgICAgIH1cbiAgICAgICAgbXVsdGlwbHkocG93KDEwLCBqLCAxKSwgMCk7XG4gICAgICAgIGogPSBlIC0gMTtcbiAgICAgICAgd2hpbGUoaiA+PSAyMyl7XG4gICAgICAgICAgZGl2aWRlKDEgPDwgMjMpO1xuICAgICAgICAgIGogLT0gMjM7XG4gICAgICAgIH1cbiAgICAgICAgZGl2aWRlKDEgPDwgaik7XG4gICAgICAgIG11bHRpcGx5KDEsIDEpO1xuICAgICAgICBkaXZpZGUoMik7XG4gICAgICAgIG0gPSBudW1Ub1N0cmluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXVsdGlwbHkoMCwgeik7XG4gICAgICAgIG11bHRpcGx5KDEgPDwgLWUsIDApO1xuICAgICAgICBtID0gbnVtVG9TdHJpbmcoKSArIHJlcGVhdC5jYWxsKFpFUk8sIGYpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZihmID4gMCl7XG4gICAgICBrID0gbS5sZW5ndGg7XG4gICAgICBtID0gcyArIChrIDw9IGYgPyAnMC4nICsgcmVwZWF0LmNhbGwoWkVSTywgZiAtIGspICsgbSA6IG0uc2xpY2UoMCwgayAtIGYpICsgJy4nICsgbS5zbGljZShrIC0gZikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gcyArIG07XG4gICAgfSByZXR1cm4gbTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGZhaWxzICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGFOdW1iZXJWYWx1ZSA9IHJlcXVpcmUoJy4vX2EtbnVtYmVyLXZhbHVlJylcbiAgLCAkdG9QcmVjaXNpb24gPSAxLi50b1ByZWNpc2lvbjtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIC8vIElFNy1cbiAgcmV0dXJuICR0b1ByZWNpc2lvbi5jYWxsKDEsIHVuZGVmaW5lZCkgIT09ICcxJztcbn0pIHx8ICEkZmFpbHMoZnVuY3Rpb24oKXtcbiAgLy8gVjggfiBBbmRyb2lkIDQuMy1cbiAgJHRvUHJlY2lzaW9uLmNhbGwoe30pO1xufSkpLCAnTnVtYmVyJywge1xuICB0b1ByZWNpc2lvbjogZnVuY3Rpb24gdG9QcmVjaXNpb24ocHJlY2lzaW9uKXtcbiAgICB2YXIgdGhhdCA9IGFOdW1iZXJWYWx1ZSh0aGlzLCAnTnVtYmVyI3RvUHJlY2lzaW9uOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgICByZXR1cm4gcHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyAkdG9QcmVjaXNpb24uY2FsbCh0aGF0KSA6ICR0b1ByZWNpc2lvbi5jYWxsKHRoYXQsIHByZWNpc2lvbik7IFxuICB9XG59KTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjMgLyAxNS4yLjMuNyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHtkZWZpbmVQcm9wZXJ0aWVzOiByZXF1aXJlKCcuL19vYmplY3QtZHBzJyl9KTsiLCIvLyAxOS4xLjIuNSBPYmplY3QuZnJlZXplKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIG1ldGEgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2ZyZWV6ZScsIGZ1bmN0aW9uKCRmcmVlemUpe1xuICByZXR1cm4gZnVuY3Rpb24gZnJlZXplKGl0KXtcbiAgICByZXR1cm4gJGZyZWV6ZSAmJiBpc09iamVjdChpdCkgPyAkZnJlZXplKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7IiwiLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0T3duUHJvcGVydHlOYW1lcycsIGZ1bmN0aW9uKCl7XG4gIHJldHVybiByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKS5mO1xufSk7IiwiLy8gMTkuMS4yLjExIE9iamVjdC5pc0V4dGVuc2libGUoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzRXh0ZW5zaWJsZScsIGZ1bmN0aW9uKCRpc0V4dGVuc2libGUpe1xuICByZXR1cm4gZnVuY3Rpb24gaXNFeHRlbnNpYmxlKGl0KXtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzRXh0ZW5zaWJsZSA/ICRpc0V4dGVuc2libGUoaXQpIDogdHJ1ZSA6IGZhbHNlO1xuICB9O1xufSk7IiwiLy8gMTkuMS4yLjEzIE9iamVjdC5pc1NlYWxlZChPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNTZWFsZWQnLCBmdW5jdGlvbigkaXNTZWFsZWQpe1xuICByZXR1cm4gZnVuY3Rpb24gaXNTZWFsZWQoaXQpe1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNTZWFsZWQgPyAkaXNTZWFsZWQoaXQpIDogZmFsc2UgOiB0cnVlO1xuICB9O1xufSk7IiwiLy8gMTkuMS4zLjEwIE9iamVjdC5pcyh2YWx1ZTEsIHZhbHVlMilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtpczogcmVxdWlyZSgnLi9fc2FtZS12YWx1ZScpfSk7IiwiLy8gMTkuMS4yLjE1IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyhPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBtZXRhICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdwcmV2ZW50RXh0ZW5zaW9ucycsIGZ1bmN0aW9uKCRwcmV2ZW50RXh0ZW5zaW9ucyl7XG4gIHJldHVybiBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyhpdCl7XG4gICAgcmV0dXJuICRwcmV2ZW50RXh0ZW5zaW9ucyAmJiBpc09iamVjdChpdCkgPyAkcHJldmVudEV4dGVuc2lvbnMobWV0YShpdCkpIDogaXQ7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuMTcgT2JqZWN0LnNlYWwoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgbWV0YSAgICAgPSByZXF1aXJlKCcuL19tZXRhJykub25GcmVlemU7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnc2VhbCcsIGZ1bmN0aW9uKCRzZWFsKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNlYWwoaXQpe1xuICAgIHJldHVybiAkc2VhbCAmJiBpc09iamVjdChpdCkgPyAkc2VhbChtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCB0ZXN0ICAgID0ge307XG50ZXN0W3JlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpXSA9ICd6JztcbmlmKHRlc3QgKyAnJyAhPSAnW29iamVjdCB6XScpe1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKE9iamVjdC5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgcmV0dXJuICdbb2JqZWN0ICcgKyBjbGFzc29mKHRoaXMpICsgJ10nO1xuICB9LCB0cnVlKTtcbn0iLCJ2YXIgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRwYXJzZUZsb2F0ID0gcmVxdWlyZSgnLi9fcGFyc2UtZmxvYXQnKTtcbi8vIDE4LjIuNCBwYXJzZUZsb2F0KHN0cmluZylcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5GICogKHBhcnNlRmxvYXQgIT0gJHBhcnNlRmxvYXQpLCB7cGFyc2VGbG9hdDogJHBhcnNlRmxvYXR9KTsiLCJ2YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcGFyc2VJbnQgPSByZXF1aXJlKCcuL19wYXJzZS1pbnQnKTtcbi8vIDE4LjIuNSBwYXJzZUludChzdHJpbmcsIHJhZGl4KVxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkYgKiAocGFyc2VJbnQgIT0gJHBhcnNlSW50KSwge3BhcnNlSW50OiAkcGFyc2VJbnR9KTsiLCIvLyAyNi4xLjEgUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdClcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIGFuT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgckFwcGx5ICAgID0gKHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3QgfHwge30pLmFwcGx5XG4gICwgZkFwcGx5ICAgID0gRnVuY3Rpb24uYXBwbHk7XG4vLyBNUyBFZGdlIGFyZ3VtZW50c0xpc3QgYXJndW1lbnQgaXMgb3B0aW9uYWxcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgckFwcGx5KGZ1bmN0aW9uKCl7fSk7XG59KSwgJ1JlZmxlY3QnLCB7XG4gIGFwcGx5OiBmdW5jdGlvbiBhcHBseSh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdCl7XG4gICAgdmFyIFQgPSBhRnVuY3Rpb24odGFyZ2V0KVxuICAgICAgLCBMID0gYW5PYmplY3QoYXJndW1lbnRzTGlzdCk7XG4gICAgcmV0dXJuIHJBcHBseSA/IHJBcHBseShULCB0aGlzQXJndW1lbnQsIEwpIDogZkFwcGx5LmNhbGwoVCwgdGhpc0FyZ3VtZW50LCBMKTtcbiAgfVxufSk7IiwiLy8gMjYuMS4yIFJlZmxlY3QuY29uc3RydWN0KHRhcmdldCwgYXJndW1lbnRzTGlzdCBbLCBuZXdUYXJnZXRdKVxudmFyICRleHBvcnQgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNyZWF0ZSAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBhRnVuY3Rpb24gID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgYW5PYmplY3QgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgaXNPYmplY3QgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZmFpbHMgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBiaW5kICAgICAgID0gcmVxdWlyZSgnLi9fYmluZCcpXG4gICwgckNvbnN0cnVjdCA9IChyZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0IHx8IHt9KS5jb25zdHJ1Y3Q7XG5cbi8vIE1TIEVkZ2Ugc3VwcG9ydHMgb25seSAyIGFyZ3VtZW50cyBhbmQgYXJndW1lbnRzTGlzdCBhcmd1bWVudCBpcyBvcHRpb25hbFxuLy8gRkYgTmlnaHRseSBzZXRzIHRoaXJkIGFyZ3VtZW50IGFzIGBuZXcudGFyZ2V0YCwgYnV0IGRvZXMgbm90IGNyZWF0ZSBgdGhpc2AgZnJvbSBpdFxudmFyIE5FV19UQVJHRVRfQlVHID0gZmFpbHMoZnVuY3Rpb24oKXtcbiAgZnVuY3Rpb24gRigpe31cbiAgcmV0dXJuICEockNvbnN0cnVjdChmdW5jdGlvbigpe30sIFtdLCBGKSBpbnN0YW5jZW9mIEYpO1xufSk7XG52YXIgQVJHU19CVUcgPSAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgckNvbnN0cnVjdChmdW5jdGlvbigpe30pO1xufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE5FV19UQVJHRVRfQlVHIHx8IEFSR1NfQlVHKSwgJ1JlZmxlY3QnLCB7XG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gY29uc3RydWN0KFRhcmdldCwgYXJncyAvKiwgbmV3VGFyZ2V0Ki8pe1xuICAgIGFGdW5jdGlvbihUYXJnZXQpO1xuICAgIGFuT2JqZWN0KGFyZ3MpO1xuICAgIHZhciBuZXdUYXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IFRhcmdldCA6IGFGdW5jdGlvbihhcmd1bWVudHNbMl0pO1xuICAgIGlmKEFSR1NfQlVHICYmICFORVdfVEFSR0VUX0JVRylyZXR1cm4gckNvbnN0cnVjdChUYXJnZXQsIGFyZ3MsIG5ld1RhcmdldCk7XG4gICAgaWYoVGFyZ2V0ID09IG5ld1RhcmdldCl7XG4gICAgICAvLyB3L28gYWx0ZXJlZCBuZXdUYXJnZXQsIG9wdGltaXphdGlvbiBmb3IgMC00IGFyZ3VtZW50c1xuICAgICAgc3dpdGNoKGFyZ3MubGVuZ3RoKXtcbiAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IFRhcmdldDtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdKTtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgIH1cbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgbG90IG9mIGFyZ3VtZW50cyBjYXNlXG4gICAgICB2YXIgJGFyZ3MgPSBbbnVsbF07XG4gICAgICAkYXJncy5wdXNoLmFwcGx5KCRhcmdzLCBhcmdzKTtcbiAgICAgIHJldHVybiBuZXcgKGJpbmQuYXBwbHkoVGFyZ2V0LCAkYXJncykpO1xuICAgIH1cbiAgICAvLyB3aXRoIGFsdGVyZWQgbmV3VGFyZ2V0LCBub3Qgc3VwcG9ydCBidWlsdC1pbiBjb25zdHJ1Y3RvcnNcbiAgICB2YXIgcHJvdG8gICAgPSBuZXdUYXJnZXQucHJvdG90eXBlXG4gICAgICAsIGluc3RhbmNlID0gY3JlYXRlKGlzT2JqZWN0KHByb3RvKSA/IHByb3RvIDogT2JqZWN0LnByb3RvdHlwZSlcbiAgICAgICwgcmVzdWx0ICAgPSBGdW5jdGlvbi5hcHBseS5jYWxsKFRhcmdldCwgaW5zdGFuY2UsIGFyZ3MpO1xuICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogaW5zdGFuY2U7XG4gIH1cbn0pOyIsIi8vIDI2LjEuMyBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpXG52YXIgZFAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcblxuLy8gTVMgRWRnZSBoYXMgYnJva2VuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkgLSB0aHJvd2luZyBpbnN0ZWFkIG9mIHJldHVybmluZyBmYWxzZVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkoZFAuZih7fSwgMSwge3ZhbHVlOiAxfSksIDEsIHt2YWx1ZTogMn0pO1xufSksICdSZWZsZWN0Jywge1xuICBkZWZpbmVQcm9wZXJ0eTogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcyl7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcbiAgICBwcm9wZXJ0eUtleSA9IHRvUHJpbWl0aXZlKHByb3BlcnR5S2V5LCB0cnVlKTtcbiAgICBhbk9iamVjdChhdHRyaWJ1dGVzKTtcbiAgICB0cnkge1xuICAgICAgZFAuZih0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTsiLCIvLyAyNi4xLjQgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBnT1BEICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZlxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZGVsZXRlUHJvcGVydHk6IGZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpe1xuICAgIHZhciBkZXNjID0gZ09QRChhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gICAgcmV0dXJuIGRlc2MgJiYgIWRlc2MuY29uZmlndXJhYmxlID8gZmFsc2UgOiBkZWxldGUgdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjYuMS41IFJlZmxlY3QuZW51bWVyYXRlKHRhcmdldClcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBFbnVtZXJhdGUgPSBmdW5jdGlvbihpdGVyYXRlZCl7XG4gIHRoaXMuX3QgPSBhbk9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHZhciBrZXlzID0gdGhpcy5fayA9IFtdICAgICAgIC8vIGtleXNcbiAgICAsIGtleTtcbiAgZm9yKGtleSBpbiBpdGVyYXRlZClrZXlzLnB1c2goa2V5KTtcbn07XG5yZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpKEVudW1lcmF0ZSwgJ09iamVjdCcsIGZ1bmN0aW9uKCl7XG4gIHZhciB0aGF0ID0gdGhpc1xuICAgICwga2V5cyA9IHRoYXQuX2tcbiAgICAsIGtleTtcbiAgZG8ge1xuICAgIGlmKHRoYXQuX2kgPj0ga2V5cy5sZW5ndGgpcmV0dXJuIHt2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlfTtcbiAgfSB3aGlsZSghKChrZXkgPSBrZXlzW3RoYXQuX2krK10pIGluIHRoYXQuX3QpKTtcbiAgcmV0dXJuIHt2YWx1ZToga2V5LCBkb25lOiBmYWxzZX07XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBlbnVtZXJhdGU6IGZ1bmN0aW9uIGVudW1lcmF0ZSh0YXJnZXQpe1xuICAgIHJldHVybiBuZXcgRW51bWVyYXRlKHRhcmdldCk7XG4gIH1cbn0pOyIsIi8vIDI2LjEuNyBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyIGdPUEQgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpe1xuICAgIHJldHVybiBnT1BELmYoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuICB9XG59KTsiLCIvLyAyNi4xLjggUmVmbGVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGdldFByb3RvID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KXtcbiAgICByZXR1cm4gZ2V0UHJvdG8oYW5PYmplY3QodGFyZ2V0KSk7XG4gIH1cbn0pOyIsIi8vIDI2LjEuNiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3BlcnR5S2V5IFssIHJlY2VpdmVyXSlcbnZhciBnT1BEICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgLCBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgaXNPYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbmZ1bmN0aW9uIGdldCh0YXJnZXQsIHByb3BlcnR5S2V5LyosIHJlY2VpdmVyKi8pe1xuICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IGFyZ3VtZW50c1syXVxuICAgICwgZGVzYywgcHJvdG87XG4gIGlmKGFuT2JqZWN0KHRhcmdldCkgPT09IHJlY2VpdmVyKXJldHVybiB0YXJnZXRbcHJvcGVydHlLZXldO1xuICBpZihkZXNjID0gZ09QRC5mKHRhcmdldCwgcHJvcGVydHlLZXkpKXJldHVybiBoYXMoZGVzYywgJ3ZhbHVlJylcbiAgICA/IGRlc2MudmFsdWVcbiAgICA6IGRlc2MuZ2V0ICE9PSB1bmRlZmluZWRcbiAgICAgID8gZGVzYy5nZXQuY2FsbChyZWNlaXZlcilcbiAgICAgIDogdW5kZWZpbmVkO1xuICBpZihpc09iamVjdChwcm90byA9IGdldFByb3RvdHlwZU9mKHRhcmdldCkpKXJldHVybiBnZXQocHJvdG8sIHByb3BlcnR5S2V5LCByZWNlaXZlcik7XG59XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtnZXQ6IGdldH0pOyIsIi8vIDI2LjEuOSBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBoYXM6IGZ1bmN0aW9uIGhhcyh0YXJnZXQsIHByb3BlcnR5S2V5KXtcbiAgICByZXR1cm4gcHJvcGVydHlLZXkgaW4gdGFyZ2V0O1xuICB9XG59KTsiLCIvLyAyNi4xLjEwIFJlZmxlY3QuaXNFeHRlbnNpYmxlKHRhcmdldClcbnZhciAkZXhwb3J0ICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhbk9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCAkaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBpc0V4dGVuc2libGU6IGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZSh0YXJnZXQpe1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgcmV0dXJuICRpc0V4dGVuc2libGUgPyAkaXNFeHRlbnNpYmxlKHRhcmdldCkgOiB0cnVlO1xuICB9XG59KTsiLCIvLyAyNi4xLjExIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7b3duS2V5czogcmVxdWlyZSgnLi9fb3duLWtleXMnKX0pOyIsIi8vIDI2LjEuMTIgUmVmbGVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpXG52YXIgJGV4cG9ydCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsICRwcmV2ZW50RXh0ZW5zaW9ucyA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBwcmV2ZW50RXh0ZW5zaW9uczogZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KXtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHRyeSB7XG4gICAgICBpZigkcHJldmVudEV4dGVuc2lvbnMpJHByZXZlbnRFeHRlbnNpb25zKHRhcmdldCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7IiwiLy8gMjYuMS4xNCBSZWZsZWN0LnNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG8pXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHNldFByb3RvID0gcmVxdWlyZSgnLi9fc2V0LXByb3RvJyk7XG5cbmlmKHNldFByb3RvKSRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgc2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG8pe1xuICAgIHNldFByb3RvLmNoZWNrKHRhcmdldCwgcHJvdG8pO1xuICAgIHRyeSB7XG4gICAgICBzZXRQcm90by5zZXQodGFyZ2V0LCBwcm90byk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7IiwiLy8gMjYuMS4xMyBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3BlcnR5S2V5LCBWIFssIHJlY2VpdmVyXSlcbnZhciBkUCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgZ09QRCAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICwgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGlzT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbmZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5S2V5LCBWLyosIHJlY2VpdmVyKi8pe1xuICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgNCA/IHRhcmdldCA6IGFyZ3VtZW50c1szXVxuICAgICwgb3duRGVzYyAgPSBnT1BELmYoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpXG4gICAgLCBleGlzdGluZ0Rlc2NyaXB0b3IsIHByb3RvO1xuICBpZighb3duRGVzYyl7XG4gICAgaWYoaXNPYmplY3QocHJvdG8gPSBnZXRQcm90b3R5cGVPZih0YXJnZXQpKSl7XG4gICAgICByZXR1cm4gc2V0KHByb3RvLCBwcm9wZXJ0eUtleSwgViwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgICBvd25EZXNjID0gY3JlYXRlRGVzYygwKTtcbiAgfVxuICBpZihoYXMob3duRGVzYywgJ3ZhbHVlJykpe1xuICAgIGlmKG93bkRlc2Mud3JpdGFibGUgPT09IGZhbHNlIHx8ICFpc09iamVjdChyZWNlaXZlcikpcmV0dXJuIGZhbHNlO1xuICAgIGV4aXN0aW5nRGVzY3JpcHRvciA9IGdPUEQuZihyZWNlaXZlciwgcHJvcGVydHlLZXkpIHx8IGNyZWF0ZURlc2MoMCk7XG4gICAgZXhpc3RpbmdEZXNjcmlwdG9yLnZhbHVlID0gVjtcbiAgICBkUC5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSwgZXhpc3RpbmdEZXNjcmlwdG9yKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gb3duRGVzYy5zZXQgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogKG93bkRlc2Muc2V0LmNhbGwocmVjZWl2ZXIsIFYpLCB0cnVlKTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge3NldDogc2V0fSk7IiwidmFyIGdsb2JhbCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKVxuICAsIGRQICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGdPUE4gICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICwgaXNSZWdFeHAgICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKVxuICAsICRmbGFncyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZmxhZ3MnKVxuICAsICRSZWdFeHAgICAgICAgICAgID0gZ2xvYmFsLlJlZ0V4cFxuICAsIEJhc2UgICAgICAgICAgICAgID0gJFJlZ0V4cFxuICAsIHByb3RvICAgICAgICAgICAgID0gJFJlZ0V4cC5wcm90b3R5cGVcbiAgLCByZTEgICAgICAgICAgICAgICA9IC9hL2dcbiAgLCByZTIgICAgICAgICAgICAgICA9IC9hL2dcbiAgLy8gXCJuZXdcIiBjcmVhdGVzIGEgbmV3IG9iamVjdCwgb2xkIHdlYmtpdCBidWdneSBoZXJlXG4gICwgQ09SUkVDVF9ORVcgICAgICAgPSBuZXcgJFJlZ0V4cChyZTEpICE9PSByZTE7XG5cbmlmKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgKCFDT1JSRUNUX05FVyB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJlMltyZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKV0gPSBmYWxzZTtcbiAgLy8gUmVnRXhwIGNvbnN0cnVjdG9yIGNhbiBhbHRlciBmbGFncyBhbmQgSXNSZWdFeHAgd29ya3MgY29ycmVjdCB3aXRoIEBAbWF0Y2hcbiAgcmV0dXJuICRSZWdFeHAocmUxKSAhPSByZTEgfHwgJFJlZ0V4cChyZTIpID09IHJlMiB8fCAkUmVnRXhwKHJlMSwgJ2knKSAhPSAnL2EvaSc7XG59KSkpe1xuICAkUmVnRXhwID0gZnVuY3Rpb24gUmVnRXhwKHAsIGYpe1xuICAgIHZhciB0aVJFID0gdGhpcyBpbnN0YW5jZW9mICRSZWdFeHBcbiAgICAgICwgcGlSRSA9IGlzUmVnRXhwKHApXG4gICAgICAsIGZpVSAgPSBmID09PSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuICF0aVJFICYmIHBpUkUgJiYgcC5jb25zdHJ1Y3RvciA9PT0gJFJlZ0V4cCAmJiBmaVUgPyBwXG4gICAgICA6IGluaGVyaXRJZlJlcXVpcmVkKENPUlJFQ1RfTkVXXG4gICAgICAgID8gbmV3IEJhc2UocGlSRSAmJiAhZmlVID8gcC5zb3VyY2UgOiBwLCBmKVxuICAgICAgICA6IEJhc2UoKHBpUkUgPSBwIGluc3RhbmNlb2YgJFJlZ0V4cCkgPyBwLnNvdXJjZSA6IHAsIHBpUkUgJiYgZmlVID8gJGZsYWdzLmNhbGwocCkgOiBmKVxuICAgICAgLCB0aVJFID8gdGhpcyA6IHByb3RvLCAkUmVnRXhwKTtcbiAgfTtcbiAgdmFyIHByb3h5ID0gZnVuY3Rpb24oa2V5KXtcbiAgICBrZXkgaW4gJFJlZ0V4cCB8fCBkUCgkUmVnRXhwLCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIEJhc2Vba2V5XTsgfSxcbiAgICAgIHNldDogZnVuY3Rpb24oaXQpeyBCYXNlW2tleV0gPSBpdDsgfVxuICAgIH0pO1xuICB9O1xuICBmb3IodmFyIGtleXMgPSBnT1BOKEJhc2UpLCBpID0gMDsga2V5cy5sZW5ndGggPiBpOyApcHJveHkoa2V5c1tpKytdKTtcbiAgcHJvdG8uY29uc3RydWN0b3IgPSAkUmVnRXhwO1xuICAkUmVnRXhwLnByb3RvdHlwZSA9IHByb3RvO1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKGdsb2JhbCwgJ1JlZ0V4cCcsICRSZWdFeHApO1xufVxuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKCdSZWdFeHAnKTsiLCIvLyAyMS4yLjUuMyBnZXQgUmVnRXhwLnByb3RvdHlwZS5mbGFncygpXG5pZihyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmIC8uL2cuZmxhZ3MgIT0gJ2cnKXJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYoUmVnRXhwLnByb3RvdHlwZSwgJ2ZsYWdzJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogcmVxdWlyZSgnLi9fZmxhZ3MnKVxufSk7IiwiLy8gQEBtYXRjaCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdtYXRjaCcsIDEsIGZ1bmN0aW9uKGRlZmluZWQsIE1BVENILCAkbWF0Y2gpe1xuICAvLyAyMS4xLjMuMTEgU3RyaW5nLnByb3RvdHlwZS5tYXRjaChyZWdleHApXG4gIHJldHVybiBbZnVuY3Rpb24gbWF0Y2gocmVnZXhwKXtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIE8gID0gZGVmaW5lZCh0aGlzKVxuICAgICAgLCBmbiA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbTUFUQ0hdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW01BVENIXShTdHJpbmcoTykpO1xuICB9LCAkbWF0Y2hdO1xufSk7IiwiLy8gQEByZXBsYWNlIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3JlcGxhY2UnLCAyLCBmdW5jdGlvbihkZWZpbmVkLCBSRVBMQUNFLCAkcmVwbGFjZSl7XG4gIC8vIDIxLjEuMy4xNCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSlcbiAgcmV0dXJuIFtmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpe1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgTyAgPSBkZWZpbmVkKHRoaXMpXG4gICAgICAsIGZuID0gc2VhcmNoVmFsdWUgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc2VhcmNoVmFsdWVbUkVQTEFDRV07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWRcbiAgICAgID8gZm4uY2FsbChzZWFyY2hWYWx1ZSwgTywgcmVwbGFjZVZhbHVlKVxuICAgICAgOiAkcmVwbGFjZS5jYWxsKFN0cmluZyhPKSwgc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSk7XG4gIH0sICRyZXBsYWNlXTtcbn0pOyIsIi8vIEBAc2VhcmNoIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3NlYXJjaCcsIDEsIGZ1bmN0aW9uKGRlZmluZWQsIFNFQVJDSCwgJHNlYXJjaCl7XG4gIC8vIDIxLjEuMy4xNSBTdHJpbmcucHJvdG90eXBlLnNlYXJjaChyZWdleHApXG4gIHJldHVybiBbZnVuY3Rpb24gc2VhcmNoKHJlZ2V4cCl7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBPICA9IGRlZmluZWQodGhpcylcbiAgICAgICwgZm4gPSByZWdleHAgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVnZXhwW1NFQVJDSF07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHJlZ2V4cCwgTykgOiBuZXcgUmVnRXhwKHJlZ2V4cClbU0VBUkNIXShTdHJpbmcoTykpO1xuICB9LCAkc2VhcmNoXTtcbn0pOyIsIi8vIEBAc3BsaXQgbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnc3BsaXQnLCAyLCBmdW5jdGlvbihkZWZpbmVkLCBTUExJVCwgJHNwbGl0KXtcbiAgJ3VzZSBzdHJpY3QnO1xuICB2YXIgaXNSZWdFeHAgICA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpXG4gICAgLCBfc3BsaXQgICAgID0gJHNwbGl0XG4gICAgLCAkcHVzaCAgICAgID0gW10ucHVzaFxuICAgICwgJFNQTElUICAgICA9ICdzcGxpdCdcbiAgICAsIExFTkdUSCAgICAgPSAnbGVuZ3RoJ1xuICAgICwgTEFTVF9JTkRFWCA9ICdsYXN0SW5kZXgnO1xuICBpZihcbiAgICAnYWJiYydbJFNQTElUXSgvKGIpKi8pWzFdID09ICdjJyB8fFxuICAgICd0ZXN0J1skU1BMSVRdKC8oPzopLywgLTEpW0xFTkdUSF0gIT0gNCB8fFxuICAgICdhYidbJFNQTElUXSgvKD86YWIpKi8pW0xFTkdUSF0gIT0gMiB8fFxuICAgICcuJ1skU1BMSVRdKC8oLj8pKC4/KS8pW0xFTkdUSF0gIT0gNCB8fFxuICAgICcuJ1skU1BMSVRdKC8oKSgpLylbTEVOR1RIXSA+IDEgfHxcbiAgICAnJ1skU1BMSVRdKC8uPy8pW0xFTkdUSF1cbiAgKXtcbiAgICB2YXIgTlBDRyA9IC8oKT8/Ly5leGVjKCcnKVsxXSA9PT0gdW5kZWZpbmVkOyAvLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cFxuICAgIC8vIGJhc2VkIG9uIGVzNS1zaGltIGltcGxlbWVudGF0aW9uLCBuZWVkIHRvIHJld29yayBpdFxuICAgICRzcGxpdCA9IGZ1bmN0aW9uKHNlcGFyYXRvciwgbGltaXQpe1xuICAgICAgdmFyIHN0cmluZyA9IFN0cmluZyh0aGlzKTtcbiAgICAgIGlmKHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwKXJldHVybiBbXTtcbiAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICBpZighaXNSZWdFeHAoc2VwYXJhdG9yKSlyZXR1cm4gX3NwbGl0LmNhbGwoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgIHZhciBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnVuaWNvZGUgPyAndScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgPyAneScgOiAnJyk7XG4gICAgICB2YXIgbGFzdExhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgc3BsaXRMaW1pdCA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyA0Mjk0OTY3Mjk1IDogbGltaXQgPj4+IDA7XG4gICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgdmFyIHNlcGFyYXRvckNvcHkgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcbiAgICAgIHZhciBzZXBhcmF0b3IyLCBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoLCBpO1xuICAgICAgLy8gRG9lc24ndCBuZWVkIGZsYWdzIGd5LCBidXQgdGhleSBkb24ndCBodXJ0XG4gICAgICBpZighTlBDRylzZXBhcmF0b3IyID0gbmV3IFJlZ0V4cCgnXicgKyBzZXBhcmF0b3JDb3B5LnNvdXJjZSArICckKD8hXFxcXHMpJywgZmxhZ3MpO1xuICAgICAgd2hpbGUobWF0Y2ggPSBzZXBhcmF0b3JDb3B5LmV4ZWMoc3RyaW5nKSl7XG4gICAgICAgIC8vIGBzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleGAgaXMgbm90IHJlbGlhYmxlIGNyb3NzLWJyb3dzZXJcbiAgICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXVtMRU5HVEhdO1xuICAgICAgICBpZihsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KXtcbiAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYCBmb3IgTlBDR1xuICAgICAgICAgIGlmKCFOUENHICYmIG1hdGNoW0xFTkdUSF0gPiAxKW1hdGNoWzBdLnJlcGxhY2Uoc2VwYXJhdG9yMiwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGZvcihpID0gMTsgaSA8IGFyZ3VtZW50c1tMRU5HVEhdIC0gMjsgaSsrKWlmKGFyZ3VtZW50c1tpXSA9PT0gdW5kZWZpbmVkKW1hdGNoW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmKG1hdGNoW0xFTkdUSF0gPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nW0xFTkdUSF0pJHB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdW0xFTkdUSF07XG4gICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICBpZihvdXRwdXRbTEVOR1RIXSA+PSBzcGxpdExpbWl0KWJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmKHNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWF0gPT09IG1hdGNoLmluZGV4KXNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWF0rKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgfVxuICAgICAgaWYobGFzdExhc3RJbmRleCA9PT0gc3RyaW5nW0xFTkdUSF0pe1xuICAgICAgICBpZihsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3JDb3B5LnRlc3QoJycpKW91dHB1dC5wdXNoKCcnKTtcbiAgICAgIH0gZWxzZSBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCkpO1xuICAgICAgcmV0dXJuIG91dHB1dFtMRU5HVEhdID4gc3BsaXRMaW1pdCA/IG91dHB1dC5zbGljZSgwLCBzcGxpdExpbWl0KSA6IG91dHB1dDtcbiAgICB9O1xuICAvLyBDaGFrcmEsIFY4XG4gIH0gZWxzZSBpZignMCdbJFNQTElUXSh1bmRlZmluZWQsIDApW0xFTkdUSF0pe1xuICAgICRzcGxpdCA9IGZ1bmN0aW9uKHNlcGFyYXRvciwgbGltaXQpe1xuICAgICAgcmV0dXJuIHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwID8gW10gOiBfc3BsaXQuY2FsbCh0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9O1xuICB9XG4gIC8vIDIxLjEuMy4xNyBTdHJpbmcucHJvdG90eXBlLnNwbGl0KHNlcGFyYXRvciwgbGltaXQpXG4gIHJldHVybiBbZnVuY3Rpb24gc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCl7XG4gICAgdmFyIE8gID0gZGVmaW5lZCh0aGlzKVxuICAgICAgLCBmbiA9IHNlcGFyYXRvciA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZXBhcmF0b3JbU1BMSVRdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChzZXBhcmF0b3IsIE8sIGxpbWl0KSA6ICRzcGxpdC5jYWxsKFN0cmluZyhPKSwgc2VwYXJhdG9yLCBsaW1pdCk7XG4gIH0sICRzcGxpdF07XG59KTsiLCIndXNlIHN0cmljdCc7XG5yZXF1aXJlKCcuL2VzNi5yZWdleHAuZmxhZ3MnKTtcbnZhciBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgJGZsYWdzICAgICAgPSByZXF1aXJlKCcuL19mbGFncycpXG4gICwgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgVE9fU1RSSU5HICAgPSAndG9TdHJpbmcnXG4gICwgJHRvU3RyaW5nICAgPSAvLi9bVE9fU1RSSU5HXTtcblxudmFyIGRlZmluZSA9IGZ1bmN0aW9uKGZuKXtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShSZWdFeHAucHJvdG90eXBlLCBUT19TVFJJTkcsIGZuLCB0cnVlKTtcbn07XG5cbi8vIDIxLjIuNS4xNCBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nKClcbmlmKHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXsgcmV0dXJuICR0b1N0cmluZy5jYWxsKHtzb3VyY2U6ICdhJywgZmxhZ3M6ICdiJ30pICE9ICcvYS9iJzsgfSkpe1xuICBkZWZpbmUoZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICB2YXIgUiA9IGFuT2JqZWN0KHRoaXMpO1xuICAgIHJldHVybiAnLycuY29uY2F0KFIuc291cmNlLCAnLycsXG4gICAgICAnZmxhZ3MnIGluIFIgPyBSLmZsYWdzIDogIURFU0NSSVBUT1JTICYmIFIgaW5zdGFuY2VvZiBSZWdFeHAgPyAkZmxhZ3MuY2FsbChSKSA6IHVuZGVmaW5lZCk7XG4gIH0pO1xuLy8gRkY0NC0gUmVnRXhwI3RvU3RyaW5nIGhhcyBhIHdyb25nIG5hbWVcbn0gZWxzZSBpZigkdG9TdHJpbmcubmFtZSAhPSBUT19TVFJJTkcpe1xuICBkZWZpbmUoZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICByZXR1cm4gJHRvU3RyaW5nLmNhbGwodGhpcyk7XG4gIH0pO1xufSIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXN0cm9uZycpO1xuXG4vLyAyMy4yIFNldCBPYmplY3RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKSgnU2V0JywgZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFNldCgpeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMi4zLjEgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKXtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih0aGlzLCB2YWx1ZSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlLCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZyk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMiBTdHJpbmcucHJvdG90eXBlLmFuY2hvcihuYW1lKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYW5jaG9yJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBhbmNob3IobmFtZSl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2EnLCAnbmFtZScsIG5hbWUpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4zIFN0cmluZy5wcm90b3R5cGUuYmlnKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JpZycsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gYmlnKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2JpZycsICcnLCAnJyk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjQgU3RyaW5nLnByb3RvdHlwZS5ibGluaygpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdibGluaycsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gYmxpbmsoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYmxpbmsnLCAnJywgJycpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy41IFN0cmluZy5wcm90b3R5cGUuYm9sZCgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdib2xkJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBib2xkKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2InLCAnJywgJycpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGF0ICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKGZhbHNlKTtcbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjMuMyBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0KHBvcylcbiAgY29kZVBvaW50QXQ6IGZ1bmN0aW9uIGNvZGVQb2ludEF0KHBvcyl7XG4gICAgcmV0dXJuICRhdCh0aGlzLCBwb3MpO1xuICB9XG59KTsiLCIvLyAyMS4xLjMuNiBTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoKHNlYXJjaFN0cmluZyBbLCBlbmRQb3NpdGlvbl0pXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGNvbnRleHQgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0JylcbiAgLCBFTkRTX1dJVEggPSAnZW5kc1dpdGgnXG4gICwgJGVuZHNXaXRoID0gJydbRU5EU19XSVRIXTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShFTkRTX1dJVEgpLCAnU3RyaW5nJywge1xuICBlbmRzV2l0aDogZnVuY3Rpb24gZW5kc1dpdGgoc2VhcmNoU3RyaW5nIC8qLCBlbmRQb3NpdGlvbiA9IEBsZW5ndGggKi8pe1xuICAgIHZhciB0aGF0ID0gY29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIEVORFNfV0lUSClcbiAgICAgICwgZW5kUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZFxuICAgICAgLCBsZW4gICAgPSB0b0xlbmd0aCh0aGF0Lmxlbmd0aClcbiAgICAgICwgZW5kICAgID0gZW5kUG9zaXRpb24gPT09IHVuZGVmaW5lZCA/IGxlbiA6IE1hdGgubWluKHRvTGVuZ3RoKGVuZFBvc2l0aW9uKSwgbGVuKVxuICAgICAgLCBzZWFyY2ggPSBTdHJpbmcoc2VhcmNoU3RyaW5nKTtcbiAgICByZXR1cm4gJGVuZHNXaXRoXG4gICAgICA/ICRlbmRzV2l0aC5jYWxsKHRoYXQsIHNlYXJjaCwgZW5kKVxuICAgICAgOiB0aGF0LnNsaWNlKGVuZCAtIHNlYXJjaC5sZW5ndGgsIGVuZCkgPT09IHNlYXJjaDtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNiBTdHJpbmcucHJvdG90eXBlLmZpeGVkKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZpeGVkJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBmaXhlZCgpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICd0dCcsICcnLCAnJyk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjcgU3RyaW5nLnByb3RvdHlwZS5mb250Y29sb3IoY29sb3IpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdmb250Y29sb3InLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbnRjb2xvcihjb2xvcil7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2ZvbnQnLCAnY29sb3InLCBjb2xvcik7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjggU3RyaW5nLnByb3RvdHlwZS5mb250c2l6ZShzaXplKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnZm9udHNpemUnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbnRzaXplKHNpemUpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdmb250JywgJ3NpemUnLCBzaXplKTtcbiAgfVxufSk7IiwidmFyICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0luZGV4ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4JylcbiAgLCBmcm9tQ2hhckNvZGUgICA9IFN0cmluZy5mcm9tQ2hhckNvZGVcbiAgLCAkZnJvbUNvZGVQb2ludCA9IFN0cmluZy5mcm9tQ29kZVBvaW50O1xuXG4vLyBsZW5ndGggc2hvdWxkIGJlIDEsIG9sZCBGRiBwcm9ibGVtXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghISRmcm9tQ29kZVBvaW50ICYmICRmcm9tQ29kZVBvaW50Lmxlbmd0aCAhPSAxKSwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4yLjIgU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY29kZVBvaW50cylcbiAgZnJvbUNvZGVQb2ludDogZnVuY3Rpb24gZnJvbUNvZGVQb2ludCh4KXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciByZXMgID0gW11cbiAgICAgICwgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgaSAgICA9IDBcbiAgICAgICwgY29kZTtcbiAgICB3aGlsZShhTGVuID4gaSl7XG4gICAgICBjb2RlID0gK2FyZ3VtZW50c1tpKytdO1xuICAgICAgaWYodG9JbmRleChjb2RlLCAweDEwZmZmZikgIT09IGNvZGUpdGhyb3cgUmFuZ2VFcnJvcihjb2RlICsgJyBpcyBub3QgYSB2YWxpZCBjb2RlIHBvaW50Jyk7XG4gICAgICByZXMucHVzaChjb2RlIDwgMHgxMDAwMFxuICAgICAgICA/IGZyb21DaGFyQ29kZShjb2RlKVxuICAgICAgICA6IGZyb21DaGFyQ29kZSgoKGNvZGUgLT0gMHgxMDAwMCkgPj4gMTApICsgMHhkODAwLCBjb2RlICUgMHg0MDAgKyAweGRjMDApXG4gICAgICApO1xuICAgIH0gcmV0dXJuIHJlcy5qb2luKCcnKTtcbiAgfVxufSk7IiwiLy8gMjEuMS4zLjcgU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlcyhzZWFyY2hTdHJpbmcsIHBvc2l0aW9uID0gMClcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY29udGV4dCAgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpXG4gICwgSU5DTFVERVMgPSAnaW5jbHVkZXMnO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKElOQ0xVREVTKSwgJ1N0cmluZycsIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaFN0cmluZyAvKiwgcG9zaXRpb24gPSAwICovKXtcbiAgICByZXR1cm4gISF+Y29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIElOQ0xVREVTKVxuICAgICAgLmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjkgU3RyaW5nLnByb3RvdHlwZS5pdGFsaWNzKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2l0YWxpY3MnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGl0YWxpY3MoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnaScsICcnLCAnJyk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjEwIFN0cmluZy5wcm90b3R5cGUubGluayh1cmwpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdsaW5rJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBsaW5rKHVybCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2EnLCAnaHJlZicsIHVybCk7XG4gIH1cbn0pOyIsInZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvTGVuZ3RoICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4yLjQgU3RyaW5nLnJhdyhjYWxsU2l0ZSwgLi4uc3Vic3RpdHV0aW9ucylcbiAgcmF3OiBmdW5jdGlvbiByYXcoY2FsbFNpdGUpe1xuICAgIHZhciB0cGwgID0gdG9JT2JqZWN0KGNhbGxTaXRlLnJhdylcbiAgICAgICwgbGVuICA9IHRvTGVuZ3RoKHRwbC5sZW5ndGgpXG4gICAgICAsIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIHJlcyAgPSBbXVxuICAgICAgLCBpICAgID0gMDtcbiAgICB3aGlsZShsZW4gPiBpKXtcbiAgICAgIHJlcy5wdXNoKFN0cmluZyh0cGxbaSsrXSkpO1xuICAgICAgaWYoaSA8IGFMZW4pcmVzLnB1c2goU3RyaW5nKGFyZ3VtZW50c1tpXSkpO1xuICAgIH0gcmV0dXJuIHJlcy5qb2luKCcnKTtcbiAgfVxufSk7IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMy4xMyBTdHJpbmcucHJvdG90eXBlLnJlcGVhdChjb3VudClcbiAgcmVwZWF0OiByZXF1aXJlKCcuL19zdHJpbmctcmVwZWF0Jylcbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjExIFN0cmluZy5wcm90b3R5cGUuc21hbGwoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc21hbGwnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNtYWxsKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3NtYWxsJywgJycsICcnKTtcbiAgfVxufSk7IiwiLy8gMjEuMS4zLjE4IFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgWywgcG9zaXRpb24gXSlcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9MZW5ndGggICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGNvbnRleHQgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKVxuICAsIFNUQVJUU19XSVRIID0gJ3N0YXJ0c1dpdGgnXG4gICwgJHN0YXJ0c1dpdGggPSAnJ1tTVEFSVFNfV0lUSF07XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoU1RBUlRTX1dJVEgpLCAnU3RyaW5nJywge1xuICBzdGFydHNXaXRoOiBmdW5jdGlvbiBzdGFydHNXaXRoKHNlYXJjaFN0cmluZyAvKiwgcG9zaXRpb24gPSAwICovKXtcbiAgICB2YXIgdGhhdCAgID0gY29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIFNUQVJUU19XSVRIKVxuICAgICAgLCBpbmRleCAgPSB0b0xlbmd0aChNYXRoLm1pbihhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgdGhhdC5sZW5ndGgpKVxuICAgICAgLCBzZWFyY2ggPSBTdHJpbmcoc2VhcmNoU3RyaW5nKTtcbiAgICByZXR1cm4gJHN0YXJ0c1dpdGhcbiAgICAgID8gJHN0YXJ0c1dpdGguY2FsbCh0aGF0LCBzZWFyY2gsIGluZGV4KVxuICAgICAgOiB0aGF0LnNsaWNlKGluZGV4LCBpbmRleCArIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjEyIFN0cmluZy5wcm90b3R5cGUuc3RyaWtlKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3N0cmlrZScsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gc3RyaWtlKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3N0cmlrZScsICcnLCAnJyk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjEzIFN0cmluZy5wcm90b3R5cGUuc3ViKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3N1YicsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gc3ViKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3N1YicsICcnLCAnJyk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjE0IFN0cmluZy5wcm90b3R5cGUuc3VwKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3N1cCcsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gc3VwKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3N1cCcsICcnLCAnJyk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIDIxLjEuMy4yNSBTdHJpbmcucHJvdG90eXBlLnRyaW0oKVxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbScsIGZ1bmN0aW9uKCR0cmltKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRyaW0oKXtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMyk7XG4gIH07XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkdHlwZWQgICAgICAgPSByZXF1aXJlKCcuL190eXBlZCcpXG4gICwgYnVmZmVyICAgICAgID0gcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJylcbiAgLCBhbk9iamVjdCAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvSW5kZXggICAgICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4JylcbiAgLCB0b0xlbmd0aCAgICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGlzT2JqZWN0ICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgQXJyYXlCdWZmZXIgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuQXJyYXlCdWZmZXJcbiAgLCBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJylcbiAgLCAkQXJyYXlCdWZmZXIgPSBidWZmZXIuQXJyYXlCdWZmZXJcbiAgLCAkRGF0YVZpZXcgICAgPSBidWZmZXIuRGF0YVZpZXdcbiAgLCAkaXNWaWV3ICAgICAgPSAkdHlwZWQuQUJWICYmIEFycmF5QnVmZmVyLmlzVmlld1xuICAsICRzbGljZSAgICAgICA9ICRBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2VcbiAgLCBWSUVXICAgICAgICAgPSAkdHlwZWQuVklFV1xuICAsIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEFycmF5QnVmZmVyICE9PSAkQXJyYXlCdWZmZXIpLCB7QXJyYXlCdWZmZXI6ICRBcnJheUJ1ZmZlcn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEkdHlwZWQuQ09OU1RSLCBBUlJBWV9CVUZGRVIsIHtcbiAgLy8gMjQuMS4zLjEgQXJyYXlCdWZmZXIuaXNWaWV3KGFyZylcbiAgaXNWaWV3OiBmdW5jdGlvbiBpc1ZpZXcoaXQpe1xuICAgIHJldHVybiAkaXNWaWV3ICYmICRpc1ZpZXcoaXQpIHx8IGlzT2JqZWN0KGl0KSAmJiBWSUVXIGluIGl0O1xuICB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlUgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiAhbmV3ICRBcnJheUJ1ZmZlcigyKS5zbGljZSgxLCB1bmRlZmluZWQpLmJ5dGVMZW5ndGg7XG59KSwgQVJSQVlfQlVGRkVSLCB7XG4gIC8vIDI0LjEuNC4zIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZShzdGFydCwgZW5kKVxuICBzbGljZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCl7XG4gICAgaWYoJHNsaWNlICE9PSB1bmRlZmluZWQgJiYgZW5kID09PSB1bmRlZmluZWQpcmV0dXJuICRzbGljZS5jYWxsKGFuT2JqZWN0KHRoaXMpLCBzdGFydCk7IC8vIEZGIGZpeFxuICAgIHZhciBsZW4gICAgPSBhbk9iamVjdCh0aGlzKS5ieXRlTGVuZ3RoXG4gICAgICAsIGZpcnN0ICA9IHRvSW5kZXgoc3RhcnQsIGxlbilcbiAgICAgICwgZmluYWwgID0gdG9JbmRleChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IGVuZCwgbGVuKVxuICAgICAgLCByZXN1bHQgPSBuZXcgKHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkQXJyYXlCdWZmZXIpKSh0b0xlbmd0aChmaW5hbCAtIGZpcnN0KSlcbiAgICAgICwgdmlld1MgID0gbmV3ICREYXRhVmlldyh0aGlzKVxuICAgICAgLCB2aWV3VCAgPSBuZXcgJERhdGFWaWV3KHJlc3VsdClcbiAgICAgICwgaW5kZXggID0gMDtcbiAgICB3aGlsZShmaXJzdCA8IGZpbmFsKXtcbiAgICAgIHZpZXdULnNldFVpbnQ4KGluZGV4KyssIHZpZXdTLmdldFVpbnQ4KGZpcnN0KyspKTtcbiAgICB9IHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKEFSUkFZX0JVRkZFUik7IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3R5cGVkJykuQUJWLCB7XG4gIERhdGFWaWV3OiByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKS5EYXRhVmlld1xufSk7IiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnRmxvYXQzMicsIDQsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gRmxvYXQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pOyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0Zsb2F0NjQnLCA4LCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIEZsb2F0NjRBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTsiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQxNicsIDIsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gSW50MTZBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTsiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQzMicsIDQsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gSW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTsiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQ4JywgMSwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQ4QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7IiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDE2JywgMiwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50MTZBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTsiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50MzInLCA0LCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pOyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQ4JywgMSwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50OEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pOyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQ4JywgMSwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50OENsYW1wZWRBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59LCB0cnVlKTsiLCIndXNlIHN0cmljdCc7XG52YXIgZWFjaCAgICAgICAgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApXG4gICwgcmVkZWZpbmUgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIG1ldGEgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKVxuICAsIGFzc2lnbiAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKVxuICAsIHdlYWsgICAgICAgICA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24td2VhaycpXG4gICwgaXNPYmplY3QgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBnZXRXZWFrICAgICAgPSBtZXRhLmdldFdlYWtcbiAgLCBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlXG4gICwgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IHdlYWsudWZzdG9yZVxuICAsIHRtcCAgICAgICAgICA9IHt9XG4gICwgSW50ZXJuYWxNYXA7XG5cbnZhciB3cmFwcGVyID0gZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtNYXAoKXtcbiAgICByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgfTtcbn07XG5cbnZhciBtZXRob2RzID0ge1xuICAvLyAyMy4zLjMuMyBXZWFrTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpe1xuICAgIGlmKGlzT2JqZWN0KGtleSkpe1xuICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICBpZihkYXRhID09PSB0cnVlKXJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHRoaXMpLmdldChrZXkpO1xuICAgICAgcmV0dXJuIGRhdGEgPyBkYXRhW3RoaXMuX2ldIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfSxcbiAgLy8gMjMuMy4zLjUgV2Vha01hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpe1xuICAgIHJldHVybiB3ZWFrLmRlZih0aGlzLCBrZXksIHZhbHVlKTtcbiAgfVxufTtcblxuLy8gMjMuMyBXZWFrTWFwIE9iamVjdHNcbnZhciAkV2Vha01hcCA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKCdXZWFrTWFwJywgd3JhcHBlciwgbWV0aG9kcywgd2VhaywgdHJ1ZSwgdHJ1ZSk7XG5cbi8vIElFMTEgV2Vha01hcCBmcm96ZW4ga2V5cyBmaXhcbmlmKG5ldyAkV2Vha01hcCgpLnNldCgoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHRtcCksIDcpLmdldCh0bXApICE9IDcpe1xuICBJbnRlcm5hbE1hcCA9IHdlYWsuZ2V0Q29uc3RydWN0b3Iod3JhcHBlcik7XG4gIGFzc2lnbihJbnRlcm5hbE1hcC5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICBtZXRhLk5FRUQgPSB0cnVlO1xuICBlYWNoKFsnZGVsZXRlJywgJ2hhcycsICdnZXQnLCAnc2V0J10sIGZ1bmN0aW9uKGtleSl7XG4gICAgdmFyIHByb3RvICA9ICRXZWFrTWFwLnByb3RvdHlwZVxuICAgICAgLCBtZXRob2QgPSBwcm90b1trZXldO1xuICAgIHJlZGVmaW5lKHByb3RvLCBrZXksIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgLy8gc3RvcmUgZnJvemVuIG9iamVjdHMgb24gaW50ZXJuYWwgd2Vha21hcCBzaGltXG4gICAgICBpZihpc09iamVjdChhKSAmJiAhaXNFeHRlbnNpYmxlKGEpKXtcbiAgICAgICAgaWYoIXRoaXMuX2YpdGhpcy5fZiA9IG5ldyBJbnRlcm5hbE1hcDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2Zba2V5XShhLCBiKTtcbiAgICAgICAgcmV0dXJuIGtleSA9PSAnc2V0JyA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICAvLyBzdG9yZSBhbGwgdGhlIHJlc3Qgb24gbmF0aXZlIHdlYWttYXBcbiAgICAgIH0gcmV0dXJuIG1ldGhvZC5jYWxsKHRoaXMsIGEsIGIpO1xuICAgIH0pO1xuICB9KTtcbn0iLCIndXNlIHN0cmljdCc7XG52YXIgd2VhayA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24td2VhaycpO1xuXG4vLyAyMy40IFdlYWtTZXQgT2JqZWN0c1xucmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKCdXZWFrU2V0JywgZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtTZXQoKXsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjQuMy4xIFdlYWtTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpe1xuICAgIHJldHVybiB3ZWFrLmRlZih0aGlzLCB2YWx1ZSwgdHJ1ZSk7XG4gIH1cbn0sIHdlYWssIGZhbHNlLCB0cnVlKTsiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9BcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRpbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhlbCAvKiwgZnJvbUluZGV4ID0gMCAqLyl7XG4gICAgcmV0dXJuICRpbmNsdWRlcyh0aGlzLCBlbCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2luY2x1ZGVzJyk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3J3YWxkcm9uL3RjMzktbm90ZXMvYmxvYi9tYXN0ZXIvZXM2LzIwMTQtMDkvc2VwdC0yNS5tZCM1MTAtZ2xvYmFsYXNhcC1mb3ItZW5xdWV1aW5nLWEtbWljcm90YXNrXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBtaWNyb3Rhc2sgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpXG4gICwgcHJvY2VzcyAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykucHJvY2Vzc1xuICAsIGlzTm9kZSAgICA9IHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJztcblxuJGV4cG9ydCgkZXhwb3J0LkcsIHtcbiAgYXNhcDogZnVuY3Rpb24gYXNhcChmbil7XG4gICAgdmFyIGRvbWFpbiA9IGlzTm9kZSAmJiBwcm9jZXNzLmRvbWFpbjtcbiAgICBtaWNyb3Rhc2soZG9tYWluID8gZG9tYWluLmJpbmQoZm4pIDogZm4pO1xuICB9XG59KTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL3Byb3Bvc2FsLWlzLWVycm9yXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY29mICAgICA9IHJlcXVpcmUoJy4vX2NvZicpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ0Vycm9yJywge1xuICBpc0Vycm9yOiBmdW5jdGlvbiBpc0Vycm9yKGl0KXtcbiAgICByZXR1cm4gY29mKGl0KSA9PT0gJ0Vycm9yJztcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnTWFwJywge3RvSlNPTjogcmVxdWlyZSgnLi9fY29sbGVjdGlvbi10by1qc29uJykoJ01hcCcpfSk7IiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vQnJlbmRhbkVpY2gvNDI5NGQ1YzIxMmE2ZDIyNTQ3MDNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaWFkZGg6IGZ1bmN0aW9uIGlhZGRoKHgwLCB4MSwgeTAsIHkxKXtcbiAgICB2YXIgJHgwID0geDAgPj4+IDBcbiAgICAgICwgJHgxID0geDEgPj4+IDBcbiAgICAgICwgJHkwID0geTAgPj4+IDA7XG4gICAgcmV0dXJuICR4MSArICh5MSA+Pj4gMCkgKyAoKCR4MCAmICR5MCB8ICgkeDAgfCAkeTApICYgfigkeDAgKyAkeTAgPj4+IDApKSA+Pj4gMzEpIHwgMDtcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vQnJlbmRhbkVpY2gvNDI5NGQ1YzIxMmE2ZDIyNTQ3MDNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaW11bGg6IGZ1bmN0aW9uIGltdWxoKHUsIHYpe1xuICAgIHZhciBVSU5UMTYgPSAweGZmZmZcbiAgICAgICwgJHUgPSArdVxuICAgICAgLCAkdiA9ICt2XG4gICAgICAsIHUwID0gJHUgJiBVSU5UMTZcbiAgICAgICwgdjAgPSAkdiAmIFVJTlQxNlxuICAgICAgLCB1MSA9ICR1ID4+IDE2XG4gICAgICAsIHYxID0gJHYgPj4gMTZcbiAgICAgICwgdCAgPSAodTEgKiB2MCA+Pj4gMCkgKyAodTAgKiB2MCA+Pj4gMTYpO1xuICAgIHJldHVybiB1MSAqIHYxICsgKHQgPj4gMTYpICsgKCh1MCAqIHYxID4+PiAwKSArICh0ICYgVUlOVDE2KSA+PiAxNik7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGlzdWJoOiBmdW5jdGlvbiBpc3ViaCh4MCwgeDEsIHkwLCB5MSl7XG4gICAgdmFyICR4MCA9IHgwID4+PiAwXG4gICAgICAsICR4MSA9IHgxID4+PiAwXG4gICAgICAsICR5MCA9IHkwID4+PiAwO1xuICAgIHJldHVybiAkeDEgLSAoeTEgPj4+IDApIC0gKCh+JHgwICYgJHkwIHwgfigkeDAgXiAkeTApICYgJHgwIC0gJHkwID4+PiAwKSA+Pj4gMzEpIHwgMDtcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vQnJlbmRhbkVpY2gvNDI5NGQ1YzIxMmE2ZDIyNTQ3MDNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdW11bGg6IGZ1bmN0aW9uIHVtdWxoKHUsIHYpe1xuICAgIHZhciBVSU5UMTYgPSAweGZmZmZcbiAgICAgICwgJHUgPSArdVxuICAgICAgLCAkdiA9ICt2XG4gICAgICAsIHUwID0gJHUgJiBVSU5UMTZcbiAgICAgICwgdjAgPSAkdiAmIFVJTlQxNlxuICAgICAgLCB1MSA9ICR1ID4+PiAxNlxuICAgICAgLCB2MSA9ICR2ID4+PiAxNlxuICAgICAgLCB0ICA9ICh1MSAqIHYwID4+PiAwKSArICh1MCAqIHYwID4+PiAxNik7XG4gICAgcmV0dXJuIHUxICogdjEgKyAodCA+Pj4gMTYpICsgKCh1MCAqIHYxID4+PiAwKSArICh0ICYgVUlOVDE2KSA+Pj4gMTYpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiAgICAgICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuXG4vLyBCLjIuMi4yIE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXyhQLCBnZXR0ZXIpXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19kZWZpbmVHZXR0ZXJfXzogZnVuY3Rpb24gX19kZWZpbmVHZXR0ZXJfXyhQLCBnZXR0ZXIpe1xuICAgICRkZWZpbmVQcm9wZXJ0eS5mKHRvT2JqZWN0KHRoaXMpLCBQLCB7Z2V0OiBhRnVuY3Rpb24oZ2V0dGVyKSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uICAgICAgID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG5cbi8vIEIuMi4yLjMgT2JqZWN0LnByb3RvdHlwZS5fX2RlZmluZVNldHRlcl9fKFAsIHNldHRlcilcbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2RlZmluZVNldHRlcl9fOiBmdW5jdGlvbiBfX2RlZmluZVNldHRlcl9fKFAsIHNldHRlcil7XG4gICAgJGRlZmluZVByb3BlcnR5LmYodG9PYmplY3QodGhpcyksIFAsIHtzZXQ6IGFGdW5jdGlvbihzZXR0ZXIpLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9KTtcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LXZhbHVlcy1lbnRyaWVzXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRlbnRyaWVzID0gcmVxdWlyZSgnLi9fb2JqZWN0LXRvLWFycmF5JykodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKGl0KXtcbiAgICByZXR1cm4gJGVudHJpZXMoaXQpO1xuICB9XG59KTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yc1xudmFyICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBvd25LZXlzICAgICAgICA9IHJlcXVpcmUoJy4vX293bi1rZXlzJylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGdPUEQgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iamVjdCl7XG4gICAgdmFyIE8gICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICAgLCBnZXREZXNjID0gZ09QRC5mXG4gICAgICAsIGtleXMgICAgPSBvd25LZXlzKE8pXG4gICAgICAsIHJlc3VsdCAgPSB7fVxuICAgICAgLCBpICAgICAgID0gMFxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUoa2V5cy5sZW5ndGggPiBpKWNyZWF0ZVByb3BlcnR5KHJlc3VsdCwga2V5ID0ga2V5c1tpKytdLCBnZXREZXNjKE8sIGtleSkpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvT2JqZWN0ICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBnZXRQcm90b3R5cGVPZiAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG5cbi8vIEIuMi4yLjQgT2JqZWN0LnByb3RvdHlwZS5fX2xvb2t1cEdldHRlcl9fKFApXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19sb29rdXBHZXR0ZXJfXzogZnVuY3Rpb24gX19sb29rdXBHZXR0ZXJfXyhQKXtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpXG4gICAgICAsIEsgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKVxuICAgICAgLCBEO1xuICAgIGRvIHtcbiAgICAgIGlmKEQgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgSykpcmV0dXJuIEQuZ2V0O1xuICAgIH0gd2hpbGUoTyA9IGdldFByb3RvdHlwZU9mKE8pKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGdldFByb3RvdHlwZU9mICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxuLy8gQi4yLjIuNSBPYmplY3QucHJvdG90eXBlLl9fbG9va3VwU2V0dGVyX18oUClcbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2xvb2t1cFNldHRlcl9fOiBmdW5jdGlvbiBfX2xvb2t1cFNldHRlcl9fKFApe1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcylcbiAgICAgICwgSyA9IHRvUHJpbWl0aXZlKFAsIHRydWUpXG4gICAgICAsIEQ7XG4gICAgZG8ge1xuICAgICAgaWYoRCA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBLKSlyZXR1cm4gRC5zZXQ7XG4gICAgfSB3aGlsZShPID0gZ2V0UHJvdG90eXBlT2YoTykpO1xuICB9XG59KTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtdmFsdWVzLWVudHJpZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkdmFsdWVzID0gcmVxdWlyZSgnLi9fb2JqZWN0LXRvLWFycmF5JykoZmFsc2UpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoaXQpe1xuICAgIHJldHVybiAkdmFsdWVzKGl0KTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3plbnBhcnNpbmcvZXMtb2JzZXJ2YWJsZVxudmFyICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBnbG9iYWwgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBtaWNyb3Rhc2sgICA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKClcbiAgLCBPQlNFUlZBQkxFICA9IHJlcXVpcmUoJy4vX3drcycpKCdvYnNlcnZhYmxlJylcbiAgLCBhRnVuY3Rpb24gICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBhbkluc3RhbmNlICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpXG4gICwgaGlkZSAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBmb3JPZiAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgUkVUVVJOICAgICAgPSBmb3JPZi5SRVRVUk47XG5cbnZhciBnZXRNZXRob2QgPSBmdW5jdGlvbihmbil7XG4gIHJldHVybiBmbiA9PSBudWxsID8gdW5kZWZpbmVkIDogYUZ1bmN0aW9uKGZuKTtcbn07XG5cbnZhciBjbGVhbnVwU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24oc3Vic2NyaXB0aW9uKXtcbiAgdmFyIGNsZWFudXAgPSBzdWJzY3JpcHRpb24uX2M7XG4gIGlmKGNsZWFudXApe1xuICAgIHN1YnNjcmlwdGlvbi5fYyA9IHVuZGVmaW5lZDtcbiAgICBjbGVhbnVwKCk7XG4gIH1cbn07XG5cbnZhciBzdWJzY3JpcHRpb25DbG9zZWQgPSBmdW5jdGlvbihzdWJzY3JpcHRpb24pe1xuICByZXR1cm4gc3Vic2NyaXB0aW9uLl9vID09PSB1bmRlZmluZWQ7XG59O1xuXG52YXIgY2xvc2VTdWJzY3JpcHRpb24gPSBmdW5jdGlvbihzdWJzY3JpcHRpb24pe1xuICBpZighc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpe1xuICAgIHN1YnNjcmlwdGlvbi5fbyA9IHVuZGVmaW5lZDtcbiAgICBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gIH1cbn07XG5cbnZhciBTdWJzY3JpcHRpb24gPSBmdW5jdGlvbihvYnNlcnZlciwgc3Vic2NyaWJlcil7XG4gIGFuT2JqZWN0KG9ic2VydmVyKTtcbiAgdGhpcy5fYyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fbyA9IG9ic2VydmVyO1xuICBvYnNlcnZlciA9IG5ldyBTdWJzY3JpcHRpb25PYnNlcnZlcih0aGlzKTtcbiAgdHJ5IHtcbiAgICB2YXIgY2xlYW51cCAgICAgID0gc3Vic2NyaWJlcihvYnNlcnZlcilcbiAgICAgICwgc3Vic2NyaXB0aW9uID0gY2xlYW51cDtcbiAgICBpZihjbGVhbnVwICE9IG51bGwpe1xuICAgICAgaWYodHlwZW9mIGNsZWFudXAudW5zdWJzY3JpYmUgPT09ICdmdW5jdGlvbicpY2xlYW51cCA9IGZ1bmN0aW9uKCl7IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpOyB9O1xuICAgICAgZWxzZSBhRnVuY3Rpb24oY2xlYW51cCk7XG4gICAgICB0aGlzLl9jID0gY2xlYW51cDtcbiAgICB9XG4gIH0gY2F0Y2goZSl7XG4gICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgcmV0dXJuO1xuICB9IGlmKHN1YnNjcmlwdGlvbkNsb3NlZCh0aGlzKSljbGVhbnVwU3Vic2NyaXB0aW9uKHRoaXMpO1xufTtcblxuU3Vic2NyaXB0aW9uLnByb3RvdHlwZSA9IHJlZGVmaW5lQWxsKHt9LCB7XG4gIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpeyBjbG9zZVN1YnNjcmlwdGlvbih0aGlzKTsgfVxufSk7XG5cbnZhciBTdWJzY3JpcHRpb25PYnNlcnZlciA9IGZ1bmN0aW9uKHN1YnNjcmlwdGlvbil7XG4gIHRoaXMuX3MgPSBzdWJzY3JpcHRpb247XG59O1xuXG5TdWJzY3JpcHRpb25PYnNlcnZlci5wcm90b3R5cGUgPSByZWRlZmluZUFsbCh7fSwge1xuICBuZXh0OiBmdW5jdGlvbiBuZXh0KHZhbHVlKXtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5fcztcbiAgICBpZighc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpe1xuICAgICAgdmFyIG9ic2VydmVyID0gc3Vic2NyaXB0aW9uLl9vO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIubmV4dCk7XG4gICAgICAgIGlmKG0pcmV0dXJuIG0uY2FsbChvYnNlcnZlciwgdmFsdWUpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjbG9zZVN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGVycm9yOiBmdW5jdGlvbiBlcnJvcih2YWx1ZSl7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XG4gICAgaWYoc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpdGhyb3cgdmFsdWU7XG4gICAgdmFyIG9ic2VydmVyID0gc3Vic2NyaXB0aW9uLl9vO1xuICAgIHN1YnNjcmlwdGlvbi5fbyA9IHVuZGVmaW5lZDtcbiAgICB0cnkge1xuICAgICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIuZXJyb3IpO1xuICAgICAgaWYoIW0pdGhyb3cgdmFsdWU7XG4gICAgICB2YWx1ZSA9IG0uY2FsbChvYnNlcnZlciwgdmFsdWUpO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICB0cnkge1xuICAgICAgICBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHZhbHVlKXtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5fcztcbiAgICBpZighc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpe1xuICAgICAgdmFyIG9ic2VydmVyID0gc3Vic2NyaXB0aW9uLl9vO1xuICAgICAgc3Vic2NyaXB0aW9uLl9vID0gdW5kZWZpbmVkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIuY29tcGxldGUpO1xuICAgICAgICB2YWx1ZSA9IG0gPyBtLmNhbGwob2JzZXJ2ZXIsIHZhbHVlKSA6IHVuZGVmaW5lZDtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH0gY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufSk7XG5cbnZhciAkT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIE9ic2VydmFibGUoc3Vic2NyaWJlcil7XG4gIGFuSW5zdGFuY2UodGhpcywgJE9ic2VydmFibGUsICdPYnNlcnZhYmxlJywgJ19mJykuX2YgPSBhRnVuY3Rpb24oc3Vic2NyaWJlcik7XG59O1xuXG5yZWRlZmluZUFsbCgkT2JzZXJ2YWJsZS5wcm90b3R5cGUsIHtcbiAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUob2JzZXJ2ZXIpe1xuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uKG9ic2VydmVyLCB0aGlzLl9mKTtcbiAgfSxcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChmbil7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgKGNvcmUuUHJvbWlzZSB8fCBnbG9iYWwuUHJvbWlzZSkoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgIGFGdW5jdGlvbihmbik7XG4gICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhhdC5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0IDogZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4odmFsdWUpO1xuICAgICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiByZWplY3QsXG4gICAgICAgIGNvbXBsZXRlOiByZXNvbHZlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbnJlZGVmaW5lQWxsKCRPYnNlcnZhYmxlLCB7XG4gIGZyb206IGZ1bmN0aW9uIGZyb20oeCl7XG4gICAgdmFyIEMgPSB0eXBlb2YgdGhpcyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiAkT2JzZXJ2YWJsZTtcbiAgICB2YXIgbWV0aG9kID0gZ2V0TWV0aG9kKGFuT2JqZWN0KHgpW09CU0VSVkFCTEVdKTtcbiAgICBpZihtZXRob2Qpe1xuICAgICAgdmFyIG9ic2VydmFibGUgPSBhbk9iamVjdChtZXRob2QuY2FsbCh4KSk7XG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZS5jb25zdHJ1Y3RvciA9PT0gQyA/IG9ic2VydmFibGUgOiBuZXcgQyhmdW5jdGlvbihvYnNlcnZlcil7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlLnN1YnNjcmliZShvYnNlcnZlcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uKG9ic2VydmVyKXtcbiAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoIWRvbmUpe1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZihmb3JPZih4LCBmYWxzZSwgZnVuY3Rpb24oaXQpe1xuICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KGl0KTtcbiAgICAgICAgICAgICAgaWYoZG9uZSlyZXR1cm4gUkVUVVJOO1xuICAgICAgICAgICAgfSkgPT09IFJFVFVSTilyZXR1cm47XG4gICAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIGlmKGRvbmUpdGhyb3cgZTtcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKXsgZG9uZSA9IHRydWU7IH07XG4gICAgfSk7XG4gIH0sXG4gIG9mOiBmdW5jdGlvbiBvZigpe1xuICAgIGZvcih2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoLCBpdGVtcyA9IEFycmF5KGwpOyBpIDwgbDspaXRlbXNbaV0gPSBhcmd1bWVudHNbaSsrXTtcbiAgICByZXR1cm4gbmV3ICh0eXBlb2YgdGhpcyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiAkT2JzZXJ2YWJsZSkoZnVuY3Rpb24ob2JzZXJ2ZXIpe1xuICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbigpe1xuICAgICAgICBpZighZG9uZSl7XG4gICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoaXRlbXNbaV0pO1xuICAgICAgICAgICAgaWYoZG9uZSlyZXR1cm47XG4gICAgICAgICAgfSBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpeyBkb25lID0gdHJ1ZTsgfTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbmhpZGUoJE9ic2VydmFibGUucHJvdG90eXBlLCBPQlNFUlZBQkxFLCBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfSk7XG5cbiRleHBvcnQoJGV4cG9ydC5HLCB7T2JzZXJ2YWJsZTogJE9ic2VydmFibGV9KTtcblxucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKSgnT2JzZXJ2YWJsZScpOyIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXlcbiAgLCBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhID0gbWV0YWRhdGEuc2V0O1xuXG5tZXRhZGF0YS5leHAoe2RlZmluZU1ldGFkYXRhOiBmdW5jdGlvbiBkZWZpbmVNZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgdGFyZ2V0LCB0YXJnZXRLZXkpe1xuICBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCBhbk9iamVjdCh0YXJnZXQpLCB0b01ldGFLZXkodGFyZ2V0S2V5KSk7XG59fSk7IiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleVxuICAsIGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAgPSBtZXRhZGF0YS5tYXBcbiAgLCBzdG9yZSAgICAgICAgICAgICAgICAgID0gbWV0YWRhdGEuc3RvcmU7XG5cbm1ldGFkYXRhLmV4cCh7ZGVsZXRlTWV0YWRhdGE6IGZ1bmN0aW9uIGRlbGV0ZU1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyosIHRhcmdldEtleSAqLyl7XG4gIHZhciB0YXJnZXRLZXkgICA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSlcbiAgICAsIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChhbk9iamVjdCh0YXJnZXQpLCB0YXJnZXRLZXksIGZhbHNlKTtcbiAgaWYobWV0YWRhdGFNYXAgPT09IHVuZGVmaW5lZCB8fCAhbWV0YWRhdGFNYXBbJ2RlbGV0ZSddKG1ldGFkYXRhS2V5KSlyZXR1cm4gZmFsc2U7XG4gIGlmKG1ldGFkYXRhTWFwLnNpemUpcmV0dXJuIHRydWU7XG4gIHZhciB0YXJnZXRNZXRhZGF0YSA9IHN0b3JlLmdldCh0YXJnZXQpO1xuICB0YXJnZXRNZXRhZGF0YVsnZGVsZXRlJ10odGFyZ2V0S2V5KTtcbiAgcmV0dXJuICEhdGFyZ2V0TWV0YWRhdGEuc2l6ZSB8fCBzdG9yZVsnZGVsZXRlJ10odGFyZ2V0KTtcbn19KTsiLCJ2YXIgU2V0ICAgICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2VzNi5zZXQnKVxuICAsIGZyb20gICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYXJyYXktZnJvbS1pdGVyYWJsZScpXG4gICwgbWV0YWRhdGEgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGdldFByb3RvdHlwZU9mICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgb3JkaW5hcnlPd25NZXRhZGF0YUtleXMgPSBtZXRhZGF0YS5rZXlzXG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXk7XG5cbnZhciBvcmRpbmFyeU1ldGFkYXRhS2V5cyA9IGZ1bmN0aW9uKE8sIFApe1xuICB2YXIgb0tleXMgID0gb3JkaW5hcnlPd25NZXRhZGF0YUtleXMoTywgUClcbiAgICAsIHBhcmVudCA9IGdldFByb3RvdHlwZU9mKE8pO1xuICBpZihwYXJlbnQgPT09IG51bGwpcmV0dXJuIG9LZXlzO1xuICB2YXIgcEtleXMgID0gb3JkaW5hcnlNZXRhZGF0YUtleXMocGFyZW50LCBQKTtcbiAgcmV0dXJuIHBLZXlzLmxlbmd0aCA/IG9LZXlzLmxlbmd0aCA/IGZyb20obmV3IFNldChvS2V5cy5jb25jYXQocEtleXMpKSkgOiBwS2V5cyA6IG9LZXlzO1xufTtcblxubWV0YWRhdGEuZXhwKHtnZXRNZXRhZGF0YUtleXM6IGZ1bmN0aW9uIGdldE1ldGFkYXRhS2V5cyh0YXJnZXQgLyosIHRhcmdldEtleSAqLyl7XG4gIHJldHVybiBvcmRpbmFyeU1ldGFkYXRhS2V5cyhhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMV0pKTtcbn19KTsiLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBnZXRQcm90b3R5cGVPZiAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmhhc1xuICAsIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEgPSBtZXRhZGF0YS5nZXRcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG52YXIgb3JkaW5hcnlHZXRNZXRhZGF0YSA9IGZ1bmN0aW9uKE1ldGFkYXRhS2V5LCBPLCBQKXtcbiAgdmFyIGhhc093biA9IG9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICBpZihoYXNPd24pcmV0dXJuIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICB2YXIgcGFyZW50ID0gZ2V0UHJvdG90eXBlT2YoTyk7XG4gIHJldHVybiBwYXJlbnQgIT09IG51bGwgPyBvcmRpbmFyeUdldE1ldGFkYXRhKE1ldGFkYXRhS2V5LCBwYXJlbnQsIFApIDogdW5kZWZpbmVkO1xufTtcblxubWV0YWRhdGEuZXhwKHtnZXRNZXRhZGF0YTogZnVuY3Rpb24gZ2V0TWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgcmV0dXJuIG9yZGluYXJ5R2V0TWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufX0pOyIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgb3JkaW5hcnlPd25NZXRhZGF0YUtleXMgPSBtZXRhZGF0YS5rZXlzXG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXk7XG5cbm1ldGFkYXRhLmV4cCh7Z2V0T3duTWV0YWRhdGFLZXlzOiBmdW5jdGlvbiBnZXRPd25NZXRhZGF0YUtleXModGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICByZXR1cm4gb3JkaW5hcnlPd25NZXRhZGF0YUtleXMoYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDIgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzFdKSk7XG59fSk7IiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgb3JkaW5hcnlHZXRPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmdldFxuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXk7XG5cbm1ldGFkYXRhLmV4cCh7Z2V0T3duTWV0YWRhdGE6IGZ1bmN0aW9uIGdldE93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyosIHRhcmdldEtleSAqLyl7XG4gIHJldHVybiBvcmRpbmFyeUdldE93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpXG4gICAgLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn19KTsiLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBnZXRQcm90b3R5cGVPZiAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmhhc1xuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXk7XG5cbnZhciBvcmRpbmFyeUhhc01ldGFkYXRhID0gZnVuY3Rpb24oTWV0YWRhdGFLZXksIE8sIFApe1xuICB2YXIgaGFzT3duID0gb3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gIGlmKGhhc093bilyZXR1cm4gdHJ1ZTtcbiAgdmFyIHBhcmVudCA9IGdldFByb3RvdHlwZU9mKE8pO1xuICByZXR1cm4gcGFyZW50ICE9PSBudWxsID8gb3JkaW5hcnlIYXNNZXRhZGF0YShNZXRhZGF0YUtleSwgcGFyZW50LCBQKSA6IGZhbHNlO1xufTtcblxubWV0YWRhdGEuZXhwKHtoYXNNZXRhZGF0YTogZnVuY3Rpb24gaGFzTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgcmV0dXJuIG9yZGluYXJ5SGFzTWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufX0pOyIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5oYXNcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG5tZXRhZGF0YS5leHAoe2hhc093bk1ldGFkYXRhOiBmdW5jdGlvbiBoYXNPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICByZXR1cm4gb3JkaW5hcnlIYXNPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KVxuICAgICwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG59fSk7IiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXlcbiAgLCBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhID0gbWV0YWRhdGEuc2V0O1xuXG5tZXRhZGF0YS5leHAoe21ldGFkYXRhOiBmdW5jdGlvbiBtZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSl7XG4gIHJldHVybiBmdW5jdGlvbiBkZWNvcmF0b3IodGFyZ2V0LCB0YXJnZXRLZXkpe1xuICAgIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEoXG4gICAgICBtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSxcbiAgICAgICh0YXJnZXRLZXkgIT09IHVuZGVmaW5lZCA/IGFuT2JqZWN0IDogYUZ1bmN0aW9uKSh0YXJnZXQpLFxuICAgICAgdG9NZXRhS2V5KHRhcmdldEtleSlcbiAgICApO1xuICB9O1xufX0pOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ1NldCcsIHt0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdTZXQnKX0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5wcm90b3R5cGUuYXRcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkYXQgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBhdDogZnVuY3Rpb24gYXQocG9zKXtcbiAgICByZXR1cm4gJGF0KHRoaXMsIHBvcyk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vU3RyaW5nLnByb3RvdHlwZS5tYXRjaEFsbC9cbnZhciAkZXhwb3J0ICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZGVmaW5lZCAgICAgPSByZXF1aXJlKCcuL19kZWZpbmVkJylcbiAgLCB0b0xlbmd0aCAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgaXNSZWdFeHAgICAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKVxuICAsIGdldEZsYWdzICAgID0gcmVxdWlyZSgnLi9fZmxhZ3MnKVxuICAsIFJlZ0V4cFByb3RvID0gUmVnRXhwLnByb3RvdHlwZTtcblxudmFyICRSZWdFeHBTdHJpbmdJdGVyYXRvciA9IGZ1bmN0aW9uKHJlZ2V4cCwgc3RyaW5nKXtcbiAgdGhpcy5fciA9IHJlZ2V4cDtcbiAgdGhpcy5fcyA9IHN0cmluZztcbn07XG5cbnJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJykoJFJlZ0V4cFN0cmluZ0l0ZXJhdG9yLCAnUmVnRXhwIFN0cmluZycsIGZ1bmN0aW9uIG5leHQoKXtcbiAgdmFyIG1hdGNoID0gdGhpcy5fci5leGVjKHRoaXMuX3MpO1xuICByZXR1cm4ge3ZhbHVlOiBtYXRjaCwgZG9uZTogbWF0Y2ggPT09IG51bGx9O1xufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBtYXRjaEFsbDogZnVuY3Rpb24gbWF0Y2hBbGwocmVnZXhwKXtcbiAgICBkZWZpbmVkKHRoaXMpO1xuICAgIGlmKCFpc1JlZ0V4cChyZWdleHApKXRocm93IFR5cGVFcnJvcihyZWdleHAgKyAnIGlzIG5vdCBhIHJlZ2V4cCEnKTtcbiAgICB2YXIgUyAgICAgPSBTdHJpbmcodGhpcylcbiAgICAgICwgZmxhZ3MgPSAnZmxhZ3MnIGluIFJlZ0V4cFByb3RvID8gU3RyaW5nKHJlZ2V4cC5mbGFncykgOiBnZXRGbGFncy5jYWxsKHJlZ2V4cClcbiAgICAgICwgcnggICAgPSBuZXcgUmVnRXhwKHJlZ2V4cC5zb3VyY2UsIH5mbGFncy5pbmRleE9mKCdnJykgPyBmbGFncyA6ICdnJyArIGZsYWdzKTtcbiAgICByeC5sYXN0SW5kZXggPSB0b0xlbmd0aChyZWdleHAubGFzdEluZGV4KTtcbiAgICByZXR1cm4gbmV3ICRSZWdFeHBTdHJpbmdJdGVyYXRvcihyeCwgUyk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHBhZCAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1wYWQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIHBhZEVuZDogZnVuY3Rpb24gcGFkRW5kKG1heExlbmd0aCAvKiwgZmlsbFN0cmluZyA9ICcgJyAqLyl7XG4gICAgcmV0dXJuICRwYWQodGhpcywgbWF4TGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgZmFsc2UpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRwYWQgICAgPSByZXF1aXJlKCcuL19zdHJpbmctcGFkJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBwYWRTdGFydDogZnVuY3Rpb24gcGFkU3RhcnQobWF4TGVuZ3RoIC8qLCBmaWxsU3RyaW5nID0gJyAnICovKXtcbiAgICByZXR1cm4gJHBhZCh0aGlzLCBtYXhMZW5ndGgsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCB0cnVlKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NlYm1hcmtiYWdlL2VjbWFzY3JpcHQtc3RyaW5nLWxlZnQtcmlnaHQtdHJpbVxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbUxlZnQnLCBmdW5jdGlvbigkdHJpbSl7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltTGVmdCgpe1xuICAgIHJldHVybiAkdHJpbSh0aGlzLCAxKTtcbiAgfTtcbn0sICd0cmltU3RhcnQnKTsiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2VibWFya2JhZ2UvZWNtYXNjcmlwdC1zdHJpbmctbGVmdC1yaWdodC10cmltXG5yZXF1aXJlKCcuL19zdHJpbmctdHJpbScpKCd0cmltUmlnaHQnLCBmdW5jdGlvbigkdHJpbSl7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltUmlnaHQoKXtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMik7XG4gIH07XG59LCAndHJpbUVuZCcpOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvcHJvcG9zYWwtZ2xvYmFsXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1N5c3RlbScsIHtnbG9iYWw6IHJlcXVpcmUoJy4vX2dsb2JhbCcpfSk7IiwidmFyICRpdGVyYXRvcnMgICAgPSByZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpXG4gICwgcmVkZWZpbmUgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBnbG9iYWwgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoaWRlICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgSXRlcmF0b3JzICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgd2tzICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcycpXG4gICwgSVRFUkFUT1IgICAgICA9IHdrcygnaXRlcmF0b3InKVxuICAsIFRPX1NUUklOR19UQUcgPSB3a3MoJ3RvU3RyaW5nVGFnJylcbiAgLCBBcnJheVZhbHVlcyAgID0gSXRlcmF0b3JzLkFycmF5O1xuXG5mb3IodmFyIGNvbGxlY3Rpb25zID0gWydOb2RlTGlzdCcsICdET01Ub2tlbkxpc3QnLCAnTWVkaWFMaXN0JywgJ1N0eWxlU2hlZXRMaXN0JywgJ0NTU1J1bGVMaXN0J10sIGkgPSAwOyBpIDwgNTsgaSsrKXtcbiAgdmFyIE5BTUUgICAgICAgPSBjb2xsZWN0aW9uc1tpXVxuICAgICwgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXVxuICAgICwgcHJvdG8gICAgICA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGVcbiAgICAsIGtleTtcbiAgaWYocHJvdG8pe1xuICAgIGlmKCFwcm90b1tJVEVSQVRPUl0paGlkZShwcm90bywgSVRFUkFUT1IsIEFycmF5VmFsdWVzKTtcbiAgICBpZighcHJvdG9bVE9fU1RSSU5HX1RBR10paGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gICAgSXRlcmF0b3JzW05BTUVdID0gQXJyYXlWYWx1ZXM7XG4gICAgZm9yKGtleSBpbiAkaXRlcmF0b3JzKWlmKCFwcm90b1trZXldKXJlZGVmaW5lKHByb3RvLCBrZXksICRpdGVyYXRvcnNba2V5XSwgdHJ1ZSk7XG4gIH1cbn0iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHRhc2sgICA9IHJlcXVpcmUoJy4vX3Rhc2snKTtcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5CLCB7XG4gIHNldEltbWVkaWF0ZTogICAkdGFzay5zZXQsXG4gIGNsZWFySW1tZWRpYXRlOiAkdGFzay5jbGVhclxufSk7IiwiLy8gaWU5LSBzZXRUaW1lb3V0ICYgc2V0SW50ZXJ2YWwgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZpeFxudmFyIGdsb2JhbCAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsICRleHBvcnQgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGludm9rZSAgICAgPSByZXF1aXJlKCcuL19pbnZva2UnKVxuICAsIHBhcnRpYWwgICAgPSByZXF1aXJlKCcuL19wYXJ0aWFsJylcbiAgLCBuYXZpZ2F0b3IgID0gZ2xvYmFsLm5hdmlnYXRvclxuICAsIE1TSUUgICAgICAgPSAhIW5hdmlnYXRvciAmJiAvTVNJRSAuXFwuLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpOyAvLyA8LSBkaXJ0eSBpZTktIGNoZWNrXG52YXIgd3JhcCA9IGZ1bmN0aW9uKHNldCl7XG4gIHJldHVybiBNU0lFID8gZnVuY3Rpb24oZm4sIHRpbWUgLyosIC4uLmFyZ3MgKi8pe1xuICAgIHJldHVybiBzZXQoaW52b2tlKFxuICAgICAgcGFydGlhbCxcbiAgICAgIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSxcbiAgICAgIHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbilcbiAgICApLCB0aW1lKTtcbiAgfSA6IHNldDtcbn07XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuQiArICRleHBvcnQuRiAqIE1TSUUsIHtcbiAgc2V0VGltZW91dDogIHdyYXAoZ2xvYmFsLnNldFRpbWVvdXQpLFxuICBzZXRJbnRlcnZhbDogd3JhcChnbG9iYWwuc2V0SW50ZXJ2YWwpXG59KTsiLCJyZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN5bWJvbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0aWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmZyZWV6ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3Quc2VhbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QucHJldmVudC1leHRlbnNpb25zJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1mcm96ZW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzLXNlYWxlZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmJpbmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5mdW5jdGlvbi5oYXMtaW5zdGFuY2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucGFyc2UtaW50Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnBhcnNlLWZsb2F0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3RvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIudG8tZml4ZWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnRvLXByZWNpc2lvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuZXBzaWxvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtZmluaXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1uYW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLXNhZmUtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIubWluLXNhZmUtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtZmxvYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWludCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmFjb3NoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguYXNpbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5hdGFuaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmNicnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5jbHozMicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmNvc2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5leHBtMScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmZyb3VuZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmh5cG90Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguaW11bCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmxvZzEwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgubG9nMXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5sb2cyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguc2lnbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnNpbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC50YW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgudHJ1bmMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZyb20tY29kZS1wb2ludCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcucmF3Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy50cmltJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuY29kZS1wb2ludC1hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZW5kcy13aXRoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5pbmNsdWRlcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcucmVwZWF0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdGFydHMtd2l0aCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYW5jaG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5iaWcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmJsaW5rJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5ib2xkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5maXhlZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udGNvbG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5mb250c2l6ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRhbGljcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcubGluaycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc21hbGwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN0cmlrZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3ViJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS5ub3cnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8taXNvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLXByaW1pdGl2ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5pcy1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5mcm9tJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lm9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmpvaW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc2xpY2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc29ydCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5mb3ItZWFjaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5tYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmlsdGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNvbWUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZXZlcnknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS1yaWdodCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5pbmRleC1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5sYXN0LWluZGV4LW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmNvcHktd2l0aGluJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbGwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmluZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maW5kLWluZGV4Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNwZWNpZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLmNvbnN0cnVjdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLmZsYWdzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5tYXRjaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAucmVwbGFjZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuc2VhcmNoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5wcm9taXNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYud2Vhay1tYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYud2Vhay1zZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuYXJyYXktYnVmZmVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmRhdGEtdmlldycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5pbnQ4LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWNsYW1wZWQtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuaW50MTYtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDE2LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmludDMyLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQzMi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDMyLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0NjQtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5hcHBseScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmNvbnN0cnVjdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlZmluZS1wcm9wZXJ0eScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlbGV0ZS1wcm9wZXJ0eScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmVudW1lcmF0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5oYXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5pcy1leHRlbnNpYmxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3Qub3duLWtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5wcmV2ZW50LWV4dGVuc2lvbnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5zZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLXN0YXJ0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtZW5kJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy50cmltLWxlZnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tcmlnaHQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLm1hdGNoLWFsbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LnZhbHVlcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZW50cmllcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLWdldHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLXNldHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLWdldHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLXNldHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXAudG8tanNvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zZXQudG8tanNvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zeXN0ZW0uZ2xvYmFsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmVycm9yLmlzLWVycm9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguaWFkZGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5pc3ViaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmltdWxoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGgudW11bGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5kZWZpbmUtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5kZWxldGUtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEta2V5cycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLWtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtb3duLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QubWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuYXNhcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYnNlcnZhYmxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLnRpbWVycycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi5pbW1lZGlhdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbW9kdWxlcy9fY29yZScpOyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBodHRwczovL3Jhdy5naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL21hc3Rlci9MSUNFTlNFIGZpbGUuIEFuXG4gKiBhZGRpdGlvbmFsIGdyYW50IG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW5cbiAqIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXG4gICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy5kb21haW4pIHtcbiAgICAgIGludm9rZSA9IHByb2Nlc3MuZG9tYWluLmJpbmQoaW52b2tlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIHJ1bnRpbWUuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxuICAgICk7XG5cbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIiB8fFxuICAgICAgICAgICAgICAobWV0aG9kID09PSBcInRocm93XCIgJiYgZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgLy8gQSByZXR1cm4gb3IgdGhyb3cgKHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyB0aHJvd1xuICAgICAgICAgICAgLy8gbWV0aG9kKSBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgICAgdmFyIHJldHVybk1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdO1xuICAgICAgICAgICAgaWYgKHJldHVybk1ldGhvZCkge1xuICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gocmV0dXJuTWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgYXJnKTtcbiAgICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmV0dXJuIG1ldGhvZCB0aHJldyBhbiBleGNlcHRpb24sIGxldCB0aGF0XG4gICAgICAgICAgICAgICAgLy8gZXhjZXB0aW9uIHByZXZhaWwgb3ZlciB0aGUgb3JpZ2luYWwgcmV0dXJuIG9yIHRocm93LlxuICAgICAgICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICAgICAgLy8gQ29udGludWUgd2l0aCB0aGUgb3V0ZXIgcmV0dXJuLCBub3cgdGhhdCB0aGUgZGVsZWdhdGVcbiAgICAgICAgICAgICAgLy8gaXRlcmF0b3IgaGFzIGJlZW4gdGVybWluYXRlZC5cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKFxuICAgICAgICAgICAgZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSxcbiAgICAgICAgICAgIGRlbGVnYXRlLml0ZXJhdG9yLFxuICAgICAgICAgICAgYXJnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gTGlrZSByZXR1cm5pbmcgZ2VuZXJhdG9yLnRocm93KHVuY2F1Z2h0KSwgYnV0IHdpdGhvdXQgdGhlXG4gICAgICAgICAgICAvLyBvdmVyaGVhZCBvZiBhbiBleHRyYSBmdW5jdGlvbiBjYWxsLlxuICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERlbGVnYXRlIGdlbmVyYXRvciByYW4gYW5kIGhhbmRsZWQgaXRzIG93biBleGNlcHRpb25zIHNvXG4gICAgICAgICAgLy8gcmVnYXJkbGVzcyBvZiB3aGF0IHRoZSBtZXRob2Qgd2FzLCB3ZSBjb250aW51ZSBhcyBpZiBpdCBpc1xuICAgICAgICAgIC8vIFwibmV4dFwiIHdpdGggYW4gdW5kZWZpbmVkIGFyZy5cbiAgICAgICAgICBtZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG4gICAgICAgICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG4gICAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oYXJnKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgICBtZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBhcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIHZhciBpbmZvID0ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmRlbGVnYXRlICYmIG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG4gICAgICAgIHJldHVybiAhIWNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbiAgLy8gQW1vbmcgdGhlIHZhcmlvdXMgdHJpY2tzIGZvciBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbFxuICAvLyBvYmplY3QsIHRoaXMgc2VlbXMgdG8gYmUgdGhlIG1vc3QgcmVsaWFibGUgdGVjaG5pcXVlIHRoYXQgZG9lcyBub3RcbiAgLy8gdXNlIGluZGlyZWN0IGV2YWwgKHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5KS5cbiAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOlxuICB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0aGlzXG4pO1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDE2IFBUIElub3Zhw6fDo28gZSBTaXN0ZW1hcyBTQVxuKiBDb3B5cmlnaHQgMjAxNiBJTkVTQy1JRFxuKiBDb3B5cmlnaHQgMjAxNiBRVU9CSVMgTkVUV09SS1MgU0xcbiogQ29weXJpZ2h0IDIwMTYgRlJBVU5IT0ZFUi1HRVNFTExTQ0hBRlQgWlVSIEZPRVJERVJVTkcgREVSIEFOR0VXQU5EVEVOIEZPUlNDSFVORyBFLlZcbiogQ29weXJpZ2h0IDIwMTYgT1JBTkdFIFNBXG4qIENvcHlyaWdodCAyMDE2IERldXRzY2hlIFRlbGVrb20gQUdcbiogQ29weXJpZ2h0IDIwMTYgQXBpemVlXG4qIENvcHlyaWdodCAyMDE2IFRFQ0hOSVNDSEUgVU5JVkVSU0lUQVQgQkVSTElOXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbioqL1xuXG4vLyBEaXN0cmlidXRpb24gZmlsZSBmb3IgTWVzc2FnZUZhY3RvcnkuanMgXG4vLyB2ZXJzaW9uOiAwLjUuMVxuLy8gTGFzdCBidWlsZDogV2VkIERlYyAyMSAyMDE2IDEyOjAyOjM3IEdNVCswMDAwIChXRVQpXG5cbiFmdW5jdGlvbihlKXtpZihcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSltb2R1bGUuZXhwb3J0cz1lKCk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQpZGVmaW5lKFtdLGUpO2Vsc2V7dmFyIHQ7dD1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOnRoaXMsdC5NZXNzYWdlRmFjdG9yeT1lKCl9fShmdW5jdGlvbigpe3ZhciBlO3JldHVybiBmdW5jdGlvbiB0KGUscixuKXtmdW5jdGlvbiBvKGEscyl7aWYoIXJbYV0pe2lmKCFlW2FdKXt2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFzJiZ1KXJldHVybiB1KGEsITApO2lmKGkpcmV0dXJuIGkoYSwhMCk7dmFyIGM9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIithK1wiJ1wiKTt0aHJvdyBjLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsY312YXIgbD1yW2FdPXtleHBvcnRzOnt9fTtlW2FdWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKHQpe3ZhciByPWVbYV1bMV1bdF07cmV0dXJuIG8ocj9yOnQpfSxsLGwuZXhwb3J0cyx0LGUscixuKX1yZXR1cm4gclthXS5leHBvcnRzfWZvcih2YXIgaT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGE9MDthPG4ubGVuZ3RoO2ErKylvKG5bYV0pO3JldHVybiBvfSh7MTpbZnVuY3Rpb24oZSx0LHIpe3QuZXhwb3J0cz17XCJkZWZhdWx0XCI6ZShcImNvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeVwiKSxfX2VzTW9kdWxlOiEwfX0se1wiY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5XCI6MTZ9XSwyOltmdW5jdGlvbihlLHQscil7dC5leHBvcnRzPXtcImRlZmF1bHRcIjplKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGVcIiksX19lc01vZHVsZTohMH19LHtcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlXCI6MTd9XSwzOltmdW5jdGlvbihlLHQscil7dC5leHBvcnRzPXtcImRlZmF1bHRcIjplKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIiksX19lc01vZHVsZTohMH19LHtcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCI6MTh9XSw0OltmdW5jdGlvbihlLHQscil7dC5leHBvcnRzPXtcImRlZmF1bHRcIjplKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9mcmVlemVcIiksX19lc01vZHVsZTohMH19LHtcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZnJlZXplXCI6MTl9XSw1OltmdW5jdGlvbihlLHQscil7dC5leHBvcnRzPXtcImRlZmF1bHRcIjplKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCIpLF9fZXNNb2R1bGU6ITB9fSx7XCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1wcm90b3R5cGUtb2ZcIjoyMH1dLDY6W2Z1bmN0aW9uKGUsdCxyKXt0LmV4cG9ydHM9e1wiZGVmYXVsdFwiOmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2tleXNcIiksX19lc01vZHVsZTohMH19LHtcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qva2V5c1wiOjIxfV0sNzpbZnVuY3Rpb24oZSx0LHIpe3QuZXhwb3J0cz17XCJkZWZhdWx0XCI6ZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKSxfX2VzTW9kdWxlOiEwfX0se1wiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCI6MjJ9XSw4OltmdW5jdGlvbihlLHQscil7dC5leHBvcnRzPXtcImRlZmF1bHRcIjplKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbFwiKSxfX2VzTW9kdWxlOiEwfX0se1wiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbFwiOjIzfV0sOTpbZnVuY3Rpb24oZSx0LHIpe3QuZXhwb3J0cz17XCJkZWZhdWx0XCI6ZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3JcIiksX19lc01vZHVsZTohMH19LHtcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3JcIjoyNH1dLDEwOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7ci5fX2VzTW9kdWxlPSEwLHJbXCJkZWZhdWx0XCJdPWZ1bmN0aW9uKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX19LHt9XSwxMTpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntcImRlZmF1bHRcIjplfX1yLl9fZXNNb2R1bGU9ITA7dmFyIG89ZShcIi4uL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKSxpPW4obyk7cltcImRlZmF1bHRcIl09ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBuPXRbcl07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLCgwLGlbXCJkZWZhdWx0XCJdKShlLG4ua2V5LG4pfX1yZXR1cm4gZnVuY3Rpb24odCxyLG4pe3JldHVybiByJiZlKHQucHJvdG90eXBlLHIpLG4mJmUodCxuKSx0fX0oKX0se1wiLi4vY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCI6M31dLDEyOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e1wiZGVmYXVsdFwiOmV9fXIuX19lc01vZHVsZT0hMDt2YXIgbz1lKFwiLi4vY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKSxpPW4obyksYT1lKFwiLi4vY29yZS1qcy9vYmplY3QvY3JlYXRlXCIpLHM9bihhKSx1PWUoXCIuLi9oZWxwZXJzL3R5cGVvZlwiKSxjPW4odSk7cltcImRlZmF1bHRcIl09ZnVuY3Rpb24oZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIisoXCJ1bmRlZmluZWRcIj09dHlwZW9mIHQ/XCJ1bmRlZmluZWRcIjooMCxjW1wiZGVmYXVsdFwiXSkodCkpKTtlLnByb3RvdHlwZT0oMCxzW1wiZGVmYXVsdFwiXSkodCYmdC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHQmJihpW1wiZGVmYXVsdFwiXT8oMCxpW1wiZGVmYXVsdFwiXSkoZSx0KTplLl9fcHJvdG9fXz10KX19LHtcIi4uL2NvcmUtanMvb2JqZWN0L2NyZWF0ZVwiOjIsXCIuLi9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCI6NyxcIi4uL2hlbHBlcnMvdHlwZW9mXCI6MTR9XSwxMzpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntcImRlZmF1bHRcIjplfX1yLl9fZXNNb2R1bGU9ITA7dmFyIG89ZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpLGk9bihvKTtyW1wiZGVmYXVsdFwiXT1mdW5jdGlvbihlLHQpe2lmKCFlKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hdHx8XCJvYmplY3RcIiE9PShcInVuZGVmaW5lZFwiPT10eXBlb2YgdD9cInVuZGVmaW5lZFwiOigwLGlbXCJkZWZhdWx0XCJdKSh0KSkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZTp0fX0se1wiLi4vaGVscGVycy90eXBlb2ZcIjoxNH1dLDE0OltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e1wiZGVmYXVsdFwiOmV9fXIuX19lc01vZHVsZT0hMDt2YXIgbz1lKFwiLi4vY29yZS1qcy9zeW1ib2wvaXRlcmF0b3JcIiksaT1uKG8pLGE9ZShcIi4uL2NvcmUtanMvc3ltYm9sXCIpLHM9bihhKSx1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHNbXCJkZWZhdWx0XCJdJiZcInN5bWJvbFwiPT10eXBlb2YgaVtcImRlZmF1bHRcIl0/ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlfTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2Ygc1tcImRlZmF1bHRcIl0mJmUuY29uc3RydWN0b3I9PT1zW1wiZGVmYXVsdFwiXSYmZSE9PXNbXCJkZWZhdWx0XCJdLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiBlfTtyW1wiZGVmYXVsdFwiXT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBzW1wiZGVmYXVsdFwiXSYmXCJzeW1ib2xcIj09PXUoaVtcImRlZmF1bHRcIl0pP2Z1bmN0aW9uKGUpe3JldHVyblwidW5kZWZpbmVkXCI9PXR5cGVvZiBlP1widW5kZWZpbmVkXCI6dShlKX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHNbXCJkZWZhdWx0XCJdJiZlLmNvbnN0cnVjdG9yPT09c1tcImRlZmF1bHRcIl0mJmUhPT1zW1wiZGVmYXVsdFwiXS5wcm90b3R5cGU/XCJzeW1ib2xcIjpcInVuZGVmaW5lZFwiPT10eXBlb2YgZT9cInVuZGVmaW5lZFwiOnUoZSl9fSx7XCIuLi9jb3JlLWpzL3N5bWJvbFwiOjgsXCIuLi9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvclwiOjl9XSwxNTpbZnVuY3Rpb24oZSx0LHIpe3QuZXhwb3J0cz1lKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKX0se1wicmVnZW5lcmF0b3ItcnVudGltZVwiOjk3fV0sMTY6W2Z1bmN0aW9uKGUsdCxyKXt2YXIgbj1lKFwiLi4vLi4vbW9kdWxlcy9fY29yZVwiKSxvPW4uSlNPTnx8KG4uSlNPTj17c3RyaW5naWZ5OkpTT04uc3RyaW5naWZ5fSk7dC5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBvLnN0cmluZ2lmeS5hcHBseShvLGFyZ3VtZW50cyl9fSx7XCIuLi8uLi9tb2R1bGVzL19jb3JlXCI6MzB9XSwxNzpbZnVuY3Rpb24oZSx0LHIpe2UoXCIuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlXCIpO3ZhciBuPWUoXCIuLi8uLi9tb2R1bGVzL19jb3JlXCIpLk9iamVjdDt0LmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbi5jcmVhdGUoZSx0KX19LHtcIi4uLy4uL21vZHVsZXMvX2NvcmVcIjozMCxcIi4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGVcIjo4NH1dLDE4OltmdW5jdGlvbihlLHQscil7ZShcIi4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHlcIik7dmFyIG49ZShcIi4uLy4uL21vZHVsZXMvX2NvcmVcIikuT2JqZWN0O3QuZXhwb3J0cz1mdW5jdGlvbihlLHQscil7cmV0dXJuIG4uZGVmaW5lUHJvcGVydHkoZSx0LHIpfX0se1wiLi4vLi4vbW9kdWxlcy9fY29yZVwiOjMwLFwiLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eVwiOjg1fV0sMTk6W2Z1bmN0aW9uKGUsdCxyKXtlKFwiLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmZyZWV6ZVwiKSx0LmV4cG9ydHM9ZShcIi4uLy4uL21vZHVsZXMvX2NvcmVcIikuT2JqZWN0LmZyZWV6ZX0se1wiLi4vLi4vbW9kdWxlcy9fY29yZVwiOjMwLFwiLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmZyZWV6ZVwiOjg2fV0sMjA6W2Z1bmN0aW9uKGUsdCxyKXtlKFwiLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2ZcIiksdC5leHBvcnRzPWUoXCIuLi8uLi9tb2R1bGVzL19jb3JlXCIpLk9iamVjdC5nZXRQcm90b3R5cGVPZn0se1wiLi4vLi4vbW9kdWxlcy9fY29yZVwiOjMwLFwiLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2ZcIjo4N31dLDIxOltmdW5jdGlvbihlLHQscil7ZShcIi4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzXCIpLHQuZXhwb3J0cz1lKFwiLi4vLi4vbW9kdWxlcy9fY29yZVwiKS5PYmplY3Qua2V5c30se1wiLi4vLi4vbW9kdWxlcy9fY29yZVwiOjMwLFwiLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmtleXNcIjo4OH1dLDIyOltmdW5jdGlvbihlLHQscil7ZShcIi4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mXCIpLHQuZXhwb3J0cz1lKFwiLi4vLi4vbW9kdWxlcy9fY29yZVwiKS5PYmplY3Quc2V0UHJvdG90eXBlT2Z9LHtcIi4uLy4uL21vZHVsZXMvX2NvcmVcIjozMCxcIi4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mXCI6ODl9XSwyMzpbZnVuY3Rpb24oZSx0LHIpe2UoXCIuLi8uLi9tb2R1bGVzL2VzNi5zeW1ib2xcIiksZShcIi4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmdcIiksZShcIi4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvclwiKSxlKFwiLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGVcIiksdC5leHBvcnRzPWUoXCIuLi8uLi9tb2R1bGVzL19jb3JlXCIpLlN5bWJvbH0se1wiLi4vLi4vbW9kdWxlcy9fY29yZVwiOjMwLFwiLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZ1wiOjkwLFwiLi4vLi4vbW9kdWxlcy9lczYuc3ltYm9sXCI6OTIsXCIuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3JcIjo5MyxcIi4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlXCI6OTR9XSwyNDpbZnVuY3Rpb24oZSx0LHIpe2UoXCIuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3JcIiksZShcIi4uLy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZVwiKSx0LmV4cG9ydHM9ZShcIi4uLy4uL21vZHVsZXMvX3drcy1leHRcIikuZihcIml0ZXJhdG9yXCIpfSx7XCIuLi8uLi9tb2R1bGVzL193a3MtZXh0XCI6ODEsXCIuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3JcIjo5MSxcIi4uLy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZVwiOjk1fV0sMjU6W2Z1bmN0aW9uKGUsdCxyKXt0LmV4cG9ydHM9ZnVuY3Rpb24oZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSl0aHJvdyBUeXBlRXJyb3IoZStcIiBpcyBub3QgYSBmdW5jdGlvbiFcIik7cmV0dXJuIGV9fSx7fV0sMjY6W2Z1bmN0aW9uKGUsdCxyKXt0LmV4cG9ydHM9ZnVuY3Rpb24oKXt9fSx7fV0sMjc6W2Z1bmN0aW9uKGUsdCxyKXt2YXIgbj1lKFwiLi9faXMtb2JqZWN0XCIpO3QuZXhwb3J0cz1mdW5jdGlvbihlKXtpZighbihlKSl0aHJvdyBUeXBlRXJyb3IoZStcIiBpcyBub3QgYW4gb2JqZWN0IVwiKTtyZXR1cm4gZX19LHtcIi4vX2lzLW9iamVjdFwiOjQ2fV0sMjg6W2Z1bmN0aW9uKGUsdCxyKXt2YXIgbj1lKFwiLi9fdG8taW9iamVjdFwiKSxvPWUoXCIuL190by1sZW5ndGhcIiksaT1lKFwiLi9fdG8taW5kZXhcIik7dC5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbih0LHIsYSl7dmFyIHMsdT1uKHQpLGM9byh1Lmxlbmd0aCksbD1pKGEsYyk7aWYoZSYmciE9cil7Zm9yKDtjPmw7KWlmKHM9dVtsKytdLHMhPXMpcmV0dXJuITB9ZWxzZSBmb3IoO2M+bDtsKyspaWYoKGV8fGwgaW4gdSkmJnVbbF09PT1yKXJldHVybiBlfHxsfHwwO3JldHVybiFlJiYtMX19fSx7XCIuL190by1pbmRleFwiOjczLFwiLi9fdG8taW9iamVjdFwiOjc1LFwiLi9fdG8tbGVuZ3RoXCI6NzZ9XSwyOTpbZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXt9LnRvU3RyaW5nO3QuZXhwb3J0cz1mdW5jdGlvbihlKXtyZXR1cm4gbi5jYWxsKGUpLnNsaWNlKDgsLTEpfX0se31dLDMwOltmdW5jdGlvbihlLHQscil7dmFyIG49dC5leHBvcnRzPXt2ZXJzaW9uOlwiMi40LjBcIn07XCJudW1iZXJcIj09dHlwZW9mIF9fZSYmKF9fZT1uKX0se31dLDMxOltmdW5jdGlvbihlLHQscil7dmFyIG49ZShcIi4vX2EtZnVuY3Rpb25cIik7dC5leHBvcnRzPWZ1bmN0aW9uKGUsdCxyKXtpZihuKGUpLHZvaWQgMD09PXQpcmV0dXJuIGU7c3dpdGNoKHIpe2Nhc2UgMTpyZXR1cm4gZnVuY3Rpb24ocil7cmV0dXJuIGUuY2FsbCh0LHIpfTtjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKHIsbil7cmV0dXJuIGUuY2FsbCh0LHIsbil9O2Nhc2UgMzpyZXR1cm4gZnVuY3Rpb24ocixuLG8pe3JldHVybiBlLmNhbGwodCxyLG4sbyl9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiBlLmFwcGx5KHQsYXJndW1lbnRzKX19fSx7XCIuL19hLWZ1bmN0aW9uXCI6MjV9XSwzMjpbZnVuY3Rpb24oZSx0LHIpe3QuZXhwb3J0cz1mdW5jdGlvbihlKXtpZih2b2lkIDA9PWUpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiK2UpO3JldHVybiBlfX0se31dLDMzOltmdW5jdGlvbihlLHQscil7dC5leHBvcnRzPSFlKFwiLi9fZmFpbHNcIikoZnVuY3Rpb24oKXtyZXR1cm4gNyE9T2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LFwiYVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gN319KS5hfSl9LHtcIi4vX2ZhaWxzXCI6Mzh9XSwzNDpbZnVuY3Rpb24oZSx0LHIpe3ZhciBuPWUoXCIuL19pcy1vYmplY3RcIiksbz1lKFwiLi9fZ2xvYmFsXCIpLmRvY3VtZW50LGk9bihvKSYmbihvLmNyZWF0ZUVsZW1lbnQpO3QuZXhwb3J0cz1mdW5jdGlvbihlKXtyZXR1cm4gaT9vLmNyZWF0ZUVsZW1lbnQoZSk6e319fSx7XCIuL19nbG9iYWxcIjozOSxcIi4vX2lzLW9iamVjdFwiOjQ2fV0sMzU6W2Z1bmN0aW9uKGUsdCxyKXt0LmV4cG9ydHM9XCJjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2ZcIi5zcGxpdChcIixcIil9LHt9XSwzNjpbZnVuY3Rpb24oZSx0LHIpe3ZhciBuPWUoXCIuL19vYmplY3Qta2V5c1wiKSxvPWUoXCIuL19vYmplY3QtZ29wc1wiKSxpPWUoXCIuL19vYmplY3QtcGllXCIpO3QuZXhwb3J0cz1mdW5jdGlvbihlKXt2YXIgdD1uKGUpLHI9by5mO2lmKHIpZm9yKHZhciBhLHM9cihlKSx1PWkuZixjPTA7cy5sZW5ndGg+YzspdS5jYWxsKGUsYT1zW2MrK10pJiZ0LnB1c2goYSk7cmV0dXJuIHR9fSx7XCIuL19vYmplY3QtZ29wc1wiOjYwLFwiLi9fb2JqZWN0LWtleXNcIjo2MyxcIi4vX29iamVjdC1waWVcIjo2NH1dLDM3OltmdW5jdGlvbihlLHQscil7dmFyIG49ZShcIi4vX2dsb2JhbFwiKSxvPWUoXCIuL19jb3JlXCIpLGk9ZShcIi4vX2N0eFwiKSxhPWUoXCIuL19oaWRlXCIpLHM9XCJwcm90b3R5cGVcIix1PWZ1bmN0aW9uKGUsdCxyKXt2YXIgYyxsLGYsZD1lJnUuRixwPWUmdS5HLGg9ZSZ1LlMseT1lJnUuUCxtPWUmdS5CLHY9ZSZ1LlcsXz1wP286b1t0XXx8KG9bdF09e30pLGI9X1tzXSxnPXA/bjpoP25bdF06KG5bdF18fHt9KVtzXTtwJiYocj10KTtmb3IoYyBpbiByKWw9IWQmJmcmJnZvaWQgMCE9PWdbY10sbCYmYyBpbiBffHwoZj1sP2dbY106cltjXSxfW2NdPXAmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGdbY10/cltjXTptJiZsP2koZixuKTp2JiZnW2NdPT1mP2Z1bmN0aW9uKGUpe3ZhciB0PWZ1bmN0aW9uKHQscixuKXtpZih0aGlzIGluc3RhbmNlb2YgZSl7c3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gbmV3IGU7Y2FzZSAxOnJldHVybiBuZXcgZSh0KTtjYXNlIDI6cmV0dXJuIG5ldyBlKHQscil9cmV0dXJuIG5ldyBlKHQscixuKX1yZXR1cm4gZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3JldHVybiB0W3NdPWVbc10sdH0oZik6eSYmXCJmdW5jdGlvblwiPT10eXBlb2YgZj9pKEZ1bmN0aW9uLmNhbGwsZik6Zix5JiYoKF8udmlydHVhbHx8KF8udmlydHVhbD17fSkpW2NdPWYsZSZ1LlImJmImJiFiW2NdJiZhKGIsYyxmKSkpfTt1LkY9MSx1Lkc9Mix1LlM9NCx1LlA9OCx1LkI9MTYsdS5XPTMyLHUuVT02NCx1LlI9MTI4LHQuZXhwb3J0cz11fSx7XCIuL19jb3JlXCI6MzAsXCIuL19jdHhcIjozMSxcIi4vX2dsb2JhbFwiOjM5LFwiLi9faGlkZVwiOjQxfV0sMzg6W2Z1bmN0aW9uKGUsdCxyKXt0LmV4cG9ydHM9ZnVuY3Rpb24oZSl7dHJ5e3JldHVybiEhZSgpfWNhdGNoKHQpe3JldHVybiEwfX19LHt9XSwzOTpbZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXQuZXhwb3J0cz1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3cuTWF0aD09TWF0aD93aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJnNlbGYuTWF0aD09TWF0aD9zZWxmOkZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcIm51bWJlclwiPT10eXBlb2YgX19nJiYoX19nPW4pfSx7fV0sNDA6W2Z1bmN0aW9uKGUsdCxyKXt2YXIgbj17fS5oYXNPd25Qcm9wZXJ0eTt0LmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbi5jYWxsKGUsdCl9fSx7fV0sNDE6W2Z1bmN0aW9uKGUsdCxyKXt2YXIgbj1lKFwiLi9fb2JqZWN0LWRwXCIpLG89ZShcIi4vX3Byb3BlcnR5LWRlc2NcIik7dC5leHBvcnRzPWUoXCIuL19kZXNjcmlwdG9yc1wiKT9mdW5jdGlvbihlLHQscil7cmV0dXJuIG4uZihlLHQsbygxLHIpKX06ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBlW3RdPXIsZX19LHtcIi4vX2Rlc2NyaXB0b3JzXCI6MzMsXCIuL19vYmplY3QtZHBcIjo1NSxcIi4vX3Byb3BlcnR5LWRlc2NcIjo2Nn1dLDQyOltmdW5jdGlvbihlLHQscil7dC5leHBvcnRzPWUoXCIuL19nbG9iYWxcIikuZG9jdW1lbnQmJmRvY3VtZW50LmRvY3VtZW50RWxlbWVudH0se1wiLi9fZ2xvYmFsXCI6Mzl9XSw0MzpbZnVuY3Rpb24oZSx0LHIpe3QuZXhwb3J0cz0hZShcIi4vX2Rlc2NyaXB0b3JzXCIpJiYhZShcIi4vX2ZhaWxzXCIpKGZ1bmN0aW9uKCl7cmV0dXJuIDchPU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlKFwiLi9fZG9tLWNyZWF0ZVwiKShcImRpdlwiKSxcImFcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDd9fSkuYX0pfSx7XCIuL19kZXNjcmlwdG9yc1wiOjMzLFwiLi9fZG9tLWNyZWF0ZVwiOjM0LFwiLi9fZmFpbHNcIjozOH1dLDQ0OltmdW5jdGlvbihlLHQscil7dmFyIG49ZShcIi4vX2NvZlwiKTt0LmV4cG9ydHM9T2JqZWN0KFwielwiKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKT9PYmplY3Q6ZnVuY3Rpb24oZSl7cmV0dXJuXCJTdHJpbmdcIj09bihlKT9lLnNwbGl0KFwiXCIpOk9iamVjdChlKX19LHtcIi4vX2NvZlwiOjI5fV0sNDU6W2Z1bmN0aW9uKGUsdCxyKXt2YXIgbj1lKFwiLi9fY29mXCIpO3QuZXhwb3J0cz1BcnJheS5pc0FycmF5fHxmdW5jdGlvbihlKXtyZXR1cm5cIkFycmF5XCI9PW4oZSl9fSx7XCIuL19jb2ZcIjoyOX1dLDQ2OltmdW5jdGlvbihlLHQscil7dC5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVyblwib2JqZWN0XCI9PXR5cGVvZiBlP251bGwhPT1lOlwiZnVuY3Rpb25cIj09dHlwZW9mIGV9fSx7fV0sNDc6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1lKFwiLi9fb2JqZWN0LWNyZWF0ZVwiKSxvPWUoXCIuL19wcm9wZXJ0eS1kZXNjXCIpLGk9ZShcIi4vX3NldC10by1zdHJpbmctdGFnXCIpLGE9e307ZShcIi4vX2hpZGVcIikoYSxlKFwiLi9fd2tzXCIpKFwiaXRlcmF0b3JcIiksZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLHQuZXhwb3J0cz1mdW5jdGlvbihlLHQscil7ZS5wcm90b3R5cGU9bihhLHtuZXh0Om8oMSxyKX0pLGkoZSx0K1wiIEl0ZXJhdG9yXCIpfX0se1wiLi9faGlkZVwiOjQxLFwiLi9fb2JqZWN0LWNyZWF0ZVwiOjU0LFwiLi9fcHJvcGVydHktZGVzY1wiOjY2LFwiLi9fc2V0LXRvLXN0cmluZy10YWdcIjo2OSxcIi4vX3drc1wiOjgyfV0sNDg6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1lKFwiLi9fbGlicmFyeVwiKSxvPWUoXCIuL19leHBvcnRcIiksaT1lKFwiLi9fcmVkZWZpbmVcIiksYT1lKFwiLi9faGlkZVwiKSxzPWUoXCIuL19oYXNcIiksdT1lKFwiLi9faXRlcmF0b3JzXCIpLGM9ZShcIi4vX2l0ZXItY3JlYXRlXCIpLGw9ZShcIi4vX3NldC10by1zdHJpbmctdGFnXCIpLGY9ZShcIi4vX29iamVjdC1ncG9cIiksZD1lKFwiLi9fd2tzXCIpKFwiaXRlcmF0b3JcIikscD0hKFtdLmtleXMmJlwibmV4dFwiaW5bXS5rZXlzKCkpLGg9XCJAQGl0ZXJhdG9yXCIseT1cImtleXNcIixtPVwidmFsdWVzXCIsdj1mdW5jdGlvbigpe3JldHVybiB0aGlzfTt0LmV4cG9ydHM9ZnVuY3Rpb24oZSx0LHIsXyxiLGcsRSl7YyhyLHQsXyk7dmFyIGosdyxPLE09ZnVuY3Rpb24oZSl7aWYoIXAmJmUgaW4gUilyZXR1cm4gUltlXTtzd2l0Y2goZSl7Y2FzZSB5OnJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgcih0aGlzLGUpfTtjYXNlIG06cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyByKHRoaXMsZSl9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgcih0aGlzLGUpfX0seD10K1wiIEl0ZXJhdG9yXCIsUD1iPT1tLGs9ITEsUj1lLnByb3RvdHlwZSxTPVJbZF18fFJbaF18fGImJlJbYl0sVD1TfHxNKGIpLEE9Yj9QP00oXCJlbnRyaWVzXCIpOlQ6dm9pZCAwLE49XCJBcnJheVwiPT10P1IuZW50cmllc3x8UzpTO2lmKE4mJihPPWYoTi5jYWxsKG5ldyBlKSksTyE9PU9iamVjdC5wcm90b3R5cGUmJihsKE8seCwhMCksbnx8cyhPLGQpfHxhKE8sZCx2KSkpLFAmJlMmJlMubmFtZSE9PW0mJihrPSEwLFQ9ZnVuY3Rpb24oKXtyZXR1cm4gUy5jYWxsKHRoaXMpfSksbiYmIUV8fCFwJiYhayYmUltkXXx8YShSLGQsVCksdVt0XT1ULHVbeF09dixiKWlmKGo9e3ZhbHVlczpQP1Q6TShtKSxrZXlzOmc/VDpNKHkpLGVudHJpZXM6QX0sRSlmb3IodyBpbiBqKXcgaW4gUnx8aShSLHcsalt3XSk7ZWxzZSBvKG8uUCtvLkYqKHB8fGspLHQsaik7cmV0dXJuIGp9fSx7XCIuL19leHBvcnRcIjozNyxcIi4vX2hhc1wiOjQwLFwiLi9faGlkZVwiOjQxLFwiLi9faXRlci1jcmVhdGVcIjo0NyxcIi4vX2l0ZXJhdG9yc1wiOjUwLFwiLi9fbGlicmFyeVwiOjUyLFwiLi9fb2JqZWN0LWdwb1wiOjYxLFwiLi9fcmVkZWZpbmVcIjo2NyxcIi4vX3NldC10by1zdHJpbmctdGFnXCI6NjksXCIuL193a3NcIjo4Mn1dLDQ5OltmdW5jdGlvbihlLHQscil7dC5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7cmV0dXJue3ZhbHVlOnQsZG9uZTohIWV9fX0se31dLDUwOltmdW5jdGlvbihlLHQscil7dC5leHBvcnRzPXt9fSx7fV0sNTE6W2Z1bmN0aW9uKGUsdCxyKXt2YXIgbj1lKFwiLi9fb2JqZWN0LWtleXNcIiksbz1lKFwiLi9fdG8taW9iamVjdFwiKTt0LmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIsaT1vKGUpLGE9bihpKSxzPWEubGVuZ3RoLHU9MDtzPnU7KWlmKGlbcj1hW3UrK11dPT09dClyZXR1cm4gcn19LHtcIi4vX29iamVjdC1rZXlzXCI6NjMsXCIuL190by1pb2JqZWN0XCI6NzV9XSw1MjpbZnVuY3Rpb24oZSx0LHIpe3QuZXhwb3J0cz0hMH0se31dLDUzOltmdW5jdGlvbihlLHQscil7dmFyIG49ZShcIi4vX3VpZFwiKShcIm1ldGFcIiksbz1lKFwiLi9faXMtb2JqZWN0XCIpLGk9ZShcIi4vX2hhc1wiKSxhPWUoXCIuL19vYmplY3QtZHBcIikuZixzPTAsdT1PYmplY3QuaXNFeHRlbnNpYmxlfHxmdW5jdGlvbigpe3JldHVybiEwfSxjPSFlKFwiLi9fZmFpbHNcIikoZnVuY3Rpb24oKXtyZXR1cm4gdShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKX0pLGw9ZnVuY3Rpb24oZSl7YShlLG4se3ZhbHVlOntpOlwiT1wiKyArK3Msdzp7fX19KX0sZj1mdW5jdGlvbihlLHQpe2lmKCFvKGUpKXJldHVyblwic3ltYm9sXCI9PXR5cGVvZiBlP2U6KFwic3RyaW5nXCI9PXR5cGVvZiBlP1wiU1wiOlwiUFwiKStlO2lmKCFpKGUsbikpe2lmKCF1KGUpKXJldHVyblwiRlwiO2lmKCF0KXJldHVyblwiRVwiO2woZSl9cmV0dXJuIGVbbl0uaX0sZD1mdW5jdGlvbihlLHQpe2lmKCFpKGUsbikpe2lmKCF1KGUpKXJldHVybiEwO2lmKCF0KXJldHVybiExO2woZSl9cmV0dXJuIGVbbl0ud30scD1mdW5jdGlvbihlKXtyZXR1cm4gYyYmaC5ORUVEJiZ1KGUpJiYhaShlLG4pJiZsKGUpLGV9LGg9dC5leHBvcnRzPXtLRVk6bixORUVEOiExLGZhc3RLZXk6ZixnZXRXZWFrOmQsb25GcmVlemU6cH19LHtcIi4vX2ZhaWxzXCI6MzgsXCIuL19oYXNcIjo0MCxcIi4vX2lzLW9iamVjdFwiOjQ2LFwiLi9fb2JqZWN0LWRwXCI6NTUsXCIuL191aWRcIjo3OX1dLDU0OltmdW5jdGlvbihlLHQscil7dmFyIG49ZShcIi4vX2FuLW9iamVjdFwiKSxvPWUoXCIuL19vYmplY3QtZHBzXCIpLGk9ZShcIi4vX2VudW0tYnVnLWtleXNcIiksYT1lKFwiLi9fc2hhcmVkLWtleVwiKShcIklFX1BST1RPXCIpLHM9ZnVuY3Rpb24oKXt9LHU9XCJwcm90b3R5cGVcIixjPWZ1bmN0aW9uKCl7dmFyIHQscj1lKFwiLi9fZG9tLWNyZWF0ZVwiKShcImlmcmFtZVwiKSxuPWkubGVuZ3RoLG89XCI8XCIsYT1cIj5cIjtmb3Ioci5zdHlsZS5kaXNwbGF5PVwibm9uZVwiLGUoXCIuL19odG1sXCIpLmFwcGVuZENoaWxkKHIpLHIuc3JjPVwiamF2YXNjcmlwdDpcIix0PXIuY29udGVudFdpbmRvdy5kb2N1bWVudCx0Lm9wZW4oKSx0LndyaXRlKG8rXCJzY3JpcHRcIithK1wiZG9jdW1lbnQuRj1PYmplY3RcIitvK1wiL3NjcmlwdFwiK2EpLHQuY2xvc2UoKSxjPXQuRjtuLS07KWRlbGV0ZSBjW3VdW2lbbl1dO3JldHVybiBjKCl9O3QuZXhwb3J0cz1PYmplY3QuY3JlYXRlfHxmdW5jdGlvbihlLHQpe3ZhciByO3JldHVybiBudWxsIT09ZT8oc1t1XT1uKGUpLHI9bmV3IHMsc1t1XT1udWxsLHJbYV09ZSk6cj1jKCksdm9pZCAwPT09dD9yOm8ocix0KX19LHtcIi4vX2FuLW9iamVjdFwiOjI3LFwiLi9fZG9tLWNyZWF0ZVwiOjM0LFwiLi9fZW51bS1idWcta2V5c1wiOjM1LFwiLi9faHRtbFwiOjQyLFwiLi9fb2JqZWN0LWRwc1wiOjU2LFwiLi9fc2hhcmVkLWtleVwiOjcwfV0sNTU6W2Z1bmN0aW9uKGUsdCxyKXt2YXIgbj1lKFwiLi9fYW4tb2JqZWN0XCIpLG89ZShcIi4vX2llOC1kb20tZGVmaW5lXCIpLGk9ZShcIi4vX3RvLXByaW1pdGl2ZVwiKSxhPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTtyLmY9ZShcIi4vX2Rlc2NyaXB0b3JzXCIpP09iamVjdC5kZWZpbmVQcm9wZXJ0eTpmdW5jdGlvbihlLHQscil7aWYobihlKSx0PWkodCwhMCksbihyKSxvKXRyeXtyZXR1cm4gYShlLHQscil9Y2F0Y2gocyl7fWlmKFwiZ2V0XCJpbiByfHxcInNldFwiaW4gcil0aHJvdyBUeXBlRXJyb3IoXCJBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCFcIik7cmV0dXJuXCJ2YWx1ZVwiaW4gciYmKGVbdF09ci52YWx1ZSksZX19LHtcIi4vX2FuLW9iamVjdFwiOjI3LFwiLi9fZGVzY3JpcHRvcnNcIjozMyxcIi4vX2llOC1kb20tZGVmaW5lXCI6NDMsXCIuL190by1wcmltaXRpdmVcIjo3OH1dLDU2OltmdW5jdGlvbihlLHQscil7dmFyIG49ZShcIi4vX29iamVjdC1kcFwiKSxvPWUoXCIuL19hbi1vYmplY3RcIiksaT1lKFwiLi9fb2JqZWN0LWtleXNcIik7dC5leHBvcnRzPWUoXCIuL19kZXNjcmlwdG9yc1wiKT9PYmplY3QuZGVmaW5lUHJvcGVydGllczpmdW5jdGlvbihlLHQpe28oZSk7Zm9yKHZhciByLGE9aSh0KSxzPWEubGVuZ3RoLHU9MDtzPnU7KW4uZihlLHI9YVt1KytdLHRbcl0pO3JldHVybiBlfX0se1wiLi9fYW4tb2JqZWN0XCI6MjcsXCIuL19kZXNjcmlwdG9yc1wiOjMzLFwiLi9fb2JqZWN0LWRwXCI6NTUsXCIuL19vYmplY3Qta2V5c1wiOjYzfV0sNTc6W2Z1bmN0aW9uKGUsdCxyKXt2YXIgbj1lKFwiLi9fb2JqZWN0LXBpZVwiKSxvPWUoXCIuL19wcm9wZXJ0eS1kZXNjXCIpLGk9ZShcIi4vX3RvLWlvYmplY3RcIiksYT1lKFwiLi9fdG8tcHJpbWl0aXZlXCIpLHM9ZShcIi4vX2hhc1wiKSx1PWUoXCIuL19pZTgtZG9tLWRlZmluZVwiKSxjPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7ci5mPWUoXCIuL19kZXNjcmlwdG9yc1wiKT9jOmZ1bmN0aW9uKGUsdCl7aWYoZT1pKGUpLHQ9YSh0LCEwKSx1KXRyeXtyZXR1cm4gYyhlLHQpfWNhdGNoKHIpe31pZihzKGUsdCkpcmV0dXJuIG8oIW4uZi5jYWxsKGUsdCksZVt0XSl9fSx7XCIuL19kZXNjcmlwdG9yc1wiOjMzLFwiLi9faGFzXCI6NDAsXCIuL19pZTgtZG9tLWRlZmluZVwiOjQzLFwiLi9fb2JqZWN0LXBpZVwiOjY0LFwiLi9fcHJvcGVydHktZGVzY1wiOjY2LFwiLi9fdG8taW9iamVjdFwiOjc1LFwiLi9fdG8tcHJpbWl0aXZlXCI6Nzh9XSw1ODpbZnVuY3Rpb24oZSx0LHIpe3ZhciBuPWUoXCIuL190by1pb2JqZWN0XCIpLG89ZShcIi4vX29iamVjdC1nb3BuXCIpLmYsaT17fS50b1N0cmluZyxhPVwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3cmJndpbmRvdyYmT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM/T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KTpbXSxzPWZ1bmN0aW9uKGUpe3RyeXtyZXR1cm4gbyhlKX1jYXRjaCh0KXtyZXR1cm4gYS5zbGljZSgpfX07dC5leHBvcnRzLmY9ZnVuY3Rpb24oZSl7cmV0dXJuIGEmJlwiW29iamVjdCBXaW5kb3ddXCI9PWkuY2FsbChlKT9zKGUpOm8obihlKSl9fSx7XCIuL19vYmplY3QtZ29wblwiOjU5LFwiLi9fdG8taW9iamVjdFwiOjc1fV0sNTk6W2Z1bmN0aW9uKGUsdCxyKXt2YXIgbj1lKFwiLi9fb2JqZWN0LWtleXMtaW50ZXJuYWxcIiksbz1lKFwiLi9fZW51bS1idWcta2V5c1wiKS5jb25jYXQoXCJsZW5ndGhcIixcInByb3RvdHlwZVwiKTtyLmY9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXN8fGZ1bmN0aW9uKGUpe3JldHVybiBuKGUsbyl9fSx7XCIuL19lbnVtLWJ1Zy1rZXlzXCI6MzUsXCIuL19vYmplY3Qta2V5cy1pbnRlcm5hbFwiOjYyfV0sNjA6W2Z1bmN0aW9uKGUsdCxyKXtyLmY9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc30se31dLDYxOltmdW5jdGlvbihlLHQscil7dmFyIG49ZShcIi4vX2hhc1wiKSxvPWUoXCIuL190by1vYmplY3RcIiksaT1lKFwiLi9fc2hhcmVkLWtleVwiKShcIklFX1BST1RPXCIpLGE9T2JqZWN0LnByb3RvdHlwZTt0LmV4cG9ydHM9T2JqZWN0LmdldFByb3RvdHlwZU9mfHxmdW5jdGlvbihlKXtyZXR1cm4gZT1vKGUpLG4oZSxpKT9lW2ldOlwiZnVuY3Rpb25cIj09dHlwZW9mIGUuY29uc3RydWN0b3ImJmUgaW5zdGFuY2VvZiBlLmNvbnN0cnVjdG9yP2UuY29uc3RydWN0b3IucHJvdG90eXBlOmUgaW5zdGFuY2VvZiBPYmplY3Q/YTpudWxsfX0se1wiLi9faGFzXCI6NDAsXCIuL19zaGFyZWQta2V5XCI6NzAsXCIuL190by1vYmplY3RcIjo3N31dLDYyOltmdW5jdGlvbihlLHQscil7dmFyIG49ZShcIi4vX2hhc1wiKSxvPWUoXCIuL190by1pb2JqZWN0XCIpLGk9ZShcIi4vX2FycmF5LWluY2x1ZGVzXCIpKCExKSxhPWUoXCIuL19zaGFyZWQta2V5XCIpKFwiSUVfUFJPVE9cIik7dC5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7dmFyIHIscz1vKGUpLHU9MCxjPVtdO2ZvcihyIGluIHMpciE9YSYmbihzLHIpJiZjLnB1c2gocik7Zm9yKDt0Lmxlbmd0aD51OyluKHMscj10W3UrK10pJiYofmkoYyxyKXx8Yy5wdXNoKHIpKTtyZXR1cm4gY319LHtcIi4vX2FycmF5LWluY2x1ZGVzXCI6MjgsXCIuL19oYXNcIjo0MCxcIi4vX3NoYXJlZC1rZXlcIjo3MCxcIi4vX3RvLWlvYmplY3RcIjo3NX1dLDYzOltmdW5jdGlvbihlLHQscil7dmFyIG49ZShcIi4vX29iamVjdC1rZXlzLWludGVybmFsXCIpLG89ZShcIi4vX2VudW0tYnVnLWtleXNcIik7dC5leHBvcnRzPU9iamVjdC5rZXlzfHxmdW5jdGlvbihlKXtyZXR1cm4gbihlLG8pfX0se1wiLi9fZW51bS1idWcta2V5c1wiOjM1LFwiLi9fb2JqZWN0LWtleXMtaW50ZXJuYWxcIjo2Mn1dLDY0OltmdW5jdGlvbihlLHQscil7ci5mPXt9LnByb3BlcnR5SXNFbnVtZXJhYmxlfSx7fV0sNjU6W2Z1bmN0aW9uKGUsdCxyKXt2YXIgbj1lKFwiLi9fZXhwb3J0XCIpLG89ZShcIi4vX2NvcmVcIiksaT1lKFwiLi9fZmFpbHNcIik7dC5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7dmFyIHI9KG8uT2JqZWN0fHx7fSlbZV18fE9iamVjdFtlXSxhPXt9O2FbZV09dChyKSxuKG4uUytuLkYqaShmdW5jdGlvbigpe3IoMSl9KSxcIk9iamVjdFwiLGEpfX0se1wiLi9fY29yZVwiOjMwLFwiLi9fZXhwb3J0XCI6MzcsXCIuL19mYWlsc1wiOjM4fV0sNjY6W2Z1bmN0aW9uKGUsdCxyKXt0LmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXtyZXR1cm57ZW51bWVyYWJsZTohKDEmZSksY29uZmlndXJhYmxlOiEoMiZlKSx3cml0YWJsZTohKDQmZSksdmFsdWU6dH19fSx7fV0sNjc6W2Z1bmN0aW9uKGUsdCxyKXt0LmV4cG9ydHM9ZShcIi4vX2hpZGVcIil9LHtcIi4vX2hpZGVcIjo0MX1dLDY4OltmdW5jdGlvbihlLHQscil7dmFyIG49ZShcIi4vX2lzLW9iamVjdFwiKSxvPWUoXCIuL19hbi1vYmplY3RcIiksaT1mdW5jdGlvbihlLHQpe2lmKG8oZSksIW4odCkmJm51bGwhPT10KXRocm93IFR5cGVFcnJvcih0K1wiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKX07dC5leHBvcnRzPXtzZXQ6T2JqZWN0LnNldFByb3RvdHlwZU9mfHwoXCJfX3Byb3RvX19cImlue30/ZnVuY3Rpb24odCxyLG4pe3RyeXtuPWUoXCIuL19jdHhcIikoRnVuY3Rpb24uY2FsbCxlKFwiLi9fb2JqZWN0LWdvcGRcIikuZihPYmplY3QucHJvdG90eXBlLFwiX19wcm90b19fXCIpLnNldCwyKSxuKHQsW10pLHI9ISh0IGluc3RhbmNlb2YgQXJyYXkpfWNhdGNoKG8pe3I9ITB9cmV0dXJuIGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGkoZSx0KSxyP2UuX19wcm90b19fPXQ6bihlLHQpLGV9fSh7fSwhMSk6dm9pZCAwKSxjaGVjazppfX0se1wiLi9fYW4tb2JqZWN0XCI6MjcsXCIuL19jdHhcIjozMSxcIi4vX2lzLW9iamVjdFwiOjQ2LFwiLi9fb2JqZWN0LWdvcGRcIjo1N31dLDY5OltmdW5jdGlvbihlLHQscil7dmFyIG49ZShcIi4vX29iamVjdC1kcFwiKS5mLG89ZShcIi4vX2hhc1wiKSxpPWUoXCIuL193a3NcIikoXCJ0b1N0cmluZ1RhZ1wiKTt0LmV4cG9ydHM9ZnVuY3Rpb24oZSx0LHIpe2UmJiFvKGU9cj9lOmUucHJvdG90eXBlLGkpJiZuKGUsaSx7Y29uZmlndXJhYmxlOiEwLHZhbHVlOnR9KX19LHtcIi4vX2hhc1wiOjQwLFwiLi9fb2JqZWN0LWRwXCI6NTUsXCIuL193a3NcIjo4Mn1dLDcwOltmdW5jdGlvbihlLHQscil7dmFyIG49ZShcIi4vX3NoYXJlZFwiKShcImtleXNcIiksbz1lKFwiLi9fdWlkXCIpO3QuZXhwb3J0cz1mdW5jdGlvbihlKXtyZXR1cm4gbltlXXx8KG5bZV09byhlKSl9fSx7XCIuL19zaGFyZWRcIjo3MSxcIi4vX3VpZFwiOjc5fV0sNzE6W2Z1bmN0aW9uKGUsdCxyKXt2YXIgbj1lKFwiLi9fZ2xvYmFsXCIpLG89XCJfX2NvcmUtanNfc2hhcmVkX19cIixpPW5bb118fChuW29dPXt9KTt0LmV4cG9ydHM9ZnVuY3Rpb24oZSl7cmV0dXJuIGlbZV18fChpW2VdPXt9KX19LHtcIi4vX2dsb2JhbFwiOjM5fV0sNzI6W2Z1bmN0aW9uKGUsdCxyKXt2YXIgbj1lKFwiLi9fdG8taW50ZWdlclwiKSxvPWUoXCIuL19kZWZpbmVkXCIpO3QuZXhwb3J0cz1mdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24odCxyKXt2YXIgaSxhLHM9U3RyaW5nKG8odCkpLHU9bihyKSxjPXMubGVuZ3RoO3JldHVybiB1PDB8fHU+PWM/ZT9cIlwiOnZvaWQgMDooaT1zLmNoYXJDb2RlQXQodSksaTw1NTI5Nnx8aT41NjMxOXx8dSsxPT09Y3x8KGE9cy5jaGFyQ29kZUF0KHUrMSkpPDU2MzIwfHxhPjU3MzQzP2U/cy5jaGFyQXQodSk6aTplP3Muc2xpY2UodSx1KzIpOihpLTU1Mjk2PDwxMCkrKGEtNTYzMjApKzY1NTM2KX19fSx7XCIuL19kZWZpbmVkXCI6MzIsXCIuL190by1pbnRlZ2VyXCI6NzR9XSw3MzpbZnVuY3Rpb24oZSx0LHIpe3ZhciBuPWUoXCIuL190by1pbnRlZ2VyXCIpLG89TWF0aC5tYXgsaT1NYXRoLm1pbjt0LmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT1uKGUpLGU8MD9vKGUrdCwwKTppKGUsdCl9fSx7XCIuL190by1pbnRlZ2VyXCI6NzR9XSw3NDpbZnVuY3Rpb24oZSx0LHIpe3ZhciBuPU1hdGguY2VpbCxvPU1hdGguZmxvb3I7dC5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBpc05hTihlPStlKT8wOihlPjA/bzpuKShlKX19LHt9XSw3NTpbZnVuY3Rpb24oZSx0LHIpe3ZhciBuPWUoXCIuL19pb2JqZWN0XCIpLG89ZShcIi4vX2RlZmluZWRcIik7dC5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBuKG8oZSkpfX0se1wiLi9fZGVmaW5lZFwiOjMyLFwiLi9faW9iamVjdFwiOjQ0fV0sNzY6W2Z1bmN0aW9uKGUsdCxyKXt2YXIgbj1lKFwiLi9fdG8taW50ZWdlclwiKSxvPU1hdGgubWluO3QuZXhwb3J0cz1mdW5jdGlvbihlKXtyZXR1cm4gZT4wP28obihlKSw5MDA3MTk5MjU0NzQwOTkxKTowfX0se1wiLi9fdG8taW50ZWdlclwiOjc0fV0sNzc6W2Z1bmN0aW9uKGUsdCxyKXt2YXIgbj1lKFwiLi9fZGVmaW5lZFwiKTt0LmV4cG9ydHM9ZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdChuKGUpKX19LHtcIi4vX2RlZmluZWRcIjozMn1dLDc4OltmdW5jdGlvbihlLHQscil7dmFyIG49ZShcIi4vX2lzLW9iamVjdFwiKTt0LmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXtpZighbihlKSlyZXR1cm4gZTt2YXIgcixvO2lmKHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mKHI9ZS50b1N0cmluZykmJiFuKG89ci5jYWxsKGUpKSlyZXR1cm4gbztpZihcImZ1bmN0aW9uXCI9PXR5cGVvZihyPWUudmFsdWVPZikmJiFuKG89ci5jYWxsKGUpKSlyZXR1cm4gbztpZighdCYmXCJmdW5jdGlvblwiPT10eXBlb2Yocj1lLnRvU3RyaW5nKSYmIW4obz1yLmNhbGwoZSkpKXJldHVybiBvO3Rocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKX19LHtcIi4vX2lzLW9iamVjdFwiOjQ2fV0sNzk6W2Z1bmN0aW9uKGUsdCxyKXt2YXIgbj0wLG89TWF0aC5yYW5kb20oKTt0LmV4cG9ydHM9ZnVuY3Rpb24oZSl7cmV0dXJuXCJTeW1ib2woXCIuY29uY2F0KHZvaWQgMD09PWU/XCJcIjplLFwiKV9cIiwoKytuK28pLnRvU3RyaW5nKDM2KSl9fSx7fV0sODA6W2Z1bmN0aW9uKGUsdCxyKXt2YXIgbj1lKFwiLi9fZ2xvYmFsXCIpLG89ZShcIi4vX2NvcmVcIiksaT1lKFwiLi9fbGlicmFyeVwiKSxhPWUoXCIuL193a3MtZXh0XCIpLHM9ZShcIi4vX29iamVjdC1kcFwiKS5mO3QuZXhwb3J0cz1mdW5jdGlvbihlKXt2YXIgdD1vLlN5bWJvbHx8KG8uU3ltYm9sPWk/e306bi5TeW1ib2x8fHt9KTtcIl9cIj09ZS5jaGFyQXQoMCl8fGUgaW4gdHx8cyh0LGUse3ZhbHVlOmEuZihlKX0pfX0se1wiLi9fY29yZVwiOjMwLFwiLi9fZ2xvYmFsXCI6MzksXCIuL19saWJyYXJ5XCI6NTIsXCIuL19vYmplY3QtZHBcIjo1NSxcIi4vX3drcy1leHRcIjo4MX1dLDgxOltmdW5jdGlvbihlLHQscil7ci5mPWUoXCIuL193a3NcIil9LHtcIi4vX3drc1wiOjgyfV0sODI6W2Z1bmN0aW9uKGUsdCxyKXt2YXIgbj1lKFwiLi9fc2hhcmVkXCIpKFwid2tzXCIpLG89ZShcIi4vX3VpZFwiKSxpPWUoXCIuL19nbG9iYWxcIikuU3ltYm9sLGE9XCJmdW5jdGlvblwiPT10eXBlb2YgaSxzPXQuZXhwb3J0cz1mdW5jdGlvbihlKXtyZXR1cm4gbltlXXx8KG5bZV09YSYmaVtlXXx8KGE/aTpvKShcIlN5bWJvbC5cIitlKSl9O3Muc3RvcmU9bn0se1wiLi9fZ2xvYmFsXCI6MzksXCIuL19zaGFyZWRcIjo3MSxcIi4vX3VpZFwiOjc5fV0sODM6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1lKFwiLi9fYWRkLXRvLXVuc2NvcGFibGVzXCIpLG89ZShcIi4vX2l0ZXItc3RlcFwiKSxpPWUoXCIuL19pdGVyYXRvcnNcIiksYT1lKFwiLi9fdG8taW9iamVjdFwiKTt0LmV4cG9ydHM9ZShcIi4vX2l0ZXItZGVmaW5lXCIpKEFycmF5LFwiQXJyYXlcIixmdW5jdGlvbihlLHQpe3RoaXMuX3Q9YShlKSx0aGlzLl9pPTAsdGhpcy5faz10fSxmdW5jdGlvbigpe3ZhciBlPXRoaXMuX3QsdD10aGlzLl9rLHI9dGhpcy5faSsrO3JldHVybiFlfHxyPj1lLmxlbmd0aD8odGhpcy5fdD12b2lkIDAsbygxKSk6XCJrZXlzXCI9PXQ/bygwLHIpOlwidmFsdWVzXCI9PXQ/bygwLGVbcl0pOm8oMCxbcixlW3JdXSl9LFwidmFsdWVzXCIpLGkuQXJndW1lbnRzPWkuQXJyYXksbihcImtleXNcIiksbihcInZhbHVlc1wiKSxuKFwiZW50cmllc1wiKX0se1wiLi9fYWRkLXRvLXVuc2NvcGFibGVzXCI6MjYsXCIuL19pdGVyLWRlZmluZVwiOjQ4LFwiLi9faXRlci1zdGVwXCI6NDksXCIuL19pdGVyYXRvcnNcIjo1MCxcIi4vX3RvLWlvYmplY3RcIjo3NX1dLDg0OltmdW5jdGlvbihlLHQscil7dmFyIG49ZShcIi4vX2V4cG9ydFwiKTtuKG4uUyxcIk9iamVjdFwiLHtjcmVhdGU6ZShcIi4vX29iamVjdC1jcmVhdGVcIil9KX0se1wiLi9fZXhwb3J0XCI6MzcsXCIuL19vYmplY3QtY3JlYXRlXCI6NTR9XSw4NTpbZnVuY3Rpb24oZSx0LHIpe3ZhciBuPWUoXCIuL19leHBvcnRcIik7bihuLlMrbi5GKiFlKFwiLi9fZGVzY3JpcHRvcnNcIiksXCJPYmplY3RcIix7ZGVmaW5lUHJvcGVydHk6ZShcIi4vX29iamVjdC1kcFwiKS5mfSl9LHtcIi4vX2Rlc2NyaXB0b3JzXCI6MzMsXCIuL19leHBvcnRcIjozNyxcIi4vX29iamVjdC1kcFwiOjU1fV0sODY6W2Z1bmN0aW9uKGUsdCxyKXt2YXIgbj1lKFwiLi9faXMtb2JqZWN0XCIpLG89ZShcIi4vX21ldGFcIikub25GcmVlemU7ZShcIi4vX29iamVjdC1zYXBcIikoXCJmcmVlemVcIixmdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIGUmJm4odCk/ZShvKHQpKTp0fX0pfSx7XCIuL19pcy1vYmplY3RcIjo0NixcIi4vX21ldGFcIjo1MyxcIi4vX29iamVjdC1zYXBcIjo2NX1dLDg3OltmdW5jdGlvbihlLHQscil7dmFyIG49ZShcIi4vX3RvLW9iamVjdFwiKSxvPWUoXCIuL19vYmplY3QtZ3BvXCIpO2UoXCIuL19vYmplY3Qtc2FwXCIpKFwiZ2V0UHJvdG90eXBlT2ZcIixmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gbyhuKGUpKX19KX0se1wiLi9fb2JqZWN0LWdwb1wiOjYxLFwiLi9fb2JqZWN0LXNhcFwiOjY1LFwiLi9fdG8tb2JqZWN0XCI6Nzd9XSw4ODpbZnVuY3Rpb24oZSx0LHIpe3ZhciBuPWUoXCIuL190by1vYmplY3RcIiksbz1lKFwiLi9fb2JqZWN0LWtleXNcIik7ZShcIi4vX29iamVjdC1zYXBcIikoXCJrZXlzXCIsZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuIG8obihlKSl9fSl9LHtcIi4vX29iamVjdC1rZXlzXCI6NjMsXCIuL19vYmplY3Qtc2FwXCI6NjUsXCIuL190by1vYmplY3RcIjo3N31dLDg5OltmdW5jdGlvbihlLHQscil7dmFyIG49ZShcIi4vX2V4cG9ydFwiKTtuKG4uUyxcIk9iamVjdFwiLHtzZXRQcm90b3R5cGVPZjplKFwiLi9fc2V0LXByb3RvXCIpLnNldH0pfSx7XCIuL19leHBvcnRcIjozNyxcIi4vX3NldC1wcm90b1wiOjY4fV0sOTA6W2Z1bmN0aW9uKGUsdCxyKXt9LHt9XSw5MTpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPWUoXCIuL19zdHJpbmctYXRcIikoITApO2UoXCIuL19pdGVyLWRlZmluZVwiKShTdHJpbmcsXCJTdHJpbmdcIixmdW5jdGlvbihlKXt0aGlzLl90PVN0cmluZyhlKSx0aGlzLl9pPTB9LGZ1bmN0aW9uKCl7dmFyIGUsdD10aGlzLl90LHI9dGhpcy5faTtyZXR1cm4gcj49dC5sZW5ndGg/e3ZhbHVlOnZvaWQgMCxkb25lOiEwfTooZT1uKHQsciksdGhpcy5faSs9ZS5sZW5ndGgse3ZhbHVlOmUsZG9uZTohMX0pfSl9LHtcIi4vX2l0ZXItZGVmaW5lXCI6NDgsXCIuL19zdHJpbmctYXRcIjo3Mn1dLDkyOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49ZShcIi4vX2dsb2JhbFwiKSxvPWUoXCIuL19oYXNcIiksaT1lKFwiLi9fZGVzY3JpcHRvcnNcIiksYT1lKFwiLi9fZXhwb3J0XCIpLHM9ZShcIi4vX3JlZGVmaW5lXCIpLHU9ZShcIi4vX21ldGFcIikuS0VZLGM9ZShcIi4vX2ZhaWxzXCIpLGw9ZShcIi4vX3NoYXJlZFwiKSxmPWUoXCIuL19zZXQtdG8tc3RyaW5nLXRhZ1wiKSxkPWUoXCIuL191aWRcIikscD1lKFwiLi9fd2tzXCIpLGg9ZShcIi4vX3drcy1leHRcIikseT1lKFwiLi9fd2tzLWRlZmluZVwiKSxtPWUoXCIuL19rZXlvZlwiKSx2PWUoXCIuL19lbnVtLWtleXNcIiksXz1lKFwiLi9faXMtYXJyYXlcIiksYj1lKFwiLi9fYW4tb2JqZWN0XCIpLGc9ZShcIi4vX3RvLWlvYmplY3RcIiksRT1lKFwiLi9fdG8tcHJpbWl0aXZlXCIpLGo9ZShcIi4vX3Byb3BlcnR5LWRlc2NcIiksdz1lKFwiLi9fb2JqZWN0LWNyZWF0ZVwiKSxPPWUoXCIuL19vYmplY3QtZ29wbi1leHRcIiksTT1lKFwiLi9fb2JqZWN0LWdvcGRcIikseD1lKFwiLi9fb2JqZWN0LWRwXCIpLFA9ZShcIi4vX29iamVjdC1rZXlzXCIpLGs9TS5mLFI9eC5mLFM9Ty5mLFQ9bi5TeW1ib2wsQT1uLkpTT04sTj1BJiZBLnN0cmluZ2lmeSxJPVwicHJvdG90eXBlXCIsVT1wKFwiX2hpZGRlblwiKSxDPXAoXCJ0b1ByaW1pdGl2ZVwiKSxMPXt9LnByb3BlcnR5SXNFbnVtZXJhYmxlLEY9bChcInN5bWJvbC1yZWdpc3RyeVwiKSxCPWwoXCJzeW1ib2xzXCIpLEQ9bChcIm9wLXN5bWJvbHNcIiksRz1PYmplY3RbSV0sSz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBULFk9bi5RT2JqZWN0LHE9IVl8fCFZW0ldfHwhWVtJXS5maW5kQ2hpbGQsej1pJiZjKGZ1bmN0aW9uKCl7cmV0dXJuIDchPXcoUih7fSxcImFcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFIodGhpcyxcImFcIix7dmFsdWU6N30pLmF9fSkpLmF9KT9mdW5jdGlvbihlLHQscil7dmFyIG49ayhHLHQpO24mJmRlbGV0ZSBHW3RdLFIoZSx0LHIpLG4mJmUhPT1HJiZSKEcsdCxuKX06UixIPWZ1bmN0aW9uKGUpe3ZhciB0PUJbZV09dyhUW0ldKTtyZXR1cm4gdC5faz1lLHR9LFc9SyYmXCJzeW1ib2xcIj09dHlwZW9mIFQuaXRlcmF0b3I/ZnVuY3Rpb24oZSl7cmV0dXJuXCJzeW1ib2xcIj09dHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgVH0sSj1mdW5jdGlvbihlLHQscil7cmV0dXJuIGU9PT1HJiZKKEQsdCxyKSxiKGUpLHQ9RSh0LCEwKSxiKHIpLG8oQix0KT8oci5lbnVtZXJhYmxlPyhvKGUsVSkmJmVbVV1bdF0mJihlW1VdW3RdPSExKSxyPXcocix7ZW51bWVyYWJsZTpqKDAsITEpfSkpOihvKGUsVSl8fFIoZSxVLGooMSx7fSkpLGVbVV1bdF09ITApLHooZSx0LHIpKTpSKGUsdCxyKX0sVj1mdW5jdGlvbihlLHQpe2IoZSk7Zm9yKHZhciByLG49dih0PWcodCkpLG89MCxpPW4ubGVuZ3RoO2k+bzspSihlLHI9bltvKytdLHRbcl0pO3JldHVybiBlfSwkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHZvaWQgMD09PXQ/dyhlKTpWKHcoZSksdCl9LFg9ZnVuY3Rpb24oZSl7dmFyIHQ9TC5jYWxsKHRoaXMsZT1FKGUsITApKTtyZXR1cm4hKHRoaXM9PT1HJiZvKEIsZSkmJiFvKEQsZSkpJiYoISh0fHwhbyh0aGlzLGUpfHwhbyhCLGUpfHxvKHRoaXMsVSkmJnRoaXNbVV1bZV0pfHx0KX0sUT1mdW5jdGlvbihlLHQpe2lmKGU9ZyhlKSx0PUUodCwhMCksZSE9PUd8fCFvKEIsdCl8fG8oRCx0KSl7dmFyIHI9ayhlLHQpO3JldHVybiFyfHwhbyhCLHQpfHxvKGUsVSkmJmVbVV1bdF18fChyLmVudW1lcmFibGU9ITApLHJ9fSxaPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxyPVMoZyhlKSksbj1bXSxpPTA7ci5sZW5ndGg+aTspbyhCLHQ9cltpKytdKXx8dD09VXx8dD09dXx8bi5wdXNoKHQpO3JldHVybiBufSxlZT1mdW5jdGlvbihlKXtmb3IodmFyIHQscj1lPT09RyxuPVMocj9EOmcoZSkpLGk9W10sYT0wO24ubGVuZ3RoPmE7KSFvKEIsdD1uW2ErK10pfHxyJiYhbyhHLHQpfHxpLnB1c2goQlt0XSk7cmV0dXJuIGl9O0t8fChUPWZ1bmN0aW9uKCl7aWYodGhpcyBpbnN0YW5jZW9mIFQpdGhyb3cgVHlwZUVycm9yKFwiU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIVwiKTt2YXIgZT1kKGFyZ3VtZW50cy5sZW5ndGg+MD9hcmd1bWVudHNbMF06dm9pZCAwKSx0PWZ1bmN0aW9uKHIpe3RoaXM9PT1HJiZ0LmNhbGwoRCxyKSxvKHRoaXMsVSkmJm8odGhpc1tVXSxlKSYmKHRoaXNbVV1bZV09ITEpLHoodGhpcyxlLGooMSxyKSl9O3JldHVybiBpJiZxJiZ6KEcsZSx7Y29uZmlndXJhYmxlOiEwLHNldDp0fSksSChlKX0scyhUW0ldLFwidG9TdHJpbmdcIixmdW5jdGlvbigpe3JldHVybiB0aGlzLl9rfSksTS5mPVEseC5mPUosZShcIi4vX29iamVjdC1nb3BuXCIpLmY9Ty5mPVosZShcIi4vX29iamVjdC1waWVcIikuZj1YLGUoXCIuL19vYmplY3QtZ29wc1wiKS5mPWVlLGkmJiFlKFwiLi9fbGlicmFyeVwiKSYmcyhHLFwicHJvcGVydHlJc0VudW1lcmFibGVcIixYLCEwKSxoLmY9ZnVuY3Rpb24oZSl7cmV0dXJuIEgocChlKSl9KSxhKGEuRythLlcrYS5GKiFLLHtTeW1ib2w6VH0pO2Zvcih2YXIgdGU9XCJoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlc1wiLnNwbGl0KFwiLFwiKSxyZT0wO3RlLmxlbmd0aD5yZTspcCh0ZVtyZSsrXSk7Zm9yKHZhciB0ZT1QKHAuc3RvcmUpLHJlPTA7dGUubGVuZ3RoPnJlOyl5KHRlW3JlKytdKTthKGEuUythLkYqIUssXCJTeW1ib2xcIix7XCJmb3JcIjpmdW5jdGlvbihlKXtyZXR1cm4gbyhGLGUrPVwiXCIpP0ZbZV06RltlXT1UKGUpfSxrZXlGb3I6ZnVuY3Rpb24oZSl7aWYoVyhlKSlyZXR1cm4gbShGLGUpO3Rocm93IFR5cGVFcnJvcihlK1wiIGlzIG5vdCBhIHN5bWJvbCFcIil9LHVzZVNldHRlcjpmdW5jdGlvbigpe3E9ITB9LHVzZVNpbXBsZTpmdW5jdGlvbigpe3E9ITF9fSksYShhLlMrYS5GKiFLLFwiT2JqZWN0XCIse2NyZWF0ZTokLGRlZmluZVByb3BlcnR5OkosZGVmaW5lUHJvcGVydGllczpWLGdldE93blByb3BlcnR5RGVzY3JpcHRvcjpRLGdldE93blByb3BlcnR5TmFtZXM6WixnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ZWV9KSxBJiZhKGEuUythLkYqKCFLfHxjKGZ1bmN0aW9uKCl7dmFyIGU9VCgpO3JldHVyblwiW251bGxdXCIhPU4oW2VdKXx8XCJ7fVwiIT1OKHthOmV9KXx8XCJ7fVwiIT1OKE9iamVjdChlKSl9KSksXCJKU09OXCIse3N0cmluZ2lmeTpmdW5jdGlvbihlKXtpZih2b2lkIDAhPT1lJiYhVyhlKSl7Zm9yKHZhciB0LHIsbj1bZV0sbz0xO2FyZ3VtZW50cy5sZW5ndGg+bzspbi5wdXNoKGFyZ3VtZW50c1tvKytdKTtyZXR1cm4gdD1uWzFdLFwiZnVuY3Rpb25cIj09dHlwZW9mIHQmJihyPXQpLCFyJiZfKHQpfHwodD1mdW5jdGlvbihlLHQpe2lmKHImJih0PXIuY2FsbCh0aGlzLGUsdCkpLCFXKHQpKXJldHVybiB0fSksblsxXT10LE4uYXBwbHkoQSxuKX19fSksVFtJXVtDXXx8ZShcIi4vX2hpZGVcIikoVFtJXSxDLFRbSV0udmFsdWVPZiksZihULFwiU3ltYm9sXCIpLGYoTWF0aCxcIk1hdGhcIiwhMCksZihuLkpTT04sXCJKU09OXCIsITApfSx7XCIuL19hbi1vYmplY3RcIjoyNyxcIi4vX2Rlc2NyaXB0b3JzXCI6MzMsXCIuL19lbnVtLWtleXNcIjozNixcIi4vX2V4cG9ydFwiOjM3LFwiLi9fZmFpbHNcIjozOCxcIi4vX2dsb2JhbFwiOjM5LFwiLi9faGFzXCI6NDAsXCIuL19oaWRlXCI6NDEsXCIuL19pcy1hcnJheVwiOjQ1LFwiLi9fa2V5b2ZcIjo1MSxcIi4vX2xpYnJhcnlcIjo1MixcIi4vX21ldGFcIjo1MyxcIi4vX29iamVjdC1jcmVhdGVcIjo1NCxcIi4vX29iamVjdC1kcFwiOjU1LFwiLi9fb2JqZWN0LWdvcGRcIjo1NyxcIi4vX29iamVjdC1nb3BuXCI6NTksXCIuL19vYmplY3QtZ29wbi1leHRcIjo1OCxcIi4vX29iamVjdC1nb3BzXCI6NjAsXCIuL19vYmplY3Qta2V5c1wiOjYzLFwiLi9fb2JqZWN0LXBpZVwiOjY0LFwiLi9fcHJvcGVydHktZGVzY1wiOjY2LFwiLi9fcmVkZWZpbmVcIjo2NyxcIi4vX3NldC10by1zdHJpbmctdGFnXCI6NjksXCIuL19zaGFyZWRcIjo3MSxcIi4vX3RvLWlvYmplY3RcIjo3NSxcIi4vX3RvLXByaW1pdGl2ZVwiOjc4LFwiLi9fdWlkXCI6NzksXCIuL193a3NcIjo4MixcIi4vX3drcy1kZWZpbmVcIjo4MCxcIi4vX3drcy1leHRcIjo4MX1dLDkzOltmdW5jdGlvbihlLHQscil7ZShcIi4vX3drcy1kZWZpbmVcIikoXCJhc3luY0l0ZXJhdG9yXCIpfSx7XCIuL193a3MtZGVmaW5lXCI6ODB9XSw5NDpbZnVuY3Rpb24oZSx0LHIpe2UoXCIuL193a3MtZGVmaW5lXCIpKFwib2JzZXJ2YWJsZVwiKX0se1wiLi9fd2tzLWRlZmluZVwiOjgwfV0sOTU6W2Z1bmN0aW9uKGUsdCxyKXtlKFwiLi9lczYuYXJyYXkuaXRlcmF0b3JcIik7Zm9yKHZhciBuPWUoXCIuL19nbG9iYWxcIiksbz1lKFwiLi9faGlkZVwiKSxpPWUoXCIuL19pdGVyYXRvcnNcIiksYT1lKFwiLi9fd2tzXCIpKFwidG9TdHJpbmdUYWdcIikscz1bXCJOb2RlTGlzdFwiLFwiRE9NVG9rZW5MaXN0XCIsXCJNZWRpYUxpc3RcIixcIlN0eWxlU2hlZXRMaXN0XCIsXCJDU1NSdWxlTGlzdFwiXSx1PTA7dTw1O3UrKyl7dmFyIGM9c1t1XSxsPW5bY10sZj1sJiZsLnByb3RvdHlwZTtmJiYhZlthXSYmbyhmLGEsYyksaVtjXT1pLkFycmF5fX0se1wiLi9fZ2xvYmFsXCI6MzksXCIuL19oaWRlXCI6NDEsXCIuL19pdGVyYXRvcnNcIjo1MCxcIi4vX3drc1wiOjgyLFwiLi9lczYuYXJyYXkuaXRlcmF0b3JcIjo4M31dLDk2OltmdW5jdGlvbihlLHQscil7ZnVuY3Rpb24gbigpe3Rocm93IG5ldyBFcnJvcihcInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9ZnVuY3Rpb24gbygpe3Rocm93IG5ldyBFcnJvcihcImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX1mdW5jdGlvbiBpKGUpe2lmKGY9PT1zZXRUaW1lb3V0KXJldHVybiBzZXRUaW1lb3V0KGUsMCk7aWYoKGY9PT1ufHwhZikmJnNldFRpbWVvdXQpcmV0dXJuIGY9c2V0VGltZW91dCxzZXRUaW1lb3V0KGUsMCk7dHJ5e3JldHVybiBmKGUsMCl9Y2F0Y2godCl7dHJ5e3JldHVybiBmLmNhbGwobnVsbCxlLDApfWNhdGNoKHQpe3JldHVybiBmLmNhbGwodGhpcyxlLDApfX19ZnVuY3Rpb24gYShlKXtpZihkPT09Y2xlYXJUaW1lb3V0KXJldHVybiBjbGVhclRpbWVvdXQoZSk7aWYoKGQ9PT1vfHwhZCkmJmNsZWFyVGltZW91dClyZXR1cm4gZD1jbGVhclRpbWVvdXQsY2xlYXJUaW1lb3V0KGUpO3RyeXtyZXR1cm4gZChlKX1jYXRjaCh0KXt0cnl7cmV0dXJuIGQuY2FsbChudWxsLGUpfWNhdGNoKHQpe3JldHVybiBkLmNhbGwodGhpcyxlKX19fWZ1bmN0aW9uIHMoKXttJiZoJiYobT0hMSxoLmxlbmd0aD95PWguY29uY2F0KHkpOnY9LTEseS5sZW5ndGgmJnUoKSl9ZnVuY3Rpb24gdSgpe2lmKCFtKXt2YXIgZT1pKHMpO209ITA7Zm9yKHZhciB0PXkubGVuZ3RoO3Q7KXtmb3IoaD15LHk9W107Kyt2PHQ7KWgmJmhbdl0ucnVuKCk7dj0tMSx0PXkubGVuZ3RofWg9bnVsbCxtPSExLGEoZSl9fWZ1bmN0aW9uIGMoZSx0KXt0aGlzLmZ1bj1lLHRoaXMuYXJyYXk9dH1mdW5jdGlvbiBsKCl7fXZhciBmLGQscD10LmV4cG9ydHM9e307IWZ1bmN0aW9uKCl7dHJ5e2Y9XCJmdW5jdGlvblwiPT10eXBlb2Ygc2V0VGltZW91dD9zZXRUaW1lb3V0Om59Y2F0Y2goZSl7Zj1ufXRyeXtkPVwiZnVuY3Rpb25cIj09dHlwZW9mIGNsZWFyVGltZW91dD9jbGVhclRpbWVvdXQ6b31jYXRjaChlKXtkPW99fSgpO3ZhciBoLHk9W10sbT0hMSx2PS0xO3AubmV4dFRpY2s9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKWZvcih2YXIgcj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspdFtyLTFdPWFyZ3VtZW50c1tyXTt5LnB1c2gobmV3IGMoZSx0KSksMSE9PXkubGVuZ3RofHxtfHxpKHUpfSxjLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfSxwLnRpdGxlPVwiYnJvd3NlclwiLHAuYnJvd3Nlcj0hMCxwLmVudj17fSxwLmFyZ3Y9W10scC52ZXJzaW9uPVwiXCIscC52ZXJzaW9ucz17fSxwLm9uPWwscC5hZGRMaXN0ZW5lcj1sLHAub25jZT1sLHAub2ZmPWwscC5yZW1vdmVMaXN0ZW5lcj1sLHAucmVtb3ZlQWxsTGlzdGVuZXJzPWwscC5lbWl0PWwscC5iaW5kaW5nPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpfSxwLmN3ZD1mdW5jdGlvbigpe3JldHVyblwiL1wifSxwLmNoZGlyPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZFwiKX0scC51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwfX0se31dLDk3OltmdW5jdGlvbihlLHQscil7KGZ1bmN0aW9uKHIpe3ZhciBuPVwib2JqZWN0XCI9PXR5cGVvZiByP3I6XCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdz93aW5kb3c6XCJvYmplY3RcIj09dHlwZW9mIHNlbGY/c2VsZjp0aGlzLG89bi5yZWdlbmVyYXRvclJ1bnRpbWUmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG4pLmluZGV4T2YoXCJyZWdlbmVyYXRvclJ1bnRpbWVcIik+PTAsaT1vJiZuLnJlZ2VuZXJhdG9yUnVudGltZTtpZihuLnJlZ2VuZXJhdG9yUnVudGltZT12b2lkIDAsdC5leHBvcnRzPWUoXCIuL3J1bnRpbWVcIiksbyluLnJlZ2VuZXJhdG9yUnVudGltZT1pO2Vsc2UgdHJ5e2RlbGV0ZSBuLnJlZ2VuZXJhdG9yUnVudGltZX1jYXRjaChhKXtuLnJlZ2VuZXJhdG9yUnVudGltZT12b2lkIDB9fSkuY2FsbCh0aGlzLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6e30pfSx7XCIuL3J1bnRpbWVcIjo5OH1dLDk4OltmdW5jdGlvbihlLHQscil7KGZ1bmN0aW9uKGUscil7IWZ1bmN0aW9uKHIpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4oZSx0LHIsbil7dmFyIG89T2JqZWN0LmNyZWF0ZSgodHx8aSkucHJvdG90eXBlKSxhPW5ldyBoKG58fFtdKTtyZXR1cm4gby5faW52b2tlPWYoZSxyLGEpLG99ZnVuY3Rpb24gbyhlLHQscil7dHJ5e3JldHVybnt0eXBlOlwibm9ybWFsXCIsYXJnOmUuY2FsbCh0LHIpfX1jYXRjaChuKXtyZXR1cm57dHlwZTpcInRocm93XCIsYXJnOm59fX1mdW5jdGlvbiBpKCl7fWZ1bmN0aW9uIGEoKXt9ZnVuY3Rpb24gcygpe31mdW5jdGlvbiB1KGUpe1tcIm5leHRcIixcInRocm93XCIsXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbih0KXtlW3RdPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9pbnZva2UodCxlKX19KX1mdW5jdGlvbiBjKGUpe3RoaXMuYXJnPWV9ZnVuY3Rpb24gbCh0KXtmdW5jdGlvbiByKGUsbixpLGEpe3ZhciBzPW8odFtlXSx0LG4pO2lmKFwidGhyb3dcIiE9PXMudHlwZSl7dmFyIHU9cy5hcmcsbD11LnZhbHVlO3JldHVybiBsIGluc3RhbmNlb2YgYz9Qcm9taXNlLnJlc29sdmUobC5hcmcpLnRoZW4oZnVuY3Rpb24oZSl7cihcIm5leHRcIixlLGksYSl9LGZ1bmN0aW9uKGUpe3IoXCJ0aHJvd1wiLGUsaSxhKX0pOlByb21pc2UucmVzb2x2ZShsKS50aGVuKGZ1bmN0aW9uKGUpe3UudmFsdWU9ZSxpKHUpfSxhKX1hKHMuYXJnKX1mdW5jdGlvbiBuKGUsdCl7ZnVuY3Rpb24gbigpe3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihuLG8pe3IoZSx0LG4sbyl9KX1yZXR1cm4gaT1pP2kudGhlbihuLG4pOm4oKX1cIm9iamVjdFwiPT10eXBlb2YgZSYmZS5kb21haW4mJihyPWUuZG9tYWluLmJpbmQocikpO3ZhciBpO3RoaXMuX2ludm9rZT1ufWZ1bmN0aW9uIGYoZSx0LHIpe3ZhciBuPU87cmV0dXJuIGZ1bmN0aW9uKGksYSl7aWYobj09PXgpdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtpZihuPT09UCl7aWYoXCJ0aHJvd1wiPT09aSl0aHJvdyBhO3JldHVybiBtKCl9Zm9yKDs7KXt2YXIgcz1yLmRlbGVnYXRlO2lmKHMpe2lmKFwicmV0dXJuXCI9PT1pfHxcInRocm93XCI9PT1pJiZzLml0ZXJhdG9yW2ldPT09dil7ci5kZWxlZ2F0ZT1udWxsO3ZhciB1PXMuaXRlcmF0b3JbXCJyZXR1cm5cIl07aWYodSl7dmFyIGM9byh1LHMuaXRlcmF0b3IsYSk7aWYoXCJ0aHJvd1wiPT09Yy50eXBlKXtpPVwidGhyb3dcIixhPWMuYXJnO2NvbnRpbnVlfX1pZihcInJldHVyblwiPT09aSljb250aW51ZX12YXIgYz1vKHMuaXRlcmF0b3JbaV0scy5pdGVyYXRvcixhKTtpZihcInRocm93XCI9PT1jLnR5cGUpe3IuZGVsZWdhdGU9bnVsbCxpPVwidGhyb3dcIixhPWMuYXJnO2NvbnRpbnVlfWk9XCJuZXh0XCIsYT12O3ZhciBsPWMuYXJnO2lmKCFsLmRvbmUpcmV0dXJuIG49TSxsO3Jbcy5yZXN1bHROYW1lXT1sLnZhbHVlLHIubmV4dD1zLm5leHRMb2Msci5kZWxlZ2F0ZT1udWxsfWlmKFwibmV4dFwiPT09aSlyLnNlbnQ9ci5fc2VudD1hO2Vsc2UgaWYoXCJ0aHJvd1wiPT09aSl7aWYobj09PU8pdGhyb3cgbj1QLGE7ci5kaXNwYXRjaEV4Y2VwdGlvbihhKSYmKGk9XCJuZXh0XCIsYT12KX1lbHNlXCJyZXR1cm5cIj09PWkmJnIuYWJydXB0KFwicmV0dXJuXCIsYSk7bj14O3ZhciBjPW8oZSx0LHIpO2lmKFwibm9ybWFsXCI9PT1jLnR5cGUpe249ci5kb25lP1A6TTt2YXIgbD17dmFsdWU6Yy5hcmcsZG9uZTpyLmRvbmV9O2lmKGMuYXJnIT09aylyZXR1cm4gbDtyLmRlbGVnYXRlJiZcIm5leHRcIj09PWkmJihhPXYpfWVsc2VcInRocm93XCI9PT1jLnR5cGUmJihuPVAsaT1cInRocm93XCIsYT1jLmFyZyl9fX1mdW5jdGlvbiBkKGUpe3ZhciB0PXt0cnlMb2M6ZVswXX07MSBpbiBlJiYodC5jYXRjaExvYz1lWzFdKSwyIGluIGUmJih0LmZpbmFsbHlMb2M9ZVsyXSx0LmFmdGVyTG9jPWVbM10pLHRoaXMudHJ5RW50cmllcy5wdXNoKHQpfWZ1bmN0aW9uIHAoZSl7dmFyIHQ9ZS5jb21wbGV0aW9ufHx7fTt0LnR5cGU9XCJub3JtYWxcIixkZWxldGUgdC5hcmcsZS5jb21wbGV0aW9uPXR9ZnVuY3Rpb24gaChlKXt0aGlzLnRyeUVudHJpZXM9W3t0cnlMb2M6XCJyb290XCJ9XSxlLmZvckVhY2goZCx0aGlzKSx0aGlzLnJlc2V0KCEwKX1mdW5jdGlvbiB5KGUpe2lmKGUpe3ZhciB0PWVbZ107aWYodClyZXR1cm4gdC5jYWxsKGUpO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUubmV4dClyZXR1cm4gZTtpZighaXNOYU4oZS5sZW5ndGgpKXt2YXIgcj0tMSxuPWZ1bmN0aW9uIG8oKXtmb3IoOysrcjxlLmxlbmd0aDspaWYoXy5jYWxsKGUscikpcmV0dXJuIG8udmFsdWU9ZVtyXSxvLmRvbmU9ITEsbztyZXR1cm4gby52YWx1ZT12LG8uZG9uZT0hMCxvfTtyZXR1cm4gbi5uZXh0PW59fXJldHVybntuZXh0Om19fWZ1bmN0aW9uIG0oKXtyZXR1cm57dmFsdWU6dixkb25lOiEwfX12YXIgdixfPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksYj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2w/U3ltYm9sOnt9LGc9Yi5pdGVyYXRvcnx8XCJAQGl0ZXJhdG9yXCIsRT1iLnRvU3RyaW5nVGFnfHxcIkBAdG9TdHJpbmdUYWdcIixqPVwib2JqZWN0XCI9PXR5cGVvZiB0LHc9ci5yZWdlbmVyYXRvclJ1bnRpbWU7aWYodylyZXR1cm4gdm9pZChqJiYodC5leHBvcnRzPXcpKTt3PXIucmVnZW5lcmF0b3JSdW50aW1lPWo/dC5leHBvcnRzOnt9LHcud3JhcD1uO3ZhciBPPVwic3VzcGVuZGVkU3RhcnRcIixNPVwic3VzcGVuZGVkWWllbGRcIix4PVwiZXhlY3V0aW5nXCIsUD1cImNvbXBsZXRlZFwiLGs9e30sUj1zLnByb3RvdHlwZT1pLnByb3RvdHlwZTthLnByb3RvdHlwZT1SLmNvbnN0cnVjdG9yPXMscy5jb25zdHJ1Y3Rvcj1hLHNbRV09YS5kaXNwbGF5TmFtZT1cIkdlbmVyYXRvckZ1bmN0aW9uXCIsdy5pc0dlbmVyYXRvckZ1bmN0aW9uPWZ1bmN0aW9uKGUpe3ZhciB0PVwiZnVuY3Rpb25cIj09dHlwZW9mIGUmJmUuY29uc3RydWN0b3I7cmV0dXJuISF0JiYodD09PWF8fFwiR2VuZXJhdG9yRnVuY3Rpb25cIj09PSh0LmRpc3BsYXlOYW1lfHx0Lm5hbWUpKX0sdy5tYXJrPWZ1bmN0aW9uKGUpe3JldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKGUscyk6KGUuX19wcm90b19fPXMsRSBpbiBlfHwoZVtFXT1cIkdlbmVyYXRvckZ1bmN0aW9uXCIpKSxcbmUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoUiksZX0sdy5hd3JhcD1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IGMoZSl9LHUobC5wcm90b3R5cGUpLHcuYXN5bmM9ZnVuY3Rpb24oZSx0LHIsbyl7dmFyIGk9bmV3IGwobihlLHQscixvKSk7cmV0dXJuIHcuaXNHZW5lcmF0b3JGdW5jdGlvbih0KT9pOmkubmV4dCgpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIGUuZG9uZT9lLnZhbHVlOmkubmV4dCgpfSl9LHUoUiksUltnXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSxSW0VdPVwiR2VuZXJhdG9yXCIsUi50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiW29iamVjdCBHZW5lcmF0b3JdXCJ9LHcua2V5cz1mdW5jdGlvbihlKXt2YXIgdD1bXTtmb3IodmFyIHIgaW4gZSl0LnB1c2gocik7cmV0dXJuIHQucmV2ZXJzZSgpLGZ1bmN0aW9uIG4oKXtmb3IoO3QubGVuZ3RoOyl7dmFyIHI9dC5wb3AoKTtpZihyIGluIGUpcmV0dXJuIG4udmFsdWU9cixuLmRvbmU9ITEsbn1yZXR1cm4gbi5kb25lPSEwLG59fSx3LnZhbHVlcz15LGgucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpoLHJlc2V0OmZ1bmN0aW9uKGUpe2lmKHRoaXMucHJldj0wLHRoaXMubmV4dD0wLHRoaXMuc2VudD10aGlzLl9zZW50PXYsdGhpcy5kb25lPSExLHRoaXMuZGVsZWdhdGU9bnVsbCx0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChwKSwhZSlmb3IodmFyIHQgaW4gdGhpcylcInRcIj09PXQuY2hhckF0KDApJiZfLmNhbGwodGhpcyx0KSYmIWlzTmFOKCt0LnNsaWNlKDEpKSYmKHRoaXNbdF09dil9LHN0b3A6ZnVuY3Rpb24oKXt0aGlzLmRvbmU9ITA7dmFyIGU9dGhpcy50cnlFbnRyaWVzWzBdLHQ9ZS5jb21wbGV0aW9uO2lmKFwidGhyb3dcIj09PXQudHlwZSl0aHJvdyB0LmFyZztyZXR1cm4gdGhpcy5ydmFsfSxkaXNwYXRjaEV4Y2VwdGlvbjpmdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQsbil7cmV0dXJuIGkudHlwZT1cInRocm93XCIsaS5hcmc9ZSxyLm5leHQ9dCwhIW59aWYodGhpcy5kb25lKXRocm93IGU7Zm9yKHZhciByPXRoaXMsbj10aGlzLnRyeUVudHJpZXMubGVuZ3RoLTE7bj49MDstLW4pe3ZhciBvPXRoaXMudHJ5RW50cmllc1tuXSxpPW8uY29tcGxldGlvbjtpZihcInJvb3RcIj09PW8udHJ5TG9jKXJldHVybiB0KFwiZW5kXCIpO2lmKG8udHJ5TG9jPD10aGlzLnByZXYpe3ZhciBhPV8uY2FsbChvLFwiY2F0Y2hMb2NcIikscz1fLmNhbGwobyxcImZpbmFsbHlMb2NcIik7aWYoYSYmcyl7aWYodGhpcy5wcmV2PG8uY2F0Y2hMb2MpcmV0dXJuIHQoby5jYXRjaExvYywhMCk7aWYodGhpcy5wcmV2PG8uZmluYWxseUxvYylyZXR1cm4gdChvLmZpbmFsbHlMb2MpfWVsc2UgaWYoYSl7aWYodGhpcy5wcmV2PG8uY2F0Y2hMb2MpcmV0dXJuIHQoby5jYXRjaExvYywhMCl9ZWxzZXtpZighcyl0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtpZih0aGlzLnByZXY8by5maW5hbGx5TG9jKXJldHVybiB0KG8uZmluYWxseUxvYyl9fX19LGFicnVwdDpmdW5jdGlvbihlLHQpe2Zvcih2YXIgcj10aGlzLnRyeUVudHJpZXMubGVuZ3RoLTE7cj49MDstLXIpe3ZhciBuPXRoaXMudHJ5RW50cmllc1tyXTtpZihuLnRyeUxvYzw9dGhpcy5wcmV2JiZfLmNhbGwobixcImZpbmFsbHlMb2NcIikmJnRoaXMucHJldjxuLmZpbmFsbHlMb2Mpe3ZhciBvPW47YnJlYWt9fW8mJihcImJyZWFrXCI9PT1lfHxcImNvbnRpbnVlXCI9PT1lKSYmby50cnlMb2M8PXQmJnQ8PW8uZmluYWxseUxvYyYmKG89bnVsbCk7dmFyIGk9bz9vLmNvbXBsZXRpb246e307cmV0dXJuIGkudHlwZT1lLGkuYXJnPXQsbz90aGlzLm5leHQ9by5maW5hbGx5TG9jOnRoaXMuY29tcGxldGUoaSksa30sY29tcGxldGU6ZnVuY3Rpb24oZSx0KXtpZihcInRocm93XCI9PT1lLnR5cGUpdGhyb3cgZS5hcmc7XCJicmVha1wiPT09ZS50eXBlfHxcImNvbnRpbnVlXCI9PT1lLnR5cGU/dGhpcy5uZXh0PWUuYXJnOlwicmV0dXJuXCI9PT1lLnR5cGU/KHRoaXMucnZhbD1lLmFyZyx0aGlzLm5leHQ9XCJlbmRcIik6XCJub3JtYWxcIj09PWUudHlwZSYmdCYmKHRoaXMubmV4dD10KX0sZmluaXNoOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD10aGlzLnRyeUVudHJpZXMubGVuZ3RoLTE7dD49MDstLXQpe3ZhciByPXRoaXMudHJ5RW50cmllc1t0XTtpZihyLmZpbmFsbHlMb2M9PT1lKXJldHVybiB0aGlzLmNvbXBsZXRlKHIuY29tcGxldGlvbixyLmFmdGVyTG9jKSxwKHIpLGt9fSxcImNhdGNoXCI6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PXRoaXMudHJ5RW50cmllcy5sZW5ndGgtMTt0Pj0wOy0tdCl7dmFyIHI9dGhpcy50cnlFbnRyaWVzW3RdO2lmKHIudHJ5TG9jPT09ZSl7dmFyIG49ci5jb21wbGV0aW9uO2lmKFwidGhyb3dcIj09PW4udHlwZSl7dmFyIG89bi5hcmc7cChyKX1yZXR1cm4gb319dGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpfSxkZWxlZ2F0ZVlpZWxkOmZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZT17aXRlcmF0b3I6eShlKSxyZXN1bHROYW1lOnQsbmV4dExvYzpyfSxrfX19KFwib2JqZWN0XCI9PXR5cGVvZiByP3I6XCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdz93aW5kb3c6XCJvYmplY3RcIj09dHlwZW9mIHNlbGY/c2VsZjp0aGlzKX0pLmNhbGwodGhpcyxlKFwiX3Byb2Nlc3NcIiksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjpcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzp7fSl9LHtfcHJvY2Vzczo5Nn1dLDk5OltmdW5jdGlvbih0LHIsbil7IWZ1bmN0aW9uKHQsbil7XCJmdW5jdGlvblwiPT10eXBlb2YgZSYmZS5hbWQ/ZShbXSxuKTpcInVuZGVmaW5lZFwiIT10eXBlb2YgciYmci5leHBvcnRzP3IuZXhwb3J0cz1uKCk6dC50djQ9bigpfSh0aGlzLGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXtyZXR1cm4gZW5jb2RlVVJJKGUpLnJlcGxhY2UoLyUyNVswLTldWzAtOV0vZyxmdW5jdGlvbihlKXtyZXR1cm5cIiVcIitlLnN1YnN0cmluZygzKX0pfWZ1bmN0aW9uIHQodCl7dmFyIHI9XCJcIjtkW3QuY2hhckF0KDApXSYmKHI9dC5jaGFyQXQoMCksdD10LnN1YnN0cmluZygxKSk7dmFyIG49XCJcIixvPVwiXCIsaT0hMCxhPSExLHM9ITE7XCIrXCI9PT1yP2k9ITE6XCIuXCI9PT1yPyhvPVwiLlwiLG49XCIuXCIpOlwiL1wiPT09cj8obz1cIi9cIixuPVwiL1wiKTpcIiNcIj09PXI/KG89XCIjXCIsaT0hMSk6XCI7XCI9PT1yPyhvPVwiO1wiLG49XCI7XCIsYT0hMCxzPSEwKTpcIj9cIj09PXI/KG89XCI/XCIsbj1cIiZcIixhPSEwKTpcIiZcIj09PXImJihvPVwiJlwiLG49XCImXCIsYT0hMCk7Zm9yKHZhciB1PVtdLGM9dC5zcGxpdChcIixcIiksbD1bXSxmPXt9LGg9MDtoPGMubGVuZ3RoO2grKyl7dmFyIHk9Y1toXSxtPW51bGw7aWYoeS5pbmRleE9mKFwiOlwiKSE9PS0xKXt2YXIgdj15LnNwbGl0KFwiOlwiKTt5PXZbMF0sbT1wYXJzZUludCh2WzFdLDEwKX1mb3IodmFyIF89e307cFt5LmNoYXJBdCh5Lmxlbmd0aC0xKV07KV9beS5jaGFyQXQoeS5sZW5ndGgtMSldPSEwLHk9eS5zdWJzdHJpbmcoMCx5Lmxlbmd0aC0xKTt2YXIgYj17dHJ1bmNhdGU6bSxuYW1lOnksc3VmZmljZXM6X307bC5wdXNoKGIpLGZbeV09Yix1LnB1c2goeSl9dmFyIGc9ZnVuY3Rpb24odCl7Zm9yKHZhciByPVwiXCIsdT0wLGM9MDtjPGwubGVuZ3RoO2MrKyl7dmFyIGY9bFtjXSxkPXQoZi5uYW1lKTtpZihudWxsPT09ZHx8dm9pZCAwPT09ZHx8QXJyYXkuaXNBcnJheShkKSYmMD09PWQubGVuZ3RofHxcIm9iamVjdFwiPT10eXBlb2YgZCYmMD09PU9iamVjdC5rZXlzKGQpLmxlbmd0aCl1Kys7ZWxzZSBpZihyKz1jPT09dT9vOm58fFwiLFwiLEFycmF5LmlzQXJyYXkoZCkpe2EmJihyKz1mLm5hbWUrXCI9XCIpO2Zvcih2YXIgcD0wO3A8ZC5sZW5ndGg7cCsrKXA+MCYmKHIrPWYuc3VmZmljZXNbXCIqXCJdP258fFwiLFwiOlwiLFwiLGYuc3VmZmljZXNbXCIqXCJdJiZhJiYocis9Zi5uYW1lK1wiPVwiKSkscis9aT9lbmNvZGVVUklDb21wb25lbnQoZFtwXSkucmVwbGFjZSgvIS9nLFwiJTIxXCIpOmUoZFtwXSl9ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgZCl7YSYmIWYuc3VmZmljZXNbXCIqXCJdJiYocis9Zi5uYW1lK1wiPVwiKTt2YXIgaD0hMDtmb3IodmFyIHkgaW4gZClofHwocis9Zi5zdWZmaWNlc1tcIipcIl0/bnx8XCIsXCI6XCIsXCIpLGg9ITEscis9aT9lbmNvZGVVUklDb21wb25lbnQoeSkucmVwbGFjZSgvIS9nLFwiJTIxXCIpOmUoeSkscis9Zi5zdWZmaWNlc1tcIipcIl0/XCI9XCI6XCIsXCIscis9aT9lbmNvZGVVUklDb21wb25lbnQoZFt5XSkucmVwbGFjZSgvIS9nLFwiJTIxXCIpOmUoZFt5XSl9ZWxzZSBhJiYocis9Zi5uYW1lLHMmJlwiXCI9PT1kfHwocis9XCI9XCIpKSxudWxsIT1mLnRydW5jYXRlJiYoZD1kLnN1YnN0cmluZygwLGYudHJ1bmNhdGUpKSxyKz1pP2VuY29kZVVSSUNvbXBvbmVudChkKS5yZXBsYWNlKC8hL2csXCIlMjFcIik6ZShkKX1yZXR1cm4gcn07cmV0dXJuIGcudmFyTmFtZXM9dSx7cHJlZml4Om8sc3Vic3RpdHV0aW9uOmd9fWZ1bmN0aW9uIHIoZSl7aWYoISh0aGlzIGluc3RhbmNlb2YgcikpcmV0dXJuIG5ldyByKGUpO2Zvcih2YXIgbj1lLnNwbGl0KFwie1wiKSxvPVtuLnNoaWZ0KCldLGk9W10sYT1bXSxzPVtdO24ubGVuZ3RoPjA7KXt2YXIgdT1uLnNoaWZ0KCksYz11LnNwbGl0KFwifVwiKVswXSxsPXUuc3Vic3RyaW5nKGMubGVuZ3RoKzEpLGY9dChjKTthLnB1c2goZi5zdWJzdGl0dXRpb24pLGkucHVzaChmLnByZWZpeCksby5wdXNoKGwpLHM9cy5jb25jYXQoZi5zdWJzdGl0dXRpb24udmFyTmFtZXMpfXRoaXMuZmlsbD1mdW5jdGlvbihlKXtmb3IodmFyIHQ9b1swXSxyPTA7cjxhLmxlbmd0aDtyKyspe3ZhciBuPWFbcl07dCs9bihlKSx0Kz1vW3IrMV19cmV0dXJuIHR9LHRoaXMudmFyTmFtZXM9cyx0aGlzLnRlbXBsYXRlPWV9ZnVuY3Rpb24gbihlLHQpe2lmKGU9PT10KXJldHVybiEwO2lmKGUmJnQmJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZcIm9iamVjdFwiPT10eXBlb2YgdCl7aWYoQXJyYXkuaXNBcnJheShlKSE9PUFycmF5LmlzQXJyYXkodCkpcmV0dXJuITE7aWYoQXJyYXkuaXNBcnJheShlKSl7aWYoZS5sZW5ndGghPT10Lmxlbmd0aClyZXR1cm4hMTtmb3IodmFyIHI9MDtyPGUubGVuZ3RoO3IrKylpZighbihlW3JdLHRbcl0pKXJldHVybiExfWVsc2V7dmFyIG87Zm9yKG8gaW4gZSlpZih2b2lkIDA9PT10W29dJiZ2b2lkIDAhPT1lW29dKXJldHVybiExO2ZvcihvIGluIHQpaWYodm9pZCAwPT09ZVtvXSYmdm9pZCAwIT09dFtvXSlyZXR1cm4hMTtmb3IobyBpbiBlKWlmKCFuKGVbb10sdFtvXSkpcmV0dXJuITF9cmV0dXJuITB9cmV0dXJuITF9ZnVuY3Rpb24gbyhlKXt2YXIgdD1TdHJpbmcoZSkucmVwbGFjZSgvXlxccyt8XFxzKyQvZyxcIlwiKS5tYXRjaCgvXihbXjpcXC8/I10rOik/KFxcL1xcLyg/OlteOkBdKig/OjpbXjpAXSopP0ApPygoW146XFwvPyNdKikoPzo6KFxcZCopKT8pKT8oW14/I10qKShcXD9bXiNdKik/KCNbXFxzXFxTXSopPy8pO3JldHVybiB0P3tocmVmOnRbMF18fFwiXCIscHJvdG9jb2w6dFsxXXx8XCJcIixhdXRob3JpdHk6dFsyXXx8XCJcIixob3N0OnRbM118fFwiXCIsaG9zdG5hbWU6dFs0XXx8XCJcIixwb3J0OnRbNV18fFwiXCIscGF0aG5hbWU6dFs2XXx8XCJcIixzZWFyY2g6dFs3XXx8XCJcIixoYXNoOnRbOF18fFwiXCJ9Om51bGx9ZnVuY3Rpb24gaShlLHQpe2Z1bmN0aW9uIHIoZSl7dmFyIHQ9W107cmV0dXJuIGUucmVwbGFjZSgvXihcXC5cXC4/KFxcL3wkKSkrLyxcIlwiKS5yZXBsYWNlKC9cXC8oXFwuKFxcL3wkKSkrL2csXCIvXCIpLnJlcGxhY2UoL1xcL1xcLlxcLiQvLFwiLy4uL1wiKS5yZXBsYWNlKC9cXC8/W15cXC9dKi9nLGZ1bmN0aW9uKGUpe1wiLy4uXCI9PT1lP3QucG9wKCk6dC5wdXNoKGUpfSksdC5qb2luKFwiXCIpLnJlcGxhY2UoL15cXC8vLFwiL1wiPT09ZS5jaGFyQXQoMCk/XCIvXCI6XCJcIil9cmV0dXJuIHQ9byh0fHxcIlwiKSxlPW8oZXx8XCJcIiksdCYmZT8odC5wcm90b2NvbHx8ZS5wcm90b2NvbCkrKHQucHJvdG9jb2x8fHQuYXV0aG9yaXR5P3QuYXV0aG9yaXR5OmUuYXV0aG9yaXR5KStyKHQucHJvdG9jb2x8fHQuYXV0aG9yaXR5fHxcIi9cIj09PXQucGF0aG5hbWUuY2hhckF0KDApP3QucGF0aG5hbWU6dC5wYXRobmFtZT8oZS5hdXRob3JpdHkmJiFlLnBhdGhuYW1lP1wiL1wiOlwiXCIpK2UucGF0aG5hbWUuc2xpY2UoMCxlLnBhdGhuYW1lLmxhc3RJbmRleE9mKFwiL1wiKSsxKSt0LnBhdGhuYW1lOmUucGF0aG5hbWUpKyh0LnByb3RvY29sfHx0LmF1dGhvcml0eXx8dC5wYXRobmFtZT90LnNlYXJjaDp0LnNlYXJjaHx8ZS5zZWFyY2gpK3QuaGFzaDpudWxsfWZ1bmN0aW9uIGEoZSl7cmV0dXJuIGUuc3BsaXQoXCIjXCIpWzBdfWZ1bmN0aW9uIHMoZSx0KXtpZihlJiZcIm9iamVjdFwiPT10eXBlb2YgZSlpZih2b2lkIDA9PT10P3Q9ZS5pZDpcInN0cmluZ1wiPT10eXBlb2YgZS5pZCYmKHQ9aSh0LGUuaWQpLGUuaWQ9dCksQXJyYXkuaXNBcnJheShlKSlmb3IodmFyIHI9MDtyPGUubGVuZ3RoO3IrKylzKGVbcl0sdCk7ZWxzZXtcInN0cmluZ1wiPT10eXBlb2YgZS4kcmVmJiYoZS4kcmVmPWkodCxlLiRyZWYpKTtmb3IodmFyIG4gaW4gZSlcImVudW1cIiE9PW4mJnMoZVtuXSx0KX19ZnVuY3Rpb24gdShlKXtlPWV8fFwiZW5cIjt2YXIgdD1FW2VdO3JldHVybiBmdW5jdGlvbihlKXt2YXIgcj10W2UuY29kZV18fGdbZS5jb2RlXTtpZihcInN0cmluZ1wiIT10eXBlb2YgcilyZXR1cm5cIlVua25vd24gZXJyb3IgY29kZSBcIitlLmNvZGUrXCI6IFwiK0pTT04uc3RyaW5naWZ5KGUubWVzc2FnZVBhcmFtcyk7dmFyIG49ZS5wYXJhbXM7cmV0dXJuIHIucmVwbGFjZSgvXFx7KFtee31dKilcXH0vZyxmdW5jdGlvbihlLHQpe3ZhciByPW5bdF07cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHJ8fFwibnVtYmVyXCI9PXR5cGVvZiByP3I6ZX0pfX1mdW5jdGlvbiBjKGUsdCxyLG4sbyl7aWYoRXJyb3IuY2FsbCh0aGlzKSx2b2lkIDA9PT1lKXRocm93IG5ldyBFcnJvcihcIk5vIGVycm9yIGNvZGUgc3VwcGxpZWQ6IFwiK24pO3RoaXMubWVzc2FnZT1cIlwiLHRoaXMucGFyYW1zPXQsdGhpcy5jb2RlPWUsdGhpcy5kYXRhUGF0aD1yfHxcIlwiLHRoaXMuc2NoZW1hUGF0aD1ufHxcIlwiLHRoaXMuc3ViRXJyb3JzPW98fG51bGw7dmFyIGk9bmV3IEVycm9yKHRoaXMubWVzc2FnZSk7aWYodGhpcy5zdGFjaz1pLnN0YWNrfHxpLnN0YWNrdHJhY2UsIXRoaXMuc3RhY2spdHJ5e3Rocm93IGl9Y2F0Y2goaSl7dGhpcy5zdGFjaz1pLnN0YWNrfHxpLnN0YWNrdHJhY2V9fWZ1bmN0aW9uIGwoZSx0KXtpZih0LnN1YnN0cmluZygwLGUubGVuZ3RoKT09PWUpe3ZhciByPXQuc3Vic3RyaW5nKGUubGVuZ3RoKTtpZih0Lmxlbmd0aD4wJiZcIi9cIj09PXQuY2hhckF0KGUubGVuZ3RoLTEpfHxcIiNcIj09PXIuY2hhckF0KDApfHxcIj9cIj09PXIuY2hhckF0KDApKXJldHVybiEwfXJldHVybiExfWZ1bmN0aW9uIGYoZSl7dmFyIHQscixuPW5ldyBoLG89e3NldEVycm9yUmVwb3J0ZXI6ZnVuY3Rpb24oZSl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGU/dGhpcy5sYW5ndWFnZShlKToocj1lLCEwKX0sYWRkRm9ybWF0OmZ1bmN0aW9uKCl7bi5hZGRGb3JtYXQuYXBwbHkobixhcmd1bWVudHMpfSxsYW5ndWFnZTpmdW5jdGlvbihlKXtyZXR1cm4gZT8oRVtlXXx8KGU9ZS5zcGxpdChcIi1cIilbMF0pLCEhRVtlXSYmKHQ9ZSxlKSk6dH0sYWRkTGFuZ3VhZ2U6ZnVuY3Rpb24oZSx0KXt2YXIgcjtmb3IociBpbiB2KXRbcl0mJiF0W3Zbcl1dJiYodFt2W3JdXT10W3JdKTt2YXIgbj1lLnNwbGl0KFwiLVwiKVswXTtpZihFW25dKXtFW2VdPU9iamVjdC5jcmVhdGUoRVtuXSk7Zm9yKHIgaW4gdClcInVuZGVmaW5lZFwiPT10eXBlb2YgRVtuXVtyXSYmKEVbbl1bcl09dFtyXSksRVtlXVtyXT10W3JdfWVsc2UgRVtlXT10LEVbbl09dDtyZXR1cm4gdGhpc30sZnJlc2hBcGk6ZnVuY3Rpb24oZSl7dmFyIHQ9ZigpO3JldHVybiBlJiZ0Lmxhbmd1YWdlKGUpLHR9LHZhbGlkYXRlOmZ1bmN0aW9uKGUsbyxpLGEpe3ZhciBzPXUodCksYz1yP2Z1bmN0aW9uKGUsdCxuKXtyZXR1cm4gcihlLHQsbil8fHMoZSx0LG4pfTpzLGw9bmV3IGgobiwoITEpLGMsaSxhKTtcInN0cmluZ1wiPT10eXBlb2YgbyYmKG89eyRyZWY6b30pLGwuYWRkU2NoZW1hKFwiXCIsbyk7dmFyIGY9bC52YWxpZGF0ZUFsbChlLG8sbnVsbCxudWxsLFwiXCIpO3JldHVybiFmJiZhJiYoZj1sLmJhblVua25vd25Qcm9wZXJ0aWVzKGUsbykpLHRoaXMuZXJyb3I9Zix0aGlzLm1pc3Npbmc9bC5taXNzaW5nLHRoaXMudmFsaWQ9bnVsbD09PWYsdGhpcy52YWxpZH0sdmFsaWRhdGVSZXN1bHQ6ZnVuY3Rpb24oKXt2YXIgZT17fTtyZXR1cm4gdGhpcy52YWxpZGF0ZS5hcHBseShlLGFyZ3VtZW50cyksZX0sdmFsaWRhdGVNdWx0aXBsZTpmdW5jdGlvbihlLG8saSxhKXt2YXIgcz11KHQpLGM9cj9mdW5jdGlvbihlLHQsbil7cmV0dXJuIHIoZSx0LG4pfHxzKGUsdCxuKX06cyxsPW5ldyBoKG4sKCEwKSxjLGksYSk7XCJzdHJpbmdcIj09dHlwZW9mIG8mJihvPXskcmVmOm99KSxsLmFkZFNjaGVtYShcIlwiLG8pLGwudmFsaWRhdGVBbGwoZSxvLG51bGwsbnVsbCxcIlwiKSxhJiZsLmJhblVua25vd25Qcm9wZXJ0aWVzKGUsbyk7dmFyIGY9e307cmV0dXJuIGYuZXJyb3JzPWwuZXJyb3JzLGYubWlzc2luZz1sLm1pc3NpbmcsZi52YWxpZD0wPT09Zi5lcnJvcnMubGVuZ3RoLGZ9LGFkZFNjaGVtYTpmdW5jdGlvbigpe3JldHVybiBuLmFkZFNjaGVtYS5hcHBseShuLGFyZ3VtZW50cyl9LGdldFNjaGVtYTpmdW5jdGlvbigpe3JldHVybiBuLmdldFNjaGVtYS5hcHBseShuLGFyZ3VtZW50cyl9LGdldFNjaGVtYU1hcDpmdW5jdGlvbigpe3JldHVybiBuLmdldFNjaGVtYU1hcC5hcHBseShuLGFyZ3VtZW50cyl9LGdldFNjaGVtYVVyaXM6ZnVuY3Rpb24oKXtyZXR1cm4gbi5nZXRTY2hlbWFVcmlzLmFwcGx5KG4sYXJndW1lbnRzKX0sZ2V0TWlzc2luZ1VyaXM6ZnVuY3Rpb24oKXtyZXR1cm4gbi5nZXRNaXNzaW5nVXJpcy5hcHBseShuLGFyZ3VtZW50cyl9LGRyb3BTY2hlbWFzOmZ1bmN0aW9uKCl7bi5kcm9wU2NoZW1hcy5hcHBseShuLGFyZ3VtZW50cyl9LGRlZmluZUtleXdvcmQ6ZnVuY3Rpb24oKXtuLmRlZmluZUtleXdvcmQuYXBwbHkobixhcmd1bWVudHMpfSxkZWZpbmVFcnJvcjpmdW5jdGlvbihlLHQscil7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGV8fCEvXltBLVpdKyhfW0EtWl0rKSokLy50ZXN0KGUpKXRocm93IG5ldyBFcnJvcihcIkNvZGUgbmFtZSBtdXN0IGJlIGEgc3RyaW5nIGluIFVQUEVSX0NBU0VfV0lUSF9VTkRFUlNDT1JFU1wiKTtpZihcIm51bWJlclwiIT10eXBlb2YgdHx8dCUxIT09MHx8dDwxZTQpdGhyb3cgbmV3IEVycm9yKFwiQ29kZSBudW1iZXIgbXVzdCBiZSBhbiBpbnRlZ2VyID4gMTAwMDBcIik7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHZbZV0pdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgYWxyZWFkeSBkZWZpbmVkOiBcIitlK1wiIGFzIFwiK3ZbZV0pO2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBfW3RdKXRocm93IG5ldyBFcnJvcihcIkVycm9yIGNvZGUgYWxyZWFkeSB1c2VkOiBcIitfW3RdK1wiIGFzIFwiK3QpO3ZbZV09dCxfW3RdPWUsZ1tlXT1nW3RdPXI7Zm9yKHZhciBuIGluIEUpe3ZhciBvPUVbbl07b1tlXSYmKG9bdF09b1t0XXx8b1tlXSl9fSxyZXNldDpmdW5jdGlvbigpe24ucmVzZXQoKSx0aGlzLmVycm9yPW51bGwsdGhpcy5taXNzaW5nPVtdLHRoaXMudmFsaWQ9ITB9LG1pc3Npbmc6W10sZXJyb3I6bnVsbCx2YWxpZDohMCxub3JtU2NoZW1hOnMscmVzb2x2ZVVybDppLGdldERvY3VtZW50VXJpOmEsZXJyb3JDb2Rlczp2fTtyZXR1cm4gby5sYW5ndWFnZShlfHxcImVuXCIpLG99T2JqZWN0LmtleXN8fChPYmplY3Qua2V5cz1mdW5jdGlvbigpe3ZhciBlPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksdD0he3RvU3RyaW5nOm51bGx9LnByb3BlcnR5SXNFbnVtZXJhYmxlKFwidG9TdHJpbmdcIikscj1bXCJ0b1N0cmluZ1wiLFwidG9Mb2NhbGVTdHJpbmdcIixcInZhbHVlT2ZcIixcImhhc093blByb3BlcnR5XCIsXCJpc1Byb3RvdHlwZU9mXCIsXCJwcm9wZXJ0eUlzRW51bWVyYWJsZVwiLFwiY29uc3RydWN0b3JcIl0sbj1yLmxlbmd0aDtyZXR1cm4gZnVuY3Rpb24obyl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIG8mJlwiZnVuY3Rpb25cIiE9dHlwZW9mIG98fG51bGw9PT1vKXRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3Qua2V5cyBjYWxsZWQgb24gbm9uLW9iamVjdFwiKTt2YXIgaT1bXTtmb3IodmFyIGEgaW4gbyllLmNhbGwobyxhKSYmaS5wdXNoKGEpO2lmKHQpZm9yKHZhciBzPTA7czxuO3MrKyllLmNhbGwobyxyW3NdKSYmaS5wdXNoKHJbc10pO3JldHVybiBpfX0oKSksT2JqZWN0LmNyZWF0ZXx8KE9iamVjdC5jcmVhdGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7fXJldHVybiBmdW5jdGlvbih0KXtpZigxIT09YXJndW1lbnRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3QuY3JlYXRlIGltcGxlbWVudGF0aW9uIG9ubHkgYWNjZXB0cyBvbmUgcGFyYW1ldGVyLlwiKTtyZXR1cm4gZS5wcm90b3R5cGU9dCxuZXcgZX19KCkpLEFycmF5LmlzQXJyYXl8fChBcnJheS5pc0FycmF5PWZ1bmN0aW9uKGUpe3JldHVyblwiW29iamVjdCBBcnJheV1cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKX0pLEFycmF5LnByb3RvdHlwZS5pbmRleE9mfHwoQXJyYXkucHJvdG90eXBlLmluZGV4T2Y9ZnVuY3Rpb24oZSl7aWYobnVsbD09PXRoaXMpdGhyb3cgbmV3IFR5cGVFcnJvcjt2YXIgdD1PYmplY3QodGhpcykscj10Lmxlbmd0aD4+PjA7aWYoMD09PXIpcmV0dXJuLTE7dmFyIG49MDtpZihhcmd1bWVudHMubGVuZ3RoPjEmJihuPU51bWJlcihhcmd1bWVudHNbMV0pLG4hPT1uP249MDowIT09biYmbiE9PTEvMCYmbiE9PS0oMS8wKSYmKG49KG4+MHx8LTEpKk1hdGguZmxvb3IoTWF0aC5hYnMobikpKSksbj49cilyZXR1cm4tMTtmb3IodmFyIG89bj49MD9uOk1hdGgubWF4KHItTWF0aC5hYnMobiksMCk7bzxyO28rKylpZihvIGluIHQmJnRbb109PT1lKXJldHVybiBvO3JldHVybi0xfSksT2JqZWN0LmlzRnJvemVufHwoT2JqZWN0LmlzRnJvemVuPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1cInR2NF90ZXN0X2Zyb3plbl9rZXlcIjtlLmhhc093blByb3BlcnR5KHQpOyl0Kz1NYXRoLnJhbmRvbSgpO3RyeXtyZXR1cm4gZVt0XT0hMCxkZWxldGUgZVt0XSwhMX1jYXRjaChyKXtyZXR1cm4hMH19KTt2YXIgZD17XCIrXCI6ITAsXCIjXCI6ITAsXCIuXCI6ITAsXCIvXCI6ITAsXCI7XCI6ITAsXCI/XCI6ITAsXCImXCI6ITB9LHA9e1wiKlwiOiEwfTtyLnByb3RvdHlwZT17dG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50ZW1wbGF0ZX0sZmlsbEZyb21PYmplY3Q6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZmlsbChmdW5jdGlvbih0KXtyZXR1cm4gZVt0XX0pfX07dmFyIGg9ZnVuY3Rpb24oZSx0LHIsbixvKXtpZih0aGlzLm1pc3Npbmc9W10sdGhpcy5taXNzaW5nTWFwPXt9LHRoaXMuZm9ybWF0VmFsaWRhdG9ycz1lP09iamVjdC5jcmVhdGUoZS5mb3JtYXRWYWxpZGF0b3JzKTp7fSx0aGlzLnNjaGVtYXM9ZT9PYmplY3QuY3JlYXRlKGUuc2NoZW1hcyk6e30sdGhpcy5jb2xsZWN0TXVsdGlwbGU9dCx0aGlzLmVycm9ycz1bXSx0aGlzLmhhbmRsZUVycm9yPXQ/dGhpcy5jb2xsZWN0RXJyb3I6dGhpcy5yZXR1cm5FcnJvcixuJiYodGhpcy5jaGVja1JlY3Vyc2l2ZT0hMCx0aGlzLnNjYW5uZWQ9W10sdGhpcy5zY2FubmVkRnJvemVuPVtdLHRoaXMuc2Nhbm5lZEZyb3plblNjaGVtYXM9W10sdGhpcy5zY2FubmVkRnJvemVuVmFsaWRhdGlvbkVycm9ycz1bXSx0aGlzLnZhbGlkYXRlZFNjaGVtYXNLZXk9XCJ0djRfdmFsaWRhdGlvbl9pZFwiLHRoaXMudmFsaWRhdGlvbkVycm9yc0tleT1cInR2NF92YWxpZGF0aW9uX2Vycm9yc19pZFwiKSxvJiYodGhpcy50cmFja1Vua25vd25Qcm9wZXJ0aWVzPSEwLHRoaXMua25vd25Qcm9wZXJ0eVBhdGhzPXt9LHRoaXMudW5rbm93blByb3BlcnR5UGF0aHM9e30pLHRoaXMuZXJyb3JSZXBvcnRlcj1yfHx1KFwiZW5cIiksXCJzdHJpbmdcIj09dHlwZW9mIHRoaXMuZXJyb3JSZXBvcnRlcil0aHJvdyBuZXcgRXJyb3IoXCJkZWJ1Z1wiKTtpZih0aGlzLmRlZmluZWRLZXl3b3Jkcz17fSxlKWZvcih2YXIgaSBpbiBlLmRlZmluZWRLZXl3b3Jkcyl0aGlzLmRlZmluZWRLZXl3b3Jkc1tpXT1lLmRlZmluZWRLZXl3b3Jkc1tpXS5zbGljZSgwKX07aC5wcm90b3R5cGUuZGVmaW5lS2V5d29yZD1mdW5jdGlvbihlLHQpe3RoaXMuZGVmaW5lZEtleXdvcmRzW2VdPXRoaXMuZGVmaW5lZEtleXdvcmRzW2VdfHxbXSx0aGlzLmRlZmluZWRLZXl3b3Jkc1tlXS5wdXNoKHQpfSxoLnByb3RvdHlwZS5jcmVhdGVFcnJvcj1mdW5jdGlvbihlLHQscixuLG8saSxhKXt2YXIgcz1uZXcgYyhlLHQscixuLG8pO3JldHVybiBzLm1lc3NhZ2U9dGhpcy5lcnJvclJlcG9ydGVyKHMsaSxhKSxzfSxoLnByb3RvdHlwZS5yZXR1cm5FcnJvcj1mdW5jdGlvbihlKXtyZXR1cm4gZX0saC5wcm90b3R5cGUuY29sbGVjdEVycm9yPWZ1bmN0aW9uKGUpe3JldHVybiBlJiZ0aGlzLmVycm9ycy5wdXNoKGUpLG51bGx9LGgucHJvdG90eXBlLnByZWZpeEVycm9ycz1mdW5jdGlvbihlLHQscil7Zm9yKHZhciBuPWU7bjx0aGlzLmVycm9ycy5sZW5ndGg7bisrKXRoaXMuZXJyb3JzW25dPXRoaXMuZXJyb3JzW25dLnByZWZpeFdpdGgodCxyKTtyZXR1cm4gdGhpc30saC5wcm90b3R5cGUuYmFuVW5rbm93blByb3BlcnRpZXM9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gdGhpcy51bmtub3duUHJvcGVydHlQYXRocyl7dmFyIG49dGhpcy5jcmVhdGVFcnJvcih2LlVOS05PV05fUFJPUEVSVFkse3BhdGg6cn0scixcIlwiLG51bGwsZSx0KSxvPXRoaXMuaGFuZGxlRXJyb3Iobik7aWYobylyZXR1cm4gb31yZXR1cm4gbnVsbH0saC5wcm90b3R5cGUuYWRkRm9ybWF0PWZ1bmN0aW9uKGUsdCl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGUpe2Zvcih2YXIgciBpbiBlKXRoaXMuYWRkRm9ybWF0KHIsZVtyXSk7cmV0dXJuIHRoaXN9dGhpcy5mb3JtYXRWYWxpZGF0b3JzW2VdPXR9LGgucHJvdG90eXBlLnJlc29sdmVSZWZzPWZ1bmN0aW9uKGUsdCl7aWYodm9pZCAwIT09ZS4kcmVmKXtpZih0PXR8fHt9LHRbZS4kcmVmXSlyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcih2LkNJUkNVTEFSX1JFRkVSRU5DRSx7dXJsczpPYmplY3Qua2V5cyh0KS5qb2luKFwiLCBcIil9LFwiXCIsXCJcIixudWxsLHZvaWQgMCxlKTt0W2UuJHJlZl09ITAsZT10aGlzLmdldFNjaGVtYShlLiRyZWYsdCl9cmV0dXJuIGV9LGgucHJvdG90eXBlLmdldFNjaGVtYT1mdW5jdGlvbihlLHQpe3ZhciByO2lmKHZvaWQgMCE9PXRoaXMuc2NoZW1hc1tlXSlyZXR1cm4gcj10aGlzLnNjaGVtYXNbZV0sdGhpcy5yZXNvbHZlUmVmcyhyLHQpO3ZhciBuPWUsbz1cIlwiO2lmKGUuaW5kZXhPZihcIiNcIikhPT0tMSYmKG89ZS5zdWJzdHJpbmcoZS5pbmRleE9mKFwiI1wiKSsxKSxuPWUuc3Vic3RyaW5nKDAsZS5pbmRleE9mKFwiI1wiKSkpLFwib2JqZWN0XCI9PXR5cGVvZiB0aGlzLnNjaGVtYXNbbl0pe3I9dGhpcy5zY2hlbWFzW25dO3ZhciBpPWRlY29kZVVSSUNvbXBvbmVudChvKTtpZihcIlwiPT09aSlyZXR1cm4gdGhpcy5yZXNvbHZlUmVmcyhyLHQpO2lmKFwiL1wiIT09aS5jaGFyQXQoMCkpcmV0dXJuO2Zvcih2YXIgYT1pLnNwbGl0KFwiL1wiKS5zbGljZSgxKSxzPTA7czxhLmxlbmd0aDtzKyspe3ZhciB1PWFbc10ucmVwbGFjZSgvfjEvZyxcIi9cIikucmVwbGFjZSgvfjAvZyxcIn5cIik7aWYodm9pZCAwPT09clt1XSl7cj12b2lkIDA7YnJlYWt9cj1yW3VdfWlmKHZvaWQgMCE9PXIpcmV0dXJuIHRoaXMucmVzb2x2ZVJlZnMocix0KX12b2lkIDA9PT10aGlzLm1pc3Npbmdbbl0mJih0aGlzLm1pc3NpbmcucHVzaChuKSx0aGlzLm1pc3Npbmdbbl09bix0aGlzLm1pc3NpbmdNYXBbbl09bil9LGgucHJvdG90eXBlLnNlYXJjaFNjaGVtYXM9ZnVuY3Rpb24oZSx0KXtpZihBcnJheS5pc0FycmF5KGUpKWZvcih2YXIgcj0wO3I8ZS5sZW5ndGg7cisrKXRoaXMuc2VhcmNoU2NoZW1hcyhlW3JdLHQpO2Vsc2UgaWYoZSYmXCJvYmplY3RcIj09dHlwZW9mIGUpe1wic3RyaW5nXCI9PXR5cGVvZiBlLmlkJiZsKHQsZS5pZCkmJnZvaWQgMD09PXRoaXMuc2NoZW1hc1tlLmlkXSYmKHRoaXMuc2NoZW1hc1tlLmlkXT1lKTtmb3IodmFyIG4gaW4gZSlpZihcImVudW1cIiE9PW4paWYoXCJvYmplY3RcIj09dHlwZW9mIGVbbl0pdGhpcy5zZWFyY2hTY2hlbWFzKGVbbl0sdCk7ZWxzZSBpZihcIiRyZWZcIj09PW4pe3ZhciBvPWEoZVtuXSk7byYmdm9pZCAwPT09dGhpcy5zY2hlbWFzW29dJiZ2b2lkIDA9PT10aGlzLm1pc3NpbmdNYXBbb10mJih0aGlzLm1pc3NpbmdNYXBbb109byl9fX0saC5wcm90b3R5cGUuYWRkU2NoZW1hPWZ1bmN0aW9uKGUsdCl7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGV8fFwidW5kZWZpbmVkXCI9PXR5cGVvZiB0KXtpZihcIm9iamVjdFwiIT10eXBlb2YgZXx8XCJzdHJpbmdcIiE9dHlwZW9mIGUuaWQpcmV0dXJuO3Q9ZSxlPXQuaWR9ZT09PWEoZSkrXCIjXCImJihlPWEoZSkpLHRoaXMuc2NoZW1hc1tlXT10LGRlbGV0ZSB0aGlzLm1pc3NpbmdNYXBbZV0scyh0LGUpLHRoaXMuc2VhcmNoU2NoZW1hcyh0LGUpfSxoLnByb3RvdHlwZS5nZXRTY2hlbWFNYXA9ZnVuY3Rpb24oKXt2YXIgZT17fTtmb3IodmFyIHQgaW4gdGhpcy5zY2hlbWFzKWVbdF09dGhpcy5zY2hlbWFzW3RdO3JldHVybiBlfSxoLnByb3RvdHlwZS5nZXRTY2hlbWFVcmlzPWZ1bmN0aW9uKGUpe3ZhciB0PVtdO2Zvcih2YXIgciBpbiB0aGlzLnNjaGVtYXMpZSYmIWUudGVzdChyKXx8dC5wdXNoKHIpO3JldHVybiB0fSxoLnByb3RvdHlwZS5nZXRNaXNzaW5nVXJpcz1mdW5jdGlvbihlKXt2YXIgdD1bXTtmb3IodmFyIHIgaW4gdGhpcy5taXNzaW5nTWFwKWUmJiFlLnRlc3Qocil8fHQucHVzaChyKTtyZXR1cm4gdH0saC5wcm90b3R5cGUuZHJvcFNjaGVtYXM9ZnVuY3Rpb24oKXt0aGlzLnNjaGVtYXM9e30sdGhpcy5yZXNldCgpfSxoLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3RoaXMubWlzc2luZz1bXSx0aGlzLm1pc3NpbmdNYXA9e30sdGhpcy5lcnJvcnM9W119LGgucHJvdG90eXBlLnZhbGlkYXRlQWxsPWZ1bmN0aW9uKGUsdCxyLG4sbyl7dmFyIGk7aWYodD10aGlzLnJlc29sdmVSZWZzKHQpLCF0KXJldHVybiBudWxsO2lmKHQgaW5zdGFuY2VvZiBjKXJldHVybiB0aGlzLmVycm9ycy5wdXNoKHQpLHQ7dmFyIGEscz10aGlzLmVycm9ycy5sZW5ndGgsdT1udWxsLGw9bnVsbDtpZih0aGlzLmNoZWNrUmVjdXJzaXZlJiZlJiZcIm9iamVjdFwiPT10eXBlb2YgZSl7aWYoaT0hdGhpcy5zY2FubmVkLmxlbmd0aCxlW3RoaXMudmFsaWRhdGVkU2NoZW1hc0tleV0pe3ZhciBmPWVbdGhpcy52YWxpZGF0ZWRTY2hlbWFzS2V5XS5pbmRleE9mKHQpO2lmKGYhPT0tMSlyZXR1cm4gdGhpcy5lcnJvcnM9dGhpcy5lcnJvcnMuY29uY2F0KGVbdGhpcy52YWxpZGF0aW9uRXJyb3JzS2V5XVtmXSksbnVsbH1pZihPYmplY3QuaXNGcm96ZW4oZSkmJihhPXRoaXMuc2Nhbm5lZEZyb3plbi5pbmRleE9mKGUpLGEhPT0tMSkpe3ZhciBkPXRoaXMuc2Nhbm5lZEZyb3plblNjaGVtYXNbYV0uaW5kZXhPZih0KTtpZihkIT09LTEpcmV0dXJuIHRoaXMuZXJyb3JzPXRoaXMuZXJyb3JzLmNvbmNhdCh0aGlzLnNjYW5uZWRGcm96ZW5WYWxpZGF0aW9uRXJyb3JzW2FdW2RdKSxudWxsfWlmKHRoaXMuc2Nhbm5lZC5wdXNoKGUpLE9iamVjdC5pc0Zyb3plbihlKSlhPT09LTEmJihhPXRoaXMuc2Nhbm5lZEZyb3plbi5sZW5ndGgsdGhpcy5zY2FubmVkRnJvemVuLnB1c2goZSksdGhpcy5zY2FubmVkRnJvemVuU2NoZW1hcy5wdXNoKFtdKSksdT10aGlzLnNjYW5uZWRGcm96ZW5TY2hlbWFzW2FdLmxlbmd0aCx0aGlzLnNjYW5uZWRGcm96ZW5TY2hlbWFzW2FdW3VdPXQsdGhpcy5zY2FubmVkRnJvemVuVmFsaWRhdGlvbkVycm9yc1thXVt1XT1bXTtlbHNle2lmKCFlW3RoaXMudmFsaWRhdGVkU2NoZW1hc0tleV0pdHJ5e09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHRoaXMudmFsaWRhdGVkU2NoZW1hc0tleSx7dmFsdWU6W10sY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdGhpcy52YWxpZGF0aW9uRXJyb3JzS2V5LHt2YWx1ZTpbXSxjb25maWd1cmFibGU6ITB9KX1jYXRjaChwKXtlW3RoaXMudmFsaWRhdGVkU2NoZW1hc0tleV09W10sZVt0aGlzLnZhbGlkYXRpb25FcnJvcnNLZXldPVtdfWw9ZVt0aGlzLnZhbGlkYXRlZFNjaGVtYXNLZXldLmxlbmd0aCxlW3RoaXMudmFsaWRhdGVkU2NoZW1hc0tleV1bbF09dCxlW3RoaXMudmFsaWRhdGlvbkVycm9yc0tleV1bbF09W119fXZhciBoPXRoaXMuZXJyb3JzLmxlbmd0aCx5PXRoaXMudmFsaWRhdGVCYXNpYyhlLHQsbyl8fHRoaXMudmFsaWRhdGVOdW1lcmljKGUsdCxvKXx8dGhpcy52YWxpZGF0ZVN0cmluZyhlLHQsbyl8fHRoaXMudmFsaWRhdGVBcnJheShlLHQsbyl8fHRoaXMudmFsaWRhdGVPYmplY3QoZSx0LG8pfHx0aGlzLnZhbGlkYXRlQ29tYmluYXRpb25zKGUsdCxvKXx8dGhpcy52YWxpZGF0ZUh5cGVybWVkaWEoZSx0LG8pfHx0aGlzLnZhbGlkYXRlRm9ybWF0KGUsdCxvKXx8dGhpcy52YWxpZGF0ZURlZmluZWRLZXl3b3JkcyhlLHQsbyl8fG51bGw7aWYoaSl7Zm9yKDt0aGlzLnNjYW5uZWQubGVuZ3RoOyl7dmFyIG09dGhpcy5zY2FubmVkLnBvcCgpO2RlbGV0ZSBtW3RoaXMudmFsaWRhdGVkU2NoZW1hc0tleV19dGhpcy5zY2FubmVkRnJvemVuPVtdLHRoaXMuc2Nhbm5lZEZyb3plblNjaGVtYXM9W119aWYoeXx8aCE9PXRoaXMuZXJyb3JzLmxlbmd0aClmb3IoO3ImJnIubGVuZ3RofHxuJiZuLmxlbmd0aDspe3ZhciB2PXImJnIubGVuZ3RoP1wiXCIrci5wb3AoKTpudWxsLF89biYmbi5sZW5ndGg/XCJcIituLnBvcCgpOm51bGw7eSYmKHk9eS5wcmVmaXhXaXRoKHYsXykpLHRoaXMucHJlZml4RXJyb3JzKGgsdixfKX1yZXR1cm4gbnVsbCE9PXU/dGhpcy5zY2FubmVkRnJvemVuVmFsaWRhdGlvbkVycm9yc1thXVt1XT10aGlzLmVycm9ycy5zbGljZShzKTpudWxsIT09bCYmKGVbdGhpcy52YWxpZGF0aW9uRXJyb3JzS2V5XVtsXT10aGlzLmVycm9ycy5zbGljZShzKSksdGhpcy5oYW5kbGVFcnJvcih5KX0saC5wcm90b3R5cGUudmFsaWRhdGVGb3JtYXQ9ZnVuY3Rpb24oZSx0KXtpZihcInN0cmluZ1wiIT10eXBlb2YgdC5mb3JtYXR8fCF0aGlzLmZvcm1hdFZhbGlkYXRvcnNbdC5mb3JtYXRdKXJldHVybiBudWxsO3ZhciByPXRoaXMuZm9ybWF0VmFsaWRhdG9yc1t0LmZvcm1hdF0uY2FsbChudWxsLGUsdCk7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHJ8fFwibnVtYmVyXCI9PXR5cGVvZiByP3RoaXMuY3JlYXRlRXJyb3Iodi5GT1JNQVRfQ1VTVE9NLHttZXNzYWdlOnJ9LFwiXCIsXCIvZm9ybWF0XCIsbnVsbCxlLHQpOnImJlwib2JqZWN0XCI9PXR5cGVvZiByP3RoaXMuY3JlYXRlRXJyb3Iodi5GT1JNQVRfQ1VTVE9NLHttZXNzYWdlOnIubWVzc2FnZXx8XCI/XCJ9LHIuZGF0YVBhdGh8fFwiXCIsci5zY2hlbWFQYXRofHxcIi9mb3JtYXRcIixudWxsLGUsdCk6bnVsbH0saC5wcm90b3R5cGUudmFsaWRhdGVEZWZpbmVkS2V5d29yZHM9ZnVuY3Rpb24oZSx0LHIpe2Zvcih2YXIgbiBpbiB0aGlzLmRlZmluZWRLZXl3b3JkcylpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgdFtuXSlmb3IodmFyIG89dGhpcy5kZWZpbmVkS2V5d29yZHNbbl0saT0wO2k8by5sZW5ndGg7aSsrKXt2YXIgYT1vW2ldLHM9YShlLHRbbl0sdCxyKTtpZihcInN0cmluZ1wiPT10eXBlb2Ygc3x8XCJudW1iZXJcIj09dHlwZW9mIHMpcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3Iodi5LRVlXT1JEX0NVU1RPTSx7a2V5Om4sbWVzc2FnZTpzfSxcIlwiLFwiXCIsbnVsbCxlLHQpLnByZWZpeFdpdGgobnVsbCxuKTtpZihzJiZcIm9iamVjdFwiPT10eXBlb2Ygcyl7dmFyIHU9cy5jb2RlO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB1KXtpZighdlt1XSl0aHJvdyBuZXcgRXJyb3IoXCJVbmRlZmluZWQgZXJyb3IgY29kZSAodXNlIGRlZmluZUVycm9yKTogXCIrdSk7dT12W3VdfWVsc2VcIm51bWJlclwiIT10eXBlb2YgdSYmKHU9di5LRVlXT1JEX0NVU1RPTSk7dmFyIGM9XCJvYmplY3RcIj09dHlwZW9mIHMubWVzc2FnZT9zLm1lc3NhZ2U6e2tleTpuLG1lc3NhZ2U6cy5tZXNzYWdlfHxcIj9cIn0sbD1zLnNjaGVtYVBhdGh8fFwiL1wiK24ucmVwbGFjZSgvfi9nLFwifjBcIikucmVwbGFjZSgvXFwvL2csXCJ+MVwiKTtyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcih1LGMscy5kYXRhUGF0aHx8bnVsbCxsLG51bGwsZSx0KX19cmV0dXJuIG51bGx9LGgucHJvdG90eXBlLnZhbGlkYXRlQmFzaWM9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuO3JldHVybihuPXRoaXMudmFsaWRhdGVUeXBlKGUsdCxyKSk/bi5wcmVmaXhXaXRoKG51bGwsXCJ0eXBlXCIpOihuPXRoaXMudmFsaWRhdGVFbnVtKGUsdCxyKSk/bi5wcmVmaXhXaXRoKG51bGwsXCJ0eXBlXCIpOm51bGx9LGgucHJvdG90eXBlLnZhbGlkYXRlVHlwZT1mdW5jdGlvbihlLHQpe2lmKHZvaWQgMD09PXQudHlwZSlyZXR1cm4gbnVsbDt2YXIgcj10eXBlb2YgZTtudWxsPT09ZT9yPVwibnVsbFwiOkFycmF5LmlzQXJyYXkoZSkmJihyPVwiYXJyYXlcIik7dmFyIG49dC50eXBlO0FycmF5LmlzQXJyYXkobil8fChuPVtuXSk7Zm9yKHZhciBvPTA7bzxuLmxlbmd0aDtvKyspe3ZhciBpPW5bb107aWYoaT09PXJ8fFwiaW50ZWdlclwiPT09aSYmXCJudW1iZXJcIj09PXImJmUlMT09PTApcmV0dXJuIG51bGx9cmV0dXJuIHRoaXMuY3JlYXRlRXJyb3Iodi5JTlZBTElEX1RZUEUse3R5cGU6cixleHBlY3RlZDpuLmpvaW4oXCIvXCIpfSxcIlwiLFwiXCIsbnVsbCxlLHQpfSxoLnByb3RvdHlwZS52YWxpZGF0ZUVudW09ZnVuY3Rpb24oZSx0KXtpZih2b2lkIDA9PT10W1wiZW51bVwiXSlyZXR1cm4gbnVsbDtmb3IodmFyIHI9MDtyPHRbXCJlbnVtXCJdLmxlbmd0aDtyKyspe3ZhciBvPXRbXCJlbnVtXCJdW3JdO2lmKG4oZSxvKSlyZXR1cm4gbnVsbH1yZXR1cm4gdGhpcy5jcmVhdGVFcnJvcih2LkVOVU1fTUlTTUFUQ0gse3ZhbHVlOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBKU09OP0pTT04uc3RyaW5naWZ5KGUpOmV9LFwiXCIsXCJcIixudWxsLGUsdCl9LGgucHJvdG90eXBlLnZhbGlkYXRlTnVtZXJpYz1mdW5jdGlvbihlLHQscil7cmV0dXJuIHRoaXMudmFsaWRhdGVNdWx0aXBsZU9mKGUsdCxyKXx8dGhpcy52YWxpZGF0ZU1pbk1heChlLHQscil8fHRoaXMudmFsaWRhdGVOYU4oZSx0LHIpfHxudWxsfTt2YXIgeT1NYXRoLnBvdygyLC01MSksbT0xLXk7aC5wcm90b3R5cGUudmFsaWRhdGVNdWx0aXBsZU9mPWZ1bmN0aW9uKGUsdCl7dmFyIHI9dC5tdWx0aXBsZU9mfHx0LmRpdmlzaWJsZUJ5O2lmKHZvaWQgMD09PXIpcmV0dXJuIG51bGw7aWYoXCJudW1iZXJcIj09dHlwZW9mIGUpe3ZhciBuPWUvciUxO2lmKG4+PXkmJm48bSlyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcih2Lk5VTUJFUl9NVUxUSVBMRV9PRix7dmFsdWU6ZSxtdWx0aXBsZU9mOnJ9LFwiXCIsXCJcIixudWxsLGUsdCl9cmV0dXJuIG51bGx9LGgucHJvdG90eXBlLnZhbGlkYXRlTWluTWF4PWZ1bmN0aW9uKGUsdCl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIGUpcmV0dXJuIG51bGw7aWYodm9pZCAwIT09dC5taW5pbXVtKXtpZihlPHQubWluaW11bSlyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcih2Lk5VTUJFUl9NSU5JTVVNLHt2YWx1ZTplLG1pbmltdW06dC5taW5pbXVtfSxcIlwiLFwiL21pbmltdW1cIixudWxsLGUsdCk7aWYodC5leGNsdXNpdmVNaW5pbXVtJiZlPT09dC5taW5pbXVtKXJldHVybiB0aGlzLmNyZWF0ZUVycm9yKHYuTlVNQkVSX01JTklNVU1fRVhDTFVTSVZFLHt2YWx1ZTplLG1pbmltdW06dC5taW5pbXVtfSxcIlwiLFwiL2V4Y2x1c2l2ZU1pbmltdW1cIixudWxsLGUsdCl9aWYodm9pZCAwIT09dC5tYXhpbXVtKXtpZihlPnQubWF4aW11bSlyZXR1cm4gdGhpcy5jcmVhdGVFcnJvcih2Lk5VTUJFUl9NQVhJTVVNLHt2YWx1ZTplLG1heGltdW06dC5tYXhpbXVtfSxcIlwiLFwiL21heGltdW1cIixudWxsLGUsdCk7aWYodC5leGNsdXNpdmVNYXhpbXVtJiZlPT09dC5tYXhpbXVtKXJldHVybiB0aGlzLmNyZWF0ZUVycm9yKHYuTlVNQkVSX01BWElNVU1fRVhDTFVTSVZFLHt2YWx1ZTplLG1heGltdW06dC5tYXhpbXVtfSxcIlwiLFwiL2V4Y2x1c2l2ZU1heGltdW1cIixudWxsLGUsdCl9cmV0dXJuIG51bGx9LGgucHJvdG90eXBlLnZhbGlkYXRlTmFOPWZ1bmN0aW9uKGUsdCl7cmV0dXJuXCJudW1iZXJcIiE9dHlwZW9mIGU/bnVsbDppc05hTihlKT09PSEwfHxlPT09MS8wfHxlPT09LSgxLzApP3RoaXMuY3JlYXRlRXJyb3Iodi5OVU1CRVJfTk9UX0FfTlVNQkVSLHt2YWx1ZTplfSxcIlwiLFwiL3R5cGVcIixudWxsLGUsdCk6bnVsbH0saC5wcm90b3R5cGUudmFsaWRhdGVTdHJpbmc9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiB0aGlzLnZhbGlkYXRlU3RyaW5nTGVuZ3RoKGUsdCxyKXx8dGhpcy52YWxpZGF0ZVN0cmluZ1BhdHRlcm4oZSx0LHIpfHxudWxsfSxoLnByb3RvdHlwZS52YWxpZGF0ZVN0cmluZ0xlbmd0aD1mdW5jdGlvbihlLHQpe3JldHVyblwic3RyaW5nXCIhPXR5cGVvZiBlP251bGw6dm9pZCAwIT09dC5taW5MZW5ndGgmJmUubGVuZ3RoPHQubWluTGVuZ3RoP3RoaXMuY3JlYXRlRXJyb3Iodi5TVFJJTkdfTEVOR1RIX1NIT1JULHtsZW5ndGg6ZS5sZW5ndGgsbWluaW11bTp0Lm1pbkxlbmd0aH0sXCJcIixcIi9taW5MZW5ndGhcIixudWxsLGUsdCk6dm9pZCAwIT09dC5tYXhMZW5ndGgmJmUubGVuZ3RoPnQubWF4TGVuZ3RoP3RoaXMuY3JlYXRlRXJyb3Iodi5TVFJJTkdfTEVOR1RIX0xPTkcse2xlbmd0aDplLmxlbmd0aCxtYXhpbXVtOnQubWF4TGVuZ3RofSxcIlwiLFwiL21heExlbmd0aFwiLG51bGwsZSx0KTpudWxsfSxoLnByb3RvdHlwZS52YWxpZGF0ZVN0cmluZ1BhdHRlcm49ZnVuY3Rpb24oZSx0KXtpZihcInN0cmluZ1wiIT10eXBlb2YgZXx8XCJzdHJpbmdcIiE9dHlwZW9mIHQucGF0dGVybiYmISh0LnBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHApKXJldHVybiBudWxsO3ZhciByO2lmKHQucGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cClyPXQucGF0dGVybjtlbHNle3ZhciBuLG89XCJcIixpPXQucGF0dGVybi5tYXRjaCgvXlxcLyguKylcXC8oW2ltZ10qKSQvKTtpPyhuPWlbMV0sbz1pWzJdKTpuPXQucGF0dGVybixyPW5ldyBSZWdFeHAobixvKX1yZXR1cm4gci50ZXN0KGUpP251bGw6dGhpcy5jcmVhdGVFcnJvcih2LlNUUklOR19QQVRURVJOLHtwYXR0ZXJuOnQucGF0dGVybn0sXCJcIixcIi9wYXR0ZXJuXCIsbnVsbCxlLHQpfSxoLnByb3RvdHlwZS52YWxpZGF0ZUFycmF5PWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gQXJyYXkuaXNBcnJheShlKT90aGlzLnZhbGlkYXRlQXJyYXlMZW5ndGgoZSx0LHIpfHx0aGlzLnZhbGlkYXRlQXJyYXlVbmlxdWVJdGVtcyhlLHQscil8fHRoaXMudmFsaWRhdGVBcnJheUl0ZW1zKGUsdCxyKXx8bnVsbDpudWxsfSxoLnByb3RvdHlwZS52YWxpZGF0ZUFycmF5TGVuZ3RoPWZ1bmN0aW9uKGUsdCl7dmFyIHI7cmV0dXJuIHZvaWQgMCE9PXQubWluSXRlbXMmJmUubGVuZ3RoPHQubWluSXRlbXMmJihyPXRoaXMuY3JlYXRlRXJyb3Iodi5BUlJBWV9MRU5HVEhfU0hPUlQse2xlbmd0aDplLmxlbmd0aCxtaW5pbXVtOnQubWluSXRlbXN9LFwiXCIsXCIvbWluSXRlbXNcIixudWxsLGUsdCksdGhpcy5oYW5kbGVFcnJvcihyKSk/cjp2b2lkIDAhPT10Lm1heEl0ZW1zJiZlLmxlbmd0aD50Lm1heEl0ZW1zJiYocj10aGlzLmNyZWF0ZUVycm9yKHYuQVJSQVlfTEVOR1RIX0xPTkcse2xlbmd0aDplLmxlbmd0aCxtYXhpbXVtOnQubWF4SXRlbXN9LFwiXCIsXCIvbWF4SXRlbXNcIixudWxsLGUsdCksdGhpcy5oYW5kbGVFcnJvcihyKSk/cjpudWxsfSxoLnByb3RvdHlwZS52YWxpZGF0ZUFycmF5VW5pcXVlSXRlbXM9ZnVuY3Rpb24oZSx0KXtpZih0LnVuaXF1ZUl0ZW1zKWZvcih2YXIgcj0wO3I8ZS5sZW5ndGg7cisrKWZvcih2YXIgbz1yKzE7bzxlLmxlbmd0aDtvKyspaWYobihlW3JdLGVbb10pKXt2YXIgaT10aGlzLmNyZWF0ZUVycm9yKHYuQVJSQVlfVU5JUVVFLHttYXRjaDE6cixtYXRjaDI6b30sXCJcIixcIi91bmlxdWVJdGVtc1wiLG51bGwsZSx0KTtpZih0aGlzLmhhbmRsZUVycm9yKGkpKXJldHVybiBpfXJldHVybiBudWxsfSxoLnByb3RvdHlwZS52YWxpZGF0ZUFycmF5SXRlbXM9ZnVuY3Rpb24oZSx0LHIpe2lmKHZvaWQgMD09PXQuaXRlbXMpcmV0dXJuIG51bGw7dmFyIG4sbztpZihBcnJheS5pc0FycmF5KHQuaXRlbXMpKXtmb3Iobz0wO288ZS5sZW5ndGg7bysrKWlmKG88dC5pdGVtcy5sZW5ndGgpe2lmKG49dGhpcy52YWxpZGF0ZUFsbChlW29dLHQuaXRlbXNbb10sW29dLFtcIml0ZW1zXCIsb10scitcIi9cIitvKSlyZXR1cm4gbn1lbHNlIGlmKHZvaWQgMCE9PXQuYWRkaXRpb25hbEl0ZW1zKWlmKFwiYm9vbGVhblwiPT10eXBlb2YgdC5hZGRpdGlvbmFsSXRlbXMpe2lmKCF0LmFkZGl0aW9uYWxJdGVtcyYmKG49dGhpcy5jcmVhdGVFcnJvcih2LkFSUkFZX0FERElUSU9OQUxfSVRFTVMse30sXCIvXCIrbyxcIi9hZGRpdGlvbmFsSXRlbXNcIixudWxsLGUsdCksdGhpcy5oYW5kbGVFcnJvcihuKSkpcmV0dXJuIG59ZWxzZSBpZihuPXRoaXMudmFsaWRhdGVBbGwoZVtvXSx0LmFkZGl0aW9uYWxJdGVtcyxbb10sW1wiYWRkaXRpb25hbEl0ZW1zXCJdLHIrXCIvXCIrbykpcmV0dXJuIG59ZWxzZSBmb3Iobz0wO288ZS5sZW5ndGg7bysrKWlmKG49dGhpcy52YWxpZGF0ZUFsbChlW29dLHQuaXRlbXMsW29dLFtcIml0ZW1zXCJdLHIrXCIvXCIrbykpcmV0dXJuIG47cmV0dXJuIG51bGx9LGgucHJvdG90eXBlLnZhbGlkYXRlT2JqZWN0PWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm5cIm9iamVjdFwiIT10eXBlb2YgZXx8bnVsbD09PWV8fEFycmF5LmlzQXJyYXkoZSk/bnVsbDp0aGlzLnZhbGlkYXRlT2JqZWN0TWluTWF4UHJvcGVydGllcyhlLHQscil8fHRoaXMudmFsaWRhdGVPYmplY3RSZXF1aXJlZFByb3BlcnRpZXMoZSx0LHIpfHx0aGlzLnZhbGlkYXRlT2JqZWN0UHJvcGVydGllcyhlLHQscil8fHRoaXMudmFsaWRhdGVPYmplY3REZXBlbmRlbmNpZXMoZSx0LHIpfHxudWxsfSxoLnByb3RvdHlwZS52YWxpZGF0ZU9iamVjdE1pbk1heFByb3BlcnRpZXM9ZnVuY3Rpb24oZSx0KXt2YXIgcixuPU9iamVjdC5rZXlzKGUpO3JldHVybiB2b2lkIDAhPT10Lm1pblByb3BlcnRpZXMmJm4ubGVuZ3RoPHQubWluUHJvcGVydGllcyYmKHI9dGhpcy5jcmVhdGVFcnJvcih2Lk9CSkVDVF9QUk9QRVJUSUVTX01JTklNVU0se3Byb3BlcnR5Q291bnQ6bi5sZW5ndGgsbWluaW11bTp0Lm1pblByb3BlcnRpZXN9LFwiXCIsXCIvbWluUHJvcGVydGllc1wiLG51bGwsZSx0KSx0aGlzLmhhbmRsZUVycm9yKHIpKT9yOnZvaWQgMCE9PXQubWF4UHJvcGVydGllcyYmbi5sZW5ndGg+dC5tYXhQcm9wZXJ0aWVzJiYocj10aGlzLmNyZWF0ZUVycm9yKHYuT0JKRUNUX1BST1BFUlRJRVNfTUFYSU1VTSx7cHJvcGVydHlDb3VudDpuLmxlbmd0aCxtYXhpbXVtOnQubWF4UHJvcGVydGllc30sXCJcIixcIi9tYXhQcm9wZXJ0aWVzXCIsbnVsbCxlLHQpLHRoaXMuaGFuZGxlRXJyb3IocikpP3I6bnVsbH0saC5wcm90b3R5cGUudmFsaWRhdGVPYmplY3RSZXF1aXJlZFByb3BlcnRpZXM9ZnVuY3Rpb24oZSx0KXtpZih2b2lkIDAhPT10LnJlcXVpcmVkKWZvcih2YXIgcj0wO3I8dC5yZXF1aXJlZC5sZW5ndGg7cisrKXt2YXIgbj10LnJlcXVpcmVkW3JdO2lmKHZvaWQgMD09PWVbbl0pe3ZhciBvPXRoaXMuY3JlYXRlRXJyb3Iodi5PQkpFQ1RfUkVRVUlSRUQse2tleTpufSxcIlwiLFwiL3JlcXVpcmVkL1wiK3IsbnVsbCxlLHQpO2lmKHRoaXMuaGFuZGxlRXJyb3IobykpcmV0dXJuIG99fXJldHVybiBudWxsfSxoLnByb3RvdHlwZS52YWxpZGF0ZU9iamVjdFByb3BlcnRpZXM9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuO2Zvcih2YXIgbyBpbiBlKXt2YXIgaT1yK1wiL1wiK28ucmVwbGFjZSgvfi9nLFwifjBcIikucmVwbGFjZSgvXFwvL2csXCJ+MVwiKSxhPSExO2lmKHZvaWQgMCE9PXQucHJvcGVydGllcyYmdm9pZCAwIT09dC5wcm9wZXJ0aWVzW29dJiYoYT0hMCxuPXRoaXMudmFsaWRhdGVBbGwoZVtvXSx0LnByb3BlcnRpZXNbb10sW29dLFtcInByb3BlcnRpZXNcIixvXSxpKSkpcmV0dXJuIG47aWYodm9pZCAwIT09dC5wYXR0ZXJuUHJvcGVydGllcylmb3IodmFyIHMgaW4gdC5wYXR0ZXJuUHJvcGVydGllcyl7dmFyIHU9bmV3IFJlZ0V4cChzKTtpZih1LnRlc3QobykmJihhPSEwLG49dGhpcy52YWxpZGF0ZUFsbChlW29dLHQucGF0dGVyblByb3BlcnRpZXNbc10sW29dLFtcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsc10saSkpKXJldHVybiBufWlmKGEpdGhpcy50cmFja1Vua25vd25Qcm9wZXJ0aWVzJiYodGhpcy5rbm93blByb3BlcnR5UGF0aHNbaV09ITAsZGVsZXRlIHRoaXMudW5rbm93blByb3BlcnR5UGF0aHNbaV0pO2Vsc2UgaWYodm9pZCAwIT09dC5hZGRpdGlvbmFsUHJvcGVydGllcyl7aWYodGhpcy50cmFja1Vua25vd25Qcm9wZXJ0aWVzJiYodGhpcy5rbm93blByb3BlcnR5UGF0aHNbaV09ITAsZGVsZXRlIHRoaXMudW5rbm93blByb3BlcnR5UGF0aHNbaV0pLFwiYm9vbGVhblwiPT10eXBlb2YgdC5hZGRpdGlvbmFsUHJvcGVydGllcyl7aWYoIXQuYWRkaXRpb25hbFByb3BlcnRpZXMmJihuPXRoaXMuY3JlYXRlRXJyb3Iodi5PQkpFQ1RfQURESVRJT05BTF9QUk9QRVJUSUVTLHtrZXk6b30sXCJcIixcIi9hZGRpdGlvbmFsUHJvcGVydGllc1wiLG51bGwsZSx0KS5wcmVmaXhXaXRoKG8sbnVsbCksdGhpcy5oYW5kbGVFcnJvcihuKSkpcmV0dXJuIG59ZWxzZSBpZihuPXRoaXMudmFsaWRhdGVBbGwoZVtvXSx0LmFkZGl0aW9uYWxQcm9wZXJ0aWVzLFtvXSxbXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiXSxpKSlyZXR1cm4gbn1lbHNlIHRoaXMudHJhY2tVbmtub3duUHJvcGVydGllcyYmIXRoaXMua25vd25Qcm9wZXJ0eVBhdGhzW2ldJiYodGhpcy51bmtub3duUHJvcGVydHlQYXRoc1tpXT0hMCl9cmV0dXJuIG51bGx9LGgucHJvdG90eXBlLnZhbGlkYXRlT2JqZWN0RGVwZW5kZW5jaWVzPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbjtpZih2b2lkIDAhPT10LmRlcGVuZGVuY2llcylmb3IodmFyIG8gaW4gdC5kZXBlbmRlbmNpZXMpaWYodm9pZCAwIT09ZVtvXSl7dmFyIGk9dC5kZXBlbmRlbmNpZXNbb107aWYoXCJzdHJpbmdcIj09dHlwZW9mIGkpe2lmKHZvaWQgMD09PWVbaV0mJihuPXRoaXMuY3JlYXRlRXJyb3Iodi5PQkpFQ1RfREVQRU5ERU5DWV9LRVkse2tleTpvLG1pc3Npbmc6aX0sXCJcIixcIlwiLG51bGwsZSx0KS5wcmVmaXhXaXRoKG51bGwsbykucHJlZml4V2l0aChudWxsLFwiZGVwZW5kZW5jaWVzXCIpLHRoaXMuaGFuZGxlRXJyb3IobikpKXJldHVybiBufWVsc2UgaWYoQXJyYXkuaXNBcnJheShpKSlmb3IodmFyIGE9MDthPGkubGVuZ3RoO2ErKyl7dmFyIHM9aVthXTtpZih2b2lkIDA9PT1lW3NdJiYobj10aGlzLmNyZWF0ZUVycm9yKHYuT0JKRUNUX0RFUEVOREVOQ1lfS0VZLHtrZXk6byxtaXNzaW5nOnN9LFwiXCIsXCIvXCIrYSxudWxsLGUsdCkucHJlZml4V2l0aChudWxsLG8pLnByZWZpeFdpdGgobnVsbCxcImRlcGVuZGVuY2llc1wiKSx0aGlzLmhhbmRsZUVycm9yKG4pKSlyZXR1cm4gbn1lbHNlIGlmKG49dGhpcy52YWxpZGF0ZUFsbChlLGksW10sW1wiZGVwZW5kZW5jaWVzXCIsb10scikpcmV0dXJuIG59cmV0dXJuIG51bGx9LGgucHJvdG90eXBlLnZhbGlkYXRlQ29tYmluYXRpb25zPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gdGhpcy52YWxpZGF0ZUFsbE9mKGUsdCxyKXx8dGhpcy52YWxpZGF0ZUFueU9mKGUsdCxyKXx8dGhpcy52YWxpZGF0ZU9uZU9mKGUsdCxyKXx8dGhpcy52YWxpZGF0ZU5vdChlLHQscil8fG51bGx9LGgucHJvdG90eXBlLnZhbGlkYXRlQWxsT2Y9ZnVuY3Rpb24oZSx0LHIpe2lmKHZvaWQgMD09PXQuYWxsT2YpcmV0dXJuIG51bGw7Zm9yKHZhciBuLG89MDtvPHQuYWxsT2YubGVuZ3RoO28rKyl7dmFyIGk9dC5hbGxPZltvXTtpZihuPXRoaXMudmFsaWRhdGVBbGwoZSxpLFtdLFtcImFsbE9mXCIsb10scikpcmV0dXJuIG59cmV0dXJuIG51bGx9LGgucHJvdG90eXBlLnZhbGlkYXRlQW55T2Y9ZnVuY3Rpb24oZSx0LHIpe2lmKHZvaWQgMD09PXQuYW55T2YpcmV0dXJuIG51bGw7dmFyIG4sbyxpPVtdLGE9dGhpcy5lcnJvcnMubGVuZ3RoO3RoaXMudHJhY2tVbmtub3duUHJvcGVydGllcyYmKG49dGhpcy51bmtub3duUHJvcGVydHlQYXRocyxvPXRoaXMua25vd25Qcm9wZXJ0eVBhdGhzKTtmb3IodmFyIHM9ITAsdT0wO3U8dC5hbnlPZi5sZW5ndGg7dSsrKXt0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMmJih0aGlzLnVua25vd25Qcm9wZXJ0eVBhdGhzPXt9LHRoaXMua25vd25Qcm9wZXJ0eVBhdGhzPXt9KTt2YXIgYz10LmFueU9mW3VdLGw9dGhpcy5lcnJvcnMubGVuZ3RoLGY9dGhpcy52YWxpZGF0ZUFsbChlLGMsW10sW1wiYW55T2ZcIix1XSxyKTtpZihudWxsPT09ZiYmbD09PXRoaXMuZXJyb3JzLmxlbmd0aCl7aWYodGhpcy5lcnJvcnM9dGhpcy5lcnJvcnMuc2xpY2UoMCxhKSx0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMpe2Zvcih2YXIgZCBpbiB0aGlzLmtub3duUHJvcGVydHlQYXRocylvW2RdPSEwLGRlbGV0ZSBuW2RdO2Zvcih2YXIgcCBpbiB0aGlzLnVua25vd25Qcm9wZXJ0eVBhdGhzKW9bcF18fChuW3BdPSEwKTtzPSExO2NvbnRpbnVlfXJldHVybiBudWxsfWYmJmkucHVzaChmLnByZWZpeFdpdGgobnVsbCxcIlwiK3UpLnByZWZpeFdpdGgobnVsbCxcImFueU9mXCIpKX1yZXR1cm4gdGhpcy50cmFja1Vua25vd25Qcm9wZXJ0aWVzJiYodGhpcy51bmtub3duUHJvcGVydHlQYXRocz1uLHRoaXMua25vd25Qcm9wZXJ0eVBhdGhzPW8pLHM/KGk9aS5jb25jYXQodGhpcy5lcnJvcnMuc2xpY2UoYSkpLHRoaXMuZXJyb3JzPXRoaXMuZXJyb3JzLnNsaWNlKDAsYSksdGhpcy5jcmVhdGVFcnJvcih2LkFOWV9PRl9NSVNTSU5HLHt9LFwiXCIsXCIvYW55T2ZcIixpLGUsdCkpOnZvaWQgMH0saC5wcm90b3R5cGUudmFsaWRhdGVPbmVPZj1mdW5jdGlvbihlLHQscil7aWYodm9pZCAwPT09dC5vbmVPZilyZXR1cm4gbnVsbDt2YXIgbixvLGk9bnVsbCxhPVtdLHM9dGhpcy5lcnJvcnMubGVuZ3RoO3RoaXMudHJhY2tVbmtub3duUHJvcGVydGllcyYmKG49dGhpcy51bmtub3duUHJvcGVydHlQYXRocyxvPXRoaXMua25vd25Qcm9wZXJ0eVBhdGhzKTtmb3IodmFyIHU9MDt1PHQub25lT2YubGVuZ3RoO3UrKyl7dGhpcy50cmFja1Vua25vd25Qcm9wZXJ0aWVzJiYodGhpcy51bmtub3duUHJvcGVydHlQYXRocz17fSx0aGlzLmtub3duUHJvcGVydHlQYXRocz17fSk7dmFyIGM9dC5vbmVPZlt1XSxsPXRoaXMuZXJyb3JzLmxlbmd0aCxmPXRoaXMudmFsaWRhdGVBbGwoZSxjLFtdLFtcIm9uZU9mXCIsdV0scik7aWYobnVsbD09PWYmJmw9PT10aGlzLmVycm9ycy5sZW5ndGgpe2lmKG51bGwhPT1pKXJldHVybiB0aGlzLmVycm9ycz10aGlzLmVycm9ycy5zbGljZSgwLHMpLHRoaXMuY3JlYXRlRXJyb3Iodi5PTkVfT0ZfTVVMVElQTEUse2luZGV4MTppLGluZGV4Mjp1fSxcIlwiLFwiL29uZU9mXCIsbnVsbCxlLHQpO2lmKGk9dSx0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMpe2Zvcih2YXIgZCBpbiB0aGlzLmtub3duUHJvcGVydHlQYXRocylvW2RdPSEwLGRlbGV0ZSBuW2RdO2Zvcih2YXIgcCBpbiB0aGlzLnVua25vd25Qcm9wZXJ0eVBhdGhzKW9bcF18fChuW3BdPSEwKX19ZWxzZSBmJiZhLnB1c2goZil9cmV0dXJuIHRoaXMudHJhY2tVbmtub3duUHJvcGVydGllcyYmKHRoaXMudW5rbm93blByb3BlcnR5UGF0aHM9bix0aGlzLmtub3duUHJvcGVydHlQYXRocz1vKSxudWxsPT09aT8oYT1hLmNvbmNhdCh0aGlzLmVycm9ycy5zbGljZShzKSksdGhpcy5lcnJvcnM9dGhpcy5lcnJvcnMuc2xpY2UoMCxzKSx0aGlzLmNyZWF0ZUVycm9yKHYuT05FX09GX01JU1NJTkcse30sXCJcIixcIi9vbmVPZlwiLGEsZSx0KSk6KHRoaXMuZXJyb3JzPXRoaXMuZXJyb3JzLnNsaWNlKDAscyksbnVsbCl9LGgucHJvdG90eXBlLnZhbGlkYXRlTm90PWZ1bmN0aW9uKGUsdCxyKXtpZih2b2lkIDA9PT10Lm5vdClyZXR1cm4gbnVsbDt2YXIgbixvLGk9dGhpcy5lcnJvcnMubGVuZ3RoO3RoaXMudHJhY2tVbmtub3duUHJvcGVydGllcyYmKG49dGhpcy51bmtub3duUHJvcGVydHlQYXRocyxvPXRoaXMua25vd25Qcm9wZXJ0eVBhdGhzLHRoaXMudW5rbm93blByb3BlcnR5UGF0aHM9e30sdGhpcy5rbm93blByb3BlcnR5UGF0aHM9e30pO3ZhciBhPXRoaXMudmFsaWRhdGVBbGwoZSx0Lm5vdCxudWxsLG51bGwscikscz10aGlzLmVycm9ycy5zbGljZShpKTtyZXR1cm4gdGhpcy5lcnJvcnM9dGhpcy5lcnJvcnMuc2xpY2UoMCxpKSx0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMmJih0aGlzLnVua25vd25Qcm9wZXJ0eVBhdGhzPW4sdGhpcy5rbm93blByb3BlcnR5UGF0aHM9byksbnVsbD09PWEmJjA9PT1zLmxlbmd0aD90aGlzLmNyZWF0ZUVycm9yKHYuTk9UX1BBU1NFRCx7fSxcIlwiLFwiL25vdFwiLG51bGwsZSx0KTpudWxsfSxoLnByb3RvdHlwZS52YWxpZGF0ZUh5cGVybWVkaWE9ZnVuY3Rpb24oZSx0LG4pe2lmKCF0LmxpbmtzKXJldHVybiBudWxsO2Zvcih2YXIgbyxpPTA7aTx0LmxpbmtzLmxlbmd0aDtpKyspe3ZhciBhPXQubGlua3NbaV07aWYoXCJkZXNjcmliZWRieVwiPT09YS5yZWwpe2Zvcih2YXIgcz1uZXcgcihhLmhyZWYpLHU9ITAsYz0wO2M8cy52YXJOYW1lcy5sZW5ndGg7YysrKWlmKCEocy52YXJOYW1lc1tjXWluIGUpKXt1PSExO2JyZWFrfWlmKHUpe3ZhciBsPXMuZmlsbEZyb21PYmplY3QoZSksZj17JHJlZjpsfTtpZihvPXRoaXMudmFsaWRhdGVBbGwoZSxmLFtdLFtcImxpbmtzXCIsaV0sbikpcmV0dXJuIG99fX19O3ZhciB2PXtJTlZBTElEX1RZUEU6MCxFTlVNX01JU01BVENIOjEsQU5ZX09GX01JU1NJTkc6MTAsT05FX09GX01JU1NJTkc6MTEsT05FX09GX01VTFRJUExFOjEyLE5PVF9QQVNTRUQ6MTMsTlVNQkVSX01VTFRJUExFX09GOjEwMCxOVU1CRVJfTUlOSU1VTToxMDEsTlVNQkVSX01JTklNVU1fRVhDTFVTSVZFOjEwMixOVU1CRVJfTUFYSU1VTToxMDMsTlVNQkVSX01BWElNVU1fRVhDTFVTSVZFOjEwNCxOVU1CRVJfTk9UX0FfTlVNQkVSOjEwNSxTVFJJTkdfTEVOR1RIX1NIT1JUOjIwMCxTVFJJTkdfTEVOR1RIX0xPTkc6MjAxLFNUUklOR19QQVRURVJOOjIwMixPQkpFQ1RfUFJPUEVSVElFU19NSU5JTVVNOjMwMCxPQkpFQ1RfUFJPUEVSVElFU19NQVhJTVVNOjMwMSxPQkpFQ1RfUkVRVUlSRUQ6MzAyLE9CSkVDVF9BRERJVElPTkFMX1BST1BFUlRJRVM6MzAzLE9CSkVDVF9ERVBFTkRFTkNZX0tFWTozMDQsQVJSQVlfTEVOR1RIX1NIT1JUOjQwMCxBUlJBWV9MRU5HVEhfTE9ORzo0MDEsQVJSQVlfVU5JUVVFOjQwMixBUlJBWV9BRERJVElPTkFMX0lURU1TOjQwMyxGT1JNQVRfQ1VTVE9NOjUwMCxLRVlXT1JEX0NVU1RPTTo1MDEsQ0lSQ1VMQVJfUkVGRVJFTkNFOjYwMCxVTktOT1dOX1BST1BFUlRZOjFlM30sXz17fTtmb3IodmFyIGIgaW4gdilfW3ZbYl1dPWI7dmFyIGc9e0lOVkFMSURfVFlQRTpcIkludmFsaWQgdHlwZToge3R5cGV9IChleHBlY3RlZCB7ZXhwZWN0ZWR9KVwiLEVOVU1fTUlTTUFUQ0g6XCJObyBlbnVtIG1hdGNoIGZvcjoge3ZhbHVlfVwiLEFOWV9PRl9NSVNTSU5HOidEYXRhIGRvZXMgbm90IG1hdGNoIGFueSBzY2hlbWFzIGZyb20gXCJhbnlPZlwiJyxPTkVfT0ZfTUlTU0lORzonRGF0YSBkb2VzIG5vdCBtYXRjaCBhbnkgc2NoZW1hcyBmcm9tIFwib25lT2ZcIicsT05FX09GX01VTFRJUExFOidEYXRhIGlzIHZhbGlkIGFnYWluc3QgbW9yZSB0aGFuIG9uZSBzY2hlbWEgZnJvbSBcIm9uZU9mXCI6IGluZGljZXMge2luZGV4MX0gYW5kIHtpbmRleDJ9JyxOT1RfUEFTU0VEOidEYXRhIG1hdGNoZXMgc2NoZW1hIGZyb20gXCJub3RcIicsTlVNQkVSX01VTFRJUExFX09GOlwiVmFsdWUge3ZhbHVlfSBpcyBub3QgYSBtdWx0aXBsZSBvZiB7bXVsdGlwbGVPZn1cIixOVU1CRVJfTUlOSU1VTTpcIlZhbHVlIHt2YWx1ZX0gaXMgbGVzcyB0aGFuIG1pbmltdW0ge21pbmltdW19XCIsTlVNQkVSX01JTklNVU1fRVhDTFVTSVZFOlwiVmFsdWUge3ZhbHVlfSBpcyBlcXVhbCB0byBleGNsdXNpdmUgbWluaW11bSB7bWluaW11bX1cIixOVU1CRVJfTUFYSU1VTTpcIlZhbHVlIHt2YWx1ZX0gaXMgZ3JlYXRlciB0aGFuIG1heGltdW0ge21heGltdW19XCIsTlVNQkVSX01BWElNVU1fRVhDTFVTSVZFOlwiVmFsdWUge3ZhbHVlfSBpcyBlcXVhbCB0byBleGNsdXNpdmUgbWF4aW11bSB7bWF4aW11bX1cIixOVU1CRVJfTk9UX0FfTlVNQkVSOlwiVmFsdWUge3ZhbHVlfSBpcyBub3QgYSB2YWxpZCBudW1iZXJcIixTVFJJTkdfTEVOR1RIX1NIT1JUOlwiU3RyaW5nIGlzIHRvbyBzaG9ydCAoe2xlbmd0aH0gY2hhcnMpLCBtaW5pbXVtIHttaW5pbXVtfVwiLFNUUklOR19MRU5HVEhfTE9ORzpcIlN0cmluZyBpcyB0b28gbG9uZyAoe2xlbmd0aH0gY2hhcnMpLCBtYXhpbXVtIHttYXhpbXVtfVwiLFNUUklOR19QQVRURVJOOlwiU3RyaW5nIGRvZXMgbm90IG1hdGNoIHBhdHRlcm46IHtwYXR0ZXJufVwiLE9CSkVDVF9QUk9QRVJUSUVTX01JTklNVU06XCJUb28gZmV3IHByb3BlcnRpZXMgZGVmaW5lZCAoe3Byb3BlcnR5Q291bnR9KSwgbWluaW11bSB7bWluaW11bX1cIixPQkpFQ1RfUFJPUEVSVElFU19NQVhJTVVNOlwiVG9vIG1hbnkgcHJvcGVydGllcyBkZWZpbmVkICh7cHJvcGVydHlDb3VudH0pLCBtYXhpbXVtIHttYXhpbXVtfVwiLE9CSkVDVF9SRVFVSVJFRDpcIk1pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHk6IHtrZXl9XCIsT0JKRUNUX0FERElUSU9OQUxfUFJPUEVSVElFUzpcIkFkZGl0aW9uYWwgcHJvcGVydGllcyBub3QgYWxsb3dlZFwiLE9CSkVDVF9ERVBFTkRFTkNZX0tFWTpcIkRlcGVuZGVuY3kgZmFpbGVkIC0ga2V5IG11c3QgZXhpc3Q6IHttaXNzaW5nfSAoZHVlIHRvIGtleToge2tleX0pXCIsQVJSQVlfTEVOR1RIX1NIT1JUOlwiQXJyYXkgaXMgdG9vIHNob3J0ICh7bGVuZ3RofSksIG1pbmltdW0ge21pbmltdW19XCIsQVJSQVlfTEVOR1RIX0xPTkc6XCJBcnJheSBpcyB0b28gbG9uZyAoe2xlbmd0aH0pLCBtYXhpbXVtIHttYXhpbXVtfVwiLEFSUkFZX1VOSVFVRTpcIkFycmF5IGl0ZW1zIGFyZSBub3QgdW5pcXVlIChpbmRpY2VzIHttYXRjaDF9IGFuZCB7bWF0Y2gyfSlcIixBUlJBWV9BRERJVElPTkFMX0lURU1TOlwiQWRkaXRpb25hbCBpdGVtcyBub3QgYWxsb3dlZFwiLEZPUk1BVF9DVVNUT006XCJGb3JtYXQgdmFsaWRhdGlvbiBmYWlsZWQgKHttZXNzYWdlfSlcIixLRVlXT1JEX0NVU1RPTTpcIktleXdvcmQgZmFpbGVkOiB7a2V5fSAoe21lc3NhZ2V9KVwiLENJUkNVTEFSX1JFRkVSRU5DRTpcIkNpcmN1bGFyICRyZWZzOiB7dXJsc31cIixVTktOT1dOX1BST1BFUlRZOlwiVW5rbm93biBwcm9wZXJ0eSAobm90IGluIHNjaGVtYSlcIn07Yy5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpLGMucHJvdG90eXBlLmNvbnN0cnVjdG9yPWMsYy5wcm90b3R5cGUubmFtZT1cIlZhbGlkYXRpb25FcnJvclwiLGMucHJvdG90eXBlLnByZWZpeFdpdGg9ZnVuY3Rpb24oZSx0KXtpZihudWxsIT09ZSYmKGU9ZS5yZXBsYWNlKC9+L2csXCJ+MFwiKS5yZXBsYWNlKC9cXC8vZyxcIn4xXCIpLHRoaXMuZGF0YVBhdGg9XCIvXCIrZSt0aGlzLmRhdGFQYXRoKSxudWxsIT09dCYmKHQ9dC5yZXBsYWNlKC9+L2csXCJ+MFwiKS5yZXBsYWNlKC9cXC8vZyxcIn4xXCIpLHRoaXMuc2NoZW1hUGF0aD1cIi9cIit0K3RoaXMuc2NoZW1hUGF0aCksbnVsbCE9PXRoaXMuc3ViRXJyb3JzKWZvcih2YXIgcj0wO3I8dGhpcy5zdWJFcnJvcnMubGVuZ3RoO3IrKyl0aGlzLnN1YkVycm9yc1tyXS5wcmVmaXhXaXRoKGUsdCk7cmV0dXJuIHRoaXN9O3ZhciBFPXt9LGo9ZigpO3JldHVybiBqLmFkZExhbmd1YWdlKFwiZW4tZ2JcIixnKSxqLnR2ND1qLGp9KX0se31dLDEwMDpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntcImRlZmF1bHRcIjplfX1PYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxyLk1lc3NhZ2VGYWN0b3J5PXZvaWQgMDt2YXIgbz1lKFwiLi9tZXNzYWdlLWZhY3RvcnkvTWVzc2FnZUZhY3RvcnlcIiksaT1uKG8pO3IuTWVzc2FnZUZhY3Rvcnk9aVtcImRlZmF1bHRcIl19LHtcIi4vbWVzc2FnZS1mYWN0b3J5L01lc3NhZ2VGYWN0b3J5XCI6MTAzfV0sMTAxOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e1wiZGVmYXVsdFwiOmV9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHIuTWVzc2FnZVR5cGU9ci5NZXNzYWdlPXZvaWQgMDt2YXIgbz1lKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCIpLGk9bihvKSxhPWUoXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikscz1uKGEpLHU9ZShcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSxjPW4odSksbD1lKFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIiksZj1uKGwpLGQ9ZShcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSxwPW4oZCksaD1lKFwiLi4vcmVUSElOS09iamVjdC9SZXRoaW5rT2JqZWN0LmpzXCIpLHk9bihoKSxtPXIuTWVzc2FnZT1mdW5jdGlvbihlKXtcbmZ1bmN0aW9uIHQoZSxyLG4sbyxhKXsoMCxzW1wiZGVmYXVsdFwiXSkodGhpcyx0KTt2YXIgdT0oMCxmW1wiZGVmYXVsdFwiXSkodGhpcywodC5fX3Byb3RvX198fCgwLGlbXCJkZWZhdWx0XCJdKSh0KSkuY2FsbCh0aGlzKSk7cmV0dXJuIHUuaWQ9ZSx1LmZyb209cix1LnRvPW4sdS50eXBlPW8sdS5ib2R5PWEsdX1yZXR1cm4oMCxwW1wiZGVmYXVsdFwiXSkodCxlKSwoMCxjW1wiZGVmYXVsdFwiXSkodCxbe2tleTpcImFzc2VydElkZW50aXR5XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtpZighZXx8IXQpdGhyb3cgbmV3IEVycm9yKFwibWVzc2FnZSwgdG9rZW4gdG8gYmUgcmVtb3ZlZCwgYW5kIGFzc2VydGVkSWRlbnRpdHkgbXVzdCBiZSBwcm92aWRlZFwiKTt2YXIgcj10aGlzLmJvZHk7cmV0dXJuIHIuaWRUb2tlbj1udWxsLHIuYXNzZXJ0ZWRJZGVudGl0eT10LHRoaXMuYm9keT1yLHRoaXN9fSx7a2V5OlwiYWRkSWRUb2tlblwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKCFlKXRocm93IG5ldyBFcnJvcihcIm1lc3NhZ2UsIHRva2VuIHRvIGJlIGFkZGVkLCBtdXN0IGJlIHByb3ZpZGVkXCIpO3ZhciB0PXRoaXMuYm9keTtyZXR1cm4gdC5pZFRva2VuPWUsdGhpcy5ib2R5PXQsdGhpc319LHtrZXk6XCJhZGRBY2Nlc3NUb2tlblwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKCFlKXRocm93IG5ldyBFcnJvcihcIm1lc3NhZ2UsIHRva2VuIHRvIGJlIGFkZGVkLCBtdXN0IGJlIHByb3ZpZGVkXCIpO3ZhciB0PXRoaXMuYm9keTtyZXR1cm4gdC5hY2Nlc3NUb2tlbj1lLHRoaXMuYm9keT10LHRoaXN9fV0pLHR9KHlbXCJkZWZhdWx0XCJdKTtyLk1lc3NhZ2VUeXBlPXtDUkVBVEU6XCJjcmVhdGVcIixSRUFEOlwicmVhZFwiLFVQREFURTpcInVwZGF0ZVwiLERFTEVURTpcImRlbGV0ZVwiLFNVQlNDUklCRTpcInN1YnNjcmliZVwiLFVOU1VCU0NSSUJFOlwidW5zdWJzY3JpYmVcIixSRVNQT05TRTpcInJlc3BvbnNlXCIsRk9SV0FSRDpcImZvcndhcmRcIixFWEVDVVRFOlwiZXhlY3V0ZVwifTtyW1wiZGVmYXVsdFwiXT1tfSx7XCIuLi9yZVRISU5LT2JqZWN0L1JldGhpbmtPYmplY3QuanNcIjoxMDQsXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2ZcIjo1LFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCI6MTAsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIjoxMSxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiOjEyLFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIjoxM31dLDEwMjpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntcImRlZmF1bHRcIjplfX1mdW5jdGlvbiBvKGUpe3ZhciB0PSgwLHVbXCJkZWZhdWx0XCJdKShlKS5yZWR1Y2UoZnVuY3Rpb24odCxyKXtyZXR1cm4gdFtlW3JdXT1yLHR9LHt9KTtyZXR1cm4oMCxhW1wiZGVmYXVsdFwiXSkoKDAsdVtcImRlZmF1bHRcIl0pKGUpLnJlZHVjZShmdW5jdGlvbih0LHIpe3JldHVybiB0W3JdPWVbcl0sdH0sZnVuY3Rpb24oZSl7cmV0dXJuIHRbZV19KSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksci5VUERBVEVfT1BFUkFUSU9OPXIuQVRUUklCVVRFX1RZUEU9ci5SRUFTT05fUEhSQVNFPXIuUkVTUE9OU0VfQ09ERT1yLkV4ZWN1dGVNZXNzYWdlQm9keT1yLlJlc3BvbnNlTWVzc2FnZUJvZHk9ci5Gb3J3YXJkTWVzc2FnZUJvZHk9ci5VcGRhdGVNZXNzYWdlQm9keT1yLkRlbGV0ZU1lc3NhZ2VCb2R5PXIuUmVhZE1lc3NhZ2VCb2R5PXIuQ3JlYXRlTWVzc2FnZUJvZHk9ci5NZXNzYWdlQm9keT12b2lkIDA7dmFyIGk9ZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZnJlZXplXCIpLGE9bihpKSxzPWUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2tleXNcIiksdT1uKHMpLGM9ZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZlwiKSxsPW4oYyksZj1lKFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpLGQ9bihmKSxwPWUoXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIiksaD1uKHApLHk9ZShcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpLG09bih5KSx2PWUoXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIiksXz1uKHYpO3IuRW51bT1vO3ZhciBiPWUoXCIuLi9yZVRISU5LT2JqZWN0L1JldGhpbmtPYmplY3QuanNcIiksZz1uKGIpLEU9ci5NZXNzYWdlQm9keT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KGUscixuLG8saSl7KDAsZFtcImRlZmF1bHRcIl0pKHRoaXMsdCk7dmFyIGE9KDAsbVtcImRlZmF1bHRcIl0pKHRoaXMsKHQuX19wcm90b19ffHwoMCxsW1wiZGVmYXVsdFwiXSkodCkpLmNhbGwodGhpcykpO3JldHVybiBhLmlkVG9rZW49ZSxhLmFjY2Vzc1Rva2VuPXIsYS5yZXNvdXJjZT1uLGEuc2NoZW1hPW8sYS5hc3NlcnRlZElkZW50aXR5PWksYX1yZXR1cm4oMCxfW1wiZGVmYXVsdFwiXSkodCxlKSwoMCxoW1wiZGVmYXVsdFwiXSkodCxbe2tleTpcImFkZFZpYVwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKCFlKXRocm93IG5ldyBFcnJvcihcInZpYSBVUkwgdG8gYmUgYWRkZWQsIG11c3QgYmUgcHJvdmlkZWRcIik7cmV0dXJuIHRoaXMudmlhPWUsdGhpc319XSksdH0oZ1tcImRlZmF1bHRcIl0pLGo9KHIuQ3JlYXRlTWVzc2FnZUJvZHk9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChlLHIsbixvLGksYSxzKXtpZigoMCxkW1wiZGVmYXVsdFwiXSkodGhpcyx0KSwhZSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgdmFsdWUgcGFyYW1ldGVyIGlzIG51bGxcIik7dmFyIHU9KDAsbVtcImRlZmF1bHRcIl0pKHRoaXMsKHQuX19wcm90b19ffHwoMCxsW1wiZGVmYXVsdFwiXSkodCkpLmNhbGwodGhpcyxuLG8saSxhLHMsYSxzKSk7cmV0dXJuIHUudmFsdWU9ZSxyJiYodS5wb2xpY3k9ciksdX1yZXR1cm4oMCxfW1wiZGVmYXVsdFwiXSkodCxlKSx0fShFKSxyLlJlYWRNZXNzYWdlQm9keT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KGUscixuLG8saSxhLHMsdSl7KDAsZFtcImRlZmF1bHRcIl0pKHRoaXMsdCk7dmFyIGM9KDAsbVtcImRlZmF1bHRcIl0pKHRoaXMsKHQuX19wcm90b19ffHwoMCxsW1wiZGVmYXVsdFwiXSkodCkpLmNhbGwodGhpcyxlLHIsbixvLGkpKTtyZXR1cm4gYSYmKGMuYXR0cmlidXRlPWEpLHMmJihjLmNyaXRlcmlhU3ludGF4PXMpLHUmJihjLmNyaXRlcmlhPXUpLGN9cmV0dXJuKDAsX1tcImRlZmF1bHRcIl0pKHQsZSksdH0oRSksci5EZWxldGVNZXNzYWdlQm9keT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KGUscixuLG8saSxhKXtpZigoMCxkW1wiZGVmYXVsdFwiXSkodGhpcyx0KSxuIGluc3RhbmNlb2YgQXJyYXkpe3ZhciBzPSgwLG1bXCJkZWZhdWx0XCJdKSh0aGlzLCh0Ll9fcHJvdG9fX3x8KDAsbFtcImRlZmF1bHRcIl0pKHQpKS5jYWxsKHRoaXMsZSxyLG51bGwsbyxpKSk7cy5jaGlsZHJlblJlc291cmNlcz1ufWVsc2UgdmFyIHM9KDAsbVtcImRlZmF1bHRcIl0pKHRoaXMsKHQuX19wcm90b19ffHwoMCxsW1wiZGVmYXVsdFwiXSkodCkpLmNhbGwodGhpcyxlLHIsbixvLGkpKTtyZXR1cm4gYSYmKHMuYXR0cmlidXRlPWEpLCgwLG1bXCJkZWZhdWx0XCJdKShzKX1yZXR1cm4oMCxfW1wiZGVmYXVsdFwiXSkodCxlKSx0fShFKSxyLlVwZGF0ZU1lc3NhZ2VCb2R5PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoZSxyLG4sbyxpLGEscyl7KDAsZFtcImRlZmF1bHRcIl0pKHRoaXMsdCk7dmFyIHU9KDAsbVtcImRlZmF1bHRcIl0pKHRoaXMsKHQuX19wcm90b19ffHwoMCxsW1wiZGVmYXVsdFwiXSkodCkpLmNhbGwodGhpcyxlLHIsbixvLGkpKTtyZXR1cm4gdS5hdHRyaWJ1dGU9YSx1LnZhbHVlPXMsdX1yZXR1cm4oMCxfW1wiZGVmYXVsdFwiXSkodCxlKSwoMCxoW1wiZGVmYXVsdFwiXSkodCxbe2tleTpcImFkZEF0dHJpYnV0ZVR5cGVcIix2YWx1ZTpmdW5jdGlvbihlKXtlJiYodGhpcy5hdHRyaWJ1dGVUeXBlPWUpfX0se2tleTpcImFkZE9wZXJhdGlvblwiLHZhbHVlOmZ1bmN0aW9uKGUpe2UmJih0aGlzLm9wZXJhdGlvbj1lKX19XSksdH0oRSksci5Gb3J3YXJkTWVzc2FnZUJvZHk9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChlLHIsbixvLGksYSl7KDAsZFtcImRlZmF1bHRcIl0pKHRoaXMsdCk7dmFyIHM9KDAsbVtcImRlZmF1bHRcIl0pKHRoaXMsKHQuX19wcm90b19ffHwoMCxsW1wiZGVmYXVsdFwiXSkodCkpLmNhbGwodGhpcyxlLHIsbixvLGkpKTtyZXR1cm4gcy5tZXNzYWdlPWEsc31yZXR1cm4oMCxfW1wiZGVmYXVsdFwiXSkodCxlKSx0fShFKSxyLlJlc3BvbnNlTWVzc2FnZUJvZHk9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChlLHIsbixvLGkpeygwLGRbXCJkZWZhdWx0XCJdKSh0aGlzLHQpO3ZhciBhPSgwLG1bXCJkZWZhdWx0XCJdKSh0aGlzLCh0Ll9fcHJvdG9fX3x8KDAsbFtcImRlZmF1bHRcIl0pKHQpKS5jYWxsKHRoaXMsZSxyLG4pKTtyZXR1cm4gbyYmKGEuY29kZT1vLGEuZGVzY3JpcHRpb249altvXSksaSYmKGEudmFsdWU9aSksYX1yZXR1cm4oMCxfW1wiZGVmYXVsdFwiXSkodCxlKSx0fShFKSxyLkV4ZWN1dGVNZXNzYWdlQm9keT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KGUscixuLG8saSxhLHMpeygwLGRbXCJkZWZhdWx0XCJdKSh0aGlzLHQpO3ZhciB1PSgwLG1bXCJkZWZhdWx0XCJdKSh0aGlzLCh0Ll9fcHJvdG9fX3x8KDAsbFtcImRlZmF1bHRcIl0pKHQpKS5jYWxsKHRoaXMsZSxyLG4sbyxpKSk7cmV0dXJuIHUubWV0aG9kPWEscyYmKHMgaW5zdGFuY2VvZiBBcnJheT91LnBhcmFtcz1zOnUucGFyYW1zPVtzXSksdX1yZXR1cm4oMCxfW1wiZGVmYXVsdFwiXSkodCxlKSx0fShFKSxyLlJFU1BPTlNFX0NPREU9byh7MTAwOlwiMTAwXCIsMTAxOlwiMTAxXCIsMjAwOlwiMjAwXCIsMjAxOlwiMjAxXCIsMjAyOlwiMjAyXCIsMjAzOlwiMjAzXCIsMjA0OlwiMjA0XCIsMjA1OlwiMjA1XCIsMjA2OlwiMjA2XCIsMzAwOlwiMzAwXCIsMzAxOlwiMzAxXCIsMzAyOlwiMzAyXCIsMzAzOlwiMzAzXCIsMzA0OlwiMzA0XCIsMzA1OlwiMzA1XCIsMzA3OlwiMzA3XCIsNDAwOlwiNDAwXCIsNDAxOlwiNDAxXCIsNDAyOlwiNDAyXCIsNDAzOlwiNDAzXCIsNDA0OlwiNDA0XCIsNDA1OlwiNDA1XCIsNDA2OlwiNDA2XCIsNDA3OlwiNDA3XCIsNDA4OlwiNDA4XCIsNDA5OlwiNDA5XCIsNDEwOlwiNDEwXCIsNDExOlwiNDExXCIsNDEyOlwiNDEyXCIsNDEzOlwiNDEzXCIsNDE0OlwiNDE0XCIsNDE1OlwiNDE1XCIsNDE2OlwiNDE2XCIsNDE3OlwiNDE3XCIsNDI2OlwiNDI2XCIsNTAwOlwiNTAwXCIsNTAxOlwiNTAxXCIsNTAyOlwiNTAyXCIsNTAzOlwiNTAzXCIsNTA0OlwiNTA0XCIsNTA1OlwiNTA1XCJ9KSxyLlJFQVNPTl9QSFJBU0U9byh7MTAwOlwiQ29udGludWVcIiwxMDE6XCJTd2l0Y2hpbmcgUHJvdG9jb2xzXCIsMjAwOlwiT0tcIiwyMDE6XCJDcmVhdGVkXCIsMjAyOlwiQWNjZXB0ZWRcIiwyMDM6XCJOb24tQXV0aG9yaXRhdGl2ZSBJbmZvcm1hdGlvblwiLDIwNDpcIk5vIENvbnRlbnRcIiwyMDU6XCJSZXNldCBDb250ZW50XCIsMjA2OlwiUGFydGlhbCBDb250ZW50XCIsMzAwOlwiTXVsdGlwbGUgQ2hvaWNlc1wiLDMwMTpcIk1vdmVkIFBlcm1hbmVudGx5XCIsMzAyOlwiRm91bmRcIiwzMDM6XCJTZWUgT3RoZXJcIiwzMDQ6XCJOb3QgTW9kaWZpZWRcIiwzMDU6XCJVc2UgUHJveHlcIiwzMDc6XCJUZW1wb3JhcnkgUmVkaXJlY3RcIiw0MDA6XCJCYWQgUmVxdWVzdFwiLDQwMTpcIlVuYXV0aG9yaXplZFwiLDQwMjpcIlBheW1lbnQgUmVxdWlyZWRcIiw0MDM6XCJGb3JiaWRkZW5cIiw0MDQ6XCJOb3QgRm91bmRcIiw0MDU6XCJNZXRob2QgTm90IEFsbG93ZWRcIiw0MDY6XCJOb3QgQWNjZXB0YWJsZVwiLDQwNzpcIlByb3h5IEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkXCIsNDA4OlwiUmVxdWVzdCBUaW1lb3V0XCIsNDA5OlwiQ29uZmxpY3RcIiw0MTA6XCJHb25lXCIsNDExOlwiTGVuZ3RoIFJlcXVpcmVkXCIsNDEyOlwiUHJlY29uZGl0aW9uIEZhaWxlZFwiLDQxMzpcIlBheWxvYWQgVG9vIExhcmdlXCIsNDE0OlwiUmVxdWVzdC1VUkkgVG9vIExvbmdcIiw0MTU6XCJVbnN1cHBvcnRlZCBNZWRpYSBUeXBlXCIsNDE2OlwiUmFuZ2UgTm90IFNhdGlzZmlhYmxlXCIsNDE3OlwiRXhwZWN0YXRpb24gRmFpbGVkXCIsNDI2OlwiVXBncmFkZSBSZXF1aXJlZFwiLDUwMDpcIkludGVybmFsIFNlcnZlciBFcnJvclwiLDUwMTpcIk5vdCBJbXBsZW1lbnRlZFwiLDUwMjpcIkJhZCBHYXRld2F5XCIsNTAzOlwiU2VydmljZSBVbmF2YWlsYWJsZVwiLDUwNDpcIkdhdGV3YXkgVGltZS1vdXRcIiw1MDU6XCJIVFRQIFZlcnNpb24gTm90IFN1cHBvcnRlZFwifSkpO3IuQVRUUklCVVRFX1RZUEU9byh7T0JKRUNUOlwiT0JKRUNUXCIsQVJSQVk6XCJBUlJBWVwifSksci5VUERBVEVfT1BFUkFUSU9OPW8oe0FERDpcIkFERFwiLFJFTU9WRTpcIlJFTU9WRVwifSk7cltcImRlZmF1bHRcIl09RX0se1wiLi4vcmVUSElOS09iamVjdC9SZXRoaW5rT2JqZWN0LmpzXCI6MTA0LFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9mcmVlemVcIjo0LFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCI6NSxcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qva2V5c1wiOjYsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIjoxMCxcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiOjExLFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCI6MTIsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiOjEzfV0sMTAzOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e1wiZGVmYXVsdFwiOmV9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHIuSWRHZW5lcmF0b3I9dm9pZCAwO3ZhciBvPWUoXCJiYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yXCIpLGk9bihvKSxhPWUoXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikscz1uKGEpLHU9ZShcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSxjPW4odSksbD1lKFwiLi9NZXNzYWdlLmpzXCIpLGY9bihsKSxkPWUoXCIuL01lc3NhZ2VCb2R5LmpzXCIpLHA9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7KDAsc1tcImRlZmF1bHRcIl0pKHRoaXMsZSksdGhpcy5teUdlbmVyYXRvcj0obmV3IGgpLmlkTWFrZXIoKX1yZXR1cm4oMCxjW1wiZGVmYXVsdFwiXSkoZSxbe2tleTpcImNyZWF0ZUNyZWF0ZU1lc3NhZ2VSZXF1ZXN0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LHIsbil7aWYoIWV8fCF0fHwhcil0aHJvdyBuZXcgRXJyb3IoXCJmcm9tLCB0bywgYW5kIHZhbHVlIG9mIG9iamVjdCB0byBiZSBjcmVhdGVkIE1VU1QgYmUgc3BlY2lmaWVkXCIpO3ZhciBvPXRoaXMubXlHZW5lcmF0b3IubmV4dCgpLnZhbHVlLGk9bmV3IGQuQ3JlYXRlTWVzc2FnZUJvZHkocixuLCh2b2lkIDApLCh2b2lkIDApLCh2b2lkIDApLCh2b2lkIDApLCh2b2lkIDApKSxhPW5ldyBmW1wiZGVmYXVsdFwiXShvLGUsdCxsLk1lc3NhZ2VUeXBlLkNSRUFURSxpKTtyZXR1cm4gYX19LHtrZXk6XCJjcmVhdGVGb3J3YXJkTWVzc2FnZVJlcXVlc3RcIix2YWx1ZTpmdW5jdGlvbihlLHQscil7aWYoIWV8fCF0fHwhcil0aHJvdyBuZXcgRXJyb3IoXCJmcm9tLCB0bywgYW5kIG1lc3NhZ2UgdG8gZm9yd2FyZCBNVVNUIGJlIHNwZWNpZmllZFwiKTt2YXIgbj10aGlzLm15R2VuZXJhdG9yLm5leHQoKS52YWx1ZSxvPW5ldyBkLkZvcndhcmRNZXNzYWdlQm9keSgodm9pZCAwKSwodm9pZCAwKSwodm9pZCAwKSwodm9pZCAwKSwodm9pZCAwKSxyKSxpPW5ldyBmW1wiZGVmYXVsdFwiXShuLGUsdCxsLk1lc3NhZ2VUeXBlLkZPUldBUkQsbyk7cmV0dXJuIGl9fSx7a2V5OlwiY3JlYXRlRGVsZXRlTWVzc2FnZVJlcXVlc3RcIix2YWx1ZTpmdW5jdGlvbihlLHQscixuKXtpZighZXx8IXQpdGhyb3cgbmV3IEVycm9yKFwiZnJvbSBhbmQgdG8gcGFyYW1ldGVycyBNVVNUIGJlIHNwZWNpZmllZFwiKTt2YXIgbz10aGlzLm15R2VuZXJhdG9yLm5leHQoKS52YWx1ZSxpPW5ldyBkLkRlbGV0ZU1lc3NhZ2VCb2R5KCh2b2lkIDApLCh2b2lkIDApLHIsbiwodm9pZCAwKSwodm9pZCAwKSksYT1uZXcgZltcImRlZmF1bHRcIl0obyxlLHQsbC5NZXNzYWdlVHlwZS5ERUxFVEUsaSk7cmV0dXJuIGF9fSx7a2V5OlwiY3JlYXRlVXBkYXRlTWVzc2FnZVJlcXVlc3RcIix2YWx1ZTpmdW5jdGlvbihlLHQscixuLG8pe2lmKCFlfHwhdHx8IXIpdGhyb3cgbmV3IEVycm9yKFwiZnJvbSwgYW5kIHRvIGFuZCB2YWx1ZSBNVVNUIGJlIHNwZWNpZmllZFwiKTt2YXIgaT10aGlzLm15R2VuZXJhdG9yLm5leHQoKS52YWx1ZSxhPW5ldyBkLlVwZGF0ZU1lc3NhZ2VCb2R5KCh2b2lkIDApLCh2b2lkIDApLG4sKHZvaWQgMCksKHZvaWQgMCksbyxyKSxzPW5ldyBmW1wiZGVmYXVsdFwiXShpLGUsdCxsLk1lc3NhZ2VUeXBlLlVQREFURSxhKTtyZXR1cm4gc319LHtrZXk6XCJjcmVhdGVSZWFkTWVzc2FnZVJlcXVlc3RcIix2YWx1ZTpmdW5jdGlvbihlLHQscixuKXtpZighZXx8IXR8fCFyKXRocm93IG5ldyBFcnJvcihcImZyb20sIHRvIGFuZCB0aGUgcmVzb3VyY2UgdG8gcmVhZCBmcm9tIE1VU1QgYmUgc3BlY2lmaWVkXCIpO3ZhciBvPXRoaXMubXlHZW5lcmF0b3IubmV4dCgpLnZhbHVlLGk9bmV3IGQuUmVhZE1lc3NhZ2VCb2R5KCh2b2lkIDApLCh2b2lkIDApLHIsKHZvaWQgMCksKHZvaWQgMCksbiwodm9pZCAwKSwodm9pZCAwKSksYT1uZXcgZltcImRlZmF1bHRcIl0obyxlLHQsbC5NZXNzYWdlVHlwZS5SRUFELGkpO3JldHVybiBhfX0se2tleTpcImNyZWF0ZVN1YnNjcmliZU1lc3NhZ2VSZXF1ZXN0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LHIpe2lmKCFlfHwhdHx8IXIpdGhyb3cgbmV3IEVycm9yKFwiZnJvbSwgdG8gYW5kIHRoZSByZXNvdXJjZSB0byBzdWJzY3JpYmUgdG8gTVVTVCBiZSBzcGVjaWZpZWRcIik7dmFyIG49dGhpcy5teUdlbmVyYXRvci5uZXh0KCkudmFsdWUsbz1uZXcgZC5NZXNzYWdlQm9keSgodm9pZCAwKSwodm9pZCAwKSxyLCh2b2lkIDApLCh2b2lkIDApKSxpPW5ldyBmW1wiZGVmYXVsdFwiXShuLGUsdCxsLk1lc3NhZ2VUeXBlLlNVQlNDUklCRSxvKTtyZXR1cm4gaX19LHtrZXk6XCJjcmVhdGVVbnN1YnNjcmliZU1lc3NhZ2VSZXF1ZXN0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LHIpe2lmKCFlfHwhdHx8IXIpdGhyb3cgbmV3IEVycm9yKFwiZnJvbSwgdG8gYW5kIHRoZSByZXNvdXJjZSB0byBzdWJzY3JpYmUgdG8gTVVTVCBiZSBzcGVjaWZpZWRcIik7dmFyIG49dGhpcy5teUdlbmVyYXRvci5uZXh0KCkudmFsdWUsbz1uZXcgZC5NZXNzYWdlQm9keSgodm9pZCAwKSwodm9pZCAwKSxyLCh2b2lkIDApLCh2b2lkIDApKSxpPW5ldyBmW1wiZGVmYXVsdFwiXShuLGUsdCxsLk1lc3NhZ2VUeXBlLlVOU1VCU0NSSUJFLG8pO3JldHVybiBpfX0se2tleTpcImNyZWF0ZUV4ZWN1dGVNZXNzYWdlUmVxdWVzdFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxyLG4pe2lmKCFlfHwhdHx8IXIpdGhyb3cgbmV3IEVycm9yKFwiZnJvbSwgdG8gYW5kIHRoZSBtZXRob2QgdG8gZXhlY3V0ZSBNVVNUIGJlIHNwZWNpZmllZFwiKTt2YXIgbz10aGlzLm15R2VuZXJhdG9yLm5leHQoKS52YWx1ZSxpPW5ldyBkLkV4ZWN1dGVNZXNzYWdlQm9keSgodm9pZCAwKSwodm9pZCAwKSwodm9pZCAwKSwodm9pZCAwKSwodm9pZCAwKSxyLG4pLGE9bmV3IGZbXCJkZWZhdWx0XCJdKG8sZSx0LGwuTWVzc2FnZVR5cGUuRVhFQ1VURSxpKTtyZXR1cm4gYX19LHtrZXk6XCJjcmVhdGVNZXNzYWdlUmVzcG9uc2VcIix2YWx1ZTpmdW5jdGlvbihlLHQscixuKXtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJyZXNwb25zZSBDb2RlIE1VU1QgYmUgc3BlY2lmaWVkXCIpO3ZhciBvPW5ldyBkLlJlc3BvbnNlTWVzc2FnZUJvZHkoKHZvaWQgMCksKHZvaWQgMCksKHZvaWQgMCksdCxyLG4pO3JldHVybiBuZXcgZltcImRlZmF1bHRcIl0oZS5pZCxlLnRvLGUuZnJvbSxsLk1lc3NhZ2VUeXBlLlJFU1BPTlNFLG8pfX0se2tleTpcImdlbmVyYXRlTWVzc2FnZVJlc3BvbnNlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LHIpe2lmKCFlfHwhdCl0aHJvdyBuZXcgRXJyb3IoXCJtZXNzYWdlIGFuZCByZXNwb25zZSBjb2RlIE1VU1QgYmUgc3BlY2lmaWVkXCIpO3ZhciBuPWUuYm9keSxvPW4uaWRUb2tlbixpPW4uYWNjZXNzVG9rZW4sYT1uLnJlc291cmNlLHM9bmV3IGQuUmVzcG9uc2VNZXNzYWdlQm9keShvLGksYSx0LHIpLHU9dGhpcy5teUdlbmVyYXRvci5uZXh0KCkudmFsdWU7cmV0dXJuIG5ldyBmW1wiZGVmYXVsdFwiXSh1LGUudG8sZS5mcm9tLGwuTWVzc2FnZVR5cGUuUkVTUE9OU0Uscyl9fV0pLGV9KCksaD1yLklkR2VuZXJhdG9yPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpeygwLHNbXCJkZWZhdWx0XCJdKSh0aGlzLGUpfXJldHVybigwLGNbXCJkZWZhdWx0XCJdKShlLFt7a2V5OlwiaWRNYWtlclwiLHZhbHVlOmlbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gdCgpe3ZhciBlO3JldHVybiBpW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uKHQpe2Zvcig7Oylzd2l0Y2godC5wcmV2PXQubmV4dCl7Y2FzZSAwOmU9MTtjYXNlIDE6aWYoIShlPDFlNikpe3QubmV4dD02O2JyZWFrfXJldHVybiB0Lm5leHQ9NCxlKys7Y2FzZSA0OnQubmV4dD0xO2JyZWFrO2Nhc2UgNjpjYXNlXCJlbmRcIjpyZXR1cm4gdC5zdG9wKCl9fSx0LHRoaXMpfSl9XSksZX0oKTtyW1wiZGVmYXVsdFwiXT1wfSx7XCIuL01lc3NhZ2UuanNcIjoxMDEsXCIuL01lc3NhZ2VCb2R5LmpzXCI6MTAyLFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCI6MTAsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIjoxMSxcImJhYmVsLXJ1bnRpbWUvcmVnZW5lcmF0b3JcIjoxNX1dLDEwNDpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntcImRlZmF1bHRcIjplfX1PYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxyLlJldGhpbmtPYmplY3Q9dm9pZCAwO3ZhciBvPWUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvanNvbi9zdHJpbmdpZnlcIiksaT1uKG8pLGE9ZShcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSxzPW4oYSksdT1lKFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpLGM9bih1KSxsPWUoXCJ0djRcIiksZj1uKGwpLGQ9ci5SZXRoaW5rT2JqZWN0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpeygwLHNbXCJkZWZhdWx0XCJdKSh0aGlzLGUpfXJldHVybigwLGNbXCJkZWZhdWx0XCJdKShlLFt7a2V5OlwidmFsaWRhdGVcIix2YWx1ZTpmdW5jdGlvbihlKXtmW1wiZGVmYXVsdFwiXS5hZGRTY2hlbWEoZS5pZCxlKTt2YXIgdD1mW1wiZGVmYXVsdFwiXS52YWxpZGF0ZU11bHRpcGxlKEpTT04ucGFyc2UoKDAsaVtcImRlZmF1bHRcIl0pKHRoaXMpKSxlKTtyZXR1cm4gdC5lcnJvcnMuZm9yRWFjaChmdW5jdGlvbihlKXtkZWxldGUgZS5zdGFja30pLCghdC52YWxpZHx8dC5taXNzaW5nLmxlbmd0aD4wKSYmKGNvbnNvbGUud2FybihcIk9iamVjdCB2YWxpZGF0aW9uIFwiKyh0LnZhbGlkP1wic3VjY2VlZGVkLCBidXQgc2NoZW1hIGNvbnRhaW5lZCByZWZlcmVuY2VzOlwiOlwiZmFpbGVkOlwiKSwoMCxpW1wiZGVmYXVsdFwiXSkodCxudWxsLDIpKSxjb25zb2xlLmxvZyhcIk9iamVjdDpcIiwoMCxpW1wiZGVmYXVsdFwiXSkodGhpcyxudWxsLDIpKSksdC52YWxpZH19XSksZX0oKTtyW1wiZGVmYXVsdFwiXT1kfSx7XCJiYWJlbC1ydW50aW1lL2NvcmUtanMvanNvbi9zdHJpbmdpZnlcIjoxLFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCI6MTAsXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIjoxMSx0djQ6OTl9XX0se30sWzEwMF0pKDEwMCl9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1lc3NhZ2VGYWN0b3J5LmpzLm1hcFxuIiwiLyoqXG4qIENvcHlyaWdodCAyMDE2IFBUIElub3Zhw6fDo28gZSBTaXN0ZW1hcyBTQVxuKiBDb3B5cmlnaHQgMjAxNiBJTkVTQy1JRFxuKiBDb3B5cmlnaHQgMjAxNiBRVU9CSVMgTkVUV09SS1MgU0xcbiogQ29weXJpZ2h0IDIwMTYgRlJBVU5IT0ZFUi1HRVNFTExTQ0hBRlQgWlVSIEZPRVJERVJVTkcgREVSIEFOR0VXQU5EVEVOIEZPUlNDSFVORyBFLlZcbiogQ29weXJpZ2h0IDIwMTYgT1JBTkdFIFNBXG4qIENvcHlyaWdodCAyMDE2IERldXRzY2hlIFRlbGVrb20gQUdcbiogQ29weXJpZ2h0IDIwMTYgQXBpemVlXG4qIENvcHlyaWdodCAyMDE2IFRFQ0hOSVNDSEUgVU5JVkVSU0lUQVQgQkVSTElOXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbioqL1xuLy8gaW1wb3J0IE1lc3NhZ2VGYWN0b3J5IGZyb20gJy4uLy4uL3Jlc291cmNlcy9NZXNzYWdlRmFjdG9yeSc7XG5cbi8qKlxuICogQ2xhc3Mgd2lsbCBhc2sgdG8gdGhlIG1lc3NhZ2Ugbm9kZSBmb3IgYWRkcmVzc2VzXG4gKi9cbmNsYXNzIEFkZHJlc3NBbGxvY2F0aW9uIHtcbiAgLyogcHJpdmF0ZVxuICBfdXJsOiBVUkxcbiAgX2J1czogTWluaUJ1c1xuICAqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gQWRkcmVzcyBBbGxvY2F0aW9uXG4gICAqIEBwYXJhbSAge1VSTC5VUkx9ICAgICAgdXJsIC0gdXJsIGZyb20gd2hvIGlzIHNlbmRpbmcgdGhlIG1lc3NhZ2VcbiAgICogQHBhcmFtICB7TWluaUJ1c30gICAgICBidXMgLSBNaW5pQnVzIHVzZWQgZm9yIGFkZHJlc3MgYWxsb2NhdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3IodXJsLCBidXMsIHJlZ2lzdHJ5KSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIC8vIGxldCBtZXNzYWdlRmFjdG9yeSA9IG5ldyBNZXNzYWdlRmFjdG9yeSgpO1xuICAgIC8vXG4gICAgLy8gX3RoaXMuX21lc3NhZ2VGYWN0b3J5ID0gbWVzc2FnZUZhY3Rvcnk7XG4gICAgX3RoaXMuX3VybCA9IHVybDtcbiAgICBfdGhpcy5fYnVzID0gYnVzO1xuICAgIF90aGlzLl9yZWdpc3RyeSA9IHJlZ2lzdHJ5O1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgVVJMIHZhbHVlXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHVybCB2YWx1ZTtcbiAgICovXG4gIGdldCB1cmwoKSB7IHJldHVybiB0aGlzLl91cmw7IH1cblxuICAvKipcbiAgICogQXNrIGZvciBjcmVhdGlvbiBvZiBhIG51bWJlciBvZiBIeXBlcnR5IGFkZHJlc3NlcywgdG8gdGhlIGRvbWFpbiBtZXNzYWdlIG5vZGUuXG4gICAqIEBwYXJhbSAge0RvbWFpbn0gZG9tYWluIC0gRG9tYWluIG9mIHRoZSBtZXNzYWdlIG5vZGUuXG4gICAqIEBwYXJhbSAge251bWJlcn0gbnVtYmVyIC0gTnVtYmVyIG9mIGFkZHJlc3NlcyB0byByZXF1ZXN0XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEh5cGVydHlVUkw+fSAgQSBsaXN0IG9mIEh5cGVydHlVUkwnc1xuICAgKi9cbiAgY3JlYXRlKGRvbWFpbiwgbnVtYmVyLCBpbmZvLCBzY2hlbWUsIHJldXNlVVJMKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cbiAgICAgIGlmIChyZXVzZVVSTCkge1xuXG4gICAgICAgIF90aGlzLl9yZWdpc3RyeS5jaGVja1JlZ2lzdGVyZWRVUkxzKGluZm8pLnRoZW4oKHVybHMpID0+IHtcblxuICAgICAgICAgIGlmICh1cmxzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJ1tBZGRyZXNzQWxsb2NhdGlvbiAtICcgKyBzY2hlbWUgKyAnXSAtIFJldXNlIFVSTCcpO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0ge25ld0FkZHJlc3M6IGZhbHNlLCBhZGRyZXNzOiB1cmxzfTtcbiAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJ1tBZGRyZXNzQWxsb2NhdGlvbiAtIHJldXNlVVJMXSAtIE9iamVjdCAnICsgcmV1c2VVUkwgKyAnIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgcmVqZWN0KCdVUkwgTm90IEZvdW5kJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0pLmNhdGNoKChyZWFzb24pID0+IHtcbiAgICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgICAgfSk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgX3RoaXMuX3JlZ2lzdHJ5LmNoZWNrUmVnaXN0ZXJlZFVSTHMoaW5mbykudGhlbigodXJscykgPT4ge1xuXG4gICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYWxyZWFkeSBhIFVSTCwgdGhlbiByZXR1cm5zIHRoYXQgVVJMLCBvdGhlcndpc2UgcmVxdWVzdCBhIG5ldyBVUkxcbiAgICAgICAgICBpZiAodXJscykge1xuXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJ1tBZGRyZXNzQWxsb2NhdGlvbiAtICcgKyBzY2hlbWUgKyAnXSAtIFJldXNlIFVSTCcpO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0ge25ld0FkZHJlc3M6IGZhbHNlLCBhZGRyZXNzOiB1cmxzfTtcbiAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuXG4gICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gVVJMIHNhdmVkIHJlcXVlc3QgYSBuZXcgVVJMXG4gICAgICAgICAgICBfdGhpcy5fYWxsb2NhdGVOZXdBZGRyZXNzKGRvbWFpbiwgc2NoZW1lLCBudW1iZXIpLnRoZW4oKGFsbG9jYXRlZCkgPT4ge1xuICAgICAgICAgICAgICByZXNvbHZlKGFsbG9jYXRlZCk7XG4gICAgICAgICAgICB9KS5jYXRjaCgocmVhc29uKSA9PiB7XG4gICAgICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKChyZWFzb24pID0+IHtcbiAgICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgICAgfSk7XG5cbiAgICAgIH1cbiAgICB9KTtcblxuICB9XG5cbiAgX2FsbG9jYXRlTmV3QWRkcmVzcyhkb21haW4sIHNjaGVtZSwgbnVtYmVyKSB7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICBsZXQgbXNnID0ge1xuICAgICAgICB0eXBlOiAnY3JlYXRlJywgZnJvbTogdGhpcy5fdXJsLCB0bzogJ2RvbWFpbjovL21zZy1ub2RlLicgKyBkb21haW4gKyAnL2FkZHJlc3MtYWxsb2NhdGlvbicsXG4gICAgICAgIGJvZHk6IHt2YWx1ZTogeyBudW1iZXI6IG51bWJlciB9IH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChzY2hlbWUgIT09ICdoeXBlcnQnKSBtc2cuYm9keS5zY2hlbWUgPSBzY2hlbWU7XG5cbiAgICAgIGNvbnNvbGUuaW5mbygnW0FkZHJlc3NBbGxvY2F0aW9uIC0gJyArIHNjaGVtZSArICddIC0gUmVxdWVzdCBuZXcgVVJMJyk7XG5cbiAgICAgIC8vIFRPRE86IGNoYW5nZSB0aGlzIHJlc3BvbnNlIE1lc3NhZ2UgdXNpbmcgdGhlIE1lc3NhZ2VGYWN0b3J5XG4gICAgICB0aGlzLl9idXMucG9zdE1lc3NhZ2UobXNnLCAocmVwbHkpID0+IHtcbiAgICAgICAgaWYgKHJlcGx5LmJvZHkuY29kZSA9PT0gMjAwKSB7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IHtuZXdBZGRyZXNzOiB0cnVlLCBhZGRyZXNzOiByZXBseS5ib2R5LnZhbHVlLmFsbG9jYXRlZH07XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChyZXBseS5ib2R5LmRlc2MpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIH0pO1xuXG4gIH1cblxuICAvKipcbiAgKiBTZW5kIGEgcmVxdWVzdCB0byB0aGUgZG9tYWluIG1lc3NhZ2Ugbm9kZSwgdG8gZGVhbGxvY2F0ZSBvbmUgb3IgbW9yZSBhZGRyZXNzZXNcbiAgKiBAcGFyYW0gIHtEb21haW59IGRvbWFpbiAtIERvbWFpbiBvZiB0aGUgbWVzc2FnZSBub2RlLlxuICAqIEBwYXJhbSAge2FkZHJlc3Nlc30gYWRkcmVzc2VzIHRvIHJlcXVlc3QgdGhlIGRlYWxsb2NhdGlvblxuICAqIEByZXR1cm5zIHtQcm9taXNlfSAgdGhlIHJlc3BvbnNlIGJ5IHRoZSBtZXNzYWdlIG5vZGVcbiAgKi9cbiAgZGVsZXRlKGRvbWFpbiwgYWRkcmVzc2VzKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIGxldCBtZXNzYWdlID0ge1xuICAgICAgdHlwZTogJ2RlbGV0ZScsIGZyb206IF90aGlzLl91cmwsIHRvOiAnZG9tYWluOi8vbXNnLW5vZGUuJyArIGRvbWFpbiArICcvYWRkcmVzcy1hbGxvY2F0aW9uJyxcbiAgICAgIGJvZHk6IHtjaGlsZHJlblJlc291cmNlczogYWRkcmVzc2VzfVxuICAgIH07XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICBfdGhpcy5fYnVzLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIChyZXBseSkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygncmVwbHknLCByZXBseSk7XG4gICAgICAgIGlmIChyZXBseS5ib2R5LmNvZGUgPT09IDIwMCkge1xuICAgICAgICAgIHJlc29sdmUocmVwbHkuYm9keS5jb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QocmVwbHkuYm9keS5kZXNjKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBZGRyZXNzQWxsb2NhdGlvbjtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxNiBQVCBJbm92YcOnw6NvIGUgU2lzdGVtYXMgU0FcbiogQ29weXJpZ2h0IDIwMTYgSU5FU0MtSURcbiogQ29weXJpZ2h0IDIwMTYgUVVPQklTIE5FVFdPUktTIFNMXG4qIENvcHlyaWdodCAyMDE2IEZSQVVOSE9GRVItR0VTRUxMU0NIQUZUIFpVUiBGT0VSREVSVU5HIERFUiBBTkdFV0FORFRFTiBGT1JTQ0hVTkcgRS5WXG4qIENvcHlyaWdodCAyMDE2IE9SQU5HRSBTQVxuKiBDb3B5cmlnaHQgMjAxNiBEZXV0c2NoZSBUZWxla29tIEFHXG4qIENvcHlyaWdodCAyMDE2IEFwaXplZVxuKiBDb3B5cmlnaHQgMjAxNiBURUNITklTQ0hFIFVOSVZFUlNJVEFUIEJFUkxJTlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qKi9cblxuLyoqXG4qIEBhdXRob3IgbWljYWVscGVkcm9zYUBnbWFpbC5jb21cbiogTWluaW1hbCBpbnRlcmZhY2UgYW5kIGltcGxlbWVudGF0aW9uIHRvIHNlbmQgYW5kIHJlY2VpdmUgbWVzc2FnZXMuIEl0IGNhbiBiZSByZXVzZWQgaW4gbWFueSB0eXBlIG9mIGNvbXBvbmVudHMuXG4qIENvbXBvbmVudHMgdGhhdCBuZWVkIGEgbWVzc2FnZSBzeXN0ZW0gc2hvdWxkIHJlY2VpdmUgdGhpcyBjbGFzcyBhcyBhIGRlcGVuZGVuY3kgb3IgZXh0ZW5kIGl0LlxuKiBFeHRlbnNpb25zIHNob3VsZCBpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBwcml2YXRlIG1ldGhvZHM6IF9vblBvc3RNZXNzYWdlIGFuZCBfcmVnaXN0ZXJFeHRlcm5hbExpc3RlbmVyXG4qL1xuY2xhc3MgQnVzIHtcbiAgLyogcHJpdmF0ZVxuICBfbXNnSWQ6IG51bWJlcjtcbiAgX3N1YnNjcmlwdGlvbnM6IDx1cmw6IE1zZ0xpc3RlbmVyW10+XG5cbiAgX3Jlc3BvbnNlVGltZU91dDogbnVtYmVyXG4gIF9yZXNwb25zZUNhbGxiYWNrczogPHVybCtpZDogKG1zZykgPT4gdm9pZD5cblxuICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG4gICAgX3RoaXMuX21zZ0lkID0gMDtcbiAgICBfdGhpcy5fc3Vic2NyaXB0aW9ucyA9IHt9O1xuXG4gICAgX3RoaXMuX3Jlc3BvbnNlVGltZU91dCA9IDUwMDA7IC8vZGVmYXVsdCB0byAzc1xuICAgIF90aGlzLl9yZXNwb25zZUNhbGxiYWNrcyA9IHt9O1xuXG4gICAgX3RoaXMuX3JlZ2lzdGVyRXh0ZXJuYWxMaXN0ZW5lcigpO1xuICB9XG5cbiAgLyoqXG4gICogUmVnaXN0ZXIgbGlzdGVuZXIgdG8gcmVjZWl2ZSBtZXNzYWdlIHdoZW4gXCJtc2cudG8gPT09IHVybFwiLlxuICAqIFNwZWNpYWwgdXJsIFwiKlwiIGZvciBkZWZhdWx0IGxpc3RlbmVyIGlzIGFjY2VwdGVkIHRvIGludGVyY2VwdCBhbGwgbWVzc2FnZXMuXG4gICogQHBhcmFtIHtVUkx9IHVybCBBZGRyZXNzIHRvIGludGVyY2VwdCwgdGhhIGlzIGluIHRoZSBtZXNzYWdlIFwidG9cIlxuICAqIEBwYXJhbSB7TGlzdGVuZXJ9IGxpc3RlbmVyIGxpc3RlbmVyXG4gICogQHJldHVybiB7TXNnTGlzdGVuZXJ9IGluc3RhbmNlIG9mIE1zZ0xpc3RlbmVyXG4gICovXG4gIGFkZExpc3RlbmVyKHVybCwgbGlzdGVuZXIpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgbGV0IGl0ZW0gPSBuZXcgTXNnTGlzdGVuZXIoX3RoaXMuX3N1YnNjcmlwdGlvbnMsIHVybCwgbGlzdGVuZXIpO1xuICAgIGxldCBpdGVtTGlzdCA9IF90aGlzLl9zdWJzY3JpcHRpb25zW3VybF07XG4gICAgaWYgKCFpdGVtTGlzdCkge1xuICAgICAgaXRlbUxpc3QgPSBbXTtcbiAgICAgIF90aGlzLl9zdWJzY3JpcHRpb25zW3VybF0gPSBpdGVtTGlzdDtcbiAgICB9XG5cbiAgICBpdGVtTGlzdC5wdXNoKGl0ZW0pO1xuICAgIHJldHVybiBpdGVtO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hbnVhbGx5IGFkZCBhIHJlc3BvbnNlIGxpc3RlbmVyLiBPbmx5IG9uZSBsaXN0ZW5lciBwZXIgbWVzc2FnZSBJRCBzaG91bGQgZXhpc3QuXG4gICAqIEFURU5USU9OLCB0aGVyZSBpcyBubyB0aW1lb3V0IGZvciB0aGlzIGxpc3RlbmVyLlxuICAgKiBUaGUgbGlzdGVuZXIgc2hvdWxkIGJlIHJlbW92ZWQgd2l0aCBhIHJlbW92ZVJlc3BvbnNlTGlzdGVuZXIsIGZhaWxpbmcgdG8gZG8gdGhpcyB3aWxsIHJlc3VsdCBpbiBhIHVucmVsZWFzZWQgbWVtb3J5IHByb2JsZW0uXG4gICAqIEBwYXJhbSB7VVJMfSB1cmwgT3JpZ2luIGFkZHJlc3Mgb2YgdGhlIG1lc3NhZ2Ugc2VudCwgXCJtc2cuZnJvbVwiLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbXNnSWQgTWVzc2FnZSBJRCB0aGF0IGlzIHJldHVybmVkIGZyb20gdGhlIHBvc3RNZXNzYWdlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNwb25zZUxpc3RlbmVyIENhbGxiYWNrIGZ1bmN0aW9uIGZvciB0aGUgcmVzcG9uc2VcbiAgICovXG4gIGFkZFJlc3BvbnNlTGlzdGVuZXIodXJsLCBtc2dJZCwgcmVzcG9uc2VMaXN0ZW5lcikge1xuICAgIHRoaXMuX3Jlc3BvbnNlQ2FsbGJhY2tzW3VybCArIG1zZ0lkXSA9IHJlc3BvbnNlTGlzdGVuZXI7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSByZXNwb25zZSBsaXN0ZW5lci5cbiAgICogQHBhcmFtIHtVUkx9IHVybCBPcmlnaW4gYWRkcmVzcyBvZiB0aGUgbWVzc2FnZSBzZW50LCBcIm1zZy5mcm9tXCIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtc2dJZCAgTWVzc2FnZSBJRCB0aGF0IGlzIHJldHVybmVkIGZyb20gdGhlIHBvc3RNZXNzYWdlXG4gICAqL1xuICByZW1vdmVSZXNwb25zZUxpc3RlbmVyKHVybCwgbXNnSWQpIHtcbiAgICBkZWxldGUgdGhpcy5fcmVzcG9uc2VDYWxsYmFja3NbdXJsICsgbXNnSWRdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgZXhpc3RlbnQgbGlzdGVuZXJzIGZvciB0aGUgVVJMXG4gICAqIEBwYXJhbSAge1VSTH0gdXJsIEFkZHJlc3MgcmVnaXN0ZXJlZFxuICAgKi9cbiAgcmVtb3ZlQWxsTGlzdGVuZXJzT2YodXJsKSB7XG4gICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvbnNbdXJsXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgbWV0aG9kIHRvIGJpbmQgbGlzdGVuZXJzIChpbiBib3RoIGRpcmVjdGlvbnMpIGludG8gb3RoZXIgTWluaUJ1cyB0YXJnZXQuXG4gICAqIEBwYXJhbSAge1VSTH0gb3V0VXJsIE91dGJvdW5kIFVSTCwgcmVnaXN0ZXIgbGlzdGVuZXIgZm9yIHVybCBpbiBkaXJlY3Rpb24gXCJ0aGlzIC0+IHRhcmdldFwiXG4gICAqIEBwYXJhbSAge1VSTH0gaW5VcmwgSW5ib3VuZCBVUkwsIHJlZ2lzdGVyIGxpc3RlbmVyIGZvciB1cmwgaW4gZGlyZWN0aW9uIFwidGFyZ2V0IC0+IHRoaXNcIlxuICAgKiBAcGFyYW0gIHtNaW5pQnVzfSB0YXJnZXQgVGhlIG90aGVyIHRhcmdldCBNaW5pQnVzXG4gICAqIEByZXR1cm4ge0JvdW5kfSBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgcHJvcGVydGllcyBbdGhpc0xpc3RlbmVyLCB0YXJnZXRMaXN0ZW5lcl0gYW5kIHRoZSB1bmJpbmQgbWV0aG9kLlxuICAgKi9cbiAgYmluZChvdXRVcmwsIGluVXJsLCB0YXJnZXQpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgbGV0IHRoaXNMaXN0biA9IF90aGlzLmFkZExpc3RlbmVyKG91dFVybCwgKG1zZykgPT4ge1xuICAgICAgdGFyZ2V0LnBvc3RNZXNzYWdlKG1zZyk7XG4gICAgfSk7XG5cbiAgICBsZXQgdGFyZ2V0TGlzdG4gPSB0YXJnZXQuYWRkTGlzdGVuZXIoaW5VcmwsIChtc2cpID0+IHtcbiAgICAgIF90aGlzLnBvc3RNZXNzYWdlKG1zZyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdGhpc0xpc3RlbmVyOiB0aGlzTGlzdG4sXG4gICAgICB0YXJnZXRMaXN0ZW5lcjogdGFyZ2V0TGlzdG4sXG4gICAgICB1bmJpbmQ6ICgpID0+IHtcbiAgICAgICAgdGhpcy50aGlzTGlzdGVuZXIucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMudGFyZ2V0TGlzdGVuZXIucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vcHVibGlzaCBvbiBkZWZhdWx0IGxpc3RlbmVyc1xuICBfcHVibGlzaE9uRGVmYXVsdChtc2cpIHtcbiAgICAvL2lzIHRoZXJlIGFueSBcIipcIiAoZGVmYXVsdCkgbGlzdGVuZXJzP1xuICAgIGxldCBpdGVtTGlzdCA9IHRoaXMuX3N1YnNjcmlwdGlvbnNbJyonXTtcbiAgICBpZiAoaXRlbUxpc3QpIHtcbiAgICAgIHRoaXMuX3B1Ymxpc2hPbihpdGVtTGlzdCwgbXNnKTtcbiAgICB9XG4gIH1cblxuICAvL3B1Ymxpc2ggb24gYSBzdWJzY3JpcHRpb24gbGlzdC5cbiAgX3B1Ymxpc2hPbihpdGVtTGlzdCwgbXNnKSB7XG4gICAgaXRlbUxpc3QuZm9yRWFjaCgoc3ViKSA9PiB7XG4gICAgICBzdWIuX2NhbGxiYWNrKG1zZyk7XG4gICAgfSk7XG4gIH1cblxuICBfcmVzcG9uc2VDYWxsYmFjayhpbk1zZywgcmVzcG9uc2VDYWxsYmFjaykge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG5cbiAgICAvL2F1dG9tYXRpYyBtYW5hZ2VtZW50IG9mIHJlc3BvbnNlIGhhbmRsZXJzXG4gICAgaWYgKHJlc3BvbnNlQ2FsbGJhY2spIHtcbiAgICAgIGxldCByZXNwb25zZUlkID0gaW5Nc2cuZnJvbSArIGluTXNnLmlkO1xuICAgICAgX3RoaXMuX3Jlc3BvbnNlQ2FsbGJhY2tzW3Jlc3BvbnNlSWRdID0gcmVzcG9uc2VDYWxsYmFjaztcblxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGxldCByZXNwb25zZUZ1biA9IF90aGlzLl9yZXNwb25zZUNhbGxiYWNrc1tyZXNwb25zZUlkXTtcbiAgICAgICAgZGVsZXRlIF90aGlzLl9yZXNwb25zZUNhbGxiYWNrc1tyZXNwb25zZUlkXTtcblxuICAgICAgICBpZiAocmVzcG9uc2VGdW4pIHtcbiAgICAgICAgICBsZXQgZXJyb3JNc2cgPSB7XG4gICAgICAgICAgICBpZDogaW5Nc2cuaWQsIHR5cGU6ICdyZXNwb25zZScsXG4gICAgICAgICAgICBib2R5OiB7IGNvZGU6IDQwOCwgZGVzYzogJ1Jlc3BvbnNlIHRpbWVvdXQhJywgdmFsdWU6IGluTXNnIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmVzcG9uc2VGdW4oZXJyb3JNc2cpO1xuICAgICAgICB9XG4gICAgICB9LCBfdGhpcy5fcmVzcG9uc2VUaW1lT3V0KTtcbiAgICB9XG4gIH1cblxuICBfb25SZXNwb25zZShtc2cpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKG1zZy50eXBlID09PSAncmVzcG9uc2UnKSB7XG4gICAgICBsZXQgcmVzcG9uc2VJZCA9IG1zZy50byArIG1zZy5pZDtcbiAgICAgIGxldCByZXNwb25zZUZ1biA9IF90aGlzLl9yZXNwb25zZUNhbGxiYWNrc1tyZXNwb25zZUlkXTtcblxuICAgICAgLy9pZiBpdCdzIGEgcHJvdmlzaW9uYWwgcmVzcG9uc2UsIGRvbid0IGRlbGV0ZSByZXNwb25zZSBsaXN0ZW5lclxuICAgICAgaWYgKG1zZy5ib2R5LmNvZGUgPj0gMjAwKSB7XG4gICAgICAgIGRlbGV0ZSBfdGhpcy5fcmVzcG9uc2VDYWxsYmFja3NbcmVzcG9uc2VJZF07XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXNwb25zZUZ1bikge1xuICAgICAgICByZXNwb25zZUZ1bihtc2cpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvL3JlY2VpdmUgbWVzc2FnZXMgZnJvbSBleHRlcm5hbCBpbnRlcmZhY2VcbiAgX29uTWVzc2FnZShtc2cpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKCFfdGhpcy5fb25SZXNwb25zZShtc2cpKSB7XG4gICAgICBsZXQgaXRlbUxpc3QgPSBfdGhpcy5fc3Vic2NyaXB0aW9uc1ttc2cudG9dO1xuICAgICAgaWYgKGl0ZW1MaXN0KSB7XG4gICAgICAgIF90aGlzLl9wdWJsaXNoT24oaXRlbUxpc3QsIG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5fcHVibGlzaE9uRGVmYXVsdChtc2cpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9nZW5JZChpbk1zZykge1xuICAgIC8vVE9ETzogaG93IGRvIHdlIG1hbmFnZSBtZXNzYWdlIElEJ3M/IFNob3VsZCBpdCBiZSBhIGdsb2JhbCBydW50aW1lIGNvdW50ZXIsIG9yIHBlciBVUkwgYWRkcmVzcz9cbiAgICAvL0dsb2JhbCBjb3VudGVyIHdpbGwgbm90IHdvcmssIGJlY2F1c2UgdGhlcmUgd2lsbCBiZSBtdWx0aXBsZSBNaW5pQnVzIGluc3RhbmNlcyFcbiAgICAvL1BlciBVUkwsIGNhbiBiZSBhIGxvdCBvZiBkYXRhIHRvIG1haW50YWluIVxuICAgIC8vTWF5YmUgYSBjb3VudGVyIHBlciBNaW5pQnVzIGluc3RhbmNlLiBUaGlzIGlzIHRoZSBhc3N1bWVkIHNvbHV0aW9uIGZvciBub3cuXG4gICAgaWYgKCFpbk1zZy5pZCB8fCBpbk1zZy5pZCA9PT0gMCkge1xuICAgICAgdGhpcy5fbXNnSWQrKztcbiAgICAgIGluTXNnLmlkID0gdGhpcy5fbXNnSWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICogU2VuZCBtZXNzYWdlcyB0byBsb2NhbCBsaXN0ZW5lcnMsIG9yIGlmIG5vdCBleGlzdHMgdG8gZXh0ZXJuYWwgbGlzdGVuZXJzLlxuICAqIEl0J3MgaGFzIGFuIG9wdGlvbmFsIG1lY2hhbmlzbSBmb3IgYXV0b21hdGljIG1hbmFnZW1lbnQgb2YgcmVzcG9uc2UgaGFuZGxlcnMuXG4gICogVGhlIHJlc3BvbnNlIGhhbmRsZXIgd2lsbCBiZSB1bnJlZ2lzdGVyZWQgYWZ0ZXIgcmVjZWl2aW5nIHRoZSByZXNwb25zZSwgb3IgYWZ0ZXIgcmVzcG9uc2UgdGltZW91dCAoZGVmYXVsdCB0byAzcykuXG4gICogQHBhcmFtICB7TWVzc2FnZX0gbXNnIE1lc3NhZ2UgdG8gc2VuZC4gTWVzc2FnZSBJRCBpcyBhdXRvbWF0aWNhbGx5IGFkZGVkIHRvIHRoZSBtZXNzYWdlLlxuICAqIEBwYXJhbSAge0Z1bmN0aW9ufSByZXNwb25zZUNhbGxiYWNrIE9wdGlvbmFsIHBhcmFtZXRlciwgaWYgdGhlIGRldmVsb3BlciB3aGF0J3MgYXV0b21hdGljIHJlc3BvbnNlIG1hbmFnZW1lbnQuXG4gICogQHJldHVybiB7bnVtYmVyfSBSZXR1cm5zIHRoZSBtZXNzYWdlIElELCBpbiBjYXNlIGl0IHNob3VsZCBiZSBuZWVkZWQgZm9yIG1hbnVhbCBtYW5hZ2VtZW50IG9mIHRoZSByZXNwb25zZSBoYW5kbGVyLlxuICAqL1xuICBwb3N0TWVzc2FnZShpbk1zZywgcmVzcG9uc2VDYWxsYmFjaykgeyB9XG5cbiAgLyoqXG4gICAqIE5vdCBwdWJsaWMgYXZhaWxhYmxlLCB1c2VkIGJ5IHRoZSBjbGFzcyBleHRlbnNpb24gaW1wbGVtZW50YXRpb24sIHRvIHByb2Nlc3MgbWVzc2FnZXMgZnJvbSB0aGUgcHVibGljIFwicG9zdE1lc3NhZ2VcIiB3aXRob3V0IGEgcmVnaXN0ZXJlZCBsaXN0ZW5lci5cbiAgICogVXNlZCB0byBzZW5kIHRoZSBtZXNzYWdlIHRvIGFuIGV4dGVybmFsIGludGVyZmFjZSwgbGlrZSBhIFdlYldvcmtlciwgSUZyYW1lLCBldGMuXG4gICAqIEBwYXJhbSAge01lc3NhZ2UuTWVzc2FnZX0gbXNnIE1lc3NhZ2VcbiAgICovXG4gIF9vblBvc3RNZXNzYWdlKG1zZykgeyAvKmltcGxlbWVudGF0aW9uIHdpbGwgc2VuZCBtZXNzYWdlIHRvIGV4dGVybmFsIHN5c3RlbSovIH1cblxuICAvKipcbiAgICogTm90IHB1YmxpYyBhdmFpbGFibGUsIHVzZWQgYnkgdGhlIGNsYXNzIGV4dGVuc2lvbiBpbXBsZW1lbnRhdGlvbiwgdG8gcHJvY2VzcyBhbGwgbWVzc2FnZXMgdGhhdCBlbnRlciB0aGUgTWluaUJ1cyBmcm9tIGFuIGV4dGVybmFsIGludGVyZmFjZSwgbGlrZSBhIFdlYldvcmtlciwgSUZyYW1lLCBldGMuXG4gICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBvbmUgdGltZSBpbiB0aGUgY29uc3RydWN0b3IgdG8gcmVnaXN0ZXIgZXh0ZXJuYWwgbGlzdGVuZXJzLlxuICAgKiBUaGUgaW1wbGVtZW50YXRpb24gd2lsbCBwcm9iYWJseSBjYWxsIHRoZSBcIl9vbk1lc3NhZ2VcIiBtZXRob2QgdG8gcHVibGlzaCBpbiB0aGUgbG9jYWwgbGlzdGVuZXJzLlxuICAgKiBETyBOT1QgY2FsbCBcInBvc3RNZXNzYWdlXCIsIHRoZXJlIGlzIGEgZGFuZ2VyIHRoYXQgdGhlIG1lc3NhZ2UgZW50ZXJzIGluIGEgY3ljbGUhXG4gICAqL1xuICBfcmVnaXN0ZXJFeHRlcm5hbExpc3RlbmVyKCkgeyAvKmltcGxlbWVudGF0aW9uIHdpbGwgcmVnaXN0ZXIgZXh0ZXJuYWwgbGlzdGVuZXIgYW5kIGNhbGwgXCJ0aGlzLl9vbk1lc3NhZ2UobXNnKVwiICovIH1cblxufVxuXG5jbGFzcyBNc2dMaXN0ZW5lciB7XG4gIC8qIHByaXZhdGVcbiAgX3N1YnNjcmlwdGlvbnM6IDxzdHJpbmc6IE1zZ0xpc3RlbmVyW10+O1xuICBfdXJsOiBzdHJpbmc7XG4gIF9jYWxsYmFjazogKG1zZykgPT4gdm9pZDtcbiAgKi9cblxuICBjb25zdHJ1Y3RvcihzdWJzY3JpcHRpb25zLCB1cmwsIGNhbGxiYWNrKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIF90aGlzLl9zdWJzY3JpcHRpb25zID0gc3Vic2NyaXB0aW9ucztcbiAgICBfdGhpcy5fdXJsID0gdXJsO1xuICAgIF90aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG5cbiAgZ2V0IHVybCgpIHsgcmV0dXJuIHRoaXMuX3VybDsgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhpcyBsaXN0ZW5lciBmcm9tIHRoZSBCdXNcbiAgICovXG4gIHJlbW92ZSgpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgbGV0IHN1YnMgPSBfdGhpcy5fc3Vic2NyaXB0aW9uc1tfdGhpcy5fdXJsXTtcbiAgICBpZiAoc3Vicykge1xuICAgICAgbGV0IGluZGV4ID0gc3Vicy5pbmRleE9mKF90aGlzKTtcbiAgICAgIHN1YnMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgLy9pZiB0aGVyZSBhcmUgbm8gbGlzdGVuZXJzLCByZW1vdmUgdGhlIHN1YnNjcmlwdGlvbiBlbnRpcmVseS5cbiAgICAgIGlmIChzdWJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkZWxldGUgX3RoaXMuX3N1YnNjcmlwdGlvbnNbX3RoaXMuX3VybF07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1cztcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxNiBQVCBJbm92YcOnw6NvIGUgU2lzdGVtYXMgU0FcbiogQ29weXJpZ2h0IDIwMTYgSU5FU0MtSURcbiogQ29weXJpZ2h0IDIwMTYgUVVPQklTIE5FVFdPUktTIFNMXG4qIENvcHlyaWdodCAyMDE2IEZSQVVOSE9GRVItR0VTRUxMU0NIQUZUIFpVUiBGT0VSREVSVU5HIERFUiBBTkdFV0FORFRFTiBGT1JTQ0hVTkcgRS5WXG4qIENvcHlyaWdodCAyMDE2IE9SQU5HRSBTQVxuKiBDb3B5cmlnaHQgMjAxNiBEZXV0c2NoZSBUZWxla29tIEFHXG4qIENvcHlyaWdodCAyMDE2IEFwaXplZVxuKiBDb3B5cmlnaHQgMjAxNiBURUNITklTQ0hFIFVOSVZFUlNJVEFUIEJFUkxJTlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qKi9cbmltcG9ydCBCdXMgZnJvbSAnLi9CdXMnO1xuaW1wb3J0IFBpcGVsaW5lIGZyb20gJy4vUGlwZWxpbmUnO1xuXG4vKipcbiogQGF1dGhvciBtaWNhZWxwZWRyb3NhQGdtYWlsLmNvbVxuKiBNZXNzYWdlIEJVUyBJbnRlcmZhY2UgaXMgYW4gZXh0ZW5zaW9uIG9mIHRoZSBCdXNcbiogSXQgZG9lc24ndCBzdXBwb3J0IHRoZSBkZWZhdWx0ICcqJyBsaXN0ZW5lciwgaW5zdGVhZCBpdCB1c2VzIHRoZSByZWdpc3RyeS5yZXNvbHZlKC4uKVxuKi9cbmNsYXNzIE1lc3NhZ2VCdXMgZXh0ZW5kcyBCdXMge1xuICAvKiBwcml2YXRlXG4gIF9yZWdpc3RyeTogUmVnaXN0cnlcbiAgX2ZvcndhcmRzOiB7IDxmcm9tLXVybD46IHsgZmw6IE1zZ0xpc3RlbmVyLCBzYW5kYm94VG9VcmxzOiBNYXAoU2FuZGJveCwgW3RvLXVybF0pLCB1cmxUb1NhbmRib3g6IHsgdG8tdXJsOiBTYW5kYm94IH0gfSB9XG5cbiAgX3BpcGVsaW5lOiBQaXBlbGluZVxuICAqL1xuXG4gIC8vVE9ETzogZnV0dXJlIG9wdGltaXphdGlvblxuICAvLzEuIG1lc3NhZ2UgYmF0Y2ggcHJvY2Vzc2luZyB3aXRoIHNldEludGVydmFsXG4gIC8vMi4gcmVzb2x2ZSBkZWZhdWx0IGdhdGV3YXkvcHJvdG9zdHViIHdpdGggcmVnaXN0ZXIucmVzb2x2ZVxuXG4gIGNvbnN0cnVjdG9yKHJlZ2lzdHJ5KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9yZWdpc3RyeSA9IHJlZ2lzdHJ5O1xuICAgIHRoaXMuX2ZvcndhcmRzID0ge307XG5cbiAgICB0aGlzLl9waXBlbGluZSA9IG5ldyBQaXBlbGluZSgoZXJyb3IpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdQSVBFTElORS1FUlJPUjogJywgSlNPTi5zdHJpbmdpZnkoZXJyb3IpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldCBwaXBlbGluZSgpIHsgcmV0dXJuIHRoaXMuX3BpcGVsaW5lOyB9XG5cbiAgLyoqXG4gICAqIFBvc3QgYSBtZXNzYWdlIGZvciByb3V0aW5nLiBJdCB3aWxsIGZpcnN0IHNlYXJjaCBmb3IgYSBsaXN0ZW5lciwgaWYgdGhlcmUgaXMgbm8gb25lLCBpdCBzZW5kcyB0byBhIGV4dGVybmFsIHJvdXRpbmcgdXNpbmcgdGhlIF9vblBvc3RNZXNzYWdlLlxuICAgKiBFeHRlcm5hbCByb3V0aW5nIHVzZSB0aGUgcmVnaXN0cnkucmVzb2x2ZSguLikgbWV0aG9kIHRvIGRlY2lkZSB0aGUgZGVzdGluYXRpb24gc2FuZGJveC5cbiAgICogQHBhcmFtICB7TWVzc2FnZX0gaW5Nc2cgICAgICAgICAgICBKU09OIHdpdGggbWFuZGF0b3J5IE1lc3NhZ2Ugc3RydWN0dXJlIHtpZCwgdHlwZSwgZnJvbSwgdG99XG4gICAqIEBwYXJhbSAge0NhbGxiYWNrfSByZXNwb25zZUNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrIGlmIGEgcmVzcG9uc2UgaXMgZXhwZWN0ZWQgZnJvbSB0aGUgcmVxdWVzdC4gQSByZXNwb25zZSB3aWxsIGJlIGFsd2F5cyBzZW50LCBldmVuIGlmIGl0IGlzIGEgXCJUaW1lb3V0XCIuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgICAgICAgICAgICB0aGUgTWVzc2FnZSBpZFxuICAgKi9cbiAgcG9zdE1lc3NhZ2UoaW5Nc2csIHJlc3BvbnNlQ2FsbGJhY2spIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgX3RoaXMuX2dlbklkKGluTXNnKTtcblxuICAgIF90aGlzLl9waXBlbGluZS5wcm9jZXNzKGluTXNnLCAobXNnKSA9PiB7XG5cbiAgICAgIF90aGlzLl9yZXNwb25zZUNhbGxiYWNrKGluTXNnLCByZXNwb25zZUNhbGxiYWNrKTtcblxuICAgICAgaWYgKCFfdGhpcy5fb25SZXNwb25zZShtc2cpKSB7XG4gICAgICAgIGxldCBpdGVtTGlzdCA9IF90aGlzLl9zdWJzY3JpcHRpb25zW21zZy50b107XG4gICAgICAgIGlmIChpdGVtTGlzdCkge1xuICAgICAgICAgIC8vZG8gbm90IHB1Ymxpc2ggb24gZGVmYXVsdCBhZGRyZXNzLCBiZWNhdXNlIG9mIGxvb3BiYWNrIGN5Y2xlXG4gICAgICAgICAgX3RoaXMuX3B1Ymxpc2hPbihpdGVtTGlzdCwgbXNnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL2lmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLCBzZW5kIHRvIGV4dGVybmFsIGludGVyZmFjZVxuICAgICAgICAgIF90aGlzLl9vblBvc3RNZXNzYWdlKG1zZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBpbk1zZy5pZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGV4dGVybmFsIHB1Ymxpc2ggYWRkcmVzcyBsaXN0ZW5lci4gRXZlcnkgbWVzc2FnZSBmb3IgdGhlIGFkZHJlc3Mgd2lsbCBiZSBmb3J3YXJkZWQgdG8gdGhlIGV4dGVybmFsIHJvdXRpbmcgYnkgX29uUG9zdE1lc3NhZ2UuXG4gICAqIFRoaXMgbWVhbnMsIGV2ZW4gaWYgdGhlcmUgaXMgYSBsaXN0ZW5lciBmb3IgdGhlIGFkZHJlc3MsIGl0IHdpbGwgYWxzbyBzZW5kIHRoZSBtZXNzYWdlIHRvIHRoZSBleHRlcm5hbCByb3V0aW5nLlxuICAgKiBAcGFyYW0ge1VSTH0gZnJvbSBQdWJsaXNoIGFkZHJlc3MuXG4gICAqL1xuICBhZGRQdWJsaXNoKGZyb20pIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy92ZXJpZnkgaWYgZm9yd2FyZCBleGlzdFxuICAgIGxldCByZWZDb3VudCA9IF90aGlzLl9mb3J3YXJkc1tmcm9tXTtcbiAgICBpZiAoIXJlZkNvdW50KSB7XG4gICAgICBsZXQgZm9yd2FyZExpc3RlbmVyID0gX3RoaXMuYWRkTGlzdGVuZXIoZnJvbSwgKG1zZykgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnTUItUFVCTElTSDogKCAnICsgZnJvbSArICcgKScpO1xuICAgICAgICBfdGhpcy5fb25Qb3N0TWVzc2FnZShtc2cpO1xuICAgICAgfSk7XG5cbiAgICAgIHJlZkNvdW50ID0ge1xuICAgICAgICBjb3VudGVyOiAwLFxuICAgICAgICBmbDogZm9yd2FyZExpc3RlbmVyLFxuICAgICAgICByZW1vdmU6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmNvdW50ZXItLTtcbiAgICAgICAgICBpZiAodGhpcy5jb3VudGVyID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmZsLnJlbW92ZSgpO1xuICAgICAgICAgICAgZGVsZXRlIF90aGlzLl9mb3J3YXJkc1tmcm9tXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgX3RoaXMuX2ZvcndhcmRzW2Zyb21dID0gcmVmQ291bnQ7XG4gICB9XG5cbiAgIHJlZkNvdW50LmNvdW50ZXIrKztcbiAgIHJldHVybiByZWZDb3VudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgZm9yd2FyZCBsaXN0ZW5lciBmb3IgYSBtZXNzYWdlIGRlc3RpbmF0aW9uLiBFdmVyeSBtZXNzYWdlIHJlYWNoaW5nIGFuIGFkZHJlc3Mgd2lsbCBiZSBhbHNvIHNlbnQgdG8gdGhlIGZvcndhcmQgYWRkcmVzcy5cbiAgICogQHBhcmFtIHtVUkx9IGZyb20gTWVzc2FnZSBkZXN0aW5hdGlvbiwgaXQncyBhY3R1YWxseSB0aGUgZmllbGQgXCJ0b1wiIG9mIHRoZSBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge1VSTH0gdG8gICBGb3J3YXJkIGFkZHJlc3MuXG4gICAqL1xuICAgYWRkRm9yd2FyZChmcm9tLCB0bykge1xuICAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgIHJldHVybiBfdGhpcy5hZGRMaXN0ZW5lcihmcm9tLCAobXNnKSA9PiB7XG4gICAgICAgY29uc29sZS5sb2coJ01CLUZPUldBUkQ6ICggJyArIGZyb20gKyAnIHRvICcgKyB0byArICcgKScpO1xuICAgICAgIF90aGlzLmZvcndhcmQodG8sIG1zZyk7XG4gICAgIH0pO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEp1c3QgZm9yd2FyZCdzIGEgbWVzc2FnZSB0byB0aGUgZm9yd2FyZCBhZGRyZXNzLiBMaXN0ZW5lcnMgc2hvdWxkIGJlIGF2YWlsYWJsZSBmb3IgdGhlIGZvcndhcmQgYWRkcmVzcy5cbiAgICAqIEBwYXJhbSAge1VSTH0gdXJsIEZvcndhcmQgYWRkcmVzcy5cbiAgICAqIEBwYXJhbSAge01lc3NhZ2V9IG1zZyBNZXNzYWdlIHRvIGZvcndhcmRcbiAgICAqL1xuICAgZm9yd2FyZCh1cmwsIG1zZykge1xuICAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgIGxldCBpdGVtTGlzdCA9IF90aGlzLl9zdWJzY3JpcHRpb25zW3VybF07XG4gICAgIGlmIChpdGVtTGlzdCkge1xuICAgICAgIF90aGlzLl9wdWJsaXNoT24oaXRlbUxpc3QsIG1zZyk7XG4gICAgIH1cbiAgIH1cblxuICAgLy9kZWZhdWx0IHJvdXRlLCBpZiB0aGVyZSBhcmUgbm8gbGlzdGVuZXJzIGF2YWlsYWJsZSBmb3IgYSBtZXNzYWdlIGRlc3RpbmF0aW9uLlxuICAgX29uUG9zdE1lc3NhZ2UobXNnKSB7XG4gICAgIGxldCBfdGhpcyA9IHRoaXM7XG5cbiAgICAgLy9yZXNvbHZlIGV4dGVybmFsIHByb3Rvc3R1Yi4uLlxuICAgICBfdGhpcy5fcmVnaXN0cnkucmVzb2x2ZShtc2cudG8pLnRoZW4oKHJvdXRlKSA9PiB7XG4gICAgICAgX3RoaXMuZm9yd2FyZChyb3V0ZSwgbXNnKTtcbiAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZSkge1xuICAgICAgIGNvbnNvbGUubG9nKCdSRVNPTFZFLUVSUk9SOiAnLCBlKTtcbiAgICAgfSk7XG4gICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1lc3NhZ2VCdXM7XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTYgUFQgSW5vdmHDp8OjbyBlIFNpc3RlbWFzIFNBXG4qIENvcHlyaWdodCAyMDE2IElORVNDLUlEXG4qIENvcHlyaWdodCAyMDE2IFFVT0JJUyBORVRXT1JLUyBTTFxuKiBDb3B5cmlnaHQgMjAxNiBGUkFVTkhPRkVSLUdFU0VMTFNDSEFGVCBaVVIgRk9FUkRFUlVORyBERVIgQU5HRVdBTkRURU4gRk9SU0NIVU5HIEUuVlxuKiBDb3B5cmlnaHQgMjAxNiBPUkFOR0UgU0FcbiogQ29weXJpZ2h0IDIwMTYgRGV1dHNjaGUgVGVsZWtvbSBBR1xuKiBDb3B5cmlnaHQgMjAxNiBBcGl6ZWVcbiogQ29weXJpZ2h0IDIwMTYgVEVDSE5JU0NIRSBVTklWRVJTSVRBVCBCRVJMSU5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKiovXG5cbi8qKlxuKiBAYXV0aG9yIG1pY2FlbHBlZHJvc2FAZ21haWwuY29tXG4qIFNlcXVlbmNpYWwgcHJvY2Vzc29yIG9mIG1ldGhvZHMuIFNpbWlsYXIgdG8gaG93IFNlcXVlbnRpYWwgUHJvbWlzZSdzIHdvcmssIGJ1dCBiZXR0ZXIgZml0IGZvciBtZXNzYWdlIHByb2Nlc3NpbmcuXG4qIE5vcm1hbCB1c2UgZm9yIHRoaXMsIGlzIHRvIGludGVyY2VwdCBhbGwgbWVzc2FnZXMgd2l0aCBjb25maWd1cmVkIGhhbmRsZXJzLCBhbmQgYWN0IGFjY29yZGluZ2x5LlxuKi9cbmNsYXNzIFBpcGVsaW5lIHtcbiAgLyogcHVibGljXG4gICAgaGFuZGxlcnM6ICgoUGlwZUNvbnRleHQpID0+IHZvaWQpW11cbiAgICBvbkZhaWw6IChlcnJvcikgPT4gdm9pZFxuICAqL1xuXG4gIGNvbnN0cnVjdG9yKF9vbkZhaWwpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgX3RoaXMuaGFuZGxlcnMgPSBbXTtcbiAgICBfdGhpcy5vbkZhaWwgPSBfb25GYWlsO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydCBhIG1lc3NhZ2UgaW4gdGhlIHBpcGVsaW5lIHF1ZXVlLiBBbGwgbWVzc2FnZXMgYXJlIHdyYXBwZWQgd2l0aCBhIFBpcGVDb250ZXh0LlxuICAgKiBAcGFyYW0gIHtNZXNzYWdlfSBtc2cgICAgICAgTWVzc2FnZSBmb3IgdGhlIHF1ZXVlXG4gICAqIEBwYXJhbSAge0NhbGxiYWNrfSBvbkRlbGl2ZXIgV2hlbiBtZXNzYWdlIGlzIGZpbmlzaGVkIHByb2Nlc3NpbmcgZnJvbSBhbGwgaGFuZGxlcnMsIGl0IHdpbGwgYmUgZGVsaXZlcmVkIGluIHRoaXMgY2FsbGJhY2suXG4gICAqL1xuICBwcm9jZXNzKG1zZywgb25EZWxpdmVyKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIGlmIChfdGhpcy5oYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICBsZXQgaXRlciA9IG5ldyBJdGVyYXRvcihfdGhpcy5oYW5kbGVycyk7XG4gICAgICBpdGVyLm5leHQobmV3IFBpcGVDb250ZXh0KF90aGlzLCBpdGVyLCBtc2csIG9uRGVsaXZlcikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbkRlbGl2ZXIobXNnKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4qIEBhdXRob3IgbWljYWVscGVkcm9zYUBnbWFpbC5jb21cbiogV3JhcHBlciBhcm91bmQgYSBtZXNzYWdlIHRoYXQgYWRkcyBhY3Rpb25zIHRoYXQgY2FuIGJlIGZpcmVkIGJ5IGFueSBpbnRlcmNlcHRvciBoYW5kbGVyLlxuKiBUaGUgUGlwZWxpbmUgaXMgYXN5bmNocm9ub3VzLCBzbyBhbiBoYW5kbGVyIHNob3VsZCBhbHdheXMgY2FsbCBhbiBhY3Rpb24sIHRoZSBkZWZhdWx0IG9uZSBpcyBcIm5leHQoKVwiXG4qL1xuY2xhc3MgUGlwZUNvbnRleHQge1xuICAvKiBwcml2YXRlXG4gICAgX2luU3RvcDogYm9vbGVhblxuXG4gICAgX3BpcGVsaW5lOiBQaXBlbGluZVxuICAgIF9pdGVyOiBJdGVyYXRvclxuICAgIF9tc2c6IE1lc3NhZ2VcbiAgKi9cblxuICBjb25zdHJ1Y3RvcihwaXBlbGluZSwgaXRlciwgbXNnLCBvbkRlbGl2ZXIpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgX3RoaXMuX2luU3RvcCA9IGZhbHNlO1xuXG4gICAgX3RoaXMuX3BpcGVsaW5lID0gcGlwZWxpbmU7XG4gICAgX3RoaXMuX2l0ZXIgPSBpdGVyO1xuICAgIF90aGlzLl9tc2cgPSBtc2c7XG4gICAgX3RoaXMuX29uRGVsaXZlciA9IG9uRGVsaXZlcjtcbiAgfVxuXG4gIGdldCBwaXBlbGluZSgpIHsgcmV0dXJuIHRoaXMuX3BpcGVsaW5lOyB9XG5cbiAgZ2V0IG1zZygpIHsgcmV0dXJuIHRoaXMuX21zZzsgfVxuICBzZXQgbXNnKGluTXNnKSB7IHRoaXMuX21zZyA9IGluTXNnOyB9XG5cbiAgLyoqXG4gICAqIFByb2NlZWQgdG8gdGhlIG5leHQgaW50ZXJjZXB0b3IgaGFuZGxlciwgdW5sZXNzIHRoZXJlIHdhcyBhbiBlcnJvci4gSWYgaXQncyB0aGUgbGFzdCBvbmUsIHByb2NlZWQgdG8gb25EZWxpdmVyIGhhbmRsZXIuXG4gICAqL1xuICBuZXh0KCkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoIV90aGlzLl9pblN0b3ApIHtcbiAgICAgIGlmIChfdGhpcy5faXRlci5oYXNOZXh0KSB7XG4gICAgICAgIF90aGlzLl9pdGVyLm5leHQoX3RoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuX29uRGVsaXZlcihfdGhpcy5fbXNnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VlZCBkaXJlY3RseSB0byB0aGUgb25EZWxpdmVyIGhhbmRsZXIsIHVubGVzcyB0aGVyZSB3YXMgYW4gZXJyb3IuXG4gICAqL1xuICBkZWxpdmVyKCkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKCFfdGhpcy5faW5TdG9wKSB7XG4gICAgICBfdGhpcy5faW5TdG9wID0gdHJ1ZTtcbiAgICAgIF90aGlzLl9vbkRlbGl2ZXIoX3RoaXMuX21zZyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1hcmsgdGhlIGNvbnRleHQgd2l0aCBhbiBlcnJvciBhbmQgcHJvY2VlZCB0byB0aGUgb25GYWlsIGhhbmRsZXIuXG4gICAqIEBwYXJhbSAge1t0eXBlXX0gZXJyb3IgW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgZmFpbChlcnJvcikge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoIV90aGlzLl9pblN0b3ApIHtcbiAgICAgIF90aGlzLl9pblN0b3AgPSB0cnVlO1xuICAgICAgaWYgKF90aGlzLl9waXBlbGluZS5vbkZhaWwpIHtcbiAgICAgICAgX3RoaXMuX3BpcGVsaW5lLm9uRmFpbChlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIEl0ZXJhdG9yIHtcbiAgLyogcHJpdmF0ZVxuICAgIF9pbmRleDogbnVtYmVyXG4gICAgX2FycmF5OiBbXVxuICAqL1xuXG4gIGNvbnN0cnVjdG9yKGFycmF5KSB7XG4gICAgdGhpcy5faW5kZXggPSAtMTtcbiAgICB0aGlzLl9hcnJheSA9IGFycmF5O1xuICB9XG5cbiAgZ2V0IGhhc05leHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4IDwgdGhpcy5fYXJyYXkubGVuZ3RoIC0gMTtcbiAgfVxuXG4gIGdldCBuZXh0KCkge1xuICAgIHRoaXMuX2luZGV4Kys7XG4gICAgcmV0dXJuIHRoaXMuX2FycmF5W3RoaXMuX2luZGV4XTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQaXBlbGluZTtcbiIsIi8qKlxuKiBDbGFzcyB3aXRoIHRoZSBjcnlwdG9ncmFwaGljIGZ1bmN0aW9ucyBmb3IgdGhlIGF1dGhlbnRpY2F0aW9uIHByb3RvY29sXG4qXG4qL1xuY2xhc3MgQ3J5cHRvIHtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gIH1cblxuICAvKipcbiAgKiBlbmNvZGUgYSBieXRlQXJyYXkgdmFsdWUgaW4gYmFzZSA2NCBlbmNvZGVcbiAgKiBAcGFyYW0gICB7Ynl0ZUFycmF5fSAgICB2YWx1ZSAgICBieXRlQXJyYXkgdmFsdWVcbiAgKiBAcmV0dXJuICB7c3RyaW5nfSAgIGVuY29kZWQgdmFsdWVcbiAgKi9cbiAgZW5jb2RlKHZhbHVlKSB7XG4gICAgcmV0dXJuIGJ0b2EodmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICogZGVjb2RlIGEgYmFzZTY0IHZhbHVlIGluIGEgbmV3IFVpbnQ4QXJyYXlcbiAgKiBAcGFyYW0gICB7c3RyaW5nfSAgICB2YWx1ZSAgICB2YWx1ZSBlbmNvZGVkIGluIGJhc2UgNjRcbiAgKiBAcmV0dXJuICB7Ynl0ZUFycmF5fSBkZWNvZGVkVmFsdWVcbiAgKi9cbiAgZGVjb2RlKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KEpTT04ucGFyc2UoJ1snICsgYXRvYih2YWx1ZSkgKyAnXScpKTtcbiAgfVxuXG4gIGVuY3J5cHRSU0EocHViS2V5LCBkYXRhKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIF90aGlzLl9pbXBvcnRSU0FlbmNyeXB0S2V5KG5ldyBVaW50OEFycmF5KHB1YktleSkpLnRoZW4oZnVuY3Rpb24ocHVibGljS2V5KSB7XG5cbiAgICAgICAgY3J5cHRvLnN1YnRsZS5lbmNyeXB0KFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBuYW1lOiAnUlNBLU9BRVAnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHVibGljS2V5LCAvL2Zyb20gZ2VuZXJhdGVLZXkgb3IgaW1wb3J0S2V5IGFib3ZlXG4gICAgICAgICAgICBkYXRhIC8vQXJyYXlCdWZmZXIgb2YgZGF0YSB5b3Ugd2FudCB0byBlbmNyeXB0XG4gICAgICAgIClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oZW5jcnlwdGVkKSB7XG4gICAgICAgICAgLy9yZXR1cm5zIGFuIEFycmF5QnVmZmVyIGNvbnRhaW5pbmcgdGhlIGVuY3J5cHRlZCBkYXRhXG4gICAgICAgICAgLy9jb25zb2xlLmxvZygnY3J5cHRvLWVuY3J5cHRSU0EnLCBuZXcgVWludDhBcnJheShlbmNyeXB0ZWQpKTtcbiAgICAgICAgICByZXNvbHZlKG5ldyBVaW50OEFycmF5KGVuY3J5cHRlZCkpO1xuXG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdjcnlwdG8tZW5jcnlwdFJTQScsIGVycik7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0pO1xuXG4gICAgICB9KTtcblxuICAgIH0pO1xuXG4gIH1cblxuICBkZWNyeXB0UlNBKHByaXZLZXksIGRhdGEpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgX3RoaXMuX2ltcG9ydFJTQWRlY3J5cHRLZXkocHJpdktleSkudGhlbihmdW5jdGlvbihwcml2YXRlS2V5KSB7XG5cbiAgICAgICAgY3J5cHRvLnN1YnRsZS5kZWNyeXB0KFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBuYW1lOiAnUlNBLU9BRVAnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJpdmF0ZUtleSwgLy9mcm9tIGdlbmVyYXRlS2V5IG9yIGltcG9ydEtleSBhYm92ZVxuICAgICAgICAgICAgZGF0YSAvL0FycmF5QnVmZmVyIG9mIHRoZSBkYXRhXG4gICAgICAgIClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oZGVjcnlwdGVkKSB7XG5cbiAgICAgICAgICBsZXQgZGVjcnlwdGVkRGF0YSA9IG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZCk7XG5cbiAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjcnlwdG8tZGVjcnlwdFJTQScsIGRlY3J5cHRlZERhdGEpO1xuICAgICAgICAgIHJlc29sdmUoZGVjcnlwdGVkRGF0YSk7XG5cbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ2NyeXB0by1kZWNyeXB0UlNBJywgZXJyKTtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgIH0pO1xuICB9XG5cbiAgc2lnblJTQShwcml2S2V5LCBkYXRhKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIF90aGlzLl9pbXBvcnRSU0FzaWduS2V5KHByaXZLZXkpLnRoZW4oZnVuY3Rpb24ocHJpdmF0ZUtleSkge1xuXG4gICAgICAgIGNyeXB0by5zdWJ0bGUuc2lnbihcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByaXZhdGVLZXksIC8vZnJvbSBnZW5lcmF0ZUtleSBvciBpbXBvcnRLZXkgYWJvdmVcbiAgICAgICAgICAgIF90aGlzLl91dGY4RW5jb2RlKGRhdGEpIC8vQXJyYXlCdWZmZXIgb2YgZGF0YSB5b3Ugd2FudCB0byBzaWduXG4gICAgICAgIClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oc2lnbmF0dXJlKSB7XG4gICAgICAgICAgLy9yZXR1cm5zIGFuIEFycmF5QnVmZmVyIGNvbnRhaW5pbmcgdGhlIHNpZ25hdHVyZVxuICAgICAgICAgIC8vY29uc29sZS5sb2coJ2NyeXB0by1zaWduUlNBJywgbmV3IFVpbnQ4QXJyYXkoc2lnbmF0dXJlKSk7XG4gICAgICAgICAgcmVzb2x2ZShuZXcgVWludDhBcnJheShzaWduYXR1cmUpKTtcblxuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnY3J5cHRvLXNpZ25SU0EnLCBlcnIpO1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9KTtcblxuICAgICAgfSk7XG5cbiAgICB9KTtcbiAgfVxuXG4gIHZlcmlmeVJTQShwdWJLZXksIGRhdGEsIHNpZ25hdHVyZSkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBfdGhpcy5faW1wb3J0UlNBdmVyaWZ5S2V5KHB1YktleSkudGhlbihmdW5jdGlvbihwdWJsaWNLZXkpIHtcblxuICAgICAgICBjcnlwdG8uc3VidGxlLnZlcmlmeShcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHB1YmxpY0tleSwgLy9mcm9tIGdlbmVyYXRlS2V5IG9yIGltcG9ydEtleSBhYm92ZVxuICAgICAgICAgICAgc2lnbmF0dXJlLCAvL0FycmF5QnVmZmVyIG9mIHRoZSBzaWduYXR1cmVcbiAgICAgICAgICAgIF90aGlzLl91dGY4RW5jb2RlKGRhdGEpIC8vQXJyYXlCdWZmZXIgb2YgdGhlIGRhdGFcbiAgICAgICAgKVxuICAgICAgICAudGhlbihmdW5jdGlvbihpc3ZhbGlkKSB7XG4gICAgICAgICAgLy9yZXR1cm5zIGEgYm9vbGVhbiBvbiB3aGV0aGVyIHRoZSBzaWduYXR1cmUgaXMgdHJ1ZSBvciBub3RcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjcnlwdG8tdmVyaWZ5UlNBJywgaXN2YWxpZCk7XG4gICAgICAgICAgcmVzb2x2ZShpc3ZhbGlkKTtcblxuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnY3J5cHRvLXZlcmlmeVJTQScsIGVycik7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0pO1xuXG4gICAgICB9KTtcblxuICAgIH0pO1xuICB9XG5cbiAgZW5jcnlwdEFFUyhrZXksIGRhdGEsIGl2KSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIF90aGlzLl9pbXBvcnRBRVNrZXkoa2V5KS50aGVuKGZ1bmN0aW9uKGFlc0tleSkge1xuXG4gICAgICAgIGNyeXB0by5zdWJ0bGUuZW5jcnlwdChcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmFtZTogJ0FFUy1DQkMnLFxuICAgICAgICAgICAgICAvL0Rvbid0IHJlLXVzZSBpbml0aWFsaXphdGlvbiB2ZWN0b3JzIVxuICAgICAgICAgICAgICAvL0Fsd2F5cyBnZW5lcmF0ZSBhIG5ldyBpdiBldmVyeSB0aW1lIHlvdXIgZW5jcnlwdCFcbiAgICAgICAgICAgICAgaXY6IGl2XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWVzS2V5LCAvL2Zyb20gZ2VuZXJhdGVLZXkgb3IgaW1wb3J0S2V5IGFib3ZlXG4gICAgICAgICAgICBfdGhpcy5fdXRmOEVuY29kZShkYXRhKSAvL0FycmF5QnVmZmVyIG9mIGRhdGEgeW91IHdhbnQgdG8gZW5jcnlwdFxuICAgICAgICApXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKGVuY3J5cHRlZCkge1xuICAgICAgICAgIC8vcmV0dXJucyBhbiBBcnJheUJ1ZmZlciBjb250YWluaW5nIHRoZSBlbmNyeXB0ZWQgZGF0YVxuICAgICAgICAgIC8vY29uc29sZS5sb2coJ2NyeXB0by1lbmNyeXB0QUVTJywgbmV3IFVpbnQ4QXJyYXkoZW5jcnlwdGVkKSk7XG4gICAgICAgICAgcmVzb2x2ZShuZXcgVWludDhBcnJheShlbmNyeXB0ZWQpKTtcblxuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnY3J5cHRvLWVuY3J5cHRBRVMnLCBlcnIpO1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9KTtcblxuICAgICAgfSk7XG5cbiAgICB9KTtcbiAgfVxuXG4gIGRlY3J5cHRBRVMoa2V5LCBkYXRhLCBpdikge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBfdGhpcy5faW1wb3J0QUVTa2V5KGtleSkudGhlbihmdW5jdGlvbihhZXNLZXkpIHtcblxuICAgICAgICBjcnlwdG8uc3VidGxlLmRlY3J5cHQoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5hbWU6ICdBRVMtQ0JDJyxcbiAgICAgICAgICAgICAgaXY6IGl2XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWVzS2V5LCAvL2Zyb20gZ2VuZXJhdGVLZXkgb3IgaW1wb3J0S2V5IGFib3ZlXG4gICAgICAgICAgICBkYXRhIC8vQXJyYXlCdWZmZXIgb2YgdGhlIGRhdGFcbiAgICAgICAgKVxuICAgICAgICAudGhlbihmdW5jdGlvbihkZWNyeXB0ZWQpIHtcblxuICAgICAgICAgIGxldCBkZWNvZGVkRGF0YSA9IF90aGlzLl91dGY4RGVjb2RlKG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZCkpO1xuICAgICAgICAgIC8vY29uc29sZS5sb2coJ2NyeXB0by1kZWNyeXB0QUVTJywgZGVjb2RlZERhdGEpO1xuICAgICAgICAgIHJlc29sdmUoZGVjb2RlZERhdGEpO1xuXG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdjcnlwdG8tZGVjcnlwdEFFUycsIGVycik7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0pO1xuXG4gICAgICB9KTtcblxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICogY3JlYXRlcyBhIGhhc2ggdXNpbmcgdGhlIEhNQUMgYWxnb3JpdGhtXG4gICogQHBhcmFtICB7Ynl0ZUFycmF5fSAgICBrZXkgICAgICAga2V5IHRvIGJlIHVzZWQgaW4gdGhlIGhtYWNcbiAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgZGF0YSAgICAgICBpbmZvcm1hdGlvbiB0byBiZSBoYXNoZWRcbiAgKiBAcmV0dXJuICB7Ynl0ZUFycmF5fSAgIHNpZ25hdHVyZSAgcmVzdWx0aW5nIGhhc2hcbiAgKi9cbiAgaGFzaEhNQUMoa2V5LCBkYXRhKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLHJlamVjdCkge1xuXG4gICAgICBfdGhpcy5faW1wb3J0SE1BQ2tleShrZXkpLnRoZW4oZnVuY3Rpb24oaG1hY0tleSkge1xuXG4gICAgICAgIGNyeXB0by5zdWJ0bGUuc2lnbihcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdITUFDJ1xuICAgICAgICB9LFxuICAgICAgICBobWFjS2V5LCAvL2Zyb20gZ2VuZXJhdGVLZXkgb3IgaW1wb3J0S2V5IGFib3ZlXG4gICAgICAgIF90aGlzLl91dGY4RW5jb2RlKGRhdGEpIC8vQXJyYXlCdWZmZXIgb2YgZGF0YSB5b3Ugd2FudCB0byBzaWduXG4gICAgICAgIClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oc2lnbmF0dXJlKSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZygnY3J5cHRvLWhhc2hITUFDJywgc2lnbmF0dXJlKTtcblxuICAgICAgICAgIC8vcmV0dXJucyBhbiBBcnJheUJ1ZmZlciBjb250YWluaW5nIHRoZSBzaWduYXR1cmVcbiAgICAgICAgICByZXNvbHZlKG5ldyBVaW50OEFycmF5KHNpZ25hdHVyZSkpO1xuXG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdjcnlwdG8taGFzaEhNQUMnLCBlcnIpO1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICogdmVyaWZpZXMgYW4gaGFzaCB1c2luZyB0aGUgSE1BQyBhbGdvcml0aG1cbiAgKiBAcGFyYW0gIHtieXRlQXJyYXl9ICAgIGtleSAgICAgICBrZXkgdG8gYmUgdXNlZCBpbiB0aGUgaG1hY1xuICAqIEBwYXJhbSAge3N0cmluZ30gICAgICBkYXRhICAgICAgIGluZm9ybWF0aW9uIHRvIGJlIGhhc2hlZCB0byBjb21wYXJlXG4gICogQHBhcmFtICB7Ynl0ZUFycmF5fSAgc2lnbmF0dXJlICAgaGFzaCB0byBjb21wYXJlIHdpdGggdGhlIHJlY2VpdmVkIGRhdGFcbiAgKiBAcmV0dXJuICB7Ym9vbGVhbn0gICBpc3ZhbGlkICAgICBib29sZWFuIHNheWluZyBpZiB0aGUgZGF0YSBjb3JyZXNwb25kcyB0byB0aGUgaGFzaCByZWNlaXZlZFxuICAqL1xuICB2ZXJpZnlITUFDKGtleSwgZGF0YSwgc2lnbmF0dXJlKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLHJlamVjdCkge1xuXG4gICAgICBfdGhpcy5faW1wb3J0SE1BQ2tleShrZXkpLnRoZW4oZnVuY3Rpb24oaG1hY0tleSkge1xuXG4gICAgICAgIGNyeXB0by5zdWJ0bGUudmVyaWZ5KFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdITUFDJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaG1hY0tleSwgLy9mcm9tIGdlbmVyYXRlS2V5IG9yIGltcG9ydEtleSBhYm92ZVxuICAgICAgICAgIHNpZ25hdHVyZSwgLy9BcnJheUJ1ZmZlciBvZiB0aGUgc2lnbmF0dXJlXG4gICAgICAgICAgX3RoaXMuX3V0ZjhFbmNvZGUoZGF0YSkgLy9BcnJheUJ1ZmZlciBvZiB0aGUgZGF0YVxuICAgICAgICApXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKGlzdmFsaWQpIHtcbiAgICAgICAgICAvL3JldHVybnMgYSBib29sZWFuIG9uIHdoZXRoZXIgdGhlIHNpZ25hdHVyZSBpcyB0cnVlIG9yIG5vdFxuICAgICAgICAgIC8vY29uc29sZS5sb2coJ2NyeXB0by12ZXJpZnlITUFDJywgaXN2YWxpZCk7XG4gICAgICAgICAgKGlzdmFsaWQpID8gcmVzb2x2ZShpc3ZhbGlkKSA6IHJlamVjdChpc3ZhbGlkKTtcblxuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdjcnlwdG8tdmVyaWZ5SE1BQycsIGVycik7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0pO1xuXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAqIGdlbmVyYXRlcyBhIFJTQSBwdWJsaWMvcHJpdmF0ZSBrZXkgcGFpciB3aXRoIGEgbW9kdWx1cyBsZW5ndGggb2YgMjA0OCBiaXRzXG4gICogQHJldHVybiAge0pTT059ICAga2V5UGFpciAgICBqc29uIGNvbnRhaW5pbmcgdGhlIHB1YmxpYyBhbmQgcHJpdmF0ZSBrZXlzXG4gICovXG4gIGdlbmVyYXRlUlNBS2V5UGFpcigpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuICAgIGxldCBrZXlQYWlyID0ge307XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBjcnlwdG8uc3VidGxlLmdlbmVyYXRlS2V5KFxuICAgICAge1xuICAgICAgICBuYW1lOiAnUlNBLVBTUycsXG4gICAgICAgIG1vZHVsdXNMZW5ndGg6IDIwNDgsIC8vY2FuIGJlIDEwMjQsIDIwNDgsIG9yIDQwOTZcbiAgICAgICAgcHVibGljRXhwb25lbnQ6IG5ldyBVaW50OEFycmF5KFsweDAxLCAweDAwLCAweDAxXSksXG4gICAgICAgIGhhc2g6IHtuYW1lOiAnU0hBLTI1Nid9IC8vY2FuIGJlICdTSEEtMScsICdTSEEtMjU2JywgJ1NIQS0zODQnLCBvciAnU0hBLTUxMidcbiAgICAgIH0sXG4gICAgICB0cnVlLCAvL3doZXRoZXIgdGhlIGtleSBpcyBleHRyYWN0YWJsZSAoaS5lLiBjYW4gYmUgdXNlZCBpbiBleHBvcnRLZXkpXG4gICAgICBbJ3NpZ24nLCAndmVyaWZ5J10gLy9jYW4gYmUgYW55IGNvbWJpbmF0aW9uIG9mICdzaWduJyBhbmQgJ3ZlcmlmeSdcblxuICAgICAgKS50aGVuKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAvL3JldHVybnMgYSBrZXlwYWlyIG9iamVjdFxuICAgICAgICAvL2NvbnNvbGUubG9nKGtleSk7XG5cbiAgICAgICAgY3J5cHRvLnN1YnRsZS5leHBvcnRLZXkoXG4gICAgICAgICAgJ3Nwa2knLCAvL2NhbiBiZSAnandrJyAocHVibGljIG9yIHByaXZhdGUpLCAnc3BraScgKHB1YmxpYyBvbmx5KSwgb3IgJ3BrY3M4JyAocHJpdmF0ZSBvbmx5KVxuICAgICAgICAgIGtleS5wdWJsaWNLZXkgLy9jYW4gYmUgYSBwdWJsaWNLZXkgb3IgcHJpdmF0ZUtleSwgYXMgbG9uZyBhcyBleHRyYWN0YWJsZSB3YXMgdHJ1ZVxuICAgICAgICApLnRoZW4oZnVuY3Rpb24ocHVibGljS2V5KSB7XG4gICAgICAgICAgLy9yZXR1cm5zIHRoZSBleHBvcnRlZCBrZXkgZGF0YVxuICAgICAgICAgIGtleVBhaXIucHVibGljICA9IG5ldyBVaW50OEFycmF5KHB1YmxpY0tleSk7XG4gICAgICAgICAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KFxuICAgICAgICAgICAgJ3BrY3M4JywgLy9jYW4gYmUgJ2p3aycgKHB1YmxpYyBvciBwcml2YXRlKSwgJ3Nwa2knIChwdWJsaWMgb25seSksIG9yICdwa2NzOCcgKHByaXZhdGUgb25seSlcbiAgICAgICAgICAgIGtleS5wcml2YXRlS2V5IC8vY2FuIGJlIGEgcHVibGljS2V5IG9yIHByaXZhdGVLZXksIGFzIGxvbmcgYXMgZXh0cmFjdGFibGUgd2FzIHRydWVcbiAgICAgICAgICApO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHByaXZhdGVLZXkpIHtcbiAgICAgICAgICBrZXlQYWlyLnByaXZhdGUgID0gbmV3IFVpbnQ4QXJyYXkocHJpdmF0ZUtleSk7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZygnY3J5cHRvLWdlbmVyYXRlUlNBS2V5UGFpcicsIGtleVBhaXIpO1xuXG4gICAgICAgICAgcmVzb2x2ZShrZXlQYWlyKTtcblxuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0pO1xuXG4gICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICogR2VuZXJhdGVzIGEgMTI4IGJpdCByYW5kb20gdmFsdWUuXG4gICogQHJldHVybiB7Ynl0ZUFycmF5fSAgYXJyYXkgICAgcmFuZG9tIHZhbHVlXG4gICovXG4gIGdlbmVyYXRlSVYoKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIGxldCBhcnJheSA9IG5ldyAgVWludDhBcnJheSgxNik7XG4gICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnJheSk7XG5cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgKiBHZW5lcmF0ZXMgYSAyNTYgYml0IHJhbmRvbSB2YWx1ZS4gMzIgYml0cyBhcmUgZXh0cmF0ZWQgZnJvbSB0aGUgbWFjaGluZSB0aW1lLFxuICAqIHRoZSByZW1haW5pbmcgYXJlIGdlbmVyYXRlZCByYW5kb21seVxuICAqIEByZXR1cm4ge2J5dGVBcnJheX0gIGFycmF5ICAgIHJhbmRvbSB2YWx1ZVxuICAqL1xuICBnZW5lcmF0ZVJhbmRvbSgpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgbGV0IGFycmF5ID0gbmV3ICBVaW50OEFycmF5KDMyKTtcbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycmF5KTtcblxuICAgIGxldCBkYXRlID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgZGF0ZUVuY29kZWQgPSBfdGhpcy5fdXRmOEVuY29kZShkYXRlKTtcblxuICAgIC8vZXh0cmFjdCB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgNCBieXRlcyBpbiB0aGUgZGF0ZVxuICAgIGxldCBmaW5hbERhdGUgPSBkYXRlRW5jb2RlZC5zbGljZShkYXRlRW5jb2RlZC5sZW5ndGggLSA0LCBkYXRlRW5jb2RlZC5sZW5ndGgpO1xuXG4gICAgLy8gYWRkIGluIHRoZSBmaXJzdCA0IGJ5dGVzIG9mIHRoZSBhcnJheSB0aGUgYnl0ZXMgZXh0cmFjdGVkIHByZXZpb3VzbHk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHsgYXJyYXlbaV0gPSBmaW5hbERhdGVbaV07IH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgKiBnZW5lcmF0ZXMgYSBwcmVtYXN0ZXIgc2VjcmV0IChQTVMpIG9mIDQ4IGJ5dGVzICgzODQgYml0cykgcmFuZG9tbHlcbiAgKiBAcmV0dXJuIHtieXRlQXJyYXl9ICBhcnJheSAgICBwcmVtYXN0ZXIgc2VjcmV0IGtleVxuICAqL1xuICBnZW5lcmF0ZVBNUygpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgbGV0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoNDgpO1xuICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyYXkpO1xuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAqIGdlbmVyYXRlcyBhIG1hc3RlcktleSBzZWNyZXQgKFBNUykgb2YgNDggYnl0ZXMgKDM4NCBiaXRzKSB1c2luZyB0aGUgcHJlbWFzdGVyIHNlY3JldCBhbmRcbiAgKiB0d28gcmFuZG9tc1xuICAqIEByZXR1cm4ge2J5dGVBcnJheX0gIGFycmF5ICAgIG1hc3RlciBzZWNyZXQga2V5IHdpdGggNDggYnl0ZXNcbiAgKi9cbiAgZ2VuZXJhdGVNYXN0ZXJTZWNyZXQoaG1hY0tleSwgZGF0YSkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBsZXQga2V5ID0gbmV3IFVpbnQ4QXJyYXkoNDgpO1xuICAgICAgbGV0IHNlZWQgPSBkYXRhO1xuXG4gICAgICBfdGhpcy5fZGlnZXN0KGhtYWNLZXkpLnRoZW4oKGRpZ2VzdGVkS2V5KSA9PiB7XG5cbiAgICAgICAgX3RoaXMuaGFzaEhNQUMoZGlnZXN0ZWRLZXksIHNlZWQpLnRoZW4oZnVuY3Rpb24oa2V5cGFydDApIHtcblxuICAgICAgICAgIC8vY29weSB0aGUgZmlyc3QgMzIgYnl0ZXMgaW50byB0aGUga2V5XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMjsgaSsrKSB7IGtleVtpXSA9IGtleXBhcnQwW2ldOyB9XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmhhc2hITUFDKGRpZ2VzdGVkS2V5LCBzZWVkICsga2V5cGFydDApO1xuXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oa2V5cGFydDEpIHtcblxuICAgICAgICAgIC8vY29weSB0aGUgZmlyc3QgMTYgYnl0ZXMgdG8gdGhlIGtleSByZW1haW5pbmcgMTYgYnl0ZXNcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHsga2V5W2kgKyAzMl0gPSBrZXlwYXJ0MVtpXTsgfVxuICAgICAgICAgIC8vY29uc29sZS5sb2coJ2NyeXB0by1nZW5lcmF0ZU1hc3RlclNlY3JldCcsIGtleSk7XG4gICAgICAgICAgcmVzb2x2ZShrZXkpO1xuXG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdjcnlwdG8tZ2VuZXJhdGVNYXN0ZXJTZWNyZXQnLCBlcnIpO1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgKiBnZW5lcmF0ZXMgYm90aCB1c2VycyBNQUMgYW5kIGVuY3J5cHRpb24ga2V5cy4gZ2VuZXJhdGUgYXMgb3V0cHV0IGFuIGFycmF5XG4gICogd2l0aCA0IGJ5dGVBcnJheSBlYWNoIHdpdGggMzIgYnl0ZXNcbiAgKiBAcGFyYW0gIHtieXRlQXJyYXl9ICAgICAgICBzZWNyZXQgICAgICAgc2VjcmV0IHRvIGJlIHVzZWQgaW4gdGhlIEhNQUMgZnVuY3Rpb25cbiAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgICAgICBkYXRhICAgICAgICAgaW5mb3JtYXRpb24gdG8gYmUgdXNlZCBhcyBzZWVkXG4gICogQHJldHVybiB7QXJyYXk8Ynl0ZUFycmF5Pn0ga2V5ICAgICAgICAgIGFycmF5IHdpdGggdGhlIGluZm9ybWF0aW9uIHRvIGdlbmVyYXRlIGtleXNcbiAgKi9cbiAgZ2VuZXJhdGVLZXlzKGhtYWNLZXksIGRhdGEpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXG4gICAgICBsZXQga2V5ID0gW107XG4gICAgICBsZXQgc2VlZCA9IGRhdGE7XG5cbiAgICAgIC8vIGl0ZXJhdGUgNCB0aW1lcyB0byBvYnRhaW4gYSAxMDI0IGtleSBzaXplXG4gICAgICBfdGhpcy5oYXNoSE1BQyhobWFjS2V5LCBzZWVkKS50aGVuKGZ1bmN0aW9uKGtleXBhcnQwKSB7XG4gICAgICAgIGtleS5wdXNoKGtleXBhcnQwKTtcbiAgICAgICAgcmV0dXJuIF90aGlzLmhhc2hITUFDKGhtYWNLZXksIHNlZWQgKyBrZXlwYXJ0MCk7XG5cbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24oa2V5cGFydDEpIHtcbiAgICAgICAga2V5LnB1c2goa2V5cGFydDEpO1xuICAgICAgICByZXR1cm4gX3RoaXMuaGFzaEhNQUMoaG1hY0tleSwgc2VlZCArIGtleXBhcnQxKTtcblxuICAgICAgfSkudGhlbihmdW5jdGlvbihrZXlwYXJ0Mikge1xuICAgICAgICBrZXkucHVzaChrZXlwYXJ0Mik7XG4gICAgICAgIHJldHVybiBfdGhpcy5oYXNoSE1BQyhobWFjS2V5LCBzZWVkICsga2V5cGFydDIpO1xuXG4gICAgICB9KS50aGVuKGZ1bmN0aW9uKGtleXBhcnQzKSB7XG4gICAgICAgIGtleS5wdXNoKGtleXBhcnQzKTtcblxuICAgICAgICAvL2NvbnNvbGUubG9nKCdjcnlwdG8tZ2VuZXJhdGVLZXlzJywga2V5KTtcbiAgICAgICAgcmVzb2x2ZShrZXkpO1xuXG4gICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnY3J5cHRvLWdlbmVyYXRlS2V5cycsIGVycik7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vY29uc29sZS5sb2coaG1hY0tleSwgZGF0YSk7XG4gICAgfSk7XG4gIH1cblxuICBfaW1wb3J0UlNBc2lnbktleShwcml2S2V5KSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgICAgICAgICdwa2NzOCcsIC8vY2FuIGJlICdqd2snIChwdWJsaWMgb3IgcHJpdmF0ZSksICdzcGtpJyAocHVibGljIG9ubHkpLCBvciAncGtjczgnIChwcml2YXRlIG9ubHkpXG4gICAgICAgICAgcHJpdktleSxcbiAgICAgICAgICB7ICAgLy90aGVzZSBhcmUgdGhlIGFsZ29yaXRobSBvcHRpb25zXG4gICAgICAgICAgICBuYW1lOiAnUlNBU1NBLVBLQ1MxLXYxXzUnLFxuICAgICAgICAgICAgaGFzaDoge25hbWU6ICdTSEEtMjU2J30gLy9jYW4gYmUgJ1NIQS0xJywgJ1NIQS0yNTYnLCAnU0hBLTM4NCcsIG9yICdTSEEtNTEyJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdHJ1ZSwgLy93aGV0aGVyIHRoZSBrZXkgaXMgZXh0cmFjdGFibGUgKGkuZS4gY2FuIGJlIHVzZWQgaW4gZXhwb3J0S2V5KVxuICAgICAgICAgIFsnc2lnbiddIC8vJ3ZlcmlmeScgZm9yIHB1YmxpYyBrZXkgaW1wb3J0LCAnc2lnbicgZm9yIHByaXZhdGUga2V5IGltcG9ydHNcbiAgICAgIClcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHByaXZhdGVLZXkpIHtcbiAgICAgICAgLy9yZXR1cm5zIGEgcHVibGljS2V5IChvciBwcml2YXRlS2V5IGlmIHlvdSBhcmUgaW1wb3J0aW5nIGEgcHJpdmF0ZSBrZXkpXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2NyeXB0by1faW1wb3J0UlNBc2lnbktleScsIHByaXZhdGVLZXkpO1xuICAgICAgICByZXNvbHZlKHByaXZhdGVLZXkpO1xuXG4gICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignY3J5cHRvLV9pbXBvcnRSU0FzaWduS2V5JywgZXJyKTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIF9pbXBvcnRSU0F2ZXJpZnlLZXkocHViS2V5KSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgICAgICAgICdzcGtpJywgLy9jYW4gYmUgJ2p3aycgKHB1YmxpYyBvciBwcml2YXRlKSwgJ3Nwa2knIChwdWJsaWMgb25seSksIG9yICdwa2NzOCcgKHByaXZhdGUgb25seSlcbiAgICAgICAgICBwdWJLZXksXG4gICAgICAgICAgeyAgIC8vdGhlc2UgYXJlIHRoZSBhbGdvcml0aG0gb3B0aW9uc1xuICAgICAgICAgICAgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81JyxcbiAgICAgICAgICAgIGhhc2g6IHtuYW1lOiAnU0hBLTI1Nid9IC8vY2FuIGJlICdTSEEtMScsICdTSEEtMjU2JywgJ1NIQS0zODQnLCBvciAnU0hBLTUxMidcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRydWUsIC8vd2hldGhlciB0aGUga2V5IGlzIGV4dHJhY3RhYmxlIChpLmUuIGNhbiBiZSB1c2VkIGluIGV4cG9ydEtleSlcbiAgICAgICAgICBbJ3ZlcmlmeSddIC8vJ3ZlcmlmeScgZm9yIHB1YmxpYyBrZXkgaW1wb3J0LCAnc2lnbicgZm9yIHByaXZhdGUga2V5IGltcG9ydHNcbiAgICAgIClcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHB1YmxpY0tleSkge1xuICAgICAgICAvL3JldHVybnMgYSBwdWJsaWNLZXkgKG9yIHByaXZhdGVLZXkgaWYgeW91IGFyZSBpbXBvcnRpbmcgYSBwcml2YXRlIGtleSlcbiAgICAgICAgLy9jb25zb2xlLmxvZygnY3J5cHRvLV9pbXBvcnRSU0F2ZXJpZnlLZXknLCBwdWJsaWNLZXkpO1xuICAgICAgICByZXNvbHZlKHB1YmxpY0tleSk7XG5cbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdjcnlwdG8tX2ltcG9ydFJTQXZlcmlmeUtleScsIGVycik7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBfaW1wb3J0UlNBZW5jcnlwdEtleShwdWJLZXkpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXG4gICAgICAgICAgJ3Nwa2knLCAvL2NhbiBiZSAnandrJyAocHVibGljIG9yIHByaXZhdGUpLCAnc3BraScgKHB1YmxpYyBvbmx5KSwgb3IgJ3BrY3M4JyAocHJpdmF0ZSBvbmx5KVxuICAgICAgICAgIHB1YktleSxcbiAgICAgICAgICB7ICAgLy90aGVzZSBhcmUgdGhlIGFsZ29yaXRobSBvcHRpb25zXG4gICAgICAgICAgICBuYW1lOiAnUlNBLU9BRVAnLFxuICAgICAgICAgICAgaGFzaDoge25hbWU6ICdTSEEtMjU2J30gLy9jYW4gYmUgJ1NIQS0xJywgJ1NIQS0yNTYnLCAnU0hBLTM4NCcsIG9yICdTSEEtNTEyJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdHJ1ZSwgLy93aGV0aGVyIHRoZSBrZXkgaXMgZXh0cmFjdGFibGUgKGkuZS4gY2FuIGJlIHVzZWQgaW4gZXhwb3J0S2V5KVxuICAgICAgICAgIFsnZW5jcnlwdCddIC8vJ2VuY3J5cHQnIG9yICd3cmFwS2V5JyBmb3IgcHVibGljIGtleSBpbXBvcnQgb3JcbiAgICAgICAgICAgICAgICAgICAgICAvLydkZWNyeXB0JyBvciAndW53cmFwS2V5JyBmb3IgcHJpdmF0ZSBrZXkgaW1wb3J0c1xuICAgICAgKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocHVibGljS2V5KSB7XG4gICAgICAgIC8vcmV0dXJucyBhIHB1YmxpY0tleSAob3IgcHJpdmF0ZUtleSBpZiB5b3UgYXJlIGltcG9ydGluZyBhIHByaXZhdGUga2V5KVxuICAgICAgICAvL2NvbnNvbGUubG9nKCdjcnlwdG8tX2ltcG9ydFJTQWVuY3J5cHRLZXknLCBwdWJsaWNLZXkpO1xuICAgICAgICByZXNvbHZlKHB1YmxpY0tleSk7XG5cbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdjcnlwdG8tX2ltcG9ydFJTQWVuY3J5cHRLZXknLCBlcnIpO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgX2ltcG9ydFJTQWRlY3J5cHRLZXkocHJpdktleSkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBjcnlwdG8uc3VidGxlLmltcG9ydEtleShcbiAgICAgICAgICAncGtjczgnLCAvL2NhbiBiZSAnandrJyAocHVibGljIG9yIHByaXZhdGUpLCAnc3BraScgKHB1YmxpYyBvbmx5KSwgb3IgJ3BrY3M4JyAocHJpdmF0ZSBvbmx5KVxuICAgICAgICAgIHByaXZLZXksXG4gICAgICAgICAgeyAgIC8vdGhlc2UgYXJlIHRoZSBhbGdvcml0aG0gb3B0aW9uc1xuICAgICAgICAgICAgbmFtZTogJ1JTQS1PQUVQJyxcbiAgICAgICAgICAgIGhhc2g6IHtuYW1lOiAnU0hBLTI1Nid9IC8vY2FuIGJlICdTSEEtMScsICdTSEEtMjU2JywgJ1NIQS0zODQnLCBvciAnU0hBLTUxMidcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRydWUsIC8vd2hldGhlciB0aGUga2V5IGlzIGV4dHJhY3RhYmxlIChpLmUuIGNhbiBiZSB1c2VkIGluIGV4cG9ydEtleSlcbiAgICAgICAgICBbJ2RlY3J5cHQnXSAvLydlbmNyeXB0JyBvciAnd3JhcEtleScgZm9yIHB1YmxpYyBrZXkgaW1wb3J0IG9yXG4gICAgICAgICAgICAgICAgICAgICAgLy8nZGVjcnlwdCcgb3IgJ3Vud3JhcEtleScgZm9yIHByaXZhdGUga2V5IGltcG9ydHNcbiAgICAgIClcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHByaXZhdGVLZXkpIHtcbiAgICAgICAgLy9yZXR1cm5zIGEgcHVibGljS2V5IChvciBwcml2YXRlS2V5IGlmIHlvdSBhcmUgaW1wb3J0aW5nIGEgcHJpdmF0ZSBrZXkpXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2NyeXB0by1faW1wb3J0UlNBZGVjcnlwdEtleScsIHByaXZhdGVLZXkpO1xuICAgICAgICByZXNvbHZlKHByaXZhdGVLZXkpO1xuXG4gICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignY3J5cHRvLV9pbXBvcnRSU0FkZWNyeXB0S2V5JywgZXJyKTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbmNhdFBNU3dpdGhSYW5kb21zKHBtcywgdG9SYW5kb20sIGZyb21SYW5kb20pIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgbGV0IGZpbmFsS2V5ID0gbmV3IFVpbnQ4QXJyYXkocG1zLmxlbmd0aCArIHRvUmFuZG9tLmxlbmd0aCArIGZyb21SYW5kb20ubGVuZ3RoKTtcblxuICAgIC8vIGFkZCBQcmVtYXN0ZXJLZXlcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBtcy5sZW5ndGg7IGkrKykge1xuICAgICAgZmluYWxLZXlbaV0gPSBwbXNbaV07XG4gICAgfVxuXG4gICAgLy9hZGQgdG8gcmFuZG9tXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b1JhbmRvbS5sZW5ndGg7IGkrKykge1xuICAgICAgZmluYWxLZXlbaSArIHBtcy5sZW5ndGhdID0gcG1zW2ldO1xuICAgIH1cblxuICAgIC8vYWRkIGZyb20gcmFuZG9tXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcm9tUmFuZG9tLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmaW5hbEtleVtpICsgcG1zLmxlbmd0aCArIHRvUmFuZG9tLmxlbmd0aF0gPSBwbXNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbmFsS2V5O1xuICB9XG5cbiAgX2dlbmVyYXRlMjU2Yml0S2V5KCkge1xuICAgIGxldCBhcnJheSA9IG5ldyAgVWludDhBcnJheSgzMik7XG4gICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnJheSk7XG5cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgKiBpbXBvcnRzIHRoZSBzZWNyZXQgdG8gdGhlIEhNQUMgZnVuY3Rpb25cbiAgKiBAcGFyYW0gIHtieXRlQXJyYXl9ICAgYXJyYXlCdWZmZXIgICAgIGJ5dGVzIHRvIGltcG9ydCBhcyBrZXlcbiAgKiBAcmV0dXJuIHtKU09OfSAgICAgICBrZXkgICAgICAgICAgICAgIGtleSByZWFkeSB0byBiZSB1c2VkIGluIHRoZSBITUFDIGNyeXB0b2dyYXBoaWMgZnVuY3Rpb25cbiAgKi9cbiAgX2ltcG9ydEhNQUNrZXkoYXJyYXlCdWZmZXIpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXG4gICAgICBfdGhpcy5fZGlnZXN0KGFycmF5QnVmZmVyKS50aGVuKChrZXkpID0+IHtcblxuICAgICAgICBjcnlwdG8uc3VidGxlLmltcG9ydEtleShcbiAgICAgICAgJ3JhdycsIC8vY2FuIGJlICdqd2snIG9yICdyYXcnXG4gICAgICAgIGtleSxcbiAgICAgICAgeyAgIC8vdGhpcyBpcyB0aGUgYWxnb3JpdGhtIG9wdGlvbnNcbiAgICAgICAgICBuYW1lOiAnSE1BQycsXG4gICAgICAgICAgaGFzaDoge25hbWU6ICdTSEEtMjU2J30sIC8vY2FuIGJlICdTSEEtMScsICdTSEEtMjU2JywgJ1NIQS0zODQnLCBvciAnU0hBLTUxMidcbiAgICAgICAgICBsZW5ndGg6IDI1NiAvL29wdGlvbmFsLCBpZiB5b3Ugd2FudCB5b3VyIGtleSBsZW5ndGggdG8gZGlmZmVyIGZyb20gdGhlIGhhc2ggZnVuY3Rpb24ncyBibG9jayBsZW5ndGhcbiAgICAgICAgfSxcbiAgICAgICAgdHJ1ZSwgLy93aGV0aGVyIHRoZSBrZXkgaXMgZXh0cmFjdGFibGUgKGkuZS4gY2FuIGJlIHVzZWQgaW4gZXhwb3J0S2V5KVxuICAgICAgICBbJ3NpZ24nLCAndmVyaWZ5J10gLy9jYW4gYmUgYW55IGNvbWJpbmF0aW9uIG9mICdzaWduJyBhbmQgJ3ZlcmlmeSdcbiAgICAgICAgKS50aGVuKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgIC8vcmV0dXJucyB0aGUgc3ltbWV0cmljIGtleVxuICAgICAgICAgIC8vY29uc29sZS5sb2coJ2NyeXB0by1faW1wb3J0SE1BQ2tleScsIGtleSk7XG4gICAgICAgICAgcmVzb2x2ZShrZXkpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBfZGlnZXN0KHZhbHVlKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGNyeXB0by5zdWJ0bGUuZGlnZXN0KFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdTSEEtMjU2J1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdmFsdWUgLy9UaGUgZGF0YSB5b3Ugd2FudCB0byBoYXNoIGFzIGFuIEFycmF5QnVmZmVyXG4gICAgICApXG4gICAgICAudGhlbihmdW5jdGlvbihoYXNoKSB7XG4gICAgICAgIC8vcmV0dXJucyB0aGUgaGFzaCBhcyBhbiBBcnJheUJ1ZmZlclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdjcnlwdG8tZGlnZXN0JywgbmV3IFVpbnQ4QXJyYXkoaGFzaCkpO1xuICAgICAgICByZXNvbHZlKG5ldyBVaW50OEFycmF5KGhhc2gpKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9KTtcblxuICAgIH0pO1xuICB9XG5cbiAgX2ltcG9ydEFFU2tleShhcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgICAgICAgICdyYXcnLCAvL2NhbiBiZSAnandrJyBvciAncmF3J1xuICAgICAgICAgIGFycmF5QnVmZmVyLFxuICAgICAgICAgIHsgICAvL3RoaXMgaXMgdGhlIGFsZ29yaXRobSBvcHRpb25zXG4gICAgICAgICAgICBuYW1lOiAnQUVTLUNCQydcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRydWUsIC8vd2hldGhlciB0aGUga2V5IGlzIGV4dHJhY3RhYmxlIChpLmUuIGNhbiBiZSB1c2VkIGluIGV4cG9ydEtleSlcbiAgICAgICAgICBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddIC8vY2FuIGJlICdlbmNyeXB0JywgJ2RlY3J5cHQnLCAnd3JhcEtleScsIG9yICd1bndyYXBLZXknXG4gICAgICApXG4gICAgICAudGhlbihmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgLy9yZXR1cm5zIHRoZSBzeW1tZXRyaWMga2V5XG4gICAgICAgIC8vY29uc29sZS5sb2coJ2NyeXB0by1pbXBvcnRBRVNrZXknLCBrZXkpO1xuICAgICAgICByZXNvbHZlKGtleSk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdjcnlwdG8taW1wb3J0QUVTa2V5JywgZXJyKTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIF91dGY4RW5jb2RlKHMpIHtcbiAgICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCd1dGYtOCcpLmVuY29kZShzKTtcbiAgfVxuXG4gIF91dGY4RGVjb2RlKHMpIHtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpLmRlY29kZShzKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDcnlwdG87XG4iLCIvKipcbiogZmFrZSBjbGFzcyBmb3IgdGhlIGd1aSB0byBzZWxlY3QgdGhlIGlkZW50aXR5LFxuKiBUT0RPIHJlcGxhY2Ugd2l0aCB0aGUgcHJvcGVyIGlkZW50aXR5IEdVSVxuKlxuKi9cbmNsYXNzIEd1aUZha2Uge1xuXG4gIGNvbnN0cnVjdG9yKHVybCwgbWVzc2FnZUJ1cykge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG5cbiAgICBfdGhpcy5fdXJsID0gdXJsO1xuICAgIF90aGlzLl93YWl0VGltZSA9IDEwMDAwO1xuICAgIF90aGlzLl9tZXNzYWdlQnVzID0gbWVzc2FnZUJ1cztcblxuICAgIF90aGlzLl9tZXNzYWdlQnVzLmFkZExpc3RlbmVyKF90aGlzLl91cmwsIG1zZyA9PiB7XG5cbiAgICAgIGxldCBpZGVudGl0aWVzID0gbXNnLmJvZHkudmFsdWUuaWRlbnRpdGllcztcbiAgICAgIGxldCBpZHBzID0gbXNnLmJvZHkudmFsdWUuaWRwcztcblxuICAgICAgbGV0IHZhbHVlO1xuXG4gICAgICBpZiAoaWRlbnRpdGllc1swXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlID0ge3R5cGU6ICdpZGVudGl0eScsIHZhbHVlOiBpZGVudGl0aWVzWzBdLCBjb2RlOiAyMDB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSB7dHlwZTogJ2lkcCcsIHZhbHVlOiBpZHBzWzBdLCBjb2RlOiAyMDB9O1xuICAgICAgfVxuXG4gICAgICBsZXQgcmVwbHlNc2cgPSB7aWQ6IG1zZy5pZCwgdHlwZTogJ3Jlc3BvbnNlJywgdG86IG1zZy5mcm9tLCBmcm9tOiBtc2cudG8sIGJvZHk6IHZhbHVlfTtcblxuICAgICAgLy8gdG8gdGVzdCBvbiB0aGUgaWRlbnRpdHkgc2lkZSB0aGUgbGlzdGVuZXIgd2l0aG91dCB0aGUgdGltZW91dFxuICAgICAgLy8gY2FuIHJlcHJlc2VudCB0aGUgdGltZSB0aGUgdXNlciB0YWtlcyB0byBjaG9vc2UgYW5kIGlkZW50aXR5XG4gICAgICBpZiAobXNnLmJvZHkudmFsdWUgPT09ICd3YWl0Jykge1xuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIF90aGlzLl9tZXNzYWdlQnVzLnBvc3RNZXNzYWdlKHJlcGx5TXNnKTtcbiAgICAgICAgfSwgX3RoaXMuX3dhaXRUaW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLl9tZXNzYWdlQnVzLnBvc3RNZXNzYWdlKHJlcGx5TXNnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEd1aUZha2U7XG4iLCIvKipcbiogVGhlIElkZW50aXR5IERhdGEgTW9kZWwgaXMgdXNlZCB0byBtb2RlbCB0aGUgcmVUSElOSyBVc2VyIGVudGl0eS4gVGhlIElkZW50aXR5IGRhdGEgbW9kZWwgaXMgaGFuZGxlZCBieSBJZGVudGl0eSBNYW5hZ2VtZW50IGZ1bmN0aW9uYWxpdHkuXG4qXG4qL1xuY2xhc3MgSWRlbnRpdHkge1xuXG4gIGNvbnN0cnVjdG9yKGd1aWQsIHR5cGUpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgX3RoaXMuZ3VpZCA9IGd1aWQ7XG4gICAgX3RoaXMudHlwZSA9IHR5cGU7XG4gICAgX3RoaXMuaWRlbnRpZmllcnNMaXN0ID0ge307XG5cbiAgfVxuXG4gIGFkZElkZW50aXR5KGlkZW50aWZpZXIpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuICAgIGxldCBpZGVudGl0eUluZm9ybWF0aW9uID0ge1xuICAgICAgaWRBc3NlcnRpb246ICcnLFxuICAgICAgc2VydmljZUFkZHJlc3M6ICcnLFxuICAgICAgYXV0aGVudGljYXRpb25EYXRhOiAnJyxcbiAgICAgIGF1dGhvcmlzYXRpb25EYXRhOiAnJyxcbiAgICAgIHVzZXJQcm9maWxlOiAnJ1xuICAgIH07XG4gICAgX3RoaXMuaWRlbnRpZmllcnNMaXN0W2lkZW50aWZpZXJdID0gaWRlbnRpdHlJbmZvcm1hdGlvbjtcbiAgfVxuXG4gIGFkZElkQXNzZXJ0aW9uKGlkZW50aWZpZXIsIGFzc2VydGlvbiwgaWRwLCBzY29wZSkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG5cbiAgICBsZXQgbmV3SWRBc3NlcnRpb24gPSBuZXcgSWRBc3NlcnRpb24oYXNzZXJ0aW9uLCBpZHAsIHNjb3BlKTtcblxuICAgIF90aGlzLmlkQXNzZXJ0aW9uTGlzdC5wdXNoKG5ld0lkQXNzZXJ0aW9uKTtcbiAgfVxufVxuXG5jbGFzcyBJZEFzc2VydGlvbiB7XG5cbiAgY29uc3RydWN0b3IoYXNzZXJ0aW9uLCBpZHAsIHNjb3BlKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIF90aGlzLmFzc2VydGlvbiA9IGFzc2VydGlvbjtcbiAgICBfdGhpcy5pZHAgPSBpZHA7XG4gICAgX3RoaXMuc2NvcGUgPSBzY29wZTtcbiAgfVxuXG59XG5cbmNsYXNzIElkVmFsaWRhdGlvbiB7XG5cbiAgY29uc3RydWN0b3IoaWRlbnRpdHksIGNvbnRlbnRzKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcbiAgICBfdGhpcy5pZGVudGl0eSA9IGlkZW50aXR5O1xuICAgIF90aGlzLmNvbnRlbnRzID0gY29udGVudHM7XG4gIH1cblxuICB2YWxpZGF0ZXMoaWRlbnRpdHksIGNvbnRlbnRzKSB7XG4gICAgLy9UT0RPIGltcGxlbWVudCB0aGUgbG9naWNcblxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IElkZW50aXR5O1xuIiwiXG5pbXBvcnQge2RpdmlkZVVSTCwgZ2V0VXNlclVSTEZyb21FbWFpbCwgZ2V0VXNlckVtYWlsRnJvbVVSTCwgaXNEYXRhT2JqZWN0VVJMLCBjb252ZXJ0VG9Vc2VyVVJMfSBmcm9tICcuLi91dGlscy91dGlscy5qcyc7XG5pbXBvcnQgSWRlbnRpdHkgZnJvbSAnLi9JZGVudGl0eSc7XG5pbXBvcnQgQ3J5cHRvIGZyb20gJy4vQ3J5cHRvJztcbmltcG9ydCBHdWlGYWtlIGZyb20gJy4vR3VpRmFrZSc7XG5cbi8qKlxuKlxuKiBUaGUgSWRlbnRpdHkgTW9kdWxlIChJZCBNb2R1bGUpIGlzIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIHRoZVxuKiB1c2VyIGlkZW50aXR5IGFuZCB0aGUgYXNzb2NpYXRpb24gb2YgdGhpcyBpZGVudGl0eSB3aXRoIHRoZSBIeXBlcnR5IGluc3RhbmNlcyxcbiogaW4gb3JkZXIgdG8gbWFrZSBIeXBlcnR5IGluc3RhbmNlcyBpZGVudGlmaWFibGUuIFRoZSBpZGVudGl0eSBpbiB0aGUgcmVUSElOSyBwcm9qZWN0XG4qIGlzIG5vdCBmaXhlZCB0byBhIHVuaXF1ZSBJZGVudGl0eSBTZXJ2aWNlIFByb3ZpZGVyLCBidXQgb2J0YWluZWQgdGhyb3VnaCBzZXZlcmFsXG4qIGRpZmZlcmVudCBJZGVudGl0eSBzb3VyY2VzLiBXaXRoIHRoaXMgYXBwcm9hY2gsIHRoZSBJZCBNb2R1bGUgcHJvdmlkZXMgdG8gdGhlIHVzZXIgdGhlXG4qIG9wdGlvbiB0byBjaG9vc2UgdGhlIHByZWZlcnJlZCBtZXRob2QgZm9yIGF1dGhlbnRpY2F0aW9uLlxuKiBUaGlzIG1vZHVsZSB3aWxsIHRodXMgYWJsZSB0byBzdXBwb3J0IG11bHRpcGxlIElkZW50aXR5IGFjcXVpc2l0aW9uIG1ldGhvZHMsXG4qIHN1Y2ggYXMgT3BlbklEIGNvbm5lY3QgMS4wLCBLZXJiZXJvcyBTeXN0ZW0sIG9yIGF1dGhlbnRpY2F0aW9uIHRocm91Z2ggc21hcnQgY2FyZHMuXG4qIEZvciBleGFtcGxlLCBhIHVzZXIgd2l0aCBhIEdvb2dsZSBhY2NvdW50IGNhbiB1c2UgdGhlIEdvb2dsZSBhcyBhbiBJZGVudGl0eSBQcm92aWRlciB0byBwcm92aWRlIElkZW50aXR5IFRva2VucyxcbiogIHdoaWNoIGNhbiBiZSB1c2VkIGJ5IHRoZSBJZGVudGl0eSBNb2R1bGUgdG8gYXNzb2NpYXRlIGl0IHdpdGggYSBIeXBlcnR5IGluc3RhbmNlLlxuKlxuKiBUaGUgSWRlbnRpdHkgTW9kdWxlIHVzZXMgYSBub2RlIHBhY2thZ2UsIHRoZSBIZWxsb0pTLCB3aGljaCBpcyBhIGNsaWVudC1zaWRlIEphdmFTY3JpcHQgQVBJIGZvciBhdXRoZW50aWNhdGlvblxuKiB0aGF0IGZhY2lsaXRhdGVzIHRoZSByZXF1ZXN0cyBmb3IgdGhlIE9wZW5JRCBjb25uZWN0IHByb3RvY29sLiBUaGlzIG1ldGhvZCBhbGxvd3MgZm9yIHNvbWUgYWJzdHJhY3Rpb25cbiogd2hlbiBtYWtpbmcgcmVxdWVzdHMgZm9yIGRpZmZlcmVudCBJZGVudGl0eSBQcm92aWRlcnMsIHN1Y2ggYXMgT3BlbklEIGNvbm5lY3QgdXNlZCBieSBHb29nbGUsIEZhY2Vib29rLCBNaWNyb3NvZnQsIGZvciBleGFtcGxlLlxuKlxuKiBXaGVuIGEgcmVxdWVzdCBmb3IgYSB1c2VyIGlkZW50aXR5IGlzIG1hZGUgdXNpbmcgdGhlIG1ldGhvZCBsb2dpbldpdGhSUChpZGVudGlmaWVyLCBzY29wZSksXG4qIHRoaXMgbWV0aG9kIHdpbGwgYW5hbHlzZSB0aGUgSWRlbnRpdHkgUHJvdmlkZXIgY2hvc2VuIHRvIG9idGFpbiBhbiBpZGVudGl0eSBhbmQgd2lsbCB1c2UgdGhlIEhlbGxvSlMgbm9kZSBwYWNrYWdlXG4qIHdpdGggdGhlIHNlbGVjdGVkIElkZW50aXR5IFByb3ZpZGVyIGFuZCBpZGVudGl0eSBzY29wZS4gQWZ0ZXIgdGhlIEhlbGxvSlMgcmVxdWVzdCBmb3IgYW4gQWNjZXNzIFRva2VuXG4qIHRvIHRoZSBJZGVudGl0eSBQcm92aWRlcnMsIHRoZSB1c2VyIHdpbGwgYmUgcHJvbXB0ZWQgdG8gYXV0aGVudGljYXRlIHRvd2FyZHMgdGhlIElkZW50aXR5IFByb3ZpZGVyLlxuKiBVcG9uIHJlY2VpdmluZyB0aGUgQWNjZXNzIFRva2VuLCB0aGlzIHRva2VuIGlzIHZhbGlkYXRlZCB3aXRoIGEgUkVTVGZ1bCB3ZWIgc2VydmljZSByZXF1ZXN0IHRvIGFuIGVuZHBvaW50XG4qIG9uIHRoZSBJZGVudGl0eSBQcm92aWRlciBBdXRob3JpemF0aW9uIFNlcnZlciwgYW5kIGFmdGVyIHRoZSB2YWxpZGF0aW9uIGlzIGRvbmUsXG4qIGFuIElEIHRva2VuIGlzIG9idGFpbmVkIHdpdGggdGhlIGluZm9ybWF0aW9uIGFjY29yZGluZyB0byB0aGUgc2NvcGUgcmVxdWlyZWQuXG4qIFRoaXMgSUQgdG9rZW4gaXMgdGhlbiBwcmVzZXJ2ZWQgaW4gdGhpcyBtb2R1bGUgdGhhdCBjYW4gb2J0YWluZWQgdGhyb3VnaCB0aGUgZ2V0SWRlbnRpdGllcygpXG4qIGFuZCBpcyBwYXNzZWQgYXMgcmV0dXJuIHZhbHVlIG9mIHRoZSBsb2dpbldpdGhSUCBmdW5jdGlvbi4gVGhlIG1ldGhvZHMgZ2VuZXJhdGVBc3NlcnRpb24gYW5kIHZhbGlkYXRlQXNzZXJ0aW9uIGhhdmUgbm90IHlldCBiZWVuIGRldmVsb3BlZC5cbipcbiovXG5jbGFzcyBJZGVudGl0eU1vZHVsZSB7XG5cbiAgLyoqXG4gICogVGhpcyBpcyB0aGUgY29uc3RydWN0b3IgdG8gaW5pdGlhbGlzZSB0aGUgSWRlbnRpdHkgTW9kdWxlIGl0IGRvZXMgbm90IHJlcXVpcmUgYW55IGlucHV0LlxuICAqL1xuICBjb25zdHJ1Y3RvcihydW50aW1lVVJMLCBydW50aW1lQ2FwYWJpbGl0aWVzLCBzdG9yYWdlTWFuYWdlcikge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoIXJ1bnRpbWVVUkwpIHRocm93IG5ldyBFcnJvcigncnVudGltZVVSTCBpcyBtaXNzaW5nLicpO1xuICAgIGlmICghc3RvcmFnZU1hbmFnZXIpIHRocm93IG5ldyBFcnJvcignc3RvcmFnZU1hbmFnZXIgaXMgbWlzc2luZycpO1xuXG4gICAgX3RoaXMuX3J1bnRpbWVVUkwgPSBydW50aW1lVVJMO1xuICAgIF90aGlzLnN0b3JhZ2VNYW5hZ2VyID0gc3RvcmFnZU1hbmFnZXI7XG4gICAgX3RoaXMuX2lkbVVSTCA9IF90aGlzLl9ydW50aW1lVVJMICsgJy9pZG0nO1xuICAgIF90aGlzLl9ndWlVUkwgPSBfdGhpcy5fcnVudGltZVVSTCArICcvaWRlbnRpdHktZ3VpJztcbiAgICBfdGhpcy5ydW50aW1lQ2FwYWJpbGl0aWVzID0gcnVudGltZUNhcGFiaWxpdGllcztcblxuICAgIF90aGlzLl9kb21haW4gPSBkaXZpZGVVUkwoX3RoaXMuX3J1bnRpbWVVUkwpLmRvbWFpbjtcblxuICAgIC8vdG8gc3RvcmUgaXRlbXMgd2l0aCB0aGlzIGZvcm1hdDoge2lkZW50aXR5OiBpZGVudGl0eVVSTCwgdG9rZW46IHRva2VuSUR9XG4gICAgX3RoaXMuaWRlbnRpdGllcyA9IFtdO1xuICAgIF90aGlzLmVtYWlsc0xpc3QgPSBbXTtcbiAgICBsZXQgbmV3SWRlbnRpdHkgPSBuZXcgSWRlbnRpdHkoJ2d1aWQnLCdIVU1BTicpO1xuICAgIF90aGlzLmlkZW50aXR5ID0gbmV3SWRlbnRpdHk7XG4gICAgX3RoaXMuY3J5cHRvID0gbmV3IENyeXB0bygpO1xuXG4gICAgLy9zdG9yZXMgdGhlIGFzc29jaWF0aW9uIG9mIHRoZSBkYXRhT2JqZWN0IGFuZCB0aGUgSHlwZXJ0eSByZWdpc3RlcmVkIHdpdGhpblxuICAgIF90aGlzLmRhdGFPYmplY3RzSWRlbnRpdHkgPSB7fTtcblxuICAgIC8vIGhhc2hUYWJsZSB0byBzdG9yZSBhbGwgdGhlIGNyeXB0byBpbmZvcm1hdGlvbiBiZXR3ZWVuIHR3byBoeXBlcnRpZXNcbiAgICBfdGhpcy5jaGF0S2V5cyA9IHt9O1xuXG4gICAgLy8gaGFzaFRhYmxlIHRvIHN0b3JlIHRoZSBzeW1tZXRyaWMga2V5cyB0byBiZSB1c2VkIGluIHRoZSBjaGF0IGdyb3VwXG4gICAgX3RoaXMuZGF0YU9iamVjdFNlc3Npb25LZXlzID0ge307XG5cbiAgICAvL2ZhaWxzYWZlIHRvIGVuYWJsZS9kaXNhYmxlIGFsbCB0aGUgY3JpcHRvZ3JhcGhpYyBmdW5jdGlvbnNcbiAgICBfdGhpcy5pc1RvVXNlRW5jcnlwdGlvbiA9IHRydWU7XG5cbiAgICAvLyB2YXJpYWJsZSB0byBrbm93IGlmIHRoZSBHVUkgaXMgZGVwbG95ZWQgdG8gY2hvb3NlIHRoZSBpZGVudGl0eS4gaWYgdGhlIHJlYWwgR1VJIGlzIG5vdCBkZXBsb3llZCwgYSBmYWtlIGd1aSBpcyBkZXBsb3llZCBpbnN0ZWFkLlxuICAgIF90aGlzLmd1aURlcGxveWVkID0gZmFsc2U7XG5cbiAgICAvLyB2ZXJpZmljYXRpb24gb2Ygbm9kZUpTLCBhbmQgaW4gY2FzZSBpdCBpcyBub2RlSlMgdGhlbiBkaXNhYmxlIGVuY3J5cHRpb25cbiAgICAvLyBUT0RPIGltcHJvdmUgbGF0ZXIsIHRoaXMgZXhpc3RzIGJlY2F1c2UgdGhlIGNyeXB0byBsaWIgdXNlcyBicm93c2VyIGNyeXB0b2dyYXBoaWMgbWV0aG9kc1xuICAgIC8vX3RoaXMuaXNUb1VzZUVuY3J5cHRpb24gPSAod2luZG93KSA/IHRydWUgOiBmYWxzZTtcblxuICAgIF90aGlzLl9sb2FkSWRlbnRpdGllcygpO1xuXG4gIH1cblxuICAvKipcbiAgKiByZXR1cm4gdGhlIG1lc3NhZ2VCdXMgaW4gdGhpcyBSZWdpc3RyeVxuICAqIEBwYXJhbSB7TWVzc2FnZUJ1c30gICAgICAgICAgIG1lc3NhZ2VCdXNcbiAgKi9cbiAgZ2V0IG1lc3NhZ2VCdXMoKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcbiAgICByZXR1cm4gX3RoaXMuX21lc3NhZ2VCdXM7XG4gIH1cblxuICAvKipcbiAgKiBTZXQgdGhlIG1lc3NhZ2VCdXMgaW4gdGhpcyBSZWdpc3RyeVxuICAqIEBwYXJhbSB7TWVzc2FnZUJ1c30gICAgICAgICAgIG1lc3NhZ2VCdXNcbiAgKi9cbiAgc2V0IG1lc3NhZ2VCdXMobWVzc2FnZUJ1cykge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG4gICAgX3RoaXMuX21lc3NhZ2VCdXMgPSBtZXNzYWdlQnVzO1xuXG4gIH1cblxuICAvKipcbiAgKiByZXR1cm4gdGhlIHJlZ2lzdHJ5IGluIHRoaXMgaWRNb2R1bGVcbiAgKiBAcGFyYW0ge3JlZ2lzdHJ5fSAgICAgICAgICAgcmVnaXN0cnlcbiAgKi9cbiAgZ2V0IHJlZ2lzdHJ5KCkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG4gICAgcmV0dXJuIF90aGlzLl9yZWdpc3RyeTtcbiAgfVxuXG4gIC8qKlxuICAqIFNldCB0aGUgcmVnaXN0cnkgaW4gdGhpcyBpZE1vZHVsZVxuICAqIEBwYXJhbSB7cmVnaXN0cnl9ICAgICByZWdcbiAgKi9cbiAgc2V0IHJlZ2lzdHJ5KHJlZ2lzdHJ5KSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcbiAgICBfdGhpcy5fcmVnaXN0cnkgPSByZWdpc3RyeTtcbiAgfVxuXG4gIC8qKlxuICAqIEZ1bmN0aW9uIHRvIHJldHVybiBhbGwgdGhlIGlkZW50aXRpZXMgcmVnaXN0ZXJlZCB3aXRoaW4gYSBzZXNzaW9uIGJ5IGEgdXNlci5cbiAgKiBUaGVzZSBpZGVudGl0aWVzIGFyZSByZXR1cm5lZCBpbiBhbiBhcnJheSBjb250YWluaW5nIGEgSlNPTiBwYWNrYWdlIGZvciBlYWNoIHVzZXIgaWRlbnRpdHkuXG4gICogQHJldHVybiB7QXJyYXk8SWRlbnRpdGllcz59ICAgICAgICAgSWRlbnRpdGllc1xuICAqL1xuICBnZXRJZGVudGl0aWVzKCkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG4gICAgcmV0dXJuIF90aGlzLmlkZW50aXRpZXM7XG4gIH1cblxuICAvKipcbiAgKiBnZXRzIGFsbCB0aGUgaW5mb3JtYXRpb24gZnJvbSBhIGdpdmVuIHVzZXJVUkxcbiAgKiBAcGFyYW0gIHtTdHJpbmd9ICB1c2VyVVJMICAgICB1c2VyIHVybFxuICAqIEByZXR1cm4ge0pTT059ICAgIGlkZW50aXR5ICAgIGlkZW50aXR5IGJ1bmRsZSBmcm9tIHRoZSB1c2VyVVJMXG4gICovXG4gIGdldElkZW50aXR5KHVzZXJVUkwpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgZm9yIChsZXQgaW5kZXggaW4gX3RoaXMuaWRlbnRpdGllcykge1xuXG4gICAgICBsZXQgaWRlbnRpdHkgPSBfdGhpcy5pZGVudGl0aWVzW2luZGV4XTtcbiAgICAgIGlmIChpZGVudGl0eS5pZGVudGl0eSA9PT0gdXNlclVSTCkge1xuICAgICAgICByZXR1cm4gaWRlbnRpdHk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgJ2lkZW50aXR5IG5vdCBmb3VuZCc7XG4gIH1cblxuICBfbG9hZElkZW50aXRpZXMoKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcblxuICAgICAgX3RoaXMuc3RvcmFnZU1hbmFnZXIuZ2V0KCdpZE1vZHVsZTppZGVudGl0aWVzJykudGhlbigoaWRlbnRpdGllcykgPT4ge1xuXG4gICAgICAgIGlmIChpZGVudGl0aWVzKSB7XG4gICAgICAgICAgX3RoaXMuaWRlbnRpdGllcyA9IGlkZW50aXRpZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBkZXBsb3lHVUkoKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcbiAgICBfdGhpcy5ndWlEZXBsb3llZCA9IHRydWU7XG4gIH1cblxuICBnZXRJZGVudGl0eU9mSHlwZXJ0eShoeXBlcnR5VVJMKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGxldCBzcGxpdFVSTCA9IGh5cGVydHlVUkwuc3BsaXQoJzovLycpO1xuICAgICAgaWYgKHNwbGl0VVJMWzBdICE9PSAnaHlwZXJ0eScpIHtcbiAgICAgICAgX3RoaXMuX2dldEh5cGVydHlGcm9tRGF0YU9iamVjdChoeXBlcnR5VVJMKS50aGVuKChyZXR1cm5lZEh5cGVydHlVUkwpID0+IHtcbiAgICAgICAgICBsZXQgdXNlclVSTCA9IF90aGlzLnJlZ2lzdHJ5LmdldEh5cGVydHlPd25lcihyZXR1cm5lZEh5cGVydHlVUkwpO1xuICAgICAgICAgIGlmICh1c2VyVVJMKSB7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4IGluIF90aGlzLmlkZW50aXRpZXMpIHtcbiAgICAgICAgICAgICAgbGV0IGlkZW50aXR5ID0gX3RoaXMuaWRlbnRpdGllc1tpbmRleF07XG4gICAgICAgICAgICAgIGlmIChpZGVudGl0eS5pZGVudGl0eSA9PT0gdXNlclVSTCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGlkZW50aXR5Lm1lc3NhZ2VJbmZvKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KCdubyBpZGVudGl0eSB3YXMgZm91bmQgJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCB1c2VyVVJMID0gX3RoaXMucmVnaXN0cnkuZ2V0SHlwZXJ0eU93bmVyKGh5cGVydHlVUkwpO1xuICAgICAgICBpZiAodXNlclVSTCkge1xuXG4gICAgICAgICAgZm9yIChsZXQgaW5kZXggaW4gX3RoaXMuaWRlbnRpdGllcykge1xuICAgICAgICAgICAgbGV0IGlkZW50aXR5ID0gX3RoaXMuaWRlbnRpdGllc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoaWRlbnRpdHkuaWRlbnRpdHkgPT09IHVzZXJVUkwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoaWRlbnRpdHkubWVzc2FnZUluZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KCdubyBpZGVudGl0eSB3YXMgZm91bmQuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGdldElkZW50aXRpZXNUb0Nob29zZSgpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuICAgIGxldCBpZGVudGl0aWVzID0gX3RoaXMuZW1haWxzTGlzdDtcbiAgICBsZXQgaWRwcyA9IFsnZ29vZ2xlLmNvbScsICdtaWNyb3NvZnQuY29tJywgJ29yYW5nZS5mciddO1xuXG4gICAgcmV0dXJuIHtpZGVudGl0aWVzOiBpZGVudGl0aWVzLCBpZHBzOiBpZHBzfTtcbiAgfVxuXG4gIC8qKlxuICAqIEZ1bmN0aW9uIHRvIHJldHVybiBhbGwgdGhlIHVzZXJzIFVSTHMgcmVnaXN0ZXJlZCB3aXRoaW4gYSBzZXNzaW9uXG4gICogVGhlc2UgdXNlcnMgVVJMcyBhcmUgcmV0dXJuZWQgaW4gYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAgKiBAcGFyYW0gIHtCb29sZWFufSAgZW1haWxGb3JtYXQgKE9wdGlvbmFsKSAgIGJvb2xlYW4gdG8gaW5kaWNhdGUgdG8gcmV0dXJuIGluIGVtYWlsIGZvcm1hdFxuICAqIEByZXR1cm4ge0FycmF5PFN0cmluZz59ICAgICAgICAgdXNlcnNcbiAgKi9cbiAgZ2V0VXNlcnNJRHMoZW1haWxGb3JtYXQpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuICAgIGxldCB1c2VycyA9IFtdO1xuXG4gICAgLy9pZiByZXF1ZXN0IGNvbWVzIHdpdGggdGhlIGVtYWlsRm9ybWF0IG9wdGlvbiwgdGhlbiBjb252ZXJ0IHVybCB0byBlbWFpbCBmb3JtYXRcbiAgICBsZXQgY29udmVydGVyID0gKGVtYWlsRm9ybWF0KSA/IGdldFVzZXJFbWFpbEZyb21VUkwgOiAodmFsdWUpID0+IHtyZXR1cm4gdmFsdWU7fTtcblxuICAgIGZvciAobGV0IGluZGV4IGluIF90aGlzLmlkZW50aXRpZXMpIHtcbiAgICAgIGxldCBpZGVudGl0eSA9IF90aGlzLmlkZW50aXRpZXNbaW5kZXhdO1xuICAgICAgdXNlcnMucHVzaChjb252ZXJ0ZXIoaWRlbnRpdHkuaWRlbnRpdHkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZXJzO1xuICB9XG5cbiAgLyoqXG4gICogRnVuY3Rpb24gdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBJZGVudGl0eSB3aXRoaW4gYSBzZXNzaW9uXG4gICogQHJldHVybiB7SWRlbnRpdHl9ICAgICAgICBpZGVudGl0eSAgICAgICAgIGlkZW50aXR5XG4gICovXG4gIGdldEN1cnJlbnRJZGVudGl0eSgpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuICAgIHJldHVybiBfdGhpcy5jdXJyZW50SWRlbnRpdHk7XG4gIH1cblxuICAvKipcbiAgKiBGdW5jdGlvbiB0byBzZXQgdGhlIGN1cnJlbnQgSWRlbnRpdHkgd2l0aCBhIGdpdmVuIElkZW50aXR5XG4gICogQHBhcmFtIHtJZGVudGl0eX0gICAgICAgIGlkZW50aXR5ICAgICAgICAgaWRlbnRpdHlcbiAgKi9cbiAgc2V0Q3VycmVudElkZW50aXR5KGlkZW50aXR5KSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcbiAgICBfdGhpcy5jdXJyZW50SWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgfVxuXG4gIC8qKlxuICAqIEZ1bmN0aW9uIHRvIHJlbW92ZSBhbiBpZGVudGl0eSBmcm9tIHRoZSBJZGVudGl0aWVzIGFycmF5XG4gICogQHBhcmFtIHtTdHJpbmd9ICAgIHVzZXJJRCAgICAgIHVzZXJJRFxuICAqL1xuICBkZWxldGVJZGVudGl0eSh1c2VySUQpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgbGV0IHVzZXJVUkwgPSBjb252ZXJ0VG9Vc2VyVVJMKHVzZXJJRCk7XG5cbiAgICBmb3IgKGxldCBpZGVudGl0eSBpbiBfdGhpcy5pZGVudGl0aWVzKSB7XG4gICAgICBpZiAoX3RoaXMuaWRlbnRpdGllc1tpZGVudGl0eV0uaWRlbnRpdHkgPT09IHVzZXJVUkwpIHtcbiAgICAgICAgX3RoaXMuaWRlbnRpdGllcy5zcGxpY2UoaWRlbnRpdHksIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAqIEZ1bmN0aW9uIHRvIHVucmVnaXN0ZXIgYW4gaWRlbnRpdHkgZnJvbSB0aGUgZW1haWxzTGlzdCBhcnJheSBhbmQgbm90IHNob3cgaW4gdG8gdGhlIEdVSVxuICAqIEBwYXJhbSB7U3RyaW5nfSAgICBlbWFpbCAgICAgIGVtYWlsXG4gICovXG4gIHVucmVnaXN0ZXJJZGVudGl0eShlbWFpbCkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG5cbiAgICBmb3IgKGxldCBlIGluIF90aGlzLmVtYWlsc0xpc3QpIHtcbiAgICAgIGlmIChfdGhpcy5lbWFpbHNMaXN0W2VdID09PSBlbWFpbCkge1xuICAgICAgICBfdGhpcy5lbWFpbHNMaXN0LnNwbGljZShlLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgKiBGdW5jdGlvbiB0aGF0IHJlc29sdmUgYW5kIGNyZWF0ZSB0aGUgZG9tYWluVVJMIGluIGNhc2UgaXQgaXMgcHJvdmlkZWQgb25lLiBJZiBub3QsIHJlc29sdmUgdGhlIGRlZmF1bHQgZG9tYWluVVJMXG4gICogQHBhcmFtIHtTdHJpbmd9ICAgICBpZHBEb21haW4gICAgIGlkcERvbWFpbiAoT3B0aW9uYWwpXG4gICovXG4gIF9yZXNvbHZlRG9tYWluKGlkcERvbWFpbikge1xuICAgIGlmICghaWRwRG9tYWluKSB7XG4gICAgICByZXR1cm4gJ2RvbWFpbi1pZHA6Ly9nb29nbGUuY29tJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICdkb21haW4taWRwOi8vJyArIGlkcERvbWFpbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgKiBGdW5jdGlvbiB0aGF0IHNlbmRzIGEgcmVxdWVzdCB0byB0aGUgR1VJIHVzaW5nIG1lc3NhZ2VzLiBTZW5kcyBhbGwgaWRlbnRpdGllcyByZWdpc3RlcmVkIGFuZFxuICAqIHRoZSBJZHBzIHN1cHBvcnRlZCwgYW5kIHJldHVybiB0aGUgaWRlbnRpdHkvaWRwIHJlY2VpdmVkIGJ5IHRoZSBHVUlcbiAgKiBAcGFyYW0ge0FycmF5PGlkZW50aXR5Pn0gIGlkZW50aXRpZXMgICAgICBsaXN0IG9mIGlkZW50aXRpaWVzXG4gICogQHBhcmFtIHtBcnJheTxTdHJpbmc+fSAgICBpZHBzICAgICAgICAgICAgbGlzdCBvZiBpZHBzIHRvIGF1dGhlbnRpY2F0ZVxuICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgcmV0dXJucyBhIGNob3NlbiBpZGVudGl0eSBvciBpZHBcbiAgKi9cbiAgcmVxdWVzdElkZW50aXR5VG9HVUkoaWRlbnRpdGllcywgaWRwcykge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSxyZWplY3QpIHtcblxuICAgICAgLy9jb25kaXRpb24gdG8gY2hlY2sgaWYgdGhlIHJlYWwgR1VJIGlzIGRlcGxveWVkLiBJZiBub3QsIGRlcGxveXMgYSBmYWtlIGd1aVxuICAgICAgaWYgKF90aGlzLmd1aURlcGxveWVkID09PSBmYWxzZSkge1xuXG4gICAgICAgIGxldCBndWlGYWtlID0gbmV3IEd1aUZha2UoX3RoaXMuX2d1aVVSTCwgX3RoaXMuX21lc3NhZ2VCdXMpO1xuICAgICAgICBfdGhpcy5ndWlGYWtlID0gZ3VpRmFrZTtcbiAgICAgICAgX3RoaXMuZ3VpRGVwbG95ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBsZXQgbWVzc2FnZSA9IHt0eXBlOidjcmVhdGUnLCB0bzogX3RoaXMuX2d1aVVSTCwgZnJvbTogX3RoaXMuX2lkbVVSTCxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge3ZhbHVlOiB7aWRlbnRpdGllczogaWRlbnRpdGllcywgaWRwczogaWRwc319fTtcblxuICAgICAgbGV0IGlkID0gX3RoaXMuX21lc3NhZ2VCdXMucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIC8vYWRkIGxpc3RlbmVyIHdpdGhvdXQgdGltb3V0XG4gICAgICBfdGhpcy5fbWVzc2FnZUJ1cy5hZGRSZXNwb25zZUxpc3RlbmVyKF90aGlzLl9pZG1VUkwsIGlkLCBtc2cgPT4ge1xuICAgICAgICBfdGhpcy5fbWVzc2FnZUJ1cy5yZW1vdmVSZXNwb25zZUxpc3RlbmVyKF90aGlzLl9pZG1VUkwsIGlkKTtcblxuICAgICAgICBpZiAobXNnLmJvZHkuY29kZSA9PT0gMjAwKSB7XG4gICAgICAgICAgbGV0IHNlbGVjdGVkSWRlbnRpdHkgPSBtc2cuYm9keTtcblxuICAgICAgICAgIGNvbnNvbGUubG9nKCdzZWxlY3RlZElkZW50aXR5OiAnLCBzZWxlY3RlZElkZW50aXR5LnZhbHVlKTtcbiAgICAgICAgICByZXNvbHZlKHNlbGVjdGVkSWRlbnRpdHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdCgnZXJyb3Igb24gcmVxdWVzdGluZyBhbiBpZGVudGl0eSB0byB0aGUgR1VJJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgb3BlblBvcHVwKHVybHJlY2VpdmVkKSB7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICBsZXQgd2luID0gd2luZG93Lm9wZW4odXJscmVjZWl2ZWQsICdvcGVuSURyZXF1ZXN0JywgJ3dpZHRoPTgwMCwgaGVpZ2h0PTYwMCcpO1xuICAgICAgaWYgKHdpbmRvdy5jb3Jkb3ZhKSB7XG4gICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKCdsb2Fkc3RhcnQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgbGV0IHVybCA9IGUudXJsO1xuICAgICAgICAgIGxldCBjb2RlID0gL1xcJmNvZGU9KC4rKSQvLmV4ZWModXJsKTtcbiAgICAgICAgICBsZXQgZXJyb3IgPSAvXFwmZXJyb3I9KC4rKSQvLmV4ZWModXJsKTtcblxuICAgICAgICAgIGlmIChjb2RlIHx8IGVycm9yKSB7XG4gICAgICAgICAgICB3aW4uY2xvc2UoKTtcbiAgICAgICAgICAgIHJlc29sdmUodXJsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHBvbGxUaW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAod2luLmNsb3NlZCkge1xuICAgICAgICAgICAgICByZWplY3QoJ1NvbWUgZXJyb3Igb2NjdXJlZCB3aGVuIHRyeWluZyB0byBnZXQgaWRlbnRpdHkuJyk7XG4gICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwocG9sbFRpbWVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHdpbi5kb2N1bWVudC5VUkwuaW5kZXhPZignaWRfdG9rZW4nKSAhPT0gLTEgfHwgd2luLmRvY3VtZW50LlVSTC5pbmRleE9mKGxvY2F0aW9uLm9yaWdpbikgIT09IC0xKSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHBvbGxUaW1lcik7XG4gICAgICAgICAgICAgIGxldCB1cmwgPSAgIHdpbi5kb2N1bWVudC5VUkw7XG5cbiAgICAgICAgICAgICAgd2luLmNsb3NlKCk7XG4gICAgICAgICAgICAgIHJlc29sdmUodXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgNTAwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAqIEZ1bmN0aW9uIHRoYXQgZmV0Y2ggYW4gaWRlbnRpdHlBc3NlcnRpb24gZnJvbSBhIHVzZXIuXG4gICpcbiAgKiBAcmV0dXJuIHtJZEFzc2VydGlvbn0gICAgICAgICAgICAgIElkQXNzZXJ0aW9uXG4gICovXG4gIGdldElkZW50aXR5QXNzZXJ0aW9uKGlkZW50aWZpZXIsIG9yaWdpbiwgdXNlcm5hbWVIaW50LCBpZHBEb21haW4pIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUscmVqZWN0KSB7XG5cbiAgICAgIC8vQ0hFQ0sgd2hldGhlciBpcyBicm93c2VyIGVudmlyb25tZW50IG9yIG5vZGVqc1xuICAgICAgLy9pZiBpdCBpcyBicm93c2VyLCB0aGVuIGNyZWF0ZSBhIGZha2UgaWRlbnRpdHlcblxuICAgICAgX3RoaXMucnVudGltZUNhcGFiaWxpdGllcy5pc0F2YWlsYWJsZSgnYnJvd3NlcicpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygncnVudGltZSBicm93c2VyIGlkZW50aXR5IGFjcXVpc2l0aW9uICcsIHJlc3VsdCk7XG5cbiAgICAgICAgaWYgKCFyZXN1bHQpIHJldHVybjtcblxuICAgICAgICBsZXQgaWRlbnRpdGllc0luZm8gPSBfdGhpcy5nZXRJZGVudGl0aWVzVG9DaG9vc2UoKTtcblxuICAgICAgICBfdGhpcy5yZXF1ZXN0SWRlbnRpdHlUb0dVSShpZGVudGl0aWVzSW5mby5pZGVudGl0aWVzLCBpZGVudGl0aWVzSW5mby5pZHBzKS50aGVuKHZhbHVlID0+IHtcblxuICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSAnaWRlbnRpdHknKSB7XG5cbiAgICAgICAgICAgIGxldCBjaG9zZW5JRCA9IGdldFVzZXJVUkxGcm9tRW1haWwodmFsdWUudmFsdWUpO1xuXG4gICAgICAgICAgICAvLyByZXR1cm5zIHRoZSBpZGVudGl0eSBpbmZvIGZyb20gdGhlIGNob3NlbiBpZFxuICAgICAgICAgICAgZm9yIChsZXQgaSBpbiBfdGhpcy5pZGVudGl0aWVzKSB7XG4gICAgICAgICAgICAgIGlmIChfdGhpcy5pZGVudGl0aWVzW2ldLmlkZW50aXR5ID09PSBjaG9zZW5JRCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKF90aGlzLmlkZW50aXRpZXNbaV0ubWVzc2FnZUluZm8pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWplY3QoJ25vIGlkZW50aXR5IHdhcyBmb3VuZCAuJyk7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS50eXBlID09PSAnaWRwJykge1xuXG4gICAgICAgICAgICBfdGhpcy5jYWxsR2VuZXJhdGVNZXRob2RzKHZhbHVlLnZhbHVlLCBvcmlnaW4pLnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgfSwgKGVycikgPT4ge1xuICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdCgnZXJyb3Igb24gR1VJIHJlY2VpdmVkIG1lc3NhZ2UuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ0Vycm9yIG9uIGlkZW50aXR5IGFjcXVpc2l0aW9uICcsIGVycm9yKTtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH0pO1xuXG4gICAgICBfdGhpcy5ydW50aW1lQ2FwYWJpbGl0aWVzLmlzQXZhaWxhYmxlKCdub2RlJykudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdub2RlIGlkZW50aXR5IGFjcXVpc2l0aW9uICcsIHJlc3VsdCk7XG5cbiAgICAgICAgaWYgKCFyZXN1bHQpIHJldHVybjtcblxuICAgICAgICBpZiAoX3RoaXMuY3VycmVudElkZW50aXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvL1RPRE8gdmVyaWZ5IHdoZXRoZXIgdGhlIHRva2VuIGlzIHN0aWxsIHZhbGlkIG9yIG5vdC5cbiAgICAgICAgICAvLyBzaG91bGQgYmUgbmVlZGVkIHRvIG1ha2UgZnVydGhlciByZXF1ZXN0cywgdG8gb2J0YWluIGEgdmFsaWQgdG9rZW5cbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShfdGhpcy5jdXJyZW50SWRlbnRpdHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdnZXRJZGVudGl0eUFzc2VydGlvbiBmb3Igbm9kZWpzJyk7XG4gICAgICAgICAgbGV0IHJhbmRvbU51bWJlciA9IE1hdGguZmxvb3IoKE1hdGgucmFuZG9tKCkgKiAxMDAwMCkgKyAxKTtcbiAgICAgICAgICBsZXQgaWRlbnRpdHlCdW5kbGUgPSB7XG4gICAgICAgICAgICBhc3NlcnRpb246ICdhc3NlcnRpb24nLFxuICAgICAgICAgICAgaWRwOidub2RlanMnLFxuICAgICAgICAgICAgdXNlclByb2ZpbGU6IHtcbiAgICAgICAgICAgICAgYXZhdGFyOiAnaHR0cHM6Ly9saDMuZ29vZ2xldXNlcmNvbnRlbnQuY29tLy1XYUNyalZNTVYtUS9BQUFBQUFBQUFBSS9BQUFBQUFBQUFBcy84T2xWcUNwU0I5Yy9waG90by5qcGcnLFxuICAgICAgICAgICAgICBjbjogJ3Rlc3Qgbm9kZWpzJyxcbiAgICAgICAgICAgICAgdXNlcm5hbWU6ICdub2RlanMtJyArIHJhbmRvbU51bWJlciArICdAbm9kZWpzLmNvbScsXG4gICAgICAgICAgICAgIHVzZXJVUkw6ICd1c2VyOi8vbm9kZWpzLmNvbS9ub2RlanMtJyArIHJhbmRvbU51bWJlclxuICAgICAgICAgICAgfX07XG4gICAgICAgICAgX3RoaXMuY3VycmVudElkZW50aXR5ID0gaWRlbnRpdHlCdW5kbGU7XG4gICAgICAgICAgX3RoaXMuaWRlbnRpdGllcy5wdXNoKGlkZW50aXR5QnVuZGxlKTtcbiAgICAgICAgICBfdGhpcy5zdG9yYWdlTWFuYWdlci5zZXQoJ2lkTW9kdWxlOmlkZW50aXRpZXMnLCAwLCBfdGhpcy5pZGVudGl0aWVzKS50aGVuKCgpID0+IHtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoaWRlbnRpdHlCdW5kbGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ0Vycm9yIG9uIGlkZW50aXR5IGFjcXVpc2l0aW9uICcsIGVycm9yKTtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgY2FsbEdlbmVyYXRlTWV0aG9kcyhpZHAsIG9yaWdpbikge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICBsZXQgcHVibGljS2V5O1xuICAgICAgbGV0IHVzZXJrZXlQYWlyO1xuXG4gICAgICAvL2dlbmVyYXRlcyB0aGUgUlNBIGtleSBwYWlyXG4gICAgICBfdGhpcy5jcnlwdG8uZ2VuZXJhdGVSU0FLZXlQYWlyKCkudGhlbihmdW5jdGlvbihrZXlQYWlyKSB7XG5cbiAgICAgICAgcHVibGljS2V5ID0gYnRvYShrZXlQYWlyLnB1YmxpYyk7XG4gICAgICAgIHVzZXJrZXlQYWlyID0ga2V5UGFpcjtcbiAgICAgICAgcmV0dXJuIF90aGlzLmdlbmVyYXRlQXNzZXJ0aW9uKHB1YmxpY0tleSwgb3JpZ2luLCAnJywgdXNlcmtleVBhaXIsIGlkcCk7XG5cbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24odXJsKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5nZW5lcmF0ZUFzc2VydGlvbihwdWJsaWNLZXksIG9yaWdpbiwgdXJsLCB1c2Vya2V5UGFpciwgaWRwKTtcblxuICAgICAgfSkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QoJ0Vycm9yIG9uIG9idGFpbmluZyBJZGVudGl0eScpO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHNlbmRHZW5lcmF0ZU1lc3NhZ2UoY29udGVudHMsIG9yaWdpbiwgdXNlcm5hbWVIaW50LCBpZHBEb21haW4pIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuICAgIGxldCBkb21haW4gPSBfdGhpcy5fcmVzb2x2ZURvbWFpbihpZHBEb21haW4pO1xuICAgIGxldCBtZXNzYWdlO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIG1lc3NhZ2UgPSB7dHlwZTonZXhlY3V0ZScsIHRvOiBkb21haW4sIGZyb206IF90aGlzLl9pZG1VUkwsIGJvZHk6IHtyZXNvdXJjZTogJ2lkZW50aXR5JywgbWV0aG9kOiAnZ2VuZXJhdGVBc3NlcnRpb24nLCBwYXJhbXM6IHtjb250ZW50czogY29udGVudHMsIG9yaWdpbjogb3JpZ2luLCB1c2VybmFtZUhpbnQ6IHVzZXJuYW1lSGludH19fTtcbiAgICAgIF90aGlzLl9tZXNzYWdlQnVzLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIChyZXMpID0+IHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHJlcy5ib2R5LnZhbHVlO1xuXG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcblxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBzdG9yZUlkZW50aXR5KHJlc3VsdCwga2V5UGFpcikge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICBsZXQgc3BsaXRlZEFzc2VydGlvbiA9IHJlc3VsdC5hc3NlcnRpb24uc3BsaXQoJy4nKTtcbiAgICAgIGxldCBhc3NlcnRpb25QYXJzZWQ7XG5cbiAgICAgIC8vdmVyaWZ5IGlmIHRoZSB0b2tlbiBjb250YWlucyB0aGUgMyBjb21wb25lbnRzLCBvciBqdXN0IHRoZSBhc3NlcnRpb25cbiAgICAgIGlmIChzcGxpdGVkQXNzZXJ0aW9uWzFdKSB7XG4gICAgICAgIGFzc2VydGlvblBhcnNlZCA9IEpTT04ucGFyc2UoYXRvYihzcGxpdGVkQXNzZXJ0aW9uWzFdKSk7XG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGFzc2VydGlvblBhcnNlZCA9IEpTT04ucGFyc2UoYXRvYihyZXN1bHQuYXNzZXJ0aW9uKSk7XG4gICAgICB9XG4gICAgICBsZXQgaWRUb2tlbjtcblxuICAgICAgLy9UT0RPIHJlbW92ZSB0aGUgdmVyaWZpY2F0aW9uIGFuZCByZW1vdmUgdGhlIHRva2VuSURKU09OIGZyb20gdGhlIGdvb2dsZSBpZHBQcm94eTtcbiAgICAgIGlmIChhc3NlcnRpb25QYXJzZWQudG9rZW5JREpTT04pIHtcbiAgICAgICAgaWRUb2tlbiA9IGFzc2VydGlvblBhcnNlZC50b2tlbklESlNPTjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkVG9rZW4gPSBhc3NlcnRpb25QYXJzZWQ7XG4gICAgICB9XG5cbiAgICAgIGxldCBlbWFpbCA9IGlkVG9rZW4uZW1haWwgfHwgaWRUb2tlbi5zdWI7XG5cbiAgICAgIGxldCBpZGVudGlmaWVyID0gZ2V0VXNlclVSTEZyb21FbWFpbChlbWFpbCk7XG5cbiAgICAgIHJlc3VsdC5pZGVudGl0eSA9IGlkZW50aWZpZXI7XG5cbiAgICAgIF90aGlzLmlkZW50aXR5LmFkZElkZW50aXR5KHJlc3VsdCk7XG5cbiAgICAgIC8vIGNoZWNrIGlmIGV4aXN0cyBhbnkgaW5mb1Rva2VuIGluIHRoZSByZXN1bHQgcmVjZWl2ZWRcbiAgICAgIGxldCBpbmZvVG9rZW4gPSAocmVzdWx0LmluZm9Ub2tlbikgPyByZXN1bHQuaW5mb1Rva2VuIDoge307XG5cbiAgICAgIGxldCBjb21tb25OYW1lID0gaWRUb2tlbi5uYW1lIHx8IGVtYWlsLnN1YnN0cmluZygwLCBlbWFpbC5pbmRleE9mKCdAJykpO1xuICAgICAgbGV0IHVzZXJQcm9maWxlQnVuZGxlID0ge3VzZXJuYW1lOiBlbWFpbCwgY246IGNvbW1vbk5hbWUsIGF2YXRhcjogaW5mb1Rva2VuLnBpY3R1cmUsIGxvY2FsZTogaW5mb1Rva2VuLmxvY2FsZSwgdXNlclVSTDogaWRlbnRpZmllcn07XG5cbiAgICAgIC8vY3JlYXRpb24gb2YgYSBuZXcgSlNPTiB3aXRoIHRoZSBpZGVudGl0eSB0byBzZW5kIHZpYSBtZXNzYWdlc1xuICAgICAgbGV0IG5ld0lkZW50aXR5ID0ge3VzZXJQcm9maWxlOiB1c2VyUHJvZmlsZUJ1bmRsZSwgaWRwOiByZXN1bHQuaWRwLmRvbWFpbiwgYXNzZXJ0aW9uOiByZXN1bHQuYXNzZXJ0aW9ufTtcbiAgICAgIHJlc3VsdC5tZXNzYWdlSW5mbyA9IG5ld0lkZW50aXR5O1xuICAgICAgcmVzdWx0LmtleVBhaXIgPSBrZXlQYWlyO1xuXG4gICAgICBfdGhpcy5jdXJyZW50SWRlbnRpdHkgPSBuZXdJZGVudGl0eTtcblxuICAgICAgLy92ZXJpZnkgaWYgdGhlIGlkIGFscmVhZHkgZXhpc3RzLiBJZiBhbHJlYWR5IGV4aXN0cyB0aGVuIGRvIG5vdCBhZGQgdG8gdGhlIGlkZW50aXRpZXMgbGlzdDtcbiAgICAgIGxldCBpZEFscmVhZHlFeGlzdHMgPSBmYWxzZTtcbiAgICAgIGxldCBvbGRJZDtcbiAgICAgIGZvciAobGV0IGlkZW50aXR5IGluIF90aGlzLmlkZW50aXRpZXMpIHtcbiAgICAgICAgaWYgKF90aGlzLmlkZW50aXRpZXNbaWRlbnRpdHldLmlkZW50aXR5ID09PSByZXN1bHQuaWRlbnRpdHkpIHtcbiAgICAgICAgICBpZEFscmVhZHlFeGlzdHMgPSB0cnVlO1xuICAgICAgICAgIG9sZElkID0gX3RoaXMuaWRlbnRpdGllc1tpZGVudGl0eV0ubWVzc2FnZUluZm87XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlkQWxyZWFkeUV4aXN0cykge1xuICAgICAgICByZXNvbHZlKG9sZElkKTtcbiAgICAgICAgbGV0IGV4aXN0cyA9IGZhbHNlO1xuXG4gICAgICAgIC8vY2hlY2sgaWYgdGhlIGlkZW50aXR5IGV4aXN0cyBpbiBlbWFpbExpc3QsIGlmIG5vdCBhZGQgaXRcbiAgICAgICAgLy9UaGlzIGlzIHVzZWZ1bCBpZiBhbiBpZGVudGl0eSB3YXMgcHJldmlvdXNseSByZWdpc3RlcmVkIGJ1dCB3YXMgbGF0ZXIgdW5yZWdpc3RlcmVkXG4gICAgICAgIGZvciAobGV0IGkgaW4gX3RoaXMuZW1haWxzTGlzdCkge1xuICAgICAgICAgIGlmIChfdGhpcy5lbWFpbHNMaXN0W2ldID09PSBlbWFpbCkge1xuICAgICAgICAgICAgZXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWV4aXN0cykge1xuICAgICAgICAgIF90aGlzLmVtYWlsc0xpc3QucHVzaChlbWFpbCk7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuZW1haWxzTGlzdC5wdXNoKGVtYWlsKTtcbiAgICAgICAgX3RoaXMuaWRlbnRpdGllcy5wdXNoKHJlc3VsdCk7XG4gICAgICAgIF90aGlzLnN0b3JhZ2VNYW5hZ2VyLnNldCgnaWRNb2R1bGU6aWRlbnRpdGllcycsIDAsIF90aGlzLmlkZW50aXRpZXMpLnRoZW4oKCkgPT4ge1xuXG4gICAgICAgICAgcmVzb2x2ZShuZXdJZGVudGl0eSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgKiBSZXF1ZXN0cyB0aGUgSWRwUHJveHkgZnJvbSBhIGdpdmVuIERvbWFpbiBmb3IgYW4gaWRlbnRpdHlBc3NlcnRpb25cbiAgKlxuICAqIEBwYXJhbSAge0RPTVN0cmluZ30gY29udGVudHMgICAgIGNvbnRlbnRzXG4gICogQHBhcmFtICB7RE9NU3RyaW5nfSBvcmlnaW4gICAgICAgb3JpZ2luXG4gICogQHBhcmFtICB7RE9NU3RyaW5nfSB1c2VybmFtZUhpbnQgdXNlcm5hbWVIaW50XG4gICogQHBhcmFtICB7SlNPTn0gICAgICBrZXlQYWlyICAgICAgIHVzZXIga2V5UGFpclxuICAqIEByZXR1cm4ge0lkQXNzZXJ0aW9ufSAgICAgICAgICAgICAgSWRBc3NlcnRpb25cbiAgKi9cbiAgZ2VuZXJhdGVBc3NlcnRpb24oY29udGVudHMsIG9yaWdpbiwgdXNlcm5hbWVIaW50LCBrZXlQYWlyLCBpZHBEb21haW4pIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgY29uc29sZS5sb2coJ2dlbmVyYXRlQXNzZXJ0aW9uJyk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSxyZWplY3QpIHtcblxuICAgICAgX3RoaXMuc2VuZEdlbmVyYXRlTWVzc2FnZShjb250ZW50cywgb3JpZ2luLCB1c2VybmFtZUhpbnQsIGlkcERvbWFpbikudGhlbigocmVzdWx0KSA9PiB7XG5cbiAgICAgICAgaWYgKHJlc3VsdC5sb2dpblVybCkge1xuXG4gICAgICAgICAgX3RoaXMub3BlblBvcHVwKHJlc3VsdC5sb2dpblVybCkudGhlbigodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICAgIH0sIChlcnIpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCkge1xuXG4gICAgICAgICAgX3RoaXMuc3RvcmVJZGVudGl0eShyZXN1bHQsIGtleVBhaXIpLnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICB9LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdCgnZXJyb3Igb24gb2J0YWluaW5nIGlkZW50aXR5IGluZm9ybWF0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgKiBPVEhFUiBVU0VSJ1MgSURFTlRJVFlcbiAgKi9cblxuICAvKipcbiAgKiBSZXF1ZXN0cyB0aGUgSWRwUHJveHkgZnJvbSBhIGdpdmVuIERvbWFpbiB0byB2YWxpZGF0ZSBhbiBJZGVudGl0eUFzc2VydGlvblxuICAqIFJldHVybnMgYSBwcm9taXNlIHdpdGggdGhlIHJlc3VsdCBmcm9tIHRoZSB2YWxpZGF0aW9uLlxuICAqIEBwYXJhbSAge0RPTVN0cmluZ30gYXNzZXJ0aW9uXG4gICogQHBhcmFtICB7RE9NU3RyaW5nfSBvcmlnaW4gICAgICAgb3JpZ2luXG4gICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICBQcm9taXNlICAgICAgICAgcHJvbWlzZSB3aXRoIHRoZSByZXN1bHQgZnJvbSB0aGUgdmFsaWRhdGlvblxuICAqL1xuICB2YWxpZGF0ZUFzc2VydGlvbihhc3NlcnRpb24sIG9yaWdpbiwgaWRwRG9tYWluKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIGxldCBkb21haW4gPSBfdGhpcy5fcmVzb2x2ZURvbWFpbihpZHBEb21haW4pO1xuXG4gICAgbGV0IG1lc3NhZ2UgPSB7dHlwZTonZXhlY3V0ZScsIHRvOiBkb21haW4sIGZyb206IF90aGlzLl9pZG1VUkwsIGJvZHk6IHtyZXNvdXJjZTogJ2lkZW50aXR5JywgbWV0aG9kOiAndmFsaWRhdGVBc3NlcnRpb24nLFxuICAgICAgICAgICAgcGFyYW1zOiB7YXNzZXJ0aW9uOiBhc3NlcnRpb24sIG9yaWdpbjogb3JpZ2lufX19O1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgX3RoaXMuX21lc3NhZ2VCdXMucG9zdE1lc3NhZ2UobWVzc2FnZSwgKHJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAocmVzdWx0LmJvZHkuY29kZSA9PT0gMjAwKSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQuYm9keS52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KCdlcnJvcicsIHJlc3VsdC5ib2R5LmNvZGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGVuY3J5cHRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgY29uc29sZS5sb2coJ2VuY3J5cHQgbWVzc2FnZSAnKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGxldCBpc0hhbmRTaGFrZVR5cGUgPSBtZXNzYWdlLnR5cGUgPT09ICdoYW5kc2hha2UnO1xuXG4gICAgICAvL2lmIGlzIG5vdCB0byBhcHBseSBlbmNyeXB0aW9uLCB0aGVuIHJldHVybnMgcmVzb2x2ZVxuICAgICAgaWYgKCFfdGhpcy5pc1RvVXNlRW5jcnlwdGlvbiAmJiAhaXNIYW5kU2hha2VUeXBlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdlbmNyeXB0aW9uIGRpc2FibGVkJyk7XG4gICAgICAgIHJldHVybiByZXNvbHZlKG1lc3NhZ2UpO1xuICAgICAgfVxuXG4gICAgICAvL1RPRE8gcmVtb3ZlIHRoaXMgbG9naWMgYW5kIG1vdmUgaXQgdG8gYSB1dGlsIGZ1bmN0aW9uXG4gICAgICBsZXQgc3BsaXRlZFRvVVJMID0gbWVzc2FnZS50by5zcGxpdCgnLycpO1xuICAgICAgbGV0IGRhdGFPYmplY3RVUkwgPSBzcGxpdGVkVG9VUkxbMF0gKyAnLy8nICsgc3BsaXRlZFRvVVJMWzJdICsgJy8nICsgc3BsaXRlZFRvVVJMWzNdO1xuICAgICAgaWYgKHNwbGl0ZWRUb1VSTC5sZW5ndGggPiA2KSB7XG4gICAgICAgIGRhdGFPYmplY3RVUkwgPSBzcGxpdGVkVG9VUkxbMF0gKyAnLy8nICsgc3BsaXRlZFRvVVJMWzJdICsgJy8nICsgc3BsaXRlZFRvVVJMWzNdICsgJy8nICsgc3BsaXRlZFRvVVJMWzRdO1xuICAgICAgfVxuXG4gICAgICBsZXQgaXNUb0RhdGFPYmplY3QgPSBpc0RhdGFPYmplY3RVUkwoZGF0YU9iamVjdFVSTCk7XG4gICAgICBsZXQgaXNGcm9tSHlwZXJ0eSA9IGRpdmlkZVVSTChtZXNzYWdlLmZyb20pLnR5cGUgPT09ICdoeXBlcnR5JztcbiAgICAgIGxldCBpc1RvSHlwZXJ0eSA9IGRpdmlkZVVSTChtZXNzYWdlLnRvKS50eXBlID09PSAnaHlwZXJ0eSc7XG5cbiAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09ICd1cGRhdGUnKSB7XG4gICAgICAgIHJlc29sdmUobWVzc2FnZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Zyb21IeXBlcnR5ICYmIGlzVG9IeXBlcnR5KSB7XG4gICAgICAgIGxldCB1c2VyVVJMID0gX3RoaXMuX3JlZ2lzdHJ5LmdldEh5cGVydHlPd25lcihtZXNzYWdlLmZyb20pO1xuICAgICAgICBpZiAodXNlclVSTCkge1xuXG4gICAgICAgICAgLy8gY2hlY2sgaWYgZXhpc3RzIGFueSBrZXlzIGJldHdlZW4gdHdvIHVzZXJzXG4gICAgICAgICAgbGV0IGNoYXRLZXlzID0gX3RoaXMuY2hhdEtleXNbbWVzc2FnZS5mcm9tICsgJzwtPicgKyBtZXNzYWdlLnRvXTtcbiAgICAgICAgICBpZiAoIWNoYXRLZXlzKSB7XG4gICAgICAgICAgICBjaGF0S2V5cyA9IF90aGlzLl9uZXdDaGF0Q3J5cHRvKG1lc3NhZ2UsIHVzZXJVUkwpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2NyZWF0ZUNoYXRLZXkgZW5jcnlwdCcsIG1lc3NhZ2UuZnJvbSArIG1lc3NhZ2UudG8pO1xuICAgICAgICAgICAgX3RoaXMuY2hhdEtleXNbbWVzc2FnZS5mcm9tICsgJzwtPicgKyBtZXNzYWdlLnRvXSA9IGNoYXRLZXlzO1xuICAgICAgICAgICAgbWVzc2FnZS5ib2R5LmhhbmRzaGFrZVBoYXNlID0gJ3N0YXJ0SGFuZFNoYWtlJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2hhdEtleXMuYXV0aGVudGljYXRlZCAmJiAhaXNIYW5kU2hha2VUeXBlKSB7XG5cbiAgICAgICAgICAgIGxldCBpdiA9IF90aGlzLmNyeXB0by5nZW5lcmF0ZUlWKCk7XG4gICAgICAgICAgICBfdGhpcy5jcnlwdG8uZW5jcnlwdEFFUyhjaGF0S2V5cy5rZXlzLmh5cGVydHlGcm9tU2Vzc2lvbktleSwgbWVzc2FnZS5ib2R5LnZhbHVlLCBpdikudGhlbihlbmNyeXB0ZWRWYWx1ZSA9PiB7XG5cbiAgICAgICAgICAgICAgbGV0IGZpbHRlcmVkTWVzc2FnZSA9IF90aGlzLl9maWx0ZXJNZXNzYWdlVG9IYXNoKG1lc3NhZ2UsIG1lc3NhZ2UuYm9keS52YWx1ZSArIGl2LCBjaGF0S2V5cy5oeXBlcnR5RnJvbS5tZXNzYWdlSW5mbyk7XG5cbiAgICAgICAgICAgICAgX3RoaXMuY3J5cHRvLmhhc2hITUFDKGNoYXRLZXlzLmtleXMuaHlwZXJ0eUZyb21IYXNoS2V5LCBmaWx0ZXJlZE1lc3NhZ2UpLnRoZW4oaGFzaCA9PiB7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncmVzdWx0IG9mIGhhc2ggJywgaGFzaCk7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0ge2l2OiBfdGhpcy5jcnlwdG8uZW5jb2RlKGl2KSwgdmFsdWU6IF90aGlzLmNyeXB0by5lbmNvZGUoZW5jcnlwdGVkVmFsdWUpLCBoYXNoOiBfdGhpcy5jcnlwdG8uZW5jb2RlKGhhc2gpfTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmJvZHkudmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICByZXNvbHZlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBpZiBpcyBhIGhhbmRzaGFrZSBtZXNzYWdlLCBqdXN0IHJlc29sdmUgaXRcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzSGFuZFNoYWtlVHlwZSkge1xuICAgICAgICAgICAgcmVzb2x2ZShtZXNzYWdlKTtcblxuICAgICAgICAgICAgLy8gZWxzZSwgc3RhcnRzIGEgbmV3IGhhbmRzaGFrZSBwcm90b2NvbFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5fZG9IYW5kU2hha2VQaGFzZShtZXNzYWdlLCBjaGF0S2V5cykudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICBfdGhpcy5jaGF0S2V5c1ttZXNzYWdlLmZyb20gKyAnPC0+JyArIG1lc3NhZ2UudG9dID0gdmFsdWUuY2hhdEtleXM7XG5cbiAgICAgICAgICAgICAgX3RoaXMuX21lc3NhZ2VCdXMucG9zdE1lc3NhZ2UodmFsdWUubWVzc2FnZSk7XG4gICAgICAgICAgICAgIHJlamVjdCgnZW5jcnlwdCBoYW5kc2hha2UgcHJvdG9jb2wgcGhhc2UgJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgLy9pZiBmcm9tIGh5cGVydHkgdG8gYSBkYXRhT2JqZWN0VVJMXG4gICAgICB9IGVsc2UgaWYgKGlzRnJvbUh5cGVydHkgJiYgaXNUb0RhdGFPYmplY3QpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ2RhdGFPYmplY3QgdmFsdWUgdG8gZW5jcnlwdDogJywgbWVzc2FnZS5ib2R5LnZhbHVlKTtcblxuICAgICAgICBsZXQgZGF0YU9iamVjdEtleSA9IF90aGlzLmRhdGFPYmplY3RTZXNzaW9uS2V5c1tkYXRhT2JqZWN0VVJMXTtcblxuICAgICAgICAvL2lmIG5vIGtleSBleGlzdHMsIGNyZWF0ZSBhIG5ldyBvbmUgaWYgaXMgdGhlIHJlcG9ydGVyIG9mIGRhdGFPYmplY3RcbiAgICAgICAgaWYgKCFkYXRhT2JqZWN0S2V5KSB7XG4gICAgICAgICAgbGV0IGlzSHlwZXJ0eVJlcG9ydGVyID0gX3RoaXMucmVnaXN0cnkuZ2V0UmVwb3J0ZXJVUkxTeW5jaG9ub3VzKGRhdGFPYmplY3RVUkwpO1xuXG4gICAgICAgICAgLy8gaWYgdGhlIGh5cGVydHkgaXMgdGhlIHJlcG9ydGVyIG9mIHRoZSBkYXRhT2JqZWN0IHRoZW4gZ2VuZXJhdGVzIGEgc2Vzc2lvbiBrZXlcbiAgICAgICAgICBpZiAoaXNIeXBlcnR5UmVwb3J0ZXIgJiYgaXNIeXBlcnR5UmVwb3J0ZXIgPT09IG1lc3NhZ2UuZnJvbSkge1xuXG4gICAgICAgICAgICBsZXQgc2Vzc2lvbktleSA9IF90aGlzLmNyeXB0by5nZW5lcmF0ZVJhbmRvbSgpO1xuICAgICAgICAgICAgX3RoaXMuZGF0YU9iamVjdFNlc3Npb25LZXlzW2RhdGFPYmplY3RVUkxdID0ge3Nlc3Npb25LZXk6IHNlc3Npb25LZXksIGlzVG9FbmNyeXB0OiB0cnVlfTtcblxuICAgICAgICAgICAgZGF0YU9iamVjdEtleSA9IF90aGlzLmRhdGFPYmplY3RTZXNzaW9uS2V5c1tkYXRhT2JqZWN0VVJMXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL2NoZWNrIGlmIHRoZXJlIGlzIGFscmVhZHkgYSBzZXNzaW9uIGtleSBmb3IgdGhlIGNoYXQgcm9vbVxuICAgICAgICBpZiAoZGF0YU9iamVjdEtleSkge1xuXG4gICAgICAgICAgLy8gYW5kIGlmIGlzIHRvIGFwcGx5IGVuY3J5cHRpb24sIGVuY3J5cHQgdGhlIG1lc3NhZ2VzXG4gICAgICAgICAgaWYgKGRhdGFPYmplY3RLZXkuaXNUb0VuY3J5cHQpIHtcbiAgICAgICAgICAgIGxldCBpdiA9IF90aGlzLmNyeXB0by5nZW5lcmF0ZUlWKCk7XG5cbiAgICAgICAgICAgIF90aGlzLmNyeXB0by5lbmNyeXB0QUVTKGRhdGFPYmplY3RLZXkuc2Vzc2lvbktleSwgX3RoaXMuY3J5cHRvLmVuY29kZShKU09OLnN0cmluZ2lmeShtZXNzYWdlLmJvZHkudmFsdWUpKSwgaXYpLnRoZW4oZW5jcnlwdGVkVmFsdWUgPT4ge1xuXG4gICAgICAgICAgICAgIGxldCBmaWx0ZXJlZE1lc3NhZ2UgPSBfdGhpcy5fZmlsdGVyTWVzc2FnZVRvSGFzaChtZXNzYWdlLCBtZXNzYWdlLmJvZHkudmFsdWUgKyBpdiwgZGF0YU9iamVjdEtleS5zZXNzaW9uS2V5KTtcblxuICAgICAgICAgICAgICBfdGhpcy5jcnlwdG8uaGFzaEhNQUMoZGF0YU9iamVjdEtleS5zZXNzaW9uS2V5LCBmaWx0ZXJlZE1lc3NhZ2UpLnRoZW4oaGFzaCA9PiB7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnaGFzaCAnLCBoYXNoKTtcblxuICAgICAgICAgICAgICAgIGxldCBuZXdWYWx1ZSA9IHt2YWx1ZTogX3RoaXMuY3J5cHRvLmVuY29kZShlbmNyeXB0ZWRWYWx1ZSksIGl2OiBfdGhpcy5jcnlwdG8uZW5jb2RlKGl2KSwgaGFzaDogX3RoaXMuY3J5cHRvLmVuY29kZShoYXNoKX07XG5cbiAgICAgICAgICAgICAgICBtZXNzYWdlLmJvZHkudmFsdWUgPSBKU09OLnN0cmluZ2lmeShuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIGlmIG5vdCwganVzdCBzZW5kIHRoZSBtZXNzYWdlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUobWVzc2FnZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gc3RhcnQgdGhlIGdlbmVyYXRpb24gb2YgYSBuZXcgc2Vzc2lvbiBLZXlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QoJ2ZhaWxlZCB0byBkZWNyeXB0IG1lc3NhZ2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZGVjcnlwdE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG5cbiAgICBjb25zb2xlLmxvZygnZGVjcnlwdCBtZXNzYWdlICcpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgbGV0IGlzSGFuZFNoYWtlVHlwZSA9IG1lc3NhZ2UudHlwZSA9PT0gJ2hhbmRzaGFrZSc7XG5cbiAgICAgIC8vaWYgaXMgbm90IHRvIGFwcGx5IGVuY3J5cHRpb24sIHRoZW4gcmV0dXJucyByZXNvbHZlXG4gICAgICBpZiAoIV90aGlzLmlzVG9Vc2VFbmNyeXB0aW9uICYmICFpc0hhbmRTaGFrZVR5cGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ2RlY3J5cHRpb24gZGlzYWJsZWQnKTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUobWVzc2FnZSk7XG4gICAgICB9XG5cbiAgICAgIC8vVE9ETyByZW1vdmUgdGhpcyBsb2dpYyBhbmQgbW92ZSBpdCB0byBhIHV0aWwgZnVuY3Rpb25cblxuICAgICAgbGV0IHNwbGl0ZWRUb1VSTCA9IG1lc3NhZ2UudG8uc3BsaXQoJy8nKTtcbiAgICAgIGxldCBkYXRhT2JqZWN0VVJMID0gc3BsaXRlZFRvVVJMWzBdICsgJy8vJyArIHNwbGl0ZWRUb1VSTFsyXSArICcvJyArIHNwbGl0ZWRUb1VSTFszXTtcbiAgICAgIGlmIChzcGxpdGVkVG9VUkwubGVuZ3RoID4gNikge1xuICAgICAgICBkYXRhT2JqZWN0VVJMID0gc3BsaXRlZFRvVVJMWzBdICsgJy8vJyArIHNwbGl0ZWRUb1VSTFsyXSArICcvJyArIHNwbGl0ZWRUb1VSTFszXSArICcvJyArIHNwbGl0ZWRUb1VSTFs0XTtcbiAgICAgIH1cblxuICAgICAgbGV0IGlzVG9EYXRhT2JqZWN0ID0gaXNEYXRhT2JqZWN0VVJMKGRhdGFPYmplY3RVUkwpO1xuICAgICAgbGV0IGlzRnJvbUh5cGVydHkgPSBkaXZpZGVVUkwobWVzc2FnZS5mcm9tKS50eXBlID09PSAnaHlwZXJ0eSc7XG4gICAgICBsZXQgaXNUb0h5cGVydHkgPSBkaXZpZGVVUkwobWVzc2FnZS50bykudHlwZSA9PT0gJ2h5cGVydHknO1xuXG4gICAgICBpZiAobWVzc2FnZS50eXBlID09PSAndXBkYXRlJykge1xuICAgICAgICByZXNvbHZlKG1lc3NhZ2UpO1xuICAgICAgfVxuXG4gICAgICAvL2lzIGlzIGh5cGVydHkgdG8gaHlwZXJ0eSBjb21tdW5pY2F0aW9uXG4gICAgICBpZiAoaXNGcm9tSHlwZXJ0eSAmJiBpc1RvSHlwZXJ0eSkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdkZWNyeXB0IGh5cGVydHkgdG8gaHlwZXJ0eScpO1xuICAgICAgICBsZXQgdXNlclVSTCA9IF90aGlzLl9yZWdpc3RyeS5nZXRIeXBlcnR5T3duZXIobWVzc2FnZS50byk7XG4gICAgICAgIGlmICh1c2VyVVJMKSB7XG5cbiAgICAgICAgICBsZXQgY2hhdEtleXMgPSBfdGhpcy5jaGF0S2V5c1ttZXNzYWdlLnRvICsgJzwtPicgKyBtZXNzYWdlLmZyb21dO1xuICAgICAgICAgIGlmICghY2hhdEtleXMpIHtcbiAgICAgICAgICAgIGNoYXRLZXlzID0gX3RoaXMuX25ld0NoYXRDcnlwdG8obWVzc2FnZSwgdXNlclVSTCwgJ2RlY3J5cHQnKTtcbiAgICAgICAgICAgIF90aGlzLmNoYXRLZXlzW21lc3NhZ2UudG8gKyAnPC0+JyArIG1lc3NhZ2UuZnJvbV0gPSBjaGF0S2V5cztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2hhdEtleXMuYXV0aGVudGljYXRlZCAmJiAhaXNIYW5kU2hha2VUeXBlKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBKU09OLnBhcnNlKG1lc3NhZ2UuYm9keS52YWx1ZSk7XG4gICAgICAgICAgICBsZXQgaXYgPSBfdGhpcy5jcnlwdG8uZGVjb2RlKHZhbHVlLml2KTtcbiAgICAgICAgICAgIGxldCBkYXRhID0gX3RoaXMuY3J5cHRvLmRlY29kZSh2YWx1ZS52YWx1ZSk7XG4gICAgICAgICAgICBsZXQgaGFzaCA9IF90aGlzLmNyeXB0by5kZWNvZGUodmFsdWUuaGFzaCk7XG4gICAgICAgICAgICBfdGhpcy5jcnlwdG8uZGVjcnlwdEFFUyhjaGF0S2V5cy5rZXlzLmh5cGVydHlUb1Nlc3Npb25LZXksIGRhdGEsIGl2KS50aGVuKGRlY3J5cHRlZERhdGEgPT4ge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnZGVjcnlwdGVkIHZhbHVlICcsIGRlY3J5cHRlZERhdGEpO1xuICAgICAgICAgICAgICBtZXNzYWdlLmJvZHkudmFsdWUgPSBkZWNyeXB0ZWREYXRhO1xuXG4gICAgICAgICAgICAgIGxldCBmaWx0ZXJlZE1lc3NhZ2UgPSBfdGhpcy5fZmlsdGVyTWVzc2FnZVRvSGFzaChtZXNzYWdlLCBkZWNyeXB0ZWREYXRhICsgaXYpO1xuXG4gICAgICAgICAgICAgIF90aGlzLmNyeXB0by52ZXJpZnlITUFDKGNoYXRLZXlzLmtleXMuaHlwZXJ0eVRvSGFzaEtleSwgZmlsdGVyZWRNZXNzYWdlLCBoYXNoKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygncmVzdWx0IG9mIGhhc2ggdmVyaWZpY2F0aW9uISAnLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuYm9keS5hc3NlcnRlZElkZW50aXR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgfSBlbHNlIGlmIChpc0hhbmRTaGFrZVR5cGUpIHtcbiAgICAgICAgICAgIF90aGlzLl9kb0hhbmRTaGFrZVBoYXNlKG1lc3NhZ2UsIGNoYXRLZXlzKS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG5cbiAgICAgICAgICAgICAgLy9pZiBpdCB3YXMgc3RhcnRlZCBieSBkb011dHVhbEF1dGhlbnRpY2F0aW9uIHRoZW4gZW5kcyB0aGUgcHJvdG9jb2xcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnaGFuZFNoYWtlRW5kJykge1xuICAgICAgICAgICAgICAgIHJlamVjdCgnZGVjcnlwdCBoYW5kc2hha2UgcHJvdG9jb2wgcGhhc2UgJyk7XG5cbiAgICAgICAgICAgICAgLy8gaWYgd2FzIHN0YXJ0ZWQgYnkgYSBtZXNzYWdlLCB0aGVuIHJlc2VuZCB0aGF0IG1lc3NhZ2VcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jaGF0S2V5c1ttZXNzYWdlLnRvICsgJzwtPicgKyBtZXNzYWdlLmZyb21dID0gdmFsdWUuY2hhdEtleXM7XG4gICAgICAgICAgICAgICAgX3RoaXMuX21lc3NhZ2VCdXMucG9zdE1lc3NhZ2UodmFsdWUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KCdkZWNyeXB0IGhhbmRzaGFrZSBwcm90b2NvbCBwaGFzZSAnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdCgnd3JvbmcgbWVzc2FnZSBkbyBkZWNyeXB0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdCgnZXJyb3Igb24gZGVjcnlwdCBtZXNzYWdlJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lmIGZyb20gaHlwZXJ0eSB0byBhIGRhdGFPYmplY3RVUkxcbiAgICAgIH0gZWxzZSBpZiAoaXNGcm9tSHlwZXJ0eSAmJiBpc1RvRGF0YU9iamVjdCkge1xuICAgICAgICBjb25zb2xlLmxvZygnZGF0YU9iamVjdCB2YWx1ZSB0byBkZWNyeXB0OiAnLCBtZXNzYWdlLmJvZHkpO1xuXG4gICAgICAgIGxldCBkYXRhT2JqZWN0S2V5ID0gX3RoaXMuZGF0YU9iamVjdFNlc3Npb25LZXlzW2RhdGFPYmplY3RVUkxdO1xuXG4gICAgICAgIGlmIChkYXRhT2JqZWN0S2V5KSB7XG5cbiAgICAgICAgICAvL2NoZWNrIGlmIGlzIHRvIGFwcGx5IGVuY3J5cHRpb25cbiAgICAgICAgICBpZiAoZGF0YU9iamVjdEtleS5pc1RvRW5jcnlwdCkge1xuICAgICAgICAgICAgbGV0IHBhcnNlZFZhbHVlID0gSlNPTi5wYXJzZShtZXNzYWdlLmJvZHkudmFsdWUpO1xuICAgICAgICAgICAgbGV0IGl2ID0gX3RoaXMuY3J5cHRvLmRlY29kZShwYXJzZWRWYWx1ZS5pdik7XG4gICAgICAgICAgICBsZXQgZW5jcnlwdGVkVmFsdWUgPSBfdGhpcy5jcnlwdG8uZGVjb2RlKHBhcnNlZFZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgIGxldCBoYXNoID0gX3RoaXMuY3J5cHRvLmRlY29kZShwYXJzZWRWYWx1ZS5oYXNoKTtcblxuICAgICAgICAgICAgX3RoaXMuY3J5cHRvLmRlY3J5cHRBRVMoZGF0YU9iamVjdEtleS5zZXNzaW9uS2V5LCBlbmNyeXB0ZWRWYWx1ZSwgaXYpLnRoZW4oZGVjcnlwdGVkVmFsdWUgPT4ge1xuICAgICAgICAgICAgICBsZXQgcGFyc2VkVmFsdWUgPSBKU09OLnBhcnNlKGF0b2IoZGVjcnlwdGVkVmFsdWUpKTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2RlY3J5cHRlZCBWYWx1ZSwnLCBwYXJzZWRWYWx1ZSk7XG4gICAgICAgICAgICAgIG1lc3NhZ2UuYm9keS52YWx1ZSA9IHBhcnNlZFZhbHVlO1xuXG4gICAgICAgICAgICAgIGxldCBmaWx0ZXJlZE1lc3NhZ2UgPSBfdGhpcy5fZmlsdGVyTWVzc2FnZVRvSGFzaChtZXNzYWdlLCBwYXJzZWRWYWx1ZSArIGl2KTtcblxuICAgICAgICAgICAgICBfdGhpcy5jcnlwdG8udmVyaWZ5SE1BQyhkYXRhT2JqZWN0S2V5LnNlc3Npb25LZXksIGZpbHRlcmVkTWVzc2FnZSwgaGFzaCkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3Jlc3VsdCBvZiBoYXNoIHZlcmlmaWNhdGlvbiEgJywgcmVzdWx0KTtcblxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuYm9keS5hc3NlcnRlZElkZW50aXR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy9pZiBub3QsIGp1c3QgcmV0dXJuIHRoZSBtZXNzYWdlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuYm9keS5hc3NlcnRlZElkZW50aXR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc29sdmUobWVzc2FnZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWVzc2FnZS5ib2R5LmFzc2VydGVkSWRlbnRpdHkgPSB0cnVlO1xuICAgICAgICAgIHJlc29sdmUobWVzc2FnZSk7XG5cbiAgICAgICAgICAvL3JlamVjdCgnbm8gc2Vzc2lvbktleSBmb3IgY2hhdCByb29tIGZvdW5kJyk7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVqZWN0KCd3cm9uZyBtZXNzYWdlIHRvIGRlY3J5cHQnKTtcbiAgICAgIH1cblxuICAgIH0pO1xuICB9XG5cbiAgZG9NdXR1YWxBdXRoZW50aWNhdGlvbihzZW5kZXIsIHJlY2VpdmVyKSB7XG4gICAgY29uc29sZS5sb2coJ2RvTXV0dWFsQXV0aGVudGljYXRpb246ICcsIHNlbmRlciwgcmVjZWl2ZXIpO1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG4gICAgbGV0IGRhdGFPYmplY3RVUkw7XG5cbiAgICAvLyBjaGVjayBpZiB0aGUgc2VuZGVyIGlzIGEgZGF0YU9iamVjdCBhbmQgaWYgc28gc3RvcmVzIHRoYXQgdmFsdWVcbiAgICBsZXQgcmVwb3J0ZXJVUkwgPSBfdGhpcy5yZWdpc3RyeS5nZXRSZXBvcnRlclVSTFN5bmNob25vdXMoc2VuZGVyKTtcbiAgICBpZiAocmVwb3J0ZXJVUkwpIHtcbiAgICAgIGRhdGFPYmplY3RVUkwgPSBzZW5kZXI7XG4gICAgICBzZW5kZXIgPSByZXBvcnRlclVSTDtcbiAgICB9XG5cbiAgICBsZXQgbXNnID0ge1xuICAgICAgdG86IHJlY2VpdmVyLFxuICAgICAgZnJvbTogc2VuZGVyLFxuICAgICAgY2FsbGJhY2s6IHVuZGVmaW5lZCxcbiAgICAgIGJvZHk6IHtoYW5kc2hha2VQaGFzZTogJ3N0YXJ0SGFuZFNoYWtlJywgaWdub3JlOiAnaWdub3JlTWVzc2FnZSd9XG4gICAgfTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblxuICAgICAgaWYgKCFzZW5kZXIgfHwgIXJlY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoJ3NlbmRlciBvciByZWNlaXZlciBtaXNzaW5nIG9uIGRvTXV0dWFsQXV0aGVudGljYXRpb24nKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGNoYXRLZXlzID0gX3RoaXMuY2hhdEtleXNbc2VuZGVyICsgJzwtPicgKyByZWNlaXZlcl07XG4gICAgICBsZXQgdXNlclVSTCA9IF90aGlzLl9yZWdpc3RyeS5nZXRIeXBlcnR5T3duZXIoc2VuZGVyKTtcblxuICAgICAgaWYgKHVzZXJVUkwpIHtcblxuICAgICAgICBpZiAoIWNoYXRLZXlzKSB7XG4gICAgICAgICAgLy8gY2FsbGJhY2sgdG8gcmVzb2x2ZSB3aGVuIGZpbmlzaCB0aGUgbXV0dWFsIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgbGV0IHJlc29sdmVkID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjYWxsYmFjayB2YWx1ZTonLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIG1zZy5jYWxsYmFjayA9IHJlc29sdmVkO1xuICAgICAgICAgIG1zZy5kYXRhT2JqZWN0VVJMID0gZGF0YU9iamVjdFVSTDtcblxuICAgICAgICAgIGNoYXRLZXlzID0gX3RoaXMuX25ld0NoYXRDcnlwdG8obXNnLCB1c2VyVVJMKTtcbiAgICAgICAgICBfdGhpcy5jaGF0S2V5c1tzZW5kZXIgKyAnPC0+JyArIHJlY2VpdmVyXSA9IGNoYXRLZXlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYXRLZXlzLmF1dGhlbnRpY2F0ZWQpIHtcblxuICAgICAgICAgIGxldCBzdGFydFNlc3Npb25LZXlFeGNoYW5nZSA9IHtcbiAgICAgICAgICAgIHRvOiBzZW5kZXIsXG4gICAgICAgICAgICBmcm9tOiByZWNlaXZlclxuICAgICAgICAgIH07XG4gICAgICAgICAgY2hhdEtleXMuZGF0YU9iamVjdFVSTCA9IGRhdGFPYmplY3RVUkw7XG4gICAgICAgICAgX3RoaXMuX3NlbmRSZXBvcnRlclNlc3Npb25LZXkoc3RhcnRTZXNzaW9uS2V5RXhjaGFuZ2UsIGNoYXRLZXlzKS50aGVuKHZhbHVlID0+IHtcblxuICAgICAgICAgICAgX3RoaXMuX21lc3NhZ2VCdXMucG9zdE1lc3NhZ2UodmFsdWUubWVzc2FnZSk7XG4gICAgICAgICAgICByZXNvbHZlKCdleGNoYW5nZSBvZiBjaGF0IHNlc3Npb25LZXkgaW5pdGlhdGVkJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBfdGhpcy5fZG9IYW5kU2hha2VQaGFzZShtc2csIGNoYXRLZXlzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVqZWN0KCdlcnJvciBvbiBkb011dHVhbEF1dGhlbnRpY2F0aW9uJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgfVxuXG4gIF9kb0hhbmRTaGFrZVBoYXNlKG1lc3NhZ2UsIGNoYXRLZXlzKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIC8vY29uc29sZS5sb2coJ2hhbmRzaGFrZVR5cGUnKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLHJlamVjdCkge1xuXG4gICAgICBsZXQgaGFuZHNoYWtlVHlwZSA9IG1lc3NhZ2UuYm9keS5oYW5kc2hha2VQaGFzZTtcbiAgICAgIGxldCBpdjtcbiAgICAgIGxldCBoYXNoO1xuICAgICAgbGV0IHZhbHVlID0ge307XG4gICAgICBsZXQgZmlsdGVyZWRNZXNzYWdlO1xuICAgICAgc3dpdGNoIChoYW5kc2hha2VUeXBlKSB7XG5cbiAgICAgICAgY2FzZSAnc3RhcnRIYW5kU2hha2UnOlxuICAgICAgICAgIGNoYXRLZXlzLmtleXMuZnJvbVJhbmRvbSA9IF90aGlzLmNyeXB0by5nZW5lcmF0ZVJhbmRvbSgpO1xuXG4gICAgICAgICAgbGV0IHN0YXJ0SGFuZFNoYWtlTXNnID0ge1xuICAgICAgICAgICAgdHlwZTogJ2hhbmRzaGFrZScsXG4gICAgICAgICAgICB0bzogbWVzc2FnZS50byxcbiAgICAgICAgICAgIGZyb206IG1lc3NhZ2UuZnJvbSxcbiAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgaGFuZHNoYWtlUGhhc2U6ICdzZW5kZXJIZWxsbycsXG4gICAgICAgICAgICAgIHZhbHVlOiBfdGhpcy5jcnlwdG8uZW5jb2RlKGNoYXRLZXlzLmtleXMuZnJvbVJhbmRvbSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGNoYXRLZXlzLmhhbmRzaGFrZUhpc3Rvcnkuc2VuZGVySGVsbG8gPSBfdGhpcy5fZmlsdGVyTWVzc2FnZVRvSGFzaChzdGFydEhhbmRTaGFrZU1zZywgdW5kZWZpbmVkLCBjaGF0S2V5cy5oeXBlcnR5RnJvbS5tZXNzYWdlSW5mbyk7XG5cbiAgICAgICAgICAvLyBjaGVjayBpZiB3YXMgdGhlIGVuY3J5cHQgZnVuY3Rpb24gb3IgdGhlIG11dHVhbCBhdXRoZW50aWNhdGlvbiB0aGF0IHJlcXVlc3QgdGhlXG4gICAgICAgICAgLy8gc3RhcnQgb2YgdGhlIGhhbmRTaGFrZVBoYXNlLlxuICAgICAgICAgIGlmIChjaGF0S2V5cy5pbml0aWFsTWVzc2FnZSkge3Jlc29sdmUoe21lc3NhZ2U6IHN0YXJ0SGFuZFNoYWtlTXNnLCBjaGF0S2V5czogY2hhdEtleXN9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMuY2hhdEtleXNbbWVzc2FnZS5mcm9tICsgJzwtPicgKyBtZXNzYWdlLnRvXSA9IGNoYXRLZXlzO1xuICAgICAgICAgICAgX3RoaXMuX21lc3NhZ2VCdXMucG9zdE1lc3NhZ2Uoc3RhcnRIYW5kU2hha2VNc2cpO1xuICAgICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2VuZGVySGVsbG8nOlxuXG4gICAgICAgICAgY29uc29sZS5sb2coJ3NlbmRlckhlbGxvJyk7XG4gICAgICAgICAgY2hhdEtleXMuaGFuZHNoYWtlSGlzdG9yeS5zZW5kZXJIZWxsbyA9IF90aGlzLl9maWx0ZXJNZXNzYWdlVG9IYXNoKG1lc3NhZ2UpO1xuICAgICAgICAgIGNoYXRLZXlzLmtleXMuZnJvbVJhbmRvbSA9IF90aGlzLmNyeXB0by5kZWNvZGUobWVzc2FnZS5ib2R5LnZhbHVlKTtcbiAgICAgICAgICBjaGF0S2V5cy5rZXlzLnRvUmFuZG9tID0gX3RoaXMuY3J5cHRvLmdlbmVyYXRlUmFuZG9tKCk7XG5cbiAgICAgICAgICBsZXQgc2VuZGVySGVsbG9Nc2cgPSB7XG4gICAgICAgICAgICB0eXBlOiAnaGFuZHNoYWtlJyxcbiAgICAgICAgICAgIHRvOiBtZXNzYWdlLmZyb20sXG4gICAgICAgICAgICBmcm9tOiBtZXNzYWdlLnRvLFxuICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICBoYW5kc2hha2VQaGFzZTogJ3JlY2VpdmVySGVsbG8nLFxuICAgICAgICAgICAgICB2YWx1ZTogX3RoaXMuY3J5cHRvLmVuY29kZShjaGF0S2V5cy5rZXlzLnRvUmFuZG9tKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgY2hhdEtleXMuaGFuZHNoYWtlSGlzdG9yeS5yZWNlaXZlckhlbGxvID0gX3RoaXMuX2ZpbHRlck1lc3NhZ2VUb0hhc2goc2VuZGVySGVsbG9Nc2csIHVuZGVmaW5lZCwgY2hhdEtleXMuaHlwZXJ0eUZyb20ubWVzc2FnZUluZm8pO1xuICAgICAgICAgIHJlc29sdmUoe21lc3NhZ2U6IHNlbmRlckhlbGxvTXNnLCBjaGF0S2V5czogY2hhdEtleXN9KTtcblxuICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmVjZWl2ZXJIZWxsbyc6XG5cbiAgICAgICAgICBjb25zb2xlLmxvZygncmVjZWl2ZXJIZWxsbycpO1xuICAgICAgICAgIGNoYXRLZXlzLmhhbmRzaGFrZUhpc3RvcnkucmVjZWl2ZXJIZWxsbyA9IF90aGlzLl9maWx0ZXJNZXNzYWdlVG9IYXNoKG1lc3NhZ2UpO1xuXG4gICAgICAgICAgX3RoaXMudmFsaWRhdGVBc3NlcnRpb24obWVzc2FnZS5ib2R5LmlkZW50aXR5LmFzc2VydGlvbiwgdW5kZWZpbmVkLCBtZXNzYWdlLmJvZHkuaWRlbnRpdHkuaWRwKS50aGVuKCh2YWx1ZSkgPT4ge1xuXG4gICAgICAgICAgICAvL1RPRE8gcmVtb3ZlIGxhdGVyIHRoaXMgdmVyaWZpY2F0aW9uIGFzIHNvb24gYXMgYWxsIHRoZSBJZFAgcHJveHkgYXJlIHVwZGF0ZWQgaW4gdGhlIGV4YW1wbGVcbiAgICAgICAgICAgIGxldCBlbmNvZGVkcHVibGljS2V5ID0gKHR5cGVvZiB2YWx1ZS5jb250ZW50cyA9PT0gJ3N0cmluZycpID8gdmFsdWUuY29udGVudHMgOiB2YWx1ZS5jb250ZW50cy5ub25jZTtcblxuICAgICAgICAgICAgbGV0IHJlY2VpdmVyUHVibGljS2V5ID0gX3RoaXMuY3J5cHRvLmRlY29kZShlbmNvZGVkcHVibGljS2V5KTtcbiAgICAgICAgICAgIGxldCBwcmVtYXN0ZXJTZWNyZXQgPSBfdGhpcy5jcnlwdG8uZ2VuZXJhdGVQTVMoKTtcbiAgICAgICAgICAgIGxldCB0b1JhbmRvbSA9IG1lc3NhZ2UuYm9keS52YWx1ZTtcbiAgICAgICAgICAgIGNoYXRLZXlzLmh5cGVydHlUby5hc3NlcnRpb24gPSBtZXNzYWdlLmJvZHkuaWRlbnRpdHkuYXNzZXJ0aW9uO1xuICAgICAgICAgICAgY2hhdEtleXMuaHlwZXJ0eVRvLnB1YmxpY0tleSA9IHJlY2VpdmVyUHVibGljS2V5O1xuICAgICAgICAgICAgY2hhdEtleXMuaHlwZXJ0eVRvLnVzZXJJRCAgICA9IHZhbHVlLmNvbnRlbnRzLmVtYWlsO1xuICAgICAgICAgICAgY2hhdEtleXMua2V5cy50b1JhbmRvbSAgPSBfdGhpcy5jcnlwdG8uZGVjb2RlKHRvUmFuZG9tKTtcbiAgICAgICAgICAgIGNoYXRLZXlzLmtleXMucHJlbWFzdGVyS2V5ID0gcHJlbWFzdGVyU2VjcmV0O1xuXG4gICAgICAgICAgICBsZXQgY29uY2F0S2V5ID0gX3RoaXMuY3J5cHRvLmNvbmNhdFBNU3dpdGhSYW5kb21zKHByZW1hc3RlclNlY3JldCwgY2hhdEtleXMua2V5cy50b1JhbmRvbSwgY2hhdEtleXMua2V5cy5mcm9tUmFuZG9tKTtcblxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNyeXB0by5nZW5lcmF0ZU1hc3RlclNlY3JldChjb25jYXRLZXksICdtZXNzYWdlSGlzdG9yaWMnICsgY2hhdEtleXMua2V5cy50b1JhbmRvbSArIGNoYXRLZXlzLmtleXMuZnJvbVJhbmRvbSk7XG5cbiAgICAgICAgICAgIC8vZ2VuZXJhdGUgdGhlIG1hc3RlciBrZXlcbiAgICAgICAgICB9KS50aGVuKChtYXN0ZXJLZXkpID0+IHtcbiAgICAgICAgICAgIGNoYXRLZXlzLmtleXMubWFzdGVyS2V5ID0gbWFzdGVyS2V5O1xuXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuY3J5cHRvLmdlbmVyYXRlS2V5cyhtYXN0ZXJLZXksICdrZXkgZXhwYW5zaW9uJyArIGNoYXRLZXlzLmtleXMudG9SYW5kb20gKyBjaGF0S2V5cy5rZXlzLmZyb21SYW5kb20pO1xuXG4gICAgICAgICAgICAvL2dlbmVyYXRlIHRoZSBzeW1tZXRyaWMgYW5kIGhhc2gga2V5c1xuICAgICAgICAgIH0pLnRoZW4oKGtleXMpID0+IHtcblxuICAgICAgICAgICAgY2hhdEtleXMua2V5cy5oeXBlcnR5VG9TZXNzaW9uS2V5ID0gbmV3IFVpbnQ4QXJyYXkoa2V5c1swXSk7XG4gICAgICAgICAgICBjaGF0S2V5cy5rZXlzLmh5cGVydHlGcm9tU2Vzc2lvbktleSA9IG5ldyBVaW50OEFycmF5KGtleXNbMV0pO1xuICAgICAgICAgICAgY2hhdEtleXMua2V5cy5oeXBlcnR5VG9IYXNoS2V5ID0gbmV3IFVpbnQ4QXJyYXkoa2V5c1syXSk7XG4gICAgICAgICAgICBjaGF0S2V5cy5rZXlzLmh5cGVydHlGcm9tSGFzaEtleSA9IG5ldyBVaW50OEFycmF5KGtleXNbM10pO1xuICAgICAgICAgICAgaXYgPSBfdGhpcy5jcnlwdG8uZ2VuZXJhdGVJVigpO1xuICAgICAgICAgICAgdmFsdWUuaXYgPSBfdGhpcy5jcnlwdG8uZW5jb2RlKGl2KTtcblxuICAgICAgICAgICAgbGV0IG1lc3NhZ2VTdHJ1Y3R1cmUgPSB7XG4gICAgICAgICAgICAgIHR5cGU6ICdoYW5kc2hha2UnLFxuICAgICAgICAgICAgICB0bzogbWVzc2FnZS5mcm9tLFxuICAgICAgICAgICAgICBmcm9tOiBtZXNzYWdlLnRvLFxuICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgaGFuZHNoYWtlUGhhc2U6ICdzZW5kZXJDZXJ0aWZpY2F0ZSdcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gaGFzaCB0aGUgdmFsdWUgYW5kIHRoZSBpdlxuICAgICAgICAgICAgZmlsdGVyZWRNZXNzYWdlID0gX3RoaXMuX2ZpbHRlck1lc3NhZ2VUb0hhc2gobWVzc2FnZVN0cnVjdHVyZSwgJ29rJyArIGl2LCBjaGF0S2V5cy5oeXBlcnR5RnJvbS5tZXNzYWdlSW5mbyk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuY3J5cHRvLmhhc2hITUFDKGNoYXRLZXlzLmtleXMuaHlwZXJ0eUZyb21IYXNoS2V5LCBmaWx0ZXJlZE1lc3NhZ2UpO1xuICAgICAgICAgIH0pLnRoZW4oKGhhc2gpID0+IHtcbiAgICAgICAgICAgIHZhbHVlLmhhc2ggPSBfdGhpcy5jcnlwdG8uZW5jb2RlKGhhc2gpO1xuXG4gICAgICAgICAgICAvL2VuY3J5cHQgdGhlIGRhdGFcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5jcnlwdG8uZW5jcnlwdEFFUyhjaGF0S2V5cy5rZXlzLmh5cGVydHlGcm9tU2Vzc2lvbktleSwgJ29rJywgaXYpO1xuICAgICAgICAgIH0pLnRoZW4oKGVuY3J5cHRlZERhdGEpID0+IHtcbiAgICAgICAgICAgIHZhbHVlLnN5bWV0cmljRW5jcnlwdGlvbiA9IF90aGlzLmNyeXB0by5lbmNvZGUoZW5jcnlwdGVkRGF0YSk7XG5cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5jcnlwdG8uZW5jcnlwdFJTQShjaGF0S2V5cy5oeXBlcnR5VG8ucHVibGljS2V5LCBjaGF0S2V5cy5rZXlzLnByZW1hc3RlcktleSk7XG5cbiAgICAgICAgICB9KS50aGVuKChlbmNyeXB0ZWRWYWx1ZSkgPT4ge1xuXG4gICAgICAgICAgICB2YWx1ZS5hc3N5bWV0cmljRW5jcnlwdGlvbiA9IF90aGlzLmNyeXB0by5lbmNvZGUoZW5jcnlwdGVkVmFsdWUpO1xuXG4gICAgICAgICAgICBsZXQgbWVzc2FnZVN0cnVjdHVyZSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogJ2hhbmRzaGFrZScsXG4gICAgICAgICAgICAgIHRvOiBtZXNzYWdlLmZyb20sXG4gICAgICAgICAgICAgIGZyb206IG1lc3NhZ2UudG8sXG4gICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICBoYW5kc2hha2VQaGFzZTogJ3NlbmRlckNlcnRpZmljYXRlJ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBsZXQgbWVzc2FnZVRvSGFzaCA9IF90aGlzLl9maWx0ZXJNZXNzYWdlVG9IYXNoKG1lc3NhZ2VTdHJ1Y3R1cmUsIGNoYXRLZXlzLmtleXMucHJlbWFzdGVyS2V5LCBjaGF0S2V5cy5oeXBlcnR5RnJvbS5tZXNzYWdlSW5mbyk7XG5cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5jcnlwdG8uc2lnblJTQShjaGF0S2V5cy5oeXBlcnR5RnJvbS5wcml2YXRlS2V5LCBKU09OLnN0cmluZ2lmeShjaGF0S2V5cy5oYW5kc2hha2VIaXN0b3J5KSArIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2VUb0hhc2gpKTtcblxuICAgICAgICAgIH0pLnRoZW4oc2lnbmF0dXJlID0+IHtcblxuICAgICAgICAgICAgdmFsdWUuc2lnbmF0dXJlID0gX3RoaXMuY3J5cHRvLmVuY29kZShzaWduYXR1cmUpO1xuXG4gICAgICAgICAgICBsZXQgcmVjZWl2ZXJIZWxsb01zZyA9IHtcbiAgICAgICAgICAgICAgdHlwZTogJ2hhbmRzaGFrZScsXG4gICAgICAgICAgICAgIHRvOiBtZXNzYWdlLmZyb20sXG4gICAgICAgICAgICAgIGZyb206IG1lc3NhZ2UudG8sXG4gICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICBoYW5kc2hha2VQaGFzZTogJ3NlbmRlckNlcnRpZmljYXRlJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogYnRvYShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjaGF0S2V5cy5oYW5kc2hha2VIaXN0b3J5LnNlbmRlckNlcnRpZmljYXRlID0gX3RoaXMuX2ZpbHRlck1lc3NhZ2VUb0hhc2gocmVjZWl2ZXJIZWxsb01zZywgJ29rJyArIGl2LCBjaGF0S2V5cy5oeXBlcnR5RnJvbS5tZXNzYWdlSW5mbyk7XG5cbiAgICAgICAgICAgIHJlc29sdmUoe21lc3NhZ2U6IHJlY2VpdmVySGVsbG9Nc2csIGNoYXRLZXlzOiBjaGF0S2V5c30pO1xuXG4gICAgICAgICAgfSwgZXJyb3IgPT4gcmVqZWN0KGVycm9yKSk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NlbmRlckNlcnRpZmljYXRlJzpcblxuICAgICAgICAgIGNvbnNvbGUubG9nKCdzZW5kZXJDZXJ0aWZpY2F0ZScpO1xuICAgICAgICAgIGxldCByZWNlaXZlZFZhbHVlID0gSlNPTi5wYXJzZShhdG9iKG1lc3NhZ2UuYm9keS52YWx1ZSkpO1xuXG4gICAgICAgICAgX3RoaXMudmFsaWRhdGVBc3NlcnRpb24obWVzc2FnZS5ib2R5LmlkZW50aXR5LmFzc2VydGlvbiwgdW5kZWZpbmVkLCBtZXNzYWdlLmJvZHkuaWRlbnRpdHkuaWRwKS50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgbGV0IGVuY3J5cHRlZFBNUyA9IF90aGlzLmNyeXB0by5kZWNvZGUocmVjZWl2ZWRWYWx1ZS5hc3N5bWV0cmljRW5jcnlwdGlvbik7XG5cbiAgICAgICAgICAgIC8vVE9ETyByZW1vdmUgbGF0ZXIgdGhpcyB2ZXJpZmljYXRpb24gYXMgc29vbiBhcyBhbGwgdGhlIElkUCBwcm94eSBhcmUgdXBkYXRlZCBpbiB0aGUgZXhhbXBsZVxuICAgICAgICAgICAgbGV0IGVuY29kZWRwdWJsaWNLZXkgPSAodHlwZW9mIHZhbHVlLmNvbnRlbnRzID09PSAnc3RyaW5nJykgPyB2YWx1ZS5jb250ZW50cyA6IHZhbHVlLmNvbnRlbnRzLm5vbmNlO1xuXG4gICAgICAgICAgICBsZXQgc2VuZGVyUHVibGljS2V5ID0gX3RoaXMuY3J5cHRvLmRlY29kZShlbmNvZGVkcHVibGljS2V5KTtcbiAgICAgICAgICAgIGNoYXRLZXlzLmh5cGVydHlUby5hc3NlcnRpb24gPSBtZXNzYWdlLmJvZHkuaWRlbnRpdHkuYXNzZXJ0aW9uO1xuICAgICAgICAgICAgY2hhdEtleXMuaHlwZXJ0eVRvLnB1YmxpY0tleSA9IHNlbmRlclB1YmxpY0tleTtcbiAgICAgICAgICAgIGNoYXRLZXlzLmh5cGVydHlUby51c2VySUQgICAgPSB2YWx1ZS5jb250ZW50cy5lbWFpbDtcblxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNyeXB0by5kZWNyeXB0UlNBKGNoYXRLZXlzLmh5cGVydHlGcm9tLnByaXZhdGVLZXksIGVuY3J5cHRlZFBNUyk7XG5cbiAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgICAgICAgIHJlamVjdCgnRXJyb3IgZHVyaW5nIGF1dGhlbnRpY2F0aW9uIG9mIGlkZW50aXR5Jyk7XG5cbiAgICAgICAgICAgIC8vb2J0YWluIHRoZSBQcmVtYXN0ZXJLZXkgdXNpbmcgdGhlIHByaXZhdGUga2V5XG4gICAgICAgICAgfSkudGhlbihwbXMgPT4ge1xuXG4gICAgICAgICAgICBjaGF0S2V5cy5rZXlzLnByZW1hc3RlcktleSA9IG5ldyBVaW50OEFycmF5KHBtcyk7XG5cbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSBfdGhpcy5jcnlwdG8uZGVjb2RlKHJlY2VpdmVkVmFsdWUuc2lnbmF0dXJlKTtcblxuICAgICAgICAgICAgbGV0IHJlY2VpdmVkbXNnVG9IYXNoID0gX3RoaXMuX2ZpbHRlck1lc3NhZ2VUb0hhc2gobWVzc2FnZSwgY2hhdEtleXMua2V5cy5wcmVtYXN0ZXJLZXkpO1xuXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuY3J5cHRvLnZlcmlmeVJTQShjaGF0S2V5cy5oeXBlcnR5VG8ucHVibGljS2V5LCBKU09OLnN0cmluZ2lmeShjaGF0S2V5cy5oYW5kc2hha2VIaXN0b3J5KSArIEpTT04uc3RyaW5naWZ5KHJlY2VpdmVkbXNnVG9IYXNoKSwgc2lnbmF0dXJlKTtcblxuICAgICAgICAgICAgLy8gdmFsaWRhdGVzIHRoZSBzaWduYXR1cmUgcmVjZWl2ZWRcbiAgICAgICAgICB9KS50aGVuKHNpZ25WYWxpZGF0aW9uUmVzdWx0ID0+IHtcblxuICAgICAgICAgICAgY29uc29sZS5sb2coJ3NpZ25hdHVyZSB2YWxpZGF0aW9uIHJlc3VsdCAnLCBzaWduVmFsaWRhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICBsZXQgY29uY2F0S2V5ID0gX3RoaXMuY3J5cHRvLmNvbmNhdFBNU3dpdGhSYW5kb21zKGNoYXRLZXlzLmtleXMucHJlbWFzdGVyS2V5LCBjaGF0S2V5cy5rZXlzLnRvUmFuZG9tLCBjaGF0S2V5cy5rZXlzLmZyb21SYW5kb20pO1xuXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuY3J5cHRvLmdlbmVyYXRlTWFzdGVyU2VjcmV0KGNvbmNhdEtleSwgJ21lc3NhZ2VIaXN0b3JpYycgKyBjaGF0S2V5cy5rZXlzLnRvUmFuZG9tICsgY2hhdEtleXMua2V5cy5mcm9tUmFuZG9tKTtcblxuICAgICAgICAgICAgLy8gZ2VuZXJhdGVzIHRoZSBtYXN0ZXIga2V5cyBmcm9tIHRoZSBQcmVtYXN0ZXIga2V5IGFuZCB0aGUgcmFuZG9tc1xuICAgICAgICAgIH0pLnRoZW4obWFzdGVyS2V5ID0+IHtcbiAgICAgICAgICAgIGNoYXRLZXlzLmtleXMubWFzdGVyS2V5ID0gbWFzdGVyS2V5O1xuXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuY3J5cHRvLmdlbmVyYXRlS2V5cyhtYXN0ZXJLZXksICdrZXkgZXhwYW5zaW9uJyArIGNoYXRLZXlzLmtleXMudG9SYW5kb20gKyBjaGF0S2V5cy5rZXlzLmZyb21SYW5kb20pO1xuXG4gICAgICAgICAgICAvLyBnZW5lcmF0ZXMgdGhlIHN5bW1ldHJpYyBrZXlzIHRvIGJlIHVzZWQgaW4gdGhlIHN5bW1ldHJpYyBlbmNyeXB0aW9uXG4gICAgICAgICAgfSkudGhlbihrZXlzID0+IHtcbiAgICAgICAgICAgIGNoYXRLZXlzLmtleXMuaHlwZXJ0eUZyb21TZXNzaW9uS2V5ID0gbmV3IFVpbnQ4QXJyYXkoa2V5c1swXSk7XG4gICAgICAgICAgICBjaGF0S2V5cy5rZXlzLmh5cGVydHlUb1Nlc3Npb25LZXkgPSBuZXcgVWludDhBcnJheShrZXlzWzFdKTtcbiAgICAgICAgICAgIGNoYXRLZXlzLmtleXMuaHlwZXJ0eUZyb21IYXNoS2V5ID0gbmV3IFVpbnQ4QXJyYXkoa2V5c1syXSk7XG4gICAgICAgICAgICBjaGF0S2V5cy5rZXlzLmh5cGVydHlUb0hhc2hLZXkgPSBuZXcgVWludDhBcnJheShrZXlzWzNdKTtcbiAgICAgICAgICAgIGl2ID0gX3RoaXMuY3J5cHRvLmRlY29kZShyZWNlaXZlZFZhbHVlLml2KTtcbiAgICAgICAgICAgIGxldCBkYXRhID0gX3RoaXMuY3J5cHRvLmRlY29kZShyZWNlaXZlZFZhbHVlLnN5bWV0cmljRW5jcnlwdGlvbik7XG5cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5jcnlwdG8uZGVjcnlwdEFFUyhjaGF0S2V5cy5rZXlzLmh5cGVydHlUb1Nlc3Npb25LZXksIGRhdGEsIGl2KTtcblxuICAgICAgICAgIH0pLnRoZW4oZGVjcnlwdGVkRGF0YSA9PiB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdkZWNyeXB0ZWREYXRhJywgZGVjcnlwdGVkRGF0YSk7XG5cbiAgICAgICAgICAgIGNoYXRLZXlzLmhhbmRzaGFrZUhpc3Rvcnkuc2VuZGVyQ2VydGlmaWNhdGUgPSBfdGhpcy5fZmlsdGVyTWVzc2FnZVRvSGFzaChtZXNzYWdlLCBkZWNyeXB0ZWREYXRhICsgaXYpO1xuXG4gICAgICAgICAgICBsZXQgaGFzaFJlY2VpdmVkID0gX3RoaXMuY3J5cHRvLmRlY29kZShyZWNlaXZlZFZhbHVlLmhhc2gpO1xuXG4gICAgICAgICAgICBmaWx0ZXJlZE1lc3NhZ2UgPSBfdGhpcy5fZmlsdGVyTWVzc2FnZVRvSGFzaChtZXNzYWdlLCBkZWNyeXB0ZWREYXRhICsgaXYpO1xuXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuY3J5cHRvLnZlcmlmeUhNQUMoY2hhdEtleXMua2V5cy5oeXBlcnR5VG9IYXNoS2V5LCBmaWx0ZXJlZE1lc3NhZ2UsIGhhc2hSZWNlaXZlZCk7XG5cbiAgICAgICAgICB9KS50aGVuKHZlcmlmaWVkSGFzaCAgPT4ge1xuXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdyZXN1bHQgb2YgaGFzaCB2ZXJpZmljYXRpb24gJywgdmVyaWZpZWRIYXNoKTtcbiAgICAgICAgICAgIGxldCByZWNlaXZlckZpbmlzaGVkTWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogJ2hhbmRzaGFrZScsXG4gICAgICAgICAgICAgIHRvOiBtZXNzYWdlLmZyb20sXG4gICAgICAgICAgICAgIGZyb206IG1lc3NhZ2UudG8sXG4gICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICBoYW5kc2hha2VQaGFzZTogJ3JlY2VpdmVyRmluaXNoZWRNZXNzYWdlJ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaXYgPSBfdGhpcy5jcnlwdG8uZ2VuZXJhdGVJVigpO1xuICAgICAgICAgICAgdmFsdWUuaXYgPSBfdGhpcy5jcnlwdG8uZW5jb2RlKGl2KTtcblxuICAgICAgICAgICAgZmlsdGVyZWRNZXNzYWdlID0gX3RoaXMuX2ZpbHRlck1lc3NhZ2VUb0hhc2gocmVjZWl2ZXJGaW5pc2hlZE1lc3NhZ2UsICdvayEnICsgaXYsIGNoYXRLZXlzLmh5cGVydHlGcm9tLm1lc3NhZ2VJbmZvKTtcblxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNyeXB0by5oYXNoSE1BQyhjaGF0S2V5cy5rZXlzLmh5cGVydHlGcm9tSGFzaEtleSwgcmVjZWl2ZXJGaW5pc2hlZE1lc3NhZ2UpO1xuICAgICAgICAgIH0pLnRoZW4oaGFzaCA9PiB7XG5cbiAgICAgICAgICAgIHZhbHVlLmhhc2ggPSBfdGhpcy5jcnlwdG8uZW5jb2RlKGhhc2gpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNyeXB0by5lbmNyeXB0QUVTKGNoYXRLZXlzLmtleXMuaHlwZXJ0eUZyb21TZXNzaW9uS2V5LCAnb2shJywgaXYpO1xuXG4gICAgICAgICAgfSkudGhlbihlbmNyeXB0ZWRWYWx1ZSA9PiB7XG4gICAgICAgICAgICB2YWx1ZS52YWx1ZSA9IF90aGlzLmNyeXB0by5lbmNvZGUoZW5jcnlwdGVkVmFsdWUpO1xuICAgICAgICAgICAgbGV0IHJlY2VpdmVyRmluaXNoZWRNZXNzYWdlID0ge1xuICAgICAgICAgICAgICB0eXBlOiAnaGFuZHNoYWtlJyxcbiAgICAgICAgICAgICAgdG86IG1lc3NhZ2UuZnJvbSxcbiAgICAgICAgICAgICAgZnJvbTogbWVzc2FnZS50byxcbiAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgIGhhbmRzaGFrZVBoYXNlOiAncmVjZWl2ZXJGaW5pc2hlZE1lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBidG9hKEpTT04uc3RyaW5naWZ5KHZhbHVlKSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY2hhdEtleXMuaGFuZHNoYWtlSGlzdG9yeS5yZWNlaXZlckZpbmlzaGVkTWVzc2FnZSA9IF90aGlzLl9maWx0ZXJNZXNzYWdlVG9IYXNoKHJlY2VpdmVyRmluaXNoZWRNZXNzYWdlLCAnb2shJyArIGl2LCBjaGF0S2V5cy5oeXBlcnR5RnJvbS5tZXNzYWdlSW5mbyk7XG4gICAgICAgICAgICBjaGF0S2V5cy5hdXRoZW50aWNhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc29sdmUoe21lc3NhZ2U6IHJlY2VpdmVyRmluaXNoZWRNZXNzYWdlLCBjaGF0S2V5czogY2hhdEtleXN9KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmVjZWl2ZXJGaW5pc2hlZE1lc3NhZ2UnOlxuXG4gICAgICAgICAgY29uc29sZS5sb2coJ3JlY2VpdmVyRmluaXNoZWRNZXNzYWdlJyk7XG4gICAgICAgICAgY2hhdEtleXMuYXV0aGVudGljYXRlZCA9IHRydWU7XG5cbiAgICAgICAgICB2YWx1ZSA9IEpTT04ucGFyc2UoYXRvYihtZXNzYWdlLmJvZHkudmFsdWUpKTtcblxuICAgICAgICAgIGl2ID0gX3RoaXMuY3J5cHRvLmRlY29kZSh2YWx1ZS5pdik7XG4gICAgICAgICAgbGV0IGRhdGEgPSBfdGhpcy5jcnlwdG8uZGVjb2RlKHZhbHVlLnZhbHVlKTtcbiAgICAgICAgICBoYXNoID0gX3RoaXMuY3J5cHRvLmRlY29kZSh2YWx1ZS5oYXNoKTtcblxuICAgICAgICAgIF90aGlzLmNyeXB0by5kZWNyeXB0QUVTKGNoYXRLZXlzLmtleXMuaHlwZXJ0eVRvU2Vzc2lvbktleSwgZGF0YSwgaXYpLnRoZW4oZGVjcnlwdGVkRGF0YSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZGVjcnlwdGVkRGF0YScsIGRlY3J5cHRlZERhdGEpO1xuICAgICAgICAgICAgY2hhdEtleXMuaGFuZHNoYWtlSGlzdG9yeS5yZWNlaXZlckZpbmlzaGVkTWVzc2FnZSA9IF90aGlzLl9maWx0ZXJNZXNzYWdlVG9IYXNoKG1lc3NhZ2UsIGRlY3J5cHRlZERhdGEgKyBpdik7XG5cbiAgICAgICAgICAgIGxldCBmaWx0ZXJlZE1lc3NhZ2UgPSBfdGhpcy5fZmlsdGVyTWVzc2FnZVRvSGFzaChtZXNzYWdlLCBkYXRhICsgaXYpO1xuICAgICAgICAgICAgX3RoaXMuY3J5cHRvLnZlcmlmeUhNQUMoY2hhdEtleXMua2V5cy5oeXBlcnR5VG9IYXNoS2V5LCBmaWx0ZXJlZE1lc3NhZ2UsIGhhc2gpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2hhc2ggcmVzdWx0JywgcmVzdWx0KTtcblxuICAgICAgICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSB3YXMgYW4gaW5pdGlhbCBtZXNzYWdlIHRoYXQgd2FzIGJsb2NrZWQgYW5kIHNlbmQgaXRcbiAgICAgICAgICAgICAgaWYgKGNoYXRLZXlzLmluaXRpYWxNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluaXRpYWxNZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ2NyZWF0ZScsXG4gICAgICAgICAgICAgICAgICB0bzogbWVzc2FnZS5mcm9tLFxuICAgICAgICAgICAgICAgICAgZnJvbTogbWVzc2FnZS50byxcbiAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNoYXRLZXlzLmluaXRpYWxNZXNzYWdlLmJvZHkudmFsdWVcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7bWVzc2FnZTogaW5pdGlhbE1lc3NhZ2UsIGNoYXRLZXlzOiBjaGF0S2V5c30pO1xuXG4gICAgICAgICAgICAgICAgLy9zZW5kcyB0aGUgc2Vzc2lvbktleSB0byB0aGUgc3Vic2NyaWJlciBoeXBlcnR5XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3NlbmRSZXBvcnRlclNlc3Npb25LZXkobWVzc2FnZSwgY2hhdEtleXMpLnRoZW4odmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyZXBvcnRlclNlc3Npb25LZXknOlxuXG4gICAgICAgICAgY29uc29sZS5sb2coJ3JlcG9ydGVyU2Vzc2lvbktleScpO1xuXG4gICAgICAgICAgbGV0IHZhbHVlSVZhbmRIYXNoID0gSlNPTi5wYXJzZShhdG9iKG1lc3NhZ2UuYm9keS52YWx1ZSkpO1xuICAgICAgICAgIGhhc2ggPSBfdGhpcy5jcnlwdG8uZGVjb2RlKHZhbHVlSVZhbmRIYXNoLmhhc2gpO1xuICAgICAgICAgIGl2ID0gX3RoaXMuY3J5cHRvLmRlY29kZSh2YWx1ZUlWYW5kSGFzaC5pdik7XG4gICAgICAgICAgbGV0IGVuY3J5cHRlZFZhbHVlID0gX3RoaXMuY3J5cHRvLmRlY29kZSh2YWx1ZUlWYW5kSGFzaC52YWx1ZSk7XG4gICAgICAgICAgbGV0IHBhcnNlZFZhbHVlO1xuICAgICAgICAgIGxldCBzZXNzaW9uS2V5O1xuICAgICAgICAgIGxldCBkYXRhT2JqZWN0VVJMO1xuICAgICAgICAgIGxldCByZWNlaXZlckFja25vd2xlZGdlTXNnO1xuXG4gICAgICAgICAgY29uc29sZS5sb2coJ1tyZXBvcnRlclNlc3Npb25LZXldIC0gZGVjcnlwdEFFUzogJywgY2hhdEtleXMua2V5cy5oeXBlcnR5VG9TZXNzaW9uS2V5LCBlbmNyeXB0ZWRWYWx1ZSwgaXYpO1xuXG4gICAgICAgICAgX3RoaXMuY3J5cHRvLmRlY3J5cHRBRVMoY2hhdEtleXMua2V5cy5oeXBlcnR5VG9TZXNzaW9uS2V5LCBlbmNyeXB0ZWRWYWx1ZSwgaXYpLnRoZW4oZGVjcnlwdGVkVmFsdWUgPT4ge1xuXG4gICAgICAgICAgICBwYXJzZWRWYWx1ZSA9IEpTT04ucGFyc2UoZGVjcnlwdGVkVmFsdWUpO1xuICAgICAgICAgICAgc2Vzc2lvbktleSA9IF90aGlzLmNyeXB0by5kZWNvZGUocGFyc2VkVmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgZGF0YU9iamVjdFVSTCA9IHBhcnNlZFZhbHVlLmRhdGFPYmplY3RVUkw7XG5cbiAgICAgICAgICAgIGxldCBtZXNzYWdlVG9IYXNoID0gX3RoaXMuX2ZpbHRlck1lc3NhZ2VUb0hhc2gobWVzc2FnZSwgZGVjcnlwdGVkVmFsdWUgKyBpdik7XG5cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5jcnlwdG8udmVyaWZ5SE1BQyhjaGF0S2V5cy5rZXlzLmh5cGVydHlUb0hhc2hLZXksIG1lc3NhZ2VUb0hhc2gsIGhhc2gpO1xuXG4gICAgICAgICAgfSkudGhlbihoYXNoUmVzdWx0ID0+IHtcblxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnaGFzaCBzdWNjZXNzZnVsbHkgdmFsaWRhdGVkICcsIGhhc2hSZXN1bHQpO1xuXG4gICAgICAgICAgICBfdGhpcy5kYXRhT2JqZWN0U2Vzc2lvbktleXNbZGF0YU9iamVjdFVSTF0gPSAge3Nlc3Npb25LZXk6IHNlc3Npb25LZXksIGlzVG9FbmNyeXB0OiB0cnVlfTtcblxuICAgICAgICAgICAgaXYgPSBfdGhpcy5jcnlwdG8uZ2VuZXJhdGVJVigpO1xuICAgICAgICAgICAgdmFsdWUuaXYgPSBfdGhpcy5jcnlwdG8uZW5jb2RlKGl2KTtcblxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNyeXB0by5lbmNyeXB0QUVTKGNoYXRLZXlzLmtleXMuaHlwZXJ0eUZyb21TZXNzaW9uS2V5LCAnb2shIScsIGl2KTtcbiAgICAgICAgICB9KS50aGVuKGVuY3J5cHRlZFZhbHVlID0+IHtcblxuICAgICAgICAgICAgcmVjZWl2ZXJBY2tub3dsZWRnZU1zZyA9IHtcbiAgICAgICAgICAgICAgdHlwZTogJ2hhbmRzaGFrZScsXG4gICAgICAgICAgICAgIHRvOiBtZXNzYWdlLmZyb20sXG4gICAgICAgICAgICAgIGZyb206IG1lc3NhZ2UudG8sXG4gICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICBoYW5kc2hha2VQaGFzZTogJ3JlY2VpdmVyQWNrbm93bGVkZ2UnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhbHVlLnZhbHVlID0gX3RoaXMuY3J5cHRvLmVuY29kZShlbmNyeXB0ZWRWYWx1ZSk7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZVRvSGFzaCA9IF90aGlzLl9maWx0ZXJNZXNzYWdlVG9IYXNoKHJlY2VpdmVyQWNrbm93bGVkZ2VNc2csICdvayEhJyArIGl2LCBjaGF0S2V5cy5oeXBlcnR5RnJvbS5tZXNzYWdlSW5mbyk7XG5cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5jcnlwdG8uaGFzaEhNQUMoY2hhdEtleXMua2V5cy5oeXBlcnR5RnJvbUhhc2hLZXksIG1lc3NhZ2VUb0hhc2gpO1xuICAgICAgICAgIH0pLnRoZW4oaGFzaGVkTWVzc2FnZSA9PiB7XG4gICAgICAgICAgICBsZXQgZmluYWxWYWx1ZSA9IGJ0b2EoSlNPTi5zdHJpbmdpZnkoe3ZhbHVlOiB2YWx1ZS52YWx1ZSwgaGFzaDogX3RoaXMuY3J5cHRvLmVuY29kZShoYXNoZWRNZXNzYWdlKSwgaXY6IHZhbHVlLml2fSkpO1xuXG4gICAgICAgICAgICByZWNlaXZlckFja25vd2xlZGdlTXNnLmJvZHkudmFsdWUgPSBmaW5hbFZhbHVlO1xuICAgICAgICAgICAgcmVzb2x2ZSh7bWVzc2FnZTogcmVjZWl2ZXJBY2tub3dsZWRnZU1zZywgY2hhdEtleXM6IGNoYXRLZXlzfSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JlY2VpdmVyQWNrbm93bGVkZ2UnOlxuXG4gICAgICAgICAgY29uc29sZS5sb2coJ3JlY2VpdmVyQWNrbm93bGVkZ2UnKTtcblxuICAgICAgICAgIGxldCByZWNlaXZlZHZhbHVlSVZhbmRIYXNoID0gSlNPTi5wYXJzZShhdG9iKG1lc3NhZ2UuYm9keS52YWx1ZSkpO1xuICAgICAgICAgIGxldCByZWNlaXZlZEhhc2ggPSBfdGhpcy5jcnlwdG8uZGVjb2RlKHJlY2VpdmVkdmFsdWVJVmFuZEhhc2guaGFzaCk7XG4gICAgICAgICAgaXYgPSBfdGhpcy5jcnlwdG8uZGVjb2RlKHJlY2VpdmVkdmFsdWVJVmFuZEhhc2guaXYpO1xuICAgICAgICAgIGxldCByZWNlaXZlZEVuY3J5cHRlZFZhbHVlID0gX3RoaXMuY3J5cHRvLmRlY29kZShyZWNlaXZlZHZhbHVlSVZhbmRIYXNoLnZhbHVlKTtcblxuICAgICAgICAgIF90aGlzLmNyeXB0by5kZWNyeXB0QUVTKGNoYXRLZXlzLmtleXMuaHlwZXJ0eVRvU2Vzc2lvbktleSwgcmVjZWl2ZWRFbmNyeXB0ZWRWYWx1ZSwgaXYpLnRoZW4oZGVjcnlwdGVkVmFsdWUgPT4ge1xuXG4gICAgICAgICAgICBsZXQgZmlsdGVyZWRNZXNzYWdlID0gX3RoaXMuX2ZpbHRlck1lc3NhZ2VUb0hhc2gobWVzc2FnZSwgZGVjcnlwdGVkVmFsdWUgKyBpdik7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuY3J5cHRvLnZlcmlmeUhNQUMoY2hhdEtleXMua2V5cy5oeXBlcnR5VG9IYXNoS2V5LCBmaWx0ZXJlZE1lc3NhZ2UsIHJlY2VpdmVkSGFzaCk7XG4gICAgICAgICAgfSkudGhlbihoYXNoUmVzdWx0ID0+IHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2hhc2hSZXN1bHQgJywgaGFzaFJlc3VsdCk7XG5cbiAgICAgICAgICAgIGxldCBjYWxsYmFjayA9IGNoYXRLZXlzLmNhbGxiYWNrO1xuXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soJ2hhbmRTaGFrZUVuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZSgnaGFuZFNoYWtlRW5kJyk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVqZWN0KG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX3NlbmRSZXBvcnRlclNlc3Npb25LZXkobWVzc2FnZSwgY2hhdEtleXMpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuICAgIGxldCBzZXNzaW9uS2V5QnVuZGxlID0gX3RoaXMuZGF0YU9iamVjdFNlc3Npb25LZXlzW2NoYXRLZXlzLmRhdGFPYmplY3RVUkxdO1xuICAgIGxldCByZXBvcnRlclNlc3Npb25LZXlNc2c7XG4gICAgbGV0IHZhbHVlVG9FbmNyeXB0O1xuICAgIGxldCBzZXNzaW9uS2V5O1xuICAgIGxldCBpdjtcbiAgICBsZXQgdmFsdWUgPSB7fTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblxuICAgICAgLy9pZiB0aGVyZSBpcyBub3QgeWV0IGEgc2Vzc2lvbiBLZXksIGdlbmVyYXRlcyBhIG5ldyBvbmVcbiAgICAgIGlmICghc2Vzc2lvbktleUJ1bmRsZSkge1xuICAgICAgICBzZXNzaW9uS2V5ID0gX3RoaXMuY3J5cHRvLmdlbmVyYXRlUmFuZG9tKCk7XG4gICAgICAgIF90aGlzLmRhdGFPYmplY3RTZXNzaW9uS2V5c1tjaGF0S2V5cy5kYXRhT2JqZWN0VVJMXSA9IHtzZXNzaW9uS2V5OiBzZXNzaW9uS2V5LCBpc1RvRW5jcnlwdDogdHJ1ZX07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXNzaW9uS2V5ID0gc2Vzc2lvbktleUJ1bmRsZS5zZXNzaW9uS2V5O1xuICAgICAgfVxuXG4gICAgICB2YWx1ZVRvRW5jcnlwdCA9IEpTT04uc3RyaW5naWZ5KHt2YWx1ZTogX3RoaXMuY3J5cHRvLmVuY29kZShzZXNzaW9uS2V5KSwgZGF0YU9iamVjdFVSTDogY2hhdEtleXMuZGF0YU9iamVjdFVSTH0pO1xuXG4gICAgICBpdiA9IF90aGlzLmNyeXB0by5nZW5lcmF0ZUlWKCk7XG4gICAgICB2YWx1ZS5pdiA9IF90aGlzLmNyeXB0by5lbmNvZGUoaXYpO1xuICAgICAgX3RoaXMuY3J5cHRvLmVuY3J5cHRBRVMoY2hhdEtleXMua2V5cy5oeXBlcnR5RnJvbVNlc3Npb25LZXksIHZhbHVlVG9FbmNyeXB0LCBpdikudGhlbihlbmNyeXB0ZWRWYWx1ZSA9PiB7XG5cbiAgICAgICAgcmVwb3J0ZXJTZXNzaW9uS2V5TXNnID0ge1xuICAgICAgICAgIHR5cGU6ICdoYW5kc2hha2UnLFxuICAgICAgICAgIHRvOiBtZXNzYWdlLmZyb20sXG4gICAgICAgICAgZnJvbTogbWVzc2FnZS50byxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBoYW5kc2hha2VQaGFzZTogJ3JlcG9ydGVyU2Vzc2lvbktleScsXG4gICAgICAgICAgICB2YWx1ZTogX3RoaXMuY3J5cHRvLmVuY29kZShlbmNyeXB0ZWRWYWx1ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IGZpbHRlcmVkTWVzc2FnZSA9IF90aGlzLl9maWx0ZXJNZXNzYWdlVG9IYXNoKHJlcG9ydGVyU2Vzc2lvbktleU1zZywgdmFsdWVUb0VuY3J5cHQgKyBpdiwgY2hhdEtleXMuaHlwZXJ0eUZyb20ubWVzc2FnZUluZm8pO1xuXG4gICAgICAgIHJldHVybiBfdGhpcy5jcnlwdG8uaGFzaEhNQUMoY2hhdEtleXMua2V5cy5oeXBlcnR5RnJvbUhhc2hLZXksIGZpbHRlcmVkTWVzc2FnZSk7XG4gICAgICB9KS50aGVuKGhhc2hlZE1lc3NhZ2UgPT4ge1xuXG4gICAgICAgIGxldCB2YWx1ZVdpdGhIYXNoID0gYnRvYShKU09OLnN0cmluZ2lmeSh7dmFsdWU6IHJlcG9ydGVyU2Vzc2lvbktleU1zZy5ib2R5LnZhbHVlLCBoYXNoOiBfdGhpcy5jcnlwdG8uZW5jb2RlKGhhc2hlZE1lc3NhZ2UpLCBpdjogdmFsdWUuaXZ9KSk7XG5cbiAgICAgICAgcmVwb3J0ZXJTZXNzaW9uS2V5TXNnLmJvZHkudmFsdWUgPSB2YWx1ZVdpdGhIYXNoO1xuICAgICAgICByZXNvbHZlKHttZXNzYWdlOiByZXBvcnRlclNlc3Npb25LZXlNc2csIGNoYXRLZXlzOiBjaGF0S2V5c30pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgKiByZXR1cm5zIHRoZSByZXBvcnRlciBhc3NvY2lhdGVkIHRvIHRoZSBkYXRhT2JqZWN0IFVSTFxuICAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgZGF0YU9iamVjdFVSTCAgICAgICAgIGRhdGFPYmplY3QgdXJsXG4gICogQHJldHVybiAgIHtTdHJpbmd9ICByZXBvcnRlciAgICAgICAgICAgICAgZGF0YU9iamVjdCB1cmwgcmVwb3J0ZXJcbiAgKi9cbiAgX2dldEh5cGVydHlGcm9tRGF0YU9iamVjdChkYXRhT2JqZWN0VVJMKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblxuICAgICAgLy9UT0RPIHJlbW92ZSB0aGlzIGxvZ2ljIGFuZCBtb3ZlIGl0IHRvIGEgdXRpbCBmdW5jdGlvblxuXG4gICAgICBsZXQgc3BsaXRlZFVSTCA9IGRhdGFPYmplY3RVUkwuc3BsaXQoJy8nKTtcbiAgICAgIGxldCBmaW5hbFVSTCA9IHNwbGl0ZWRVUkxbMF0gKyAnLy8nICsgc3BsaXRlZFVSTFsyXSArICcvJyArIHNwbGl0ZWRVUkxbM107XG4gICAgICBpZiAoc3BsaXRlZFVSTC5sZW5ndGggPiA2KSB7XG4gICAgICAgIGZpbmFsVVJMID0gc3BsaXRlZFVSTFswXSArICcvLycgKyBzcGxpdGVkVVJMWzJdICsgJy8nICsgc3BsaXRlZFVSTFszXSArICcvJyArIHNwbGl0ZWRVUkxbNF07XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGlmIGlzIHRoZSBjcmVhdG9yIG9mIHRoZSBoeXBlcnR5XG4gICAgICBsZXQgcmVwb3J0ZXJVUkwgPSBfdGhpcy5yZWdpc3RyeS5nZXRSZXBvcnRlclVSTFN5bmNob25vdXMoZmluYWxVUkwpO1xuXG4gICAgICBpZiAocmVwb3J0ZXJVUkwpIHtcbiAgICAgICAgcmVzb2x2ZShyZXBvcnRlclVSTCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBpcyBhbHJlYWR5IGFuIGFzc29jaWF0aW9uIGZyb20gYW4gaHlwZXJ0eVVSTCB0byB0aGUgZGF0YU9iamVjdFxuICAgICAgICBsZXQgc3RvcmVkUmVwb3J0ZXJVUkwgPSBfdGhpcy5kYXRhT2JqZWN0c0lkZW50aXR5W2ZpbmFsVVJMXTtcblxuICAgICAgICBpZiAoc3RvcmVkUmVwb3J0ZXJVUkwpIHtcbiAgICAgICAgICByZXNvbHZlKHN0b3JlZFJlcG9ydGVyVVJMKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBpcyBhbnkgaHlwZXJ0eSB0aGF0IHN1YnNjcmliZWQgdGhlIGRhdGFPYmplY3RVUkxcbiAgICAgICAgICBsZXQgc3Vic2NyaWJlckh5cGVydHkgPSBfdGhpcy5yZWdpc3RyeS5nZXREYXRhT2JqZWN0U3Vic2NyaWJlckh5cGVydHkoZGF0YU9iamVjdFVSTCk7XG5cbiAgICAgICAgICBpZiAoc3Vic2NyaWJlckh5cGVydHkpIHtcbiAgICAgICAgICAgIHJlc29sdmUoc3Vic2NyaWJlckh5cGVydHkpO1xuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIHNlYXJjaCBpbiBkb21haW4gcmVnaXN0cnkgZm9yIHRoZSBoeXBlcnR5IGFzc29jaWF0ZWQgdG8gdGhlIGRhdGFPYmplY3RcbiAgICAgICAgICAgIC8vIHNlYXJjaCBpbiBjYXNlIGlzIGEgc3Vic2NyaWJlciB3aG8gd2FudHMgdG8ga25vdyB0aGUgcmVwb3J0ZXJcbiAgICAgICAgICAgIF90aGlzLnJlZ2lzdHJ5LmRpc2NvdmVyRGF0YU9iamVjdFBlclVSTChmaW5hbFVSTCwgc3BsaXRlZFVSTFsyXSkudGhlbihkYXRhT2JqZWN0ID0+IHtcbiAgICAgICAgICAgICAgX3RoaXMuZGF0YU9iamVjdHNJZGVudGl0eVtmaW5hbFVSTF0gPSBkYXRhT2JqZWN0LnJlcG9ydGVyO1xuICAgICAgICAgICAgICByZXNvbHZlKGRhdGFPYmplY3QucmVwb3J0ZXIpO1xuICAgICAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAqIGZpbHRlciB0aGUgbWVzc2FnZXMgdG8gaGFzaCwgYnkgcmVtb3Zpbmcgc29tZSBmaWVsZHMgbm90IGdlbmVyYXRlZCBieSB0aGUgcnVudGltZSBjb3JlXG4gICogQHBhcmFtIHtNZXNzYWdlfSAgbWVzc2FnZSAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VcbiAgKiBAcGFyYW0ge1N0cmluZ30gIGRlY3J5cHRlZFZhbHVlIChPcHRpb25hbCkgICAgdmFsdWUgZnJvbSBib2R5LnZhbHVlIGluIGNhc2UgaXQgb3JpZ2luYWxseSBjb21lcyBlbmNyeXB0ZWRcbiAgKiBAcGFyYW0ge0pTT059ICBpZGVudGl0eShPcHRpb25hbCkgICAgYWRkIHRoZSBoeXBlcnR5IGlkZW50aXR5IGFzc29jaWF0ZWQgaW4gY2FzZSBpcyBub3QgYWRkZWQgdG8gdGhlIGluaXRpYWwgbWVzc2FnZVxuICAqIEByZXR1cm4ge01lc3NhZ2V9ICBuZXcgbWVzc2FnZSBmaWx0ZXJlZFxuICAqL1xuICBfZmlsdGVyTWVzc2FnZVRvSGFzaChtZXNzYWdlLCBkZWNyeXB0ZWRWYWx1ZSwgaWRlbnRpdHkpIHtcblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBtZXNzYWdlLnR5cGUsXG4gICAgICBmcm9tOiBtZXNzYWdlLmZyb20sXG4gICAgICB0bzogICBtZXNzYWdlLnRvLFxuICAgICAgYm9keToge1xuICAgICAgICBpZGVudGl0eTogaWRlbnRpdHkgfHwgbWVzc2FnZS5ib2R5LmlkZW50aXR5LFxuICAgICAgICB2YWx1ZTogZGVjcnlwdGVkVmFsdWUgfHwgbWVzc2FnZS5ib2R5LnZhbHVlLFxuICAgICAgICBoYW5kc2hha2VQaGFzZTogbWVzc2FnZS5ib2R5LmhhbmRzaGFrZVBoYXNlXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAqIGdlbmVyYXRlcyB0aGUgaW5pdGlhbCBzdHJ1Y3R1cmUgZm9yIHRoZSBrZXlzIGJldHdlZW4gdHdvIHVzZXJzXG4gICogQHBhcmFtIHtKU09OfSAgICBtZXNzYWdlICAgICAgICAgICAgICBpbml0aWFsIG1lc3NhZ2UgdGhhdCB0cmlnZ2VycyB0aGUgbXV0dWFsIGF1dGhlbnRpY2F0aW9uXG4gICogQHBhcmFtIHtTdHJpbmd9ICB1c2VyVVJMICAgICAgICAgICAgICB1c2VyVVJMXG4gICogQHBhcmFtIHtib29sZWFufSByZWNlaXZlcihPcHRpb25hbCkgIGluZGljYXRlcyBpZiBpcyB0aGUgc2VuZGVyIG9yIHRoZSByZWNlaXZlciB0aGF0IGNyZWF0ZXMgYSBuZXcgY2hhdCBjcnlwdG9cbiAgKiBAcmV0dXJuIHtKU09OfSBuZXdDaGF0Q3J5cHRvICBuZXcgSlNPTiBzdHJ1Y3R1cmUgZm9yIHRoZSBjaGF0IGNyeXB0b1xuICAqL1xuICBfbmV3Q2hhdENyeXB0byhtZXNzYWdlLCB1c2VyVVJMLCByZWNlaXZlcikge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG5cbiAgICAvL2NoZWNrIHdoZXRoZXIgaXMgdGhlIHNlbmRlciBvciB0aGUgcmVjZWl2ZXIgdG8gY3JlYXRlIGEgbmV3IGNoYXRDcnlwdG9cbiAgICAvL3RvIG1hbnRhaW4gY29uc2lzdGVuY3kgb24gdGhlIGtleXMgaWYgdGhlIHJlY2VpdmVyIGNyZWF0ZSBhIG5ldyBjaGF0Q3J5cHRvLFxuICAgIC8vdGhlbiBpbnZlcnQgdGhlIGZpZWxkc1xuICAgIGxldCBmcm9tID0gKHJlY2VpdmVyKSA/IG1lc3NhZ2UudG8gOiBtZXNzYWdlLmZyb207XG4gICAgbGV0IHRvID0gKHJlY2VpdmVyKSA/IG1lc3NhZ2UuZnJvbSA6IG1lc3NhZ2UudG87XG5cbiAgICBsZXQgdXNlckluZm8gPSBfdGhpcy5nZXRJZGVudGl0eSh1c2VyVVJMKTtcblxuICAgIGxldCBuZXdDaGF0Q3J5cHRvID1cbiAgICB7XG4gICAgICBoeXBlcnR5RnJvbTpcbiAgICAgIHtcbiAgICAgICAgaHlwZXJ0eTogZnJvbSxcbiAgICAgICAgdXNlcklEOiB1c2VySW5mby5tZXNzYWdlSW5mby51c2VyUHJvZmlsZS51c2VybmFtZSxcbiAgICAgICAgcHJpdmF0ZUtleTogdXNlckluZm8ua2V5UGFpci5wcml2YXRlLFxuICAgICAgICBwdWJsaWNLZXk6IHVzZXJJbmZvLmtleVBhaXIucHVibGljLFxuICAgICAgICBhc3NlcnRpb246IHVzZXJJbmZvLmFzc2VydGlvbixcbiAgICAgICAgbWVzc2FnZUluZm86IHVzZXJJbmZvLm1lc3NhZ2VJbmZvXG4gICAgICB9LFxuICAgICAgaHlwZXJ0eVRvOlxuICAgICAge1xuICAgICAgICBoeXBlcnR5OiB0byxcbiAgICAgICAgdXNlcklEOiB1bmRlZmluZWQsXG4gICAgICAgIHB1YmxpY0tleTogdW5kZWZpbmVkLFxuICAgICAgICBhc3NlcnRpb246IHVuZGVmaW5lZFxuICAgICAgfSxcbiAgICAgIGtleXM6XG4gICAgICB7XG4gICAgICAgIGh5cGVydHlUb1Nlc3Npb25LZXk6IHVuZGVmaW5lZCxcbiAgICAgICAgaHlwZXJ0eUZyb21TZXNzaW9uS2V5OiB1bmRlZmluZWQsXG4gICAgICAgIGh5cGVydHlUb0hhc2hLZXk6IHVuZGVmaW5lZCxcbiAgICAgICAgaHlwZXJ0eUZyb21IYXNoS2V5OiB1bmRlZmluZWQsXG4gICAgICAgIHRvUmFuZG9tOiB1bmRlZmluZWQsXG4gICAgICAgIGZyb21SYW5kb206IHVuZGVmaW5lZCxcbiAgICAgICAgcHJlbWFzdGVyS2V5OiB1bmRlZmluZWQsXG4gICAgICAgIG1hc3RlcktleTogdW5kZWZpbmVkXG4gICAgICB9LFxuICAgICAgaGFuZHNoYWtlSGlzdG9yeToge1xuICAgICAgICBzZW5kZXJIZWxsbzogdW5kZWZpbmVkLFxuICAgICAgICByZWNlaXZlckhlbGxvOiB1bmRlZmluZWQsXG4gICAgICAgIHNlbmRlckNlcnRpZmljYXRlOiB1bmRlZmluZWQsXG4gICAgICAgIHJlY2VpdmVyRmluaXNoZWRNZXNzYWdlOiB1bmRlZmluZWRcbiAgICAgIH0sXG4gICAgICBpbml0aWFsTWVzc2FnZTogKG1lc3NhZ2UuYm9keS5pZ25vcmUpID8gdW5kZWZpbmVkIDogbWVzc2FnZSxcbiAgICAgIGNhbGxiYWNrOiBtZXNzYWdlLmNhbGxiYWNrLFxuICAgICAgYXV0aGVudGljYXRlZDogZmFsc2UsXG4gICAgICBkYXRhT2JqZWN0VVJMOiBtZXNzYWdlLmRhdGFPYmplY3RVUkxcbiAgICB9O1xuXG4gICAgcmV0dXJuIG5ld0NoYXRDcnlwdG87XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSWRlbnRpdHlNb2R1bGU7XG4iLCJjbGFzcyBBY3Rpb25zU2VydmljZSB7XG5cbiAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIH1cblxuICBlbmZvcmNlUG9saWNpZXMobWVzc2FnZSwgaXNJbmNvbWluZ01lc3NhZ2UpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cbiAgICAgIGxldCBwb2xpY2llcyA9IF90aGlzLmNvbnRleHQuZ2V0UG9saWNpZXMobWVzc2FnZSwgaXNJbmNvbWluZ01lc3NhZ2UpO1xuXG4gICAgICBpZiAocG9saWNpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAocG9saWNpZXMuc2VydmljZVByb3ZpZGVyUG9saWN5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwb2xpY2llcy5zZXJ2aWNlUHJvdmlkZXJQb2xpY3kuZW5mb3JjZUFjdGlvbnMoX3RoaXMuY29udGV4dCwgbWVzc2FnZSkudGhlbihtZXNzYWdlcyA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKG1lc3NhZ2VzKTtcbiAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHBvbGljaWVzLnVzZXJQb2xpY3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcG9saWNpZXMudXNlclBvbGljeS5lbmZvcmNlQWN0aW9ucyhfdGhpcy5jb250ZXh0LCBtZXNzYWdlKS50aGVuKG1lc3NhZ2VzID0+IHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShtZXNzYWdlcyk7XG4gICAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKFttZXNzYWdlXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKFttZXNzYWdlXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmb3J3YXJkVG9JRChtZXNzYWdlLCBlbWFpbCkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKCFfdGhpcy5jb250ZXh0LnJ1bnRpbWVSZWdpc3RyeSkgdGhyb3cgbmV3IEVycm9yKCdmb3J3YXJkIG1lc3NhZ2UgdG8gZ2l2ZW4gSUQgaXMgdW5zdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudCcpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmIChfdGhpcy5jb250ZXh0LnJ1bnRpbWVSZWdpc3RyeS5oeXBlcnRpZXNMaXN0WzBdLmh5cGVydHlVUkwgPT09IG1lc3NhZ2UudG8pIHtcbiAgICAgICAgbGV0IHNwbGl0VG8gPSAobWVzc2FnZS50bykuc3BsaXQoJzovLycpO1xuICAgICAgICBpZiAoc3BsaXRUb1swXSAhPT0gJ3J1bnRpbWUnKSB7XG4gICAgICAgICAgX3RoaXMuY29udGV4dC5ydW50aW1lUmVnaXN0cnkuZGlzY292ZXJIeXBlcnR5UGVyVXNlcihlbWFpbCkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgbWVzc2FnZS50byA9IHJlc3VsdC5oeXBlcnR5VVJMO1xuICAgICAgICAgICAgbWVzc2FnZS5ib2R5LnZpYSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJlc29sdmUobWVzc2FnZSk7XG4gICAgICAgICAgICBfdGhpcy5jb250ZXh0LnJ1bnRpbWVSZWdpc3RyeS5fbWVzc2FnZUJ1cy5wb3N0TWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZShtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZvcndhcmRUb0h5cGVydHkobWVzc2FnZSwgaHlwZXJ0eVVSTCkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKCFfdGhpcy5jb250ZXh0LnJ1bnRpbWVSZWdpc3RyeSkgdGhyb3cgbmV3IEVycm9yKCdmb3J3YXJkIG1lc3NhZ2UgdG8gZ2l2ZW4gSUQgaXMgdW5zdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudCcpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBpZiAoX3RoaXMuY29udGV4dC5ydW50aW1lUmVnaXN0cnkuaHlwZXJ0aWVzTGlzdFswXS5oeXBlcnR5VVJMID09PSBtZXNzYWdlLnRvKSB7XG4gICAgICAgIGxldCBzcGxpdFRvID0gKG1lc3NhZ2UudG8pLnNwbGl0KCc6Ly8nKTtcbiAgICAgICAgaWYgKHNwbGl0VG9bMF0gIT09ICdydW50aW1lJykge1xuICAgICAgICAgIG1lc3NhZ2UudG8gPSBoeXBlcnR5VVJMO1xuICAgICAgICAgIG1lc3NhZ2UuYm9keS52aWEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgcmVzb2x2ZShtZXNzYWdlKTtcbiAgICAgICAgICBfdGhpcy5jb250ZXh0LnJ1bnRpbWVSZWdpc3RyeS5fbWVzc2FnZUJ1cy5wb3N0TWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc2VuZEF1dG9tYXRpY01lc3NhZ2UobWVzc2FnZSwgdGV4dCkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBsZXQgYXV0b21hdGljTWVzc2FnZSA9IHtcbiAgICAgICAgZnJvbTogbWVzc2FnZS50byxcbiAgICAgICAgdG86IG1lc3NhZ2UuZnJvbSxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgIHZhbHVlOiB0ZXh0XG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IG1lc3NhZ2UudHlwZVxuICAgICAgfTtcbiAgICAgIHJlc29sdmUobWVzc2FnZSk7XG4gICAgICBfdGhpcy5jb250ZXh0LnJ1bnRpbWVSZWdpc3RyeS5fbWVzc2FnZUJ1cy5wb3N0TWVzc2FnZShhdXRvbWF0aWNNZXNzYWdlKTtcbiAgICB9KTtcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEFjdGlvbnNTZXJ2aWNlO1xuIiwiY2xhc3MgT3BlcmF0b3JzIHtcblxuICBhbmQocGFyYW1zKSB7XG4gICAgcmV0dXJuIHBhcmFtc1swXSAmJiBwYXJhbXNbMV07XG4gIH1cblxuICBiZXR3ZWVuKHBhcmFtcykge1xuICAgIGxldCBzdGFydCA9IHBhcnNlSW50KHBhcmFtc1swXVswXSk7XG4gICAgbGV0IGVuZCA9IHBhcnNlSW50KHBhcmFtc1swXVsxXSk7XG4gICAgbGV0IG5vdyA9IHBhcmFtc1sxXTtcblxuICAgIGlmIChlbmQgPCBzdGFydCkge1xuICAgICAgbm93ID0gKG5vdyA8IHN0YXJ0KSA/IG5vdyArPSAyNDAwIDogbm93O1xuICAgICAgZW5kICs9IDI0MDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIChub3cgPiBzdGFydCAmJiBub3cgPCBlbmQpO1xuICB9XG5cbiAgZXF1YWxzKHBhcmFtcykge1xuICAgIHJldHVybiBTdHJpbmcocGFyYW1zWzBdKSA9PT0gJyonIHx8IFN0cmluZyhwYXJhbXNbMF0pID09PSBTdHJpbmcocGFyYW1zWzFdKTtcbiAgfVxuXG4gIGdyZWF0ZXJUaGFuKHBhcmFtcykge1xuICAgIHJldHVybiBwYXJhbXNbMV0gPiBwYXJhbXNbMF07XG4gIH1cblxuICBpbihwYXJhbXMpIHtcbiAgICByZXR1cm4gcGFyYW1zWzBdLmluZGV4T2YocGFyYW1zWzFdKSA+IC0xO1xuICB9XG5cbiAgbGVzc1RoYW4ocGFyYW1zKSB7XG4gICAgcmV0dXJuIHBhcmFtc1sxXSA8IHBhcmFtc1swXTtcbiAgfVxuXG4gIG5vdChwYXJhbXMpIHtcbiAgICByZXR1cm4gIXBhcmFtc1swXTtcbiAgfVxuXG4gIG9yKHBhcmFtcykge1xuICAgIHJldHVybiBwYXJhbXNbMF0gfHwgcGFyYW1zWzFdO1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgT3BlcmF0b3JzO1xuIiwiaW1wb3J0IE9wZXJhdG9ycyBmcm9tICcuL09wZXJhdG9ycyc7XG5cbi8qKlxuKiBUaGUgUG9saWN5IERlY2lzaW9uIFBvaW50IChQRFApIGRlY2lkZXMgaWYgYSBtZXNzYWdlIGlzIHRvIGJlIGF1dGhvcmlzZWQgYnkgY2hlY2tpbmcgYSBzZXQgb2ZcbiogcG9saWNpZXMuIFRoZSByZXNvdXJjZSB0byBiZSB2ZXJpZmllZCBpcyBzcGVjaWZpZWQgaW4gdGhlIGZpcnN0IHdvcmQgb2YgdGhlICdjb25kaXRpb24nIGZpZWxkIG9mXG4qIGEgUG9saWN5IG9iamVjdC4gVGhlIGltcGxlbWVudGF0aW9uIHRoYXQgdmVyaWZpZXMgaWYgdGhlIG1lc3NhZ2UgaXMgY29tcGxpYW50IHdpdGggYSBwb2xpY3kgaXNcbiogc3BlY2lmaWVkIGluIGEgaGFzaHRhYmxlIHRvIGFsbG93IGR5bmFtaWMgZGVmaW5pdGlvbiBvZiB0aGUgaW1wbGVtZW50YXRpb24sIHByb3ZpZGluZ1xuKiBleHRlbnNpYmlsaXR5IHRvIHRoZSBQb2xpY3kgRW5naW5lIGZ1bmN0aW9uYWxpdGllcy5cbiovXG5jbGFzcyBQRFAge1xuXG4gIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMub3BlcmF0b3JzID0gbmV3IE9wZXJhdG9ycygpO1xuICB9XG5cbiAgZXZhbHVhdGVQb2xpY2llcyhtZXNzYWdlLCBpc0luY29taW5nTWVzc2FnZSkge1xuICAgIGxldCBwb2xpY2llcyA9IHRoaXMuY29udGV4dC5nZXRQb2xpY2llcyhtZXNzYWdlLCBpc0luY29taW5nTWVzc2FnZSk7XG4gICAgbGV0IHJlc3VsdCA9ICdOb3QgQXBwbGljYWJsZSc7XG5cbiAgICBpZiAocG9saWNpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5ldmFsdWF0ZVBvbGljeShtZXNzYWdlLCBwb2xpY2llcy5zZXJ2aWNlUHJvdmlkZXJQb2xpY3ksIGlzSW5jb21pbmdNZXNzYWdlKTtcbiAgICAgIGlmIChyZXN1bHQgfHwgcmVzdWx0ID09PSAnTm90IEFwcGxpY2FibGUnKSB7XG4gICAgICAgIGxldCB1c2VyUmVzdWx0ID0gdGhpcy5ldmFsdWF0ZVBvbGljeShtZXNzYWdlLCBwb2xpY2llcy51c2VyUG9saWN5LCBpc0luY29taW5nTWVzc2FnZSk7XG4gICAgICAgIGlmICh1c2VyUmVzdWx0ICE9PSAnTm90IEFwcGxpY2FibGUnKSB7XG4gICAgICAgICAgcmVzdWx0ID0gdXNlclJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBldmFsdWF0ZVBvbGljeShtZXNzYWdlLCBwb2xpY3ksIGlzSW5jb21pbmcpIHtcbiAgICBsZXQgcmVzdWx0ID0gJ05vdCBBcHBsaWNhYmxlJztcbiAgICBpZiAocG9saWN5KSB7XG4gICAgICByZXN1bHQgPSBwb2xpY3kuZXZhbHVhdGVSdWxlcyh0aGlzLmNvbnRleHQsIG1lc3NhZ2UsIGlzSW5jb21pbmcpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBQRFA7XG4iLCJpbXBvcnQgQWN0aW9uc1NlcnZpY2UgZnJvbSAnLi9BY3Rpb25zU2VydmljZSc7XG5pbXBvcnQgUERQIGZyb20gJy4vUERQJztcbmltcG9ydCBQb2xpY3kgZnJvbSAnLi9Qb2xpY3knO1xuXG5jbGFzcyBQRVAge1xuXG4gIC8qKlxuICAqIENyZWF0ZXMgYSBQb2xpY3kgRW5mb3JjZW1lbnQgUG9pbnQgKFBFUCkgaW5zdGFuY2VcbiAgKiBAcGFyYW0gICAge09iamVjdH0gICAgY29udGV4dFxuICAqL1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIF90aGlzLnBkcCA9IG5ldyBQRFAoY29udGV4dCk7XG4gICAgX3RoaXMuYWN0aW9uc1NlcnZpY2UgPSBuZXcgQWN0aW9uc1NlcnZpY2UoY29udGV4dCk7XG4gICAgX3RoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgY29udGV4dC5wZXAgPSBfdGhpcztcblxuICAgIC8vVE9ETyBzaG91bGQgYmUgYWRkZWQgYSB0cmlnZ2VyIHRvIHZlcmlmeSB3aGVuIHRoZSBsb2FkQ29uZmlndXJhdGlvbnMgaXMgc3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZFxuICAgIGNvbnRleHQubG9hZENvbmZpZ3VyYXRpb25zKCk7XG4gIH1cblxuICAvKipcbiAgKiBBZGRzIGEgcG9saWN5IHRvIHRoZSBQb2xpY3kgRW5mb3JjZW1lbnQgUG9pbnQgKFBFUCkuIFRoZSBwb2xpY3kgY2FuIGJlIGNyZWF0ZWQgYnkgdGhlIHNlcnZpY2VcbiAgKiBwcm92aWRlciBvciBieSB0aGUgdXNlci5cbiAgKiBAcGFyYW0gICAge1N0cmluZ30gICAgc291cmNlXG4gICogQHBhcmFtICAgIHtTdHJpbmd9ICAgIGtleVxuICAqIEBwYXJhbSAgICB7T2JqZWN0fSAgICBwb2xpY3lcbiAgKi9cbiAgYWRkUG9saWN5KHNvdXJjZSwga2V5LCBwb2xpY3ksIGNvbWJpbmluZ0FsZ29yaXRobSkge1xuICAgIGlmICghc291cmNlKSB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZSBpcyBub3QgZGVmaW5lZCcpO1xuICAgIGlmICgha2V5KSB0aHJvdyBuZXcgRXJyb3IoJ2tleSBpcyBub3QgZGVmaW5lZCcpO1xuXG4gICAgaWYgKHBvbGljeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwb2xpY3kgPSBuZXcgUG9saWN5KGtleSwgW10sIFtdLCBjb21iaW5pbmdBbGdvcml0aG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIShwb2xpY3kgaW5zdGFuY2VvZiBQb2xpY3kpKSB7XG4gICAgICAgIHBvbGljeSA9IG5ldyBQb2xpY3kocG9saWN5LmtleSwgcG9saWN5LnJ1bGVzLCBwb2xpY3kuYWN0aW9ucywgcG9saWN5LmNvbWJpbmluZ0FsZ29yaXRobSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoIChzb3VyY2UpIHtcbiAgICAgIGNhc2UgJ1NFUlZJQ0VfUFJPVklERVInOlxuICAgICAgICB0aGlzLmNvbnRleHQuc2F2ZVBvbGljaWVzKHNvdXJjZSwgcG9saWN5LCBrZXkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1VTRVInOlxuICAgICAgICB0aGlzLmNvbnRleHQudXNlclBvbGljaWVzW2tleV0gPSBwb2xpY3k7XG4gICAgICAgIHRoaXMuY29udGV4dC5zYXZlUG9saWNpZXMoc291cmNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBFcnJvcignVW5rbm93biBwb2xpY3kgc291cmNlOiAnICsgc291cmNlKTtcbiAgICB9XG4gIH1cblxuICBhdXRob3Jpc2UobWVzc2FnZSkge1xuICAgIGNvbnNvbGUubG9nKCctLS0gUG9saWN5IEVuZ2luZSAtLS0nKTtcbiAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcbiAgICBpZiAoIW1lc3NhZ2UpIHRocm93IG5ldyBFcnJvcignbWVzc2FnZSBpcyBub3QgZGVmaW5lZCcpO1xuICAgIGlmICghbWVzc2FnZS5mcm9tKSB0aHJvdyBuZXcgRXJyb3IoJ21lc3NhZ2UuZnJvbSBpcyBub3QgZGVmaW5lZCcpO1xuICAgIGlmICghbWVzc2FnZS50bykgdGhyb3cgbmV3IEVycm9yKCdtZXNzYWdlLnRvIGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgaWYgKCFtZXNzYWdlLnR5cGUpIHRocm93IG5ldyBFcnJvcignbWVzc2FnZS50eXBlIGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgbWVzc2FnZS5ib2R5ID0gbWVzc2FnZS5ib2R5IHx8IHt9O1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgbWVzc2FnZS5ib2R5ID0gbWVzc2FnZS5ib2R5IHx8IHt9O1xuICAgICAgbGV0IF90aGlzID0gdGhpcztcbiAgICAgIGxldCByZXN1bHQ7XG4gICAgICBpZiAoX3RoaXMuX2lzVG9WZXJpZnkobWVzc2FnZSkpIHtcbiAgICAgICAgbGV0IGlzSW5jb21pbmcgPSBfdGhpcy5faXNJbmNvbWluZ01lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIF90aGlzLmNvbnRleHQucHJlcGFyZUZvckV2YWx1YXRpb24obWVzc2FnZSwgaXNJbmNvbWluZykudGhlbihtZXNzYWdlID0+IHtcbiAgICAgICAgICByZXN1bHQgPSBfdGhpcy5wZHAuZXZhbHVhdGVQb2xpY2llcyhtZXNzYWdlLCBpc0luY29taW5nKTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSAnTm90IEFwcGxpY2FibGUnKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBfdGhpcy5jb250ZXh0LmRlZmF1bHRCZWhhdmlvdXI7XG4gICAgICAgICAgICBtZXNzYWdlLmJvZHkuYXV0aCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpcy5hY3Rpb25zU2VydmljZS5lbmZvcmNlUG9saWNpZXMobWVzc2FnZSwgaXNJbmNvbWluZykudGhlbihtZXNzYWdlcyA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBpIGluIG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlc1tpXTtcbiAgICAgICAgICAgICAgX3RoaXMuY29udGV4dC5wcmVwYXJlVG9Gb3J3YXJkKG1lc3NhZ2UsIGlzSW5jb21pbmcsIHJlc3VsdCkudGhlbihtZXNzYWdlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLmJvZHkuYXV0aCA9IChtZXNzYWdlLmJvZHkuYXV0aCA9PT0gdW5kZWZpbmVkKSA/IHRydWUgOiBtZXNzYWdlLmJvZHkuYXV0aDtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSB7IGJvZHk6IHsgY29kZTogNDAzLCBkZXNjcmlwdGlvbjogJ0Jsb2NrZWQgYnkgcG9saWN5JyB9LCBmcm9tOiBtZXNzYWdlLnRvLCB0bzogbWVzc2FnZS5mcm9tLCB0eXBlOiAncmVzcG9uc2UnIH07XG4gICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBfdGhpcy5jb250ZXh0LmRlZmF1bHRCZWhhdmlvdXI7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBtZXNzYWdlLmJvZHkuYXV0aCA9IGZhbHNlO1xuICAgICAgICAgIHJlc29sdmUobWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9IHsgYm9keTogeyBjb2RlOiA0MDMsIGRlc2NyaXB0aW9uOiAnQmxvY2tlZCBieSBwb2xpY3knIH0sIGZyb206IG1lc3NhZ2UudG8sIHRvOiBtZXNzYWdlLmZyb20sIHR5cGU6ICdyZXNwb25zZScgfTtcbiAgICAgICAgICByZWplY3QoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYXV0aG9yaXNlU3luYyhtZXNzYWdlKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBtZXNzYWdlLmJvZHkgPSBtZXNzYWdlLmJvZHkgfHwge307XG4gICAgaWYgKHRoaXMuX2lzVG9WZXJpZnkobWVzc2FnZSkpIHtcbiAgICAgIGxldCBpc0luY29taW5nID0gdGhpcy5faXNJbmNvbWluZ01lc3NhZ2UobWVzc2FnZSk7XG4gICAgICBtZXNzYWdlID0gdGhpcy5jb250ZXh0LnByZXBhcmVGb3JFdmFsdWF0aW9uKG1lc3NhZ2UsIGlzSW5jb21pbmcpO1xuICAgICAgcmVzdWx0ID0gdGhpcy5wZHAuZXZhbHVhdGVQb2xpY2llcyhtZXNzYWdlLCBpc0luY29taW5nKTtcbiAgICAgIGlmIChyZXN1bHQgPT09ICdOb3QgQXBwbGljYWJsZScpIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5jb250ZXh0LmRlZmF1bHRCZWhhdmlvdXI7XG4gICAgICAgIG1lc3NhZ2UuYm9keS5hdXRoID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLmFjdGlvbnNTZXJ2aWNlLmVuZm9yY2VQb2xpY2llcyhtZXNzYWdlLCBpc0luY29taW5nKTtcbiAgICAgIG1lc3NhZ2UgPSB0aGlzLmNvbnRleHQucHJlcGFyZVRvRm9yd2FyZChtZXNzYWdlLCBpc0luY29taW5nLCByZXN1bHQpO1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBtZXNzYWdlLmJvZHkuYXV0aCA9IChtZXNzYWdlLmJvZHkuYXV0aCA9PT0gdW5kZWZpbmVkKSA/IHRydWUgOiBtZXNzYWdlLmJvZHkuYXV0aDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuY29udGV4dC5kZWZhdWx0QmVoYXZpb3VyO1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBtZXNzYWdlLmJvZHkuYXV0aCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfaXNJbmNvbWluZ01lc3NhZ2UobWVzc2FnZSkge1xuICAgIHJldHVybiAobWVzc2FnZS5ib2R5ICE9PSB1bmRlZmluZWQgJiYgbWVzc2FnZS5ib2R5LmlkZW50aXR5ICE9PSB1bmRlZmluZWQpID8gdHJ1ZSA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICogSWRlbnRpZmllcyB0aGUgbWVzc2FnZXMgdG8gYmUgdmVyaWZpZWQgYnkgdGhlIFBvbGljeSBFbmdpbmVcbiAgKiBAcGFyYW0gICAge01lc3NhZ2V9ICAgbWVzc2FnZVxuICAqIEByZXR1cm5zICB7Ym9vbGVhbn0gICByZXR1cm5zIHRydWUgaWYgdGhlIG1lc3NhZ2UgcmVxdWlyZXMgZW5jcnlwdGlvbi9kZWNyeXB0aW9uXG4gICogICAgICAgICAgICAgICAgICAgICAgIG9yIGlmIGl0cyB0eXBlIGVxdWFscyAnaGFuZHNoYWtlJzsgZmFsc2Ugb3RoZXJ3aXNlXG4gICovXG4gIF9pc1RvVmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICBsZXQgc2NoZW1hc1RvSWdub3JlID0gWydkb21haW4nLCAnZG9tYWluLWlkcCcsICdnbG9iYWwnLCAnaHlwZXJ0eS1ydW50aW1lJywgJ3J1bnRpbWUnXTtcbiAgICBsZXQgc3BsaXRGcm9tID0gKG1lc3NhZ2UuZnJvbSkuc3BsaXQoJzovLycpO1xuICAgIGxldCBmcm9tU2NoZW1hID0gc3BsaXRGcm9tWzBdO1xuICAgIGxldCBzcGxpdFRvID0gKG1lc3NhZ2UudG8pLnNwbGl0KCc6Ly8nKTtcbiAgICBsZXQgdG9TY2hlbWEgPSAgc3BsaXRUb1swXTtcblxuICAgIGlmIChtZXNzYWdlLmZyb20gPT09IGZyb21TY2hlbWEgfHwgbWVzc2FnZS50byA9PT0gdG9TY2hlbWEgfHwgbWVzc2FnZS50eXBlID09PSAncmVhZCcgfHwgbWVzc2FnZS50eXBlID09PSAncmVzcG9uc2UnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzY2hlbWFzVG9JZ25vcmUuaW5kZXhPZihmcm9tU2NoZW1hKSA9PT0gLTEgfHwgc2NoZW1hc1RvSWdub3JlLmluZGV4T2YodG9TY2hlbWEpID09PSAtMTtcbiAgICB9XG4gIH1cblxuICByZW1vdmVQb2xpY3koc291cmNlLCBrZXkpIHtcbiAgICBpZiAoIXNvdXJjZSkgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2UgaXMgbm90IGRlZmluZWQnKTtcbiAgICBpZiAoc291cmNlICE9PSAnKicgJiYgIWtleSkgdGhyb3cgbmV3IEVycm9yKCdrZXkgaXMgbm90IGRlZmluZWQnKTtcblxuICAgIHN3aXRjaCAoc291cmNlKSB7XG4gICAgICBjYXNlICcqJzpcbiAgICAgICAgdGhpcy5jb250ZXh0LnNlcnZpY2VQcm92aWRlclBvbGljeSA9IHt9O1xuICAgICAgICB0aGlzLmNvbnRleHQudXNlclBvbGljaWVzID0ge307XG4gICAgICAgIHRoaXMuY29udGV4dC5hY3RpdmVVc2VyUG9saWN5ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNvbnRleHQuc2F2ZVBvbGljaWVzKCdVU0VSJyk7XG4gICAgICAgIHRoaXMuY29udGV4dC5zYXZlUG9saWNpZXMoJ1NFUlZJQ0VfUFJPVklERVInKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LnNhdmVBY3RpdmVQb2xpY3koKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdTRVJWSUNFX1BST1ZJREVSJzpcbiAgICAgICAgZGVsZXRlIHRoaXMuY29udGV4dC5zZXJ2aWNlUHJvdmlkZXJQb2xpY3lba2V5XTtcbiAgICAgICAgdGhpcy5jb250ZXh0LnNhdmVQb2xpY2llcygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1VTRVInOlxuICAgICAgICBkZWxldGUgdGhpcy5jb250ZXh0LnVzZXJQb2xpY2llc1trZXldO1xuICAgICAgICBpZiAoa2V5ID09PSB0aGlzLmNvbnRleHQuYWN0aXZlVXNlclBvbGljeSkge1xuICAgICAgICAgIHRoaXMuY29udGV4dC5hY3RpdmVVc2VyUG9saWN5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHRoaXMuY29udGV4dC5zYXZlQWN0aXZlUG9saWN5KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250ZXh0LnNhdmVQb2xpY2llcygnVVNFUicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IEVycm9yKCdVbmtub3duIHBvbGljeSBzb3VyY2U6ICcgKyBzb3VyY2UpO1xuICAgIH1cbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFBFUDtcbiIsImltcG9ydCBBbGxvd092ZXJyaWRlcyBmcm9tICcuL2NvbWJpbmluZ0FsZ29yaXRobXMvQWxsb3dPdmVycmlkZXMnO1xuaW1wb3J0IEJsb2NrT3ZlcnJpZGVzIGZyb20gJy4vY29tYmluaW5nQWxnb3JpdGhtcy9CbG9ja092ZXJyaWRlcyc7XG5pbXBvcnQgRmlyc3RBcHBsaWNhYmxlIGZyb20gJy4vY29tYmluaW5nQWxnb3JpdGhtcy9GaXJzdEFwcGxpY2FibGUnO1xuaW1wb3J0IFJ1bGUgZnJvbSAnLi9SdWxlJztcblxuY2xhc3MgUG9saWN5IHtcblxuICBjb25zdHJ1Y3RvcihrZXksIHJ1bGVzLCBhY3Rpb25zLCBjb21iaW5pbmdBbGdvcml0aG0pIHtcbiAgICBpZiAoIWtleSkgdGhyb3cgbmV3IEVycm9yKCdrZXkgaXMgbm90IGRlZmluZWQnKTtcbiAgICBpZiAoIWFjdGlvbnMpIHRocm93IG5ldyBFcnJvcignYWN0aW9ucyBhcmUgbm90IGRlZmluZWQnKTtcblxuICAgIHRoaXMuYWN0aW9ucyA9IGFjdGlvbnM7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5fc2V0UnVsZXMocnVsZXMpO1xuICAgIHRoaXMuX3NldENvbWJpbmluZ0FsZ29yaXRobShjb21iaW5pbmdBbGdvcml0aG0pO1xuICB9XG5cbiAgYWRkQWN0aW9uKG1ldGhvZCwgcGFyYW0pIHtcbiAgICB0aGlzLmFjdGlvbnMucHVzaCh7IG1ldGhvZDogbWV0aG9kLCBwYXJhbTogcGFyYW0gfSk7XG4gIH1cblxuICBjcmVhdGVSdWxlKGRlY2lzaW9uLCBjb25kaXRpb24sIHNjb3BlLCB0YXJnZXQsIHByaW9yaXR5KSB7XG4gICAgaWYgKHByaW9yaXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHByaW9yaXR5ID0gdGhpcy5nZXRMYXN0UHJpb3JpdHkoKSArIDE7XG4gICAgfVxuICAgIGxldCBydWxlID0gbmV3IFJ1bGUoZGVjaXNpb24sIGNvbmRpdGlvbiwgc2NvcGUsIHRhcmdldCwgcHJpb3JpdHkpO1xuICAgIHRoaXMucnVsZXMucHVzaChydWxlKTtcbiAgfVxuXG4gIGRlbGV0ZVJ1bGUocnVsZSkge1xuICAgIGxldCBpbmRleFRvUmVtb3ZlID0gdGhpcy5ydWxlcy5pbmRleE9mKHJ1bGUpO1xuICAgIHRoaXMucnVsZXMuc3BsaWNlKGluZGV4VG9SZW1vdmUsIDEpO1xuICB9XG5cbiAgZW5mb3JjZUFjdGlvbnMoY29udGV4dCwgbWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgcmVzdWx0cyA9IFtdO1xuICAgICAgaWYgKHRoaXMuYWN0aW9ucy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSBpbiB0aGlzLmFjdGlvbnMpIHtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gY29udGV4dC5wZXAuYWN0aW9uc1NlcnZpY2VbdGhpcy5hY3Rpb25zW2ldLm1ldGhvZF0obWVzc2FnZSwgdGhpcy5hY3Rpb25zW2ldLnBhcmFtKTtcbiAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBQcm9taXNlLmFsbChyZXN1bHRzKS50aGVuKChtZXNzYWdlcykgPT4ge1xuICAgICAgICAgIHJlc29sdmUobWVzc2FnZXMpO1xuICAgICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKFttZXNzYWdlXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBldmFsdWF0ZVJ1bGVzKGNvbnRleHQsIG1lc3NhZ2UsIGlzSW5jb21pbmcpIHtcbiAgICBsZXQgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgaW4gdGhpcy5ydWxlcykge1xuICAgICAgcmVzdWx0cy5wdXNoKHRoaXMucnVsZXNbaV0uZXZhbHVhdGUoY29udGV4dCwgbWVzc2FnZSwgaXNJbmNvbWluZykpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbWJpbmluZ0FsZ29yaXRobS5jb21iaW5lKHJlc3VsdHMpO1xuICB9XG5cbiAgZ2V0TGFzdFByaW9yaXR5KCkge1xuICAgIGxldCBwcmlvcml0aWVzID0gW107XG5cbiAgICBpZiAodGhpcy5ydWxlcy5sZW5ndGggIT09IDApIHtcbiAgICAgIGZvciAobGV0IGkgaW4gdGhpcy5ydWxlcykge1xuICAgICAgICBwcmlvcml0aWVzLnB1c2godGhpcy5ydWxlc1tpXS5wcmlvcml0eSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkoTWF0aCwgcHJpb3JpdGllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cblxuICBnZXRSdWxlQnlQcmlvcml0eShwcmlvcml0eSkge1xuICAgIGZvciAobGV0IGkgaW4gdGhpcy5ydWxlcykge1xuICAgICAgaWYgKFN0cmluZyh0aGlzLnJ1bGVzW2ldLnByaW9yaXR5KSA9PT0gU3RyaW5nKHByaW9yaXR5KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5ydWxlc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoJ1J1bGUgd2l0aCBwcmlvcml0eSAnICsgcHJpb3JpdHkgKyAnIGRvZXMgbm90IGV4aXN0IScpO1xuICB9XG5cbiAgX3NldENvbWJpbmluZ0FsZ29yaXRobShjb21iaW5pbmdBbGdvcml0aG0pIHtcbiAgICBpZiAoIWNvbWJpbmluZ0FsZ29yaXRobSkge1xuICAgICAgY29tYmluaW5nQWxnb3JpdGhtID0gJ2Jsb2NrT3ZlcnJpZGVzJztcbiAgICB9XG4gICAgc3dpdGNoIChjb21iaW5pbmdBbGdvcml0aG0pIHtcbiAgICAgIGNhc2UgJ2Jsb2NrT3ZlcnJpZGVzJzpcbiAgICAgICAgdGhpcy5jb21iaW5pbmdBbGdvcml0aG0gPSBuZXcgQmxvY2tPdmVycmlkZXMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdhbGxvd092ZXJyaWRlcyc6XG4gICAgICAgIHRoaXMuY29tYmluaW5nQWxnb3JpdGhtID0gbmV3IEFsbG93T3ZlcnJpZGVzKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZmlyc3RBcHBsaWNhYmxlJzpcbiAgICAgICAgdGhpcy5jb21iaW5pbmdBbGdvcml0aG0gPSBuZXcgRmlyc3RBcHBsaWNhYmxlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1Vua25vd24gYWxnb3JpdGhtOiAnICsgY29tYmluaW5nQWxnb3JpdGhtKTtcbiAgICB9XG4gIH1cblxuICBfc2V0UnVsZXMocnVsZXMpIHtcbiAgICB0aGlzLnJ1bGVzID0gW107XG5cbiAgICBmb3IgKGxldCBpIGluIHJ1bGVzKSB7XG4gICAgICBsZXQgcnVsZSA9IHJ1bGVzW2ldO1xuICAgICAgaWYgKHJ1bGUucHJpb3JpdHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBydWxlLnByaW9yaXR5ID0gdGhpcy5nZXRMYXN0UHJpb3JpdHkoKSArIDE7XG4gICAgICB9XG4gICAgICBpZiAoIShydWxlIGluc3RhbmNlb2YgUnVsZSkpIHtcbiAgICAgICAgcnVsZSA9IG5ldyBSdWxlKHJ1bGUuZGVjaXNpb24sIHJ1bGUuY29uZGl0aW9uLCBydWxlLnNjb3BlLCBydWxlLnRhcmdldCwgcnVsZS5wcmlvcml0eSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJ1bGVzLnB1c2gocnVsZSk7XG4gICAgfVxuICB9XG5cbiAgc29ydFJ1bGVzKCkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgbGV0IHggPSBhLnByaW9yaXR5OyBsZXQgeSA9IGIucHJpb3JpdHk7XG4gICAgICByZXR1cm4gKCh4IDwgeSkgPyAtMSA6ICgoeCA+IHkpID8gMSA6IDApKTtcbiAgICB9KTtcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFBvbGljeTtcbiIsImltcG9ydCB7ZGl2aWRlRW1haWwsIGRpdmlkZVVSTCwgaXNEYXRhT2JqZWN0VVJMfSBmcm9tICcuLi91dGlscy91dGlscyc7XG5cbmNsYXNzIFJlVGhpbmtDdHgge1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZGVmYXVsdEJlaGF2aW91ciA9IHRydWU7XG4gICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgfVxuXG4gIGdldCBzY2hlbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NjaGVtZTtcbiAgfVxuXG4gIGdldCBkYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlO1xuICB9XG5cbiAgZ2V0IGRvbWFpbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZG9tYWluO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gIH1cblxuICBnZXQgc291cmNlKCkge1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2U7XG4gIH1cblxuICBnZXQgdGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGltZTtcbiAgfVxuXG4gIGdldCB3ZWVrZGF5KCkge1xuICAgIHJldHVybiB0aGlzLl93ZWVrZGF5O1xuICB9XG5cbiAgc2V0IHNjaGVtZShwYXJhbXMpIHtcbiAgICBsZXQgZnJvbSA9IHBhcmFtcy5tZXNzYWdlLmZyb207XG4gICAgaWYgKGlzRGF0YU9iamVjdFVSTChmcm9tKSkge1xuICAgICAgdGhpcy5fc2NoZW1lID0gZGl2aWRlVVJMKGZyb20pLnR5cGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NjaGVtZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBzZXQgZGF0ZShub3cpIHtcbiAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgbGV0IGRheSA9IFN0cmluZyhkYXRlLmdldERhdGUoKSk7XG4gICAgaWYgKGRheS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGRheSA9ICcwJyArIGRheTtcbiAgICB9XG4gICAgbGV0IG1vbnRoID0gU3RyaW5nKGRhdGUuZ2V0TW9udGgoKSArIDEpO1xuICAgIGlmIChtb250aC5sZW5ndGggPT09IDEpIHtcbiAgICAgIG1vbnRoID0gJzAnICsgbW9udGg7XG4gICAgfVxuICAgIHRoaXMuX2RhdGUgPSBkYXkgKyAnLycgKyBtb250aCArICcvJyArIGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgfVxuXG4gIHNldCBkb21haW4ocGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcy5tZXNzYWdlLmJvZHkuaWRlbnRpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fZG9tYWluID0gZGl2aWRlRW1haWwocGFyYW1zLm1lc3NhZ2UuYm9keS5pZGVudGl0eS51c2VyUHJvZmlsZS51c2VybmFtZSkuZG9tYWluO1xuICAgIH1cbiAgfVxuXG4gIHNldCB0eXBlKHBhcmFtcykge1xuICAgIGxldCBtZXNzYWdlID0gcGFyYW1zLm1lc3NhZ2U7XG4gICAgaWYgKG1lc3NhZ2UuYm9keS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl90eXBlID0gbWVzc2FnZS5ib2R5LnZhbHVlLnJlc291cmNlVHlwZTtcbiAgICB9XG4gIH1cblxuICBzZXQgc291cmNlKHBhcmFtcykge1xuICAgIGlmIChwYXJhbXMubWVzc2FnZS5ib2R5LmlkZW50aXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3NvdXJjZSA9IHBhcmFtcy5tZXNzYWdlLmJvZHkuaWRlbnRpdHkudXNlclByb2ZpbGUudXNlcm5hbWU7XG4gICAgfVxuICB9XG5cbiAgc2V0IHRpbWUobm93KSB7XG4gICAgbm93ID0gbmV3IERhdGUoKTtcbiAgICBsZXQgbWludXRlcyA9IFN0cmluZyhub3cuZ2V0TWludXRlcygpKTtcbiAgICBpZiAobWludXRlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIG1pbnV0ZXMgPSAnMCcgKyBtaW51dGVzO1xuICAgIH1cbiAgICB0aGlzLl90aW1lID0gcGFyc2VJbnQoU3RyaW5nKG5vdy5nZXRIb3VycygpKSArIG1pbnV0ZXMpO1xuICB9XG5cbiAgc2V0IHdlZWtkYXkobm93KSB7XG4gICAgdGhpcy5fd2Vla2RheSA9IFN0cmluZyhuZXcgRGF0ZSgpLmdldERheSgpKTtcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlVGhpbmtDdHg7XG4iLCJpbXBvcnQgQWR2YW5jZWRDb25kaXRpb24gZnJvbSAnLi9jb25kaXRpb25zL0FkdmFuY2VkQ29uZGl0aW9uJztcbmltcG9ydCBDb25kaXRpb24gZnJvbSAnLi9jb25kaXRpb25zL0NvbmRpdGlvbic7XG5pbXBvcnQge2dldFVzZXJFbWFpbEZyb21VUkwsIGlzRGF0YU9iamVjdFVSTCwgcmVtb3ZlUGF0aEZyb21VUkx9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCBTdWJzY3JpcHRpb25Db25kaXRpb24gZnJvbSAnLi9jb25kaXRpb25zL0FkdmFuY2VkQ29uZGl0aW9uJztcblxuY2xhc3MgUnVsZSB7XG5cbiAgY29uc3RydWN0b3IoZGVjaXNpb24sIGNvbmRpdGlvbiwgc2NvcGUsIHRhcmdldCwgcHJpb3JpdHkpIHtcbiAgICB0aGlzLmRlY2lzaW9uID0gZGVjaXNpb247XG4gICAgdGhpcy5zZXRDb25kaXRpb24oY29uZGl0aW9uKTtcbiAgICB0aGlzLnByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICB9XG5cbiAgc2V0Q29uZGl0aW9uKGNvbmRpdGlvbikge1xuICAgIGlmICghKGNvbmRpdGlvbiBpbnN0YW5jZW9mIENvbmRpdGlvbiB8fCBjb25kaXRpb24gaW5zdGFuY2VvZiBTdWJzY3JpcHRpb25Db25kaXRpb24gfHwgY29uZGl0aW9uIGluc3RhbmNlb2YgQWR2YW5jZWRDb25kaXRpb24pKSB7XG4gICAgICBsZXQgYXR0cmlidXRlID0gY29uZGl0aW9uLmF0dHJpYnV0ZTtcbiAgICAgIHN3aXRjaCAoYXR0cmlidXRlKSB7XG4gICAgICAgIGNhc2UgJ3N1YnNjcmlwdGlvbic6XG4gICAgICAgICAgdGhpcy5jb25kaXRpb24gPSBuZXcgU3Vic2NyaXB0aW9uQ29uZGl0aW9uKGNvbmRpdGlvbi5hdHRyaWJ1dGUsIGNvbmRpdGlvbi5vcGVyYXRvciwgY29uZGl0aW9uLnBhcmFtcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgIHRoaXMuY29uZGl0aW9uID0gbmV3IEFkdmFuY2VkQ29uZGl0aW9uKGNvbmRpdGlvbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy5jb25kaXRpb24gPSBuZXcgQ29uZGl0aW9uKGNvbmRpdGlvbi5hdHRyaWJ1dGUsIGNvbmRpdGlvbi5vcGVyYXRvciwgY29uZGl0aW9uLnBhcmFtcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgIH1cbiAgfVxuXG4gIGV2YWx1YXRlKGNvbnRleHQsIG1lc3NhZ2UsIGlzSW5jb21pbmcpIHtcbiAgICBsZXQgZmllbGQgPSAoaXNJbmNvbWluZykgPyBtZXNzYWdlLnRvIDogbWVzc2FnZS5mcm9tO1xuICAgIGxldCBoeXBlcnR5TmFtZTtcbiAgICBzd2l0Y2ggKHRoaXMuc2NvcGUpIHtcbiAgICAgIGNhc2UgJ2dsb2JhbCc6XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdoeXBlcnR5JzpcbiAgICAgICAgaWYgKGlzRGF0YU9iamVjdFVSTChmaWVsZCkpIHtcbiAgICAgICAgICBsZXQgcmVwb3J0ZXIgPSBjb250ZXh0LnJ1bnRpbWVSZWdpc3RyeS5nZXRSZXBvcnRlclVSTFN5bmNob25vdXMocmVtb3ZlUGF0aEZyb21VUkwoZmllbGQpKTtcbiAgICAgICAgICBpZiAocmVwb3J0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaHlwZXJ0eU5hbWUgPSBjb250ZXh0LnJ1bnRpbWVSZWdpc3RyeS5nZXRIeXBlcnR5TmFtZShyZXBvcnRlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChmaWVsZC5zcGxpdCgnOi8vJylbMF0gPT09ICdoeXBlcnR5Jykge1xuICAgICAgICAgICAgaHlwZXJ0eU5hbWUgPSBjb250ZXh0LnJ1bnRpbWVSZWdpc3RyeS5nZXRIeXBlcnR5TmFtZShyZW1vdmVQYXRoRnJvbVVSTChmaWVsZCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaHlwZXJ0eU5hbWUgPT09IHRoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJ05vdCBBcHBsaWNhYmxlJztcblxuICAgICAgY2FzZSAnaWRlbnRpdHknOlxuICAgICAgICBsZXQgb3duZXI7XG5cbiAgICAgICAgaWYgKGlzRGF0YU9iamVjdFVSTChmaWVsZCkpIHtcbiAgICAgICAgICBsZXQgcmVwb3J0ZXIgPSBjb250ZXh0LnJ1bnRpbWVSZWdpc3RyeS5nZXRSZXBvcnRlclVSTFN5bmNob25vdXMocmVtb3ZlUGF0aEZyb21VUkwoZmllbGQpKTtcbiAgICAgICAgICBvd25lciA9IGNvbnRleHQucnVudGltZVJlZ2lzdHJ5LmdldEh5cGVydHlPd25lcihyZXBvcnRlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGZpZWxkLnNwbGl0KCc6Ly8nKVswXSA9PT0gJ2h5cGVydHknKSB7XG4gICAgICAgICAgICBvd25lciA9IGNvbnRleHQucnVudGltZVJlZ2lzdHJ5LmdldEh5cGVydHlPd25lcihyZW1vdmVQYXRoRnJvbVVSTChmaWVsZCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3duZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG93bmVyID0gZ2V0VXNlckVtYWlsRnJvbVVSTChvd25lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG93bmVyID09PSB0aGlzLnRhcmdldCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICdOb3QgQXBwbGljYWJsZSc7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY29uZGl0aW9uLmlzQXBwbGljYWJsZShjb250ZXh0LCBtZXNzYWdlLCB0aGlzLnNjb3BlLCB0aGlzLnRhcmdldCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlY2lzaW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ05vdCBBcHBsaWNhYmxlJztcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUnVsZTtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxNiBQVCBJbm92YcOnw6NvIGUgU2lzdGVtYXMgU0FcbiogQ29weXJpZ2h0IDIwMTYgSU5FU0MtSURcbiogQ29weXJpZ2h0IDIwMTYgUVVPQklTIE5FVFdPUktTIFNMXG4qIENvcHlyaWdodCAyMDE2IEZSQVVOSE9GRVItR0VTRUxMU0NIQUZUIFpVUiBGT0VSREVSVU5HIERFUiBBTkdFV0FORFRFTiBGT1JTQ0hVTkcgRS5WXG4qIENvcHlyaWdodCAyMDE2IE9SQU5HRSBTQVxuKiBDb3B5cmlnaHQgMjAxNiBEZXV0c2NoZSBUZWxla29tIEFHXG4qIENvcHlyaWdodCAyMDE2IEFwaXplZVxuKiBDb3B5cmlnaHQgMjAxNiBURUNITklTQ0hFIFVOSVZFUlNJVEFUIEJFUkxJTlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qKi9cblxuLyoqXG4qIEBhdXRob3IgQW5hIENhbGRlaXJhIDxhbmEuY2FsZGVpcmFAdGVjbmljby51bGlzYm9hLnB0PlxuKiBAY2xhc3NkZXNjIENsYXNzIHRvIGNvbWJpbmUgdGhlIGF1dGhvcml6YXRpb24gZGVjaXNpb25zIHRoYXQgcmVzdWx0IGZyb20gcnVsZXMgZXZhbHVhdGlvbi5cbiovXG5jbGFzcyBBbGxvd092ZXJyaWRlcyB7XG5cbiAgLyoqXG4gICogR2l2ZW4gYW4gYXJyYXkgb2YgaW5kaXZpZHVhbCBhdXRob3JpemF0aW9uIGRlY2lzaW9ucywgcHJpb3JpdGl6ZXMgYSBwb3NpdGl2ZSBvbmUuXG4gICogQHBhcmFtICAgIHtib29sZWFuW119ICAgZGVjaXNpb25zXG4gICogQHJldHVybnMgIHtib29sZWFufVxuICAqL1xuICBjb21iaW5lKGRlY2lzaW9ucykge1xuICAgIGlmIChkZWNpc2lvbnMuaW5kZXhPZih0cnVlKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZGVjaXNpb25zLmluZGV4T2YoZmFsc2UpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ05vdCBBcHBsaWNhYmxlJztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBBbGxvd092ZXJyaWRlcztcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxNiBQVCBJbm92YcOnw6NvIGUgU2lzdGVtYXMgU0FcbiogQ29weXJpZ2h0IDIwMTYgSU5FU0MtSURcbiogQ29weXJpZ2h0IDIwMTYgUVVPQklTIE5FVFdPUktTIFNMXG4qIENvcHlyaWdodCAyMDE2IEZSQVVOSE9GRVItR0VTRUxMU0NIQUZUIFpVUiBGT0VSREVSVU5HIERFUiBBTkdFV0FORFRFTiBGT1JTQ0hVTkcgRS5WXG4qIENvcHlyaWdodCAyMDE2IE9SQU5HRSBTQVxuKiBDb3B5cmlnaHQgMjAxNiBEZXV0c2NoZSBUZWxla29tIEFHXG4qIENvcHlyaWdodCAyMDE2IEFwaXplZVxuKiBDb3B5cmlnaHQgMjAxNiBURUNITklTQ0hFIFVOSVZFUlNJVEFUIEJFUkxJTlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qKi9cblxuLyoqXG4qIEBhdXRob3IgQW5hIENhbGRlaXJhIDxhbmEuY2FsZGVpcmFAdGVjbmljby51bGlzYm9hLnB0PlxuKiBAY2xhc3NkZXNjIENsYXNzIHRvIGNvbWJpbmUgdGhlIGF1dGhvcml6YXRpb24gZGVjaXNpb25zIHRoYXQgcmVzdWx0IGZyb20gcnVsZXMgZXZhbHVhdGlvbi5cbiovXG5jbGFzcyBCbG9ja092ZXJyaWRlcyB7XG5cbiAgLyoqXG4gICogR2l2ZW4gYW4gYXJyYXkgb2YgaW5kaXZpZHVhbCBhdXRob3Jpc2F0aW9uIGRlY2lzaW9ucywgcHJpb3JpdGlzZXMgYSBuZWdhdGl2ZSBvbmUuXG4gICogQHBhcmFtICAgIHtib29sZWFuW119ICAgZGVjaXNpb25zXG4gICogQHJldHVybnMgIHtib29sZWFufVxuICAqL1xuICBjb21iaW5lKGRlY2lzaW9ucykge1xuICAgIGlmIChkZWNpc2lvbnMuaW5kZXhPZihmYWxzZSkgIT09IC0xKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkZWNpc2lvbnMuaW5kZXhPZih0cnVlKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ05vdCBBcHBsaWNhYmxlJztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBCbG9ja092ZXJyaWRlcztcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxNiBQVCBJbm92YcOnw6NvIGUgU2lzdGVtYXMgU0FcbiogQ29weXJpZ2h0IDIwMTYgSU5FU0MtSURcbiogQ29weXJpZ2h0IDIwMTYgUVVPQklTIE5FVFdPUktTIFNMXG4qIENvcHlyaWdodCAyMDE2IEZSQVVOSE9GRVItR0VTRUxMU0NIQUZUIFpVUiBGT0VSREVSVU5HIERFUiBBTkdFV0FORFRFTiBGT1JTQ0hVTkcgRS5WXG4qIENvcHlyaWdodCAyMDE2IE9SQU5HRSBTQVxuKiBDb3B5cmlnaHQgMjAxNiBEZXV0c2NoZSBUZWxla29tIEFHXG4qIENvcHlyaWdodCAyMDE2IEFwaXplZVxuKiBDb3B5cmlnaHQgMjAxNiBURUNITklTQ0hFIFVOSVZFUlNJVEFUIEJFUkxJTlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qKi9cblxuLyoqXG4qIEBhdXRob3IgQW5hIENhbGRlaXJhIDxhbmEuY2FsZGVpcmFAdGVjbmljby51bGlzYm9hLnB0PlxuKiBAY2xhc3NkZXNjIENsYXNzIHRvIGNvbWJpbmUgdGhlIGF1dGhvcml6YXRpb24gZGVjaXNpb25zIHRoYXQgcmVzdWx0IGZyb20gcnVsZXMgZXZhbHVhdGlvbi5cbiovXG5jbGFzcyBGaXJzdEFwcGxpY2FibGUge1xuXG4gIC8qKlxuICAqIEdpdmVuIGFuIGFycmF5IG9mIGluZGl2aWR1YWwgYXV0aG9yaXNhdGlvbiBkZWNpc2lvbnMsIHJldHVybnMgdGhlIGZpcnN0IG9uZSBkaWZmZXJlbnQgZnJvbSAnTm90IEFwcGxpY2FibGUnLCBlaXRoZXIgcG9zaXRpdmUgb3IgbmVnYXRpdmUuXG4gICogQHBhcmFtICAgIHtib29sZWFuW119ICAgICBkZWNpc2lvbnNcbiAgKiBAcmV0dXJucyAge2Jvb2xlYW59XG4gICovXG4gIGNvbWJpbmUoZGVjaXNpb25zKSB7XG4gICAgZm9yIChsZXQgaSBpbiBkZWNpc2lvbnMpIHtcbiAgICAgIGlmIChkZWNpc2lvbnNbaV0gIT09ICdOb3QgQXBwbGljYWJsZScpIHtcbiAgICAgICAgcmV0dXJuIGRlY2lzaW9uc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICdOb3QgQXBwbGljYWJsZSc7XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBGaXJzdEFwcGxpY2FibGU7XG4iLCJpbXBvcnQgQ29uZGl0aW9uIGZyb20gJy4vQ29uZGl0aW9uJztcbmltcG9ydCBPcGVyYXRvcnMgZnJvbSAnLi4vT3BlcmF0b3JzJztcbmltcG9ydCBTdWJzY3JpcHRpb25Db25kaXRpb24gZnJvbSAnLi9TdWJzY3JpcHRpb25Db25kaXRpb24nO1xuXG5jbGFzcyBBZHZhbmNlZENvbmRpdGlvbiB7XG5cbiAgY29uc3RydWN0b3IoY29uZGl0aW9uKSB7XG4gICAgdGhpcy5vcGVyYXRvcnMgPSBuZXcgT3BlcmF0b3JzKCk7XG4gICAgaWYgKGNvbmRpdGlvbi5vcGVyYXRvcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uZGl0aW9uID0gY29uZGl0aW9uLmNvbmRpdGlvbjtcbiAgICB9XG4gICAgY29uZGl0aW9uID0gdGhpcy5idWlsZENvbmRpdGlvbihjb25kaXRpb24pO1xuICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICB9XG5cbiAgYnVpbGRDb25kaXRpb24oY29uZGl0aW9uKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZGl0aW9uWzFdKSkge1xuICAgICAgY29uZGl0aW9uWzFdID0gdGhpcy5idWlsZENvbmRpdGlvbihjb25kaXRpb25bMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29uZGl0aW9uWzFdLmF0dHJpYnV0ZSA9PT0gJ3N1YnNjcmlwdGlvbicpIHtcbiAgICAgICAgY29uZGl0aW9uWzFdID0gbmV3IFN1YnNjcmlwdGlvbkNvbmRpdGlvbihjb25kaXRpb25bMV0uYXR0cmlidXRlLCBjb25kaXRpb25bMV0ub3BlcmF0b3IsIGNvbmRpdGlvblsxXS5wYXJhbXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uZGl0aW9uWzFdID0gbmV3IENvbmRpdGlvbihjb25kaXRpb25bMV0uYXR0cmlidXRlLCBjb25kaXRpb25bMV0ub3BlcmF0b3IsIGNvbmRpdGlvblsxXS5wYXJhbXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb25kaXRpb25bMl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZGl0aW9uWzJdKSkge1xuICAgICAgICBjb25kaXRpb25bMl0gPSB0aGlzLmJ1aWxkQ29uZGl0aW9uKGNvbmRpdGlvblsyXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY29uZGl0aW9uWzJdLmF0dHJpYnV0ZSA9PT0gJ3N1YnNjcmlwdGlvbicpIHtcbiAgICAgICAgICBjb25kaXRpb25bMl0gPSBuZXcgU3Vic2NyaXB0aW9uQ29uZGl0aW9uKGNvbmRpdGlvblsyXS5hdHRyaWJ1dGUsIGNvbmRpdGlvblsyXS5vcGVyYXRvciwgY29uZGl0aW9uWzJdLnBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uZGl0aW9uWzJdID0gbmV3IENvbmRpdGlvbihjb25kaXRpb25bMl0uYXR0cmlidXRlLCBjb25kaXRpb25bMl0ub3BlcmF0b3IsIGNvbmRpdGlvblsyXS5wYXJhbXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb25kaXRpb247XG4gIH1cblxuICBpc0FwcGxpY2FibGUoY29udGV4dCwgbWVzc2FnZSwgc2NvcGUsIHRhcmdldCwgb3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKCFvcGVyYXRvcikge1xuICAgICAgb3BlcmF0b3IgPSB0aGlzLmNvbmRpdGlvblswXTtcbiAgICAgIGxlZnQgPSB0aGlzLmNvbmRpdGlvblsxXTtcbiAgICAgIHJpZ2h0ID0gdGhpcy5jb25kaXRpb25bMl07XG4gICAgfVxuXG4gICAgd2hpbGUgKCEobGVmdCBpbnN0YW5jZW9mIENvbmRpdGlvbikgJiAhKGxlZnQgaW5zdGFuY2VvZiBTdWJzY3JpcHRpb25Db25kaXRpb24pICYgKHR5cGVvZiBsZWZ0ICE9PSAnYm9vbGVhbicpKSB7XG4gICAgICBsZWZ0ID0gdGhpcy5pc0FwcGxpY2FibGUoY29udGV4dCwgbWVzc2FnZSwgc2NvcGUsIHRhcmdldCwgbGVmdFswXSwgbGVmdFsxXSwgbGVmdFsyXSk7XG4gICAgfVxuICAgIGlmIChyaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB3aGlsZSAoIShyaWdodCBpbnN0YW5jZW9mIENvbmRpdGlvbikgJiAhKHJpZ2h0IGluc3RhbmNlb2YgU3Vic2NyaXB0aW9uQ29uZGl0aW9uKSAmICh0eXBlb2YgcmlnaHQgIT09ICdib29sZWFuJykpIHtcbiAgICAgICAgcmlnaHQgPSB0aGlzLmlzQXBwbGljYWJsZShjb250ZXh0LCBtZXNzYWdlLCBzY29wZSwgdGFyZ2V0LCByaWdodFswXSwgcmlnaHRbMV0sIHJpZ2h0WzJdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0TGVmdCA9ICh0eXBlb2YgbGVmdCA9PT0gJ2Jvb2xlYW4nKSA/IGxlZnQgOiBsZWZ0LmlzQXBwbGljYWJsZShjb250ZXh0LCBtZXNzYWdlLCBzY29wZSwgdGFyZ2V0KTtcbiAgICBsZXQgcmVzdWx0UmlnaHQ7XG4gICAgaWYgKHJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc3VsdFJpZ2h0ID0gKHR5cGVvZiByaWdodCA9PT0gJ2Jvb2xlYW4nKSA/IHJpZ2h0IDogcmlnaHQuaXNBcHBsaWNhYmxlKGNvbnRleHQsIG1lc3NhZ2UsIHNjb3BlLCB0YXJnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vcGVyYXRvcnNbb3BlcmF0b3JdKFtyZXN1bHRMZWZ0LCByZXN1bHRSaWdodF0pO1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQWR2YW5jZWRDb25kaXRpb247XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTYgUFQgSW5vdmHDp8OjbyBlIFNpc3RlbWFzIFNBXG4qIENvcHlyaWdodCAyMDE2IElORVNDLUlEXG4qIENvcHlyaWdodCAyMDE2IFFVT0JJUyBORVRXT1JLUyBTTFxuKiBDb3B5cmlnaHQgMjAxNiBGUkFVTkhPRkVSLUdFU0VMTFNDSEFGVCBaVVIgRk9FUkRFUlVORyBERVIgQU5HRVdBTkRURU4gRk9SU0NIVU5HIEUuVlxuKiBDb3B5cmlnaHQgMjAxNiBPUkFOR0UgU0FcbiogQ29weXJpZ2h0IDIwMTYgRGV1dHNjaGUgVGVsZWtvbSBBR1xuKiBDb3B5cmlnaHQgMjAxNiBBcGl6ZWVcbiogQ29weXJpZ2h0IDIwMTYgVEVDSE5JU0NIRSBVTklWRVJTSVRBVCBCRVJMSU5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKiovXG5cbmltcG9ydCBPcGVyYXRvcnMgZnJvbSAnLi4vT3BlcmF0b3JzJztcblxuLyoqXG4qIEBhdXRob3IgQW5hIENhbGRlaXJhIDxhbmEuY2FsZGVpcmFAdGVjbmljby51bGlzYm9hLnB0PlxuKiBAY2xhc3NkZXNjIENsYXNzIHRvIHJlcHJlc2VudCBhIGNvbmRpdGlvbiBhbmQgZXZhbHVhdGUgaXRzIGFwcGxpY2FiaWxpdHkuXG4qL1xuY2xhc3MgQ29uZGl0aW9uIHtcblxuICAvKipcbiAgKiBDcmVhdGVzIGEgbmV3IENvbmRpdGlvbi5cbiAgKiBAY2xhc3NcbiAgKiBAcGFyYW0gIHtzdHJpbmd9ICBhdHRyaWJ1dGVcbiAgKiBAcGFyYW0gIHtzdHJpbmd9ICBvcGVyYXRvclxuICAqIEBwYXJhbSAgeyp9ICAgICAgIHBhcmFtc1xuICAqL1xuICBjb25zdHJ1Y3RvcihhdHRyaWJ1dGUsIG9wZXJhdG9yLCBwYXJhbXMpIHtcbiAgICB0aGlzLmF0dHJpYnV0ZSA9IGF0dHJpYnV0ZTtcbiAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgdGhpcy5vcGVyYXRvcnMgPSBuZXcgT3BlcmF0b3JzKCk7XG4gIH1cblxuICAvKipcbiAgKiBWZXJpZmllcyBpZiB0aGUgY29uZGl0aW9uIGlzIGFwcGxpY2FibGUgdG8gdGhlIG1lc3NhZ2UuIEZpcnN0LCB0aGUgc3lzdGVtIHZhbHVlIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGF0dHJpYnV0ZSBpcyByZXRyaWV2ZWQ7IHRoZW4sIHRoYXQgdmFsdWUgaXMgY29tcGFyZWQgd2l0aCB0aGUgcGFyYW1ldGVyIHNwZWNpZmllZCBpbiB0aGUgY29uZGl0aW9uIGJ5IGV4ZWN1dGluZyB0aGUgb3BlcmF0b3IgaW1wbGVtZW50YXRpb24uIElmIHRoZSBvcGVyYXRvciBpcyAnaW4nIGFuZCB0aGUgbmFtZSBvZiBhIGdyb3VwIGlzIGdpdmVuLCB0aGVuIHRoZSBhcnJheSBob2xkaW5nIHRoZSBtZW1iZXJzIG9mIHRoZSBncm91cCBpcyByZXRyaWV2ZWQgYmVmb3JlIHRoZSBjb21wYXJpc29uLlxuICAqIEBwYXJhbSAge09iamVjdH0gICAgY29udGV4dCAgIGVudmlyb25tZW50IHdoZXJlIHRoZSBQb2xpY3kgRW5naW5lIGlzIGJlaW5nIHVzZWRcbiAgKiBAcGFyYW0gIHtPYmplY3R9ICAgIG1lc3NhZ2VcbiAgKi9cbiAgaXNBcHBsaWNhYmxlKGNvbnRleHQsIG1lc3NhZ2UpIHtcbiAgICBjb250ZXh0W3RoaXMuYXR0cmlidXRlXSA9IHsgbWVzc2FnZTogbWVzc2FnZSB9O1xuICAgIGxldCB2YWx1ZSA9IGNvbnRleHRbdGhpcy5hdHRyaWJ1dGVdO1xuICAgIGxldCB0ZW1wUGFyYW07XG5cbiAgICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJ2luJykge1xuICAgICAgaWYgKCEoQXJyYXkuaXNBcnJheSh0aGlzLnBhcmFtcykpKSB7XG4gICAgICAgIHRlbXBQYXJhbSA9IGNvbnRleHQuZ2V0R3JvdXAodGhpcy5wYXJhbXMsIG1lc3NhZ2UudG8pO1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRvcnNbdGhpcy5vcGVyYXRvcl0oW3RlbXBQYXJhbSwgdmFsdWVdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5vcGVyYXRvcnNbdGhpcy5vcGVyYXRvcl0oW3RoaXMucGFyYW1zLCB2YWx1ZV0pO1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29uZGl0aW9uO1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDE2IFBUIElub3Zhw6fDo28gZSBTaXN0ZW1hcyBTQVxuKiBDb3B5cmlnaHQgMjAxNiBJTkVTQy1JRFxuKiBDb3B5cmlnaHQgMjAxNiBRVU9CSVMgTkVUV09SS1MgU0xcbiogQ29weXJpZ2h0IDIwMTYgRlJBVU5IT0ZFUi1HRVNFTExTQ0hBRlQgWlVSIEZPRVJERVJVTkcgREVSIEFOR0VXQU5EVEVOIEZPUlNDSFVORyBFLlZcbiogQ29weXJpZ2h0IDIwMTYgT1JBTkdFIFNBXG4qIENvcHlyaWdodCAyMDE2IERldXRzY2hlIFRlbGVrb20gQUdcbiogQ29weXJpZ2h0IDIwMTYgQXBpemVlXG4qIENvcHlyaWdodCAyMDE2IFRFQ0hOSVNDSEUgVU5JVkVSU0lUQVQgQkVSTElOXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbioqL1xuXG5pbXBvcnQgQ29uZGl0aW9uIGZyb20gJy4vQ29uZGl0aW9uJztcblxuLyoqXG4qIEBhdXRob3IgQW5hIENhbGRlaXJhIDxhbmEuY2FsZGVpcmFAdGVjbmljby51bGlzYm9hLnB0PlxuKiBAY2xhc3NkZXNjIENsYXNzIHRvIHJlcHJlc2VudCBhIHN1YnNjcmlwdGlvbiBjb25kaXRpb24gYW5kIGV2YWx1YXRlIGl0cyBhcHBsaWNhYmlsaXR5LlxuKi9cbmNsYXNzIFN1YnNjcmlwdGlvbkNvbmRpdGlvbiBleHRlbmRzIENvbmRpdGlvbiB7XG5cbiAgLyoqXG4gICogQ3JlYXRlcyBhIG5ldyBTdWJzY3JpcHRpb25Db25kaXRpb24uXG4gICogQGNsYXNzXG4gICogQHBhcmFtICB7c3RyaW5nfSAgYXR0cmlidXRlXG4gICogQHBhcmFtICB7c3RyaW5nfSAgb3BlcmF0b3JcbiAgKiBAcGFyYW0gIHsqfSAgICAgICBwYXJhbXNcbiAgKi9cbiAgY29uc3RydWN0b3IoYXR0cmlidXRlLCBvcGVyYXRvciwgcGFyYW1zKSB7XG4gICAgc3VwZXIoYXR0cmlidXRlLCBvcGVyYXRvciwgcGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAqIFZlcmlmaWVzIGlmIHRoZSBzdWJzY3JpcHRpb24gY29uZGl0aW9uIGlzIGFwcGxpY2FibGUgdG8gdGhlIG1lc3NhZ2UuIEZpcnN0LCB2ZXJpZmllcyBpZiB0aGUgbWVzc2FnZSBpcyBvZiB0aGUgc3Vic2NyaXB0aW9uIHR5cGU7IHNlY29uZCwgdmVyaWZpZXMgaWYgdGhlIG1lc3NhZ2UgaXMgZnJvbSBhIHJlbW90ZSBydW50aW1lIHRvIGd1YXJhbnRlZSB0aGF0IHRoZSBzdWJzY3JpcHRpb24gaXMgYmVpbmcgdmFsaWRhdGVkIGluIHRoZSBkZXN0aW5hdGlvbiBydW50aW1lOyB0aGlyZCwgdmVyaWZpZXMgaWYgdGhlIHN1YnNjcmlwdGlvbiBwcmVmZXJlbmNlIGlzIG1ldC5cbiAgKiBAcGFyYW0gIHtPYmplY3R9ICAgIGNvbnRleHQgICBlbnZpcm9ubWVudCB3aGVyZSB0aGUgUG9saWN5IEVuZ2luZSBpcyBiZWluZyB1c2VkXG4gICogQHBhcmFtICB7T2JqZWN0fSAgICBtZXNzYWdlXG4gICovXG4gIGlzQXBwbGljYWJsZShjb250ZXh0LCBtZXNzYWdlKSB7XG4gICAgbGV0IGlzU3Vic2NyaXB0aW9uID0gbWVzc2FnZS50eXBlID09PSAnc3Vic2NyaWJlJztcbiAgICBsZXQgaXNGcm9tUmVtb3RlU00gPSBjb250ZXh0LmlzRnJvbVJlbW90ZVNNKG1lc3NhZ2UuZnJvbSk7XG4gICAgaWYgKGlzU3Vic2NyaXB0aW9uICYgaXNGcm9tUmVtb3RlU00pIHtcbiAgICAgIHJldHVybiBzdXBlci5pc0FwcGxpY2FibGUoY29udGV4dCwgbWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBTdWJzY3JpcHRpb25Db25kaXRpb247XG4iLCJpbXBvcnQgQWxsb3dPdmVycmlkZXMgZnJvbSAnLi4vY29tYmluaW5nQWxnb3JpdGhtcy9BbGxvd092ZXJyaWRlcyc7XG5pbXBvcnQgQmxvY2tPdmVycmlkZXMgZnJvbSAnLi4vY29tYmluaW5nQWxnb3JpdGhtcy9CbG9ja092ZXJyaWRlcyc7XG5pbXBvcnQge2RpdmlkZVVSTCwgZ2V0VXNlckVtYWlsRnJvbVVSTCwgaXNEYXRhT2JqZWN0VVJMfSBmcm9tICcuLi8uLi91dGlscy91dGlscyc7XG5pbXBvcnQgRmlyc3RBcHBsaWNhYmxlIGZyb20gJy4uL2NvbWJpbmluZ0FsZ29yaXRobXMvRmlyc3RBcHBsaWNhYmxlJztcbmltcG9ydCBSZVRoaW5rQ3R4IGZyb20gJy4uL1JlVGhpbmtDdHgnO1xuXG5jbGFzcyBSdW50aW1lQ29yZUN0eCBleHRlbmRzIFJlVGhpbmtDdHgge1xuXG4gIGNvbnN0cnVjdG9yKGlkTW9kdWxlLCBydW50aW1lUmVnaXN0cnksIHN0b3JhZ2VNYW5hZ2VyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmlkTW9kdWxlID0gaWRNb2R1bGU7XG4gICAgdGhpcy5ydW50aW1lUmVnaXN0cnkgPSBydW50aW1lUmVnaXN0cnk7XG4gICAgdGhpcy5hY3RpdmVVc2VyUG9saWN5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2VydmljZVByb3ZpZGVyUG9saWN5ID0ge307XG4gICAgdGhpcy51c2VyUG9saWNpZXMgPSB7fTtcbiAgICB0aGlzLnN0b3JhZ2VNYW5hZ2VyID0gc3RvcmFnZU1hbmFnZXI7XG4gIH1cblxuICBnZXQgc3Vic2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9zdWJzY3JpcHRpb247XG4gIH1cblxuICBzZXQgc3Vic2NyaXB0aW9uKHBhcmFtcykge1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHBhcmFtcy5tZXNzYWdlLmJvZHkuc3Vic2NyaWJlcjtcbiAgfVxuXG4gIGxvYWRDb25maWd1cmF0aW9ucygpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgX3RoaXMuc3RvcmFnZU1hbmFnZXIuZ2V0KCdyZXRoaW5rOmFjdGl2ZVBvbGljeScpLnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgIF90aGlzLmFjdGl2ZVVzZXJQb2xpY3kgPSB2YWx1ZTtcblxuICAgICAgICByZXR1cm4gX3RoaXMuc3RvcmFnZU1hbmFnZXIuZ2V0KCdyZXRoaW5rOmdyb3VwcycpO1xuICAgICAgfSkudGhlbigoZ3JvdXBJbmZvKSA9PiB7XG4gICAgICAgIGxldCBncm91cHMgPSBncm91cEluZm87XG4gICAgICAgIF90aGlzLmdyb3VwcyA9IChncm91cHMgPT09IHVuZGVmaW5lZCkgPyB7fSA6IGdyb3VwcztcblxuICAgICAgICByZXR1cm4gX3RoaXMuc3RvcmFnZU1hbmFnZXIuZ2V0KCdyZXRoaW5rOnNwUG9saWNpZXMnKTtcbiAgICAgIH0pLnRoZW4oKHBvbGljaWVzSW5mbykgPT4ge1xuICAgICAgICBsZXQgc3BQb2xpY2llcyA9IHBvbGljaWVzSW5mbztcbiAgICAgICAgX3RoaXMuc2VydmljZVByb3ZpZGVyUG9saWN5ID0gKHNwUG9saWNpZXMgPT09IHVuZGVmaW5lZCkgPyB7fSA6IHNwUG9saWNpZXM7XG5cbiAgICAgICAgX3RoaXMuX2xvYWRVc2VyUG9saWNpZXMoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBwcmVwYXJlRm9yRXZhbHVhdGlvbihtZXNzYWdlLCBpc0luY29taW5nKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgbGV0IF90aGlzID0gdGhpcztcbiAgICAgIGlmIChpc0luY29taW5nKSB7XG4gICAgICAgIGlmIChfdGhpcy5faXNUb0N5cGhlck1vZHVsZShtZXNzYWdlKSkge1xuICAgICAgICAgIF90aGlzLmlkTW9kdWxlLmRlY3J5cHRNZXNzYWdlKG1lc3NhZ2UpLnRoZW4oZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgLyppZiAobWVzc2FnZS50eXBlID09PSAndXBkYXRlJykge1xuICAgICAgICAgICAgICBfdGhpcy5faXNWYWxpZFVwZGF0ZShtZXNzYWdlKS50aGVuKG1lc3NhZ2UgPT4geyovXG4gICAgICAgICAgICByZXNvbHZlKG1lc3NhZ2UpO1xuICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIC8qfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSovXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKF90aGlzLl9pc1RvU2V0SUQobWVzc2FnZSkpIHtcbiAgICAgICAgICBfdGhpcy5fZ2V0SWRlbnRpdHkobWVzc2FnZSkudGhlbihpZGVudGl0eSA9PiB7XG4gICAgICAgICAgICBtZXNzYWdlLmJvZHkuaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICAgICAgICAgIHJlc29sdmUobWVzc2FnZSk7XG4gICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH0pO1xuICB9XG5cbiAgZ2V0UG9saWNpZXMobWVzc2FnZSwgaXNJbmNvbWluZ01lc3NhZ2UpIHtcbiAgICBsZXQgcG9saWNpZXMgPSB7fTtcblxuICAgIGlmICh0aGlzLmFjdGl2ZVVzZXJQb2xpY3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcG9saWNpZXMudXNlclBvbGljeSA9IHRoaXMudXNlclBvbGljaWVzW3RoaXMuYWN0aXZlVXNlclBvbGljeV07XG4gICAgfVxuXG4gICAgcG9saWNpZXMuc2VydmljZVByb3ZpZGVyUG9saWN5ID0gdGhpcy5nZXRTZXJ2aWNlUHJvdmlkZXJQb2xpY3kobWVzc2FnZSwgaXNJbmNvbWluZ01lc3NhZ2UpO1xuXG4gICAgcmV0dXJuIHBvbGljaWVzO1xuICB9XG5cbiAgX2lzVmFsaWRVcGRhdGUobWVzc2FnZSkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmIChtZXNzYWdlLmZyb20uc3BsaXQoJzovLycpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgX3RoaXMuaWRNb2R1bGUuX2dldEh5cGVydHlGcm9tRGF0YU9iamVjdChtZXNzYWdlLmZyb20pLnRoZW4oaHlwZXJ0eVVSTCA9PiB7XG4gICAgICAgICAgaWYgKGh5cGVydHlVUkwgPT09IG1lc3NhZ2UuYm9keS5zb3VyY2UpIHtcbiAgICAgICAgICAgIHJlc29sdmUobWVzc2FnZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdCgnVGhlIHNvdXJjZSBvZiB0aGUgbWVzc2FnZSBpcyBub3QgdmFsaWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUobWVzc2FnZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcmVwYXJlVG9Gb3J3YXJkKG1lc3NhZ2UsIGlzSW5jb21pbmcsIHJlc3VsdCkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmIChpc0luY29taW5nICYgcmVzdWx0KSB7XG4gICAgICAgIGxldCBpc1N1YnNjcmlwdGlvbiA9IG1lc3NhZ2UudHlwZSA9PT0gJ3N1YnNjcmliZSc7XG4gICAgICAgIGxldCBpc0Zyb21SZW1vdGVTTSA9IF90aGlzLmlzRnJvbVJlbW90ZVNNKG1lc3NhZ2UuZnJvbSk7XG4gICAgICAgIGlmIChpc1N1YnNjcmlwdGlvbiAmIGlzRnJvbVJlbW90ZVNNKSB7XG4gICAgICAgICAgX3RoaXMuZG9NdXR1YWxBdXRoZW50aWNhdGlvbihtZXNzYWdlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUobWVzc2FnZSk7XG4gICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChfdGhpcy5faXNUb0N5cGhlck1vZHVsZShtZXNzYWdlKSkge1xuICAgICAgICAgIF90aGlzLmlkTW9kdWxlLmVuY3J5cHRNZXNzYWdlKG1lc3NhZ2UpLnRoZW4oKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUobWVzc2FnZSk7XG4gICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGRvTXV0dWFsQXV0aGVudGljYXRpb24obWVzc2FnZSkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgbGV0IHRvID0gbWVzc2FnZS50by5zcGxpdCgnLycpO1xuICAgICAgbGV0IHN1YnNJbmRleCA9IHRvLmluZGV4T2YoJ3N1YnNjcmlwdGlvbicpO1xuICAgICAgbGV0IGlzRGF0YU9iamVjdFN1YnNjcmlwdGlvbiA9IHN1YnNJbmRleCAhPT0gLTE7XG4gICAgICBsZXQgaXNGcm9tUmVtb3RlU00gPSBfdGhpcy5pc0Zyb21SZW1vdGVTTShtZXNzYWdlLmZyb20pO1xuICAgICAgaWYgKGlzRGF0YU9iamVjdFN1YnNjcmlwdGlvbiAmIGlzRnJvbVJlbW90ZVNNKSB7XG4gICAgICAgIHRvLnBvcCgpO1xuICAgICAgICBsZXQgZGF0YU9iamVjdFVSTCA9IHRvWzBdICsgJy8vJyArIHRvWzJdICsgJy8nICsgdG9bM107XG4gICAgICAgIF90aGlzLmlkTW9kdWxlLmRvTXV0dWFsQXV0aGVudGljYXRpb24oZGF0YU9iamVjdFVSTCwgbWVzc2FnZS5ib2R5LnN1YnNjcmliZXIpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIF90aGlzLnJ1bnRpbWVSZWdpc3RyeS5yZWdpc3RlclN1YnNjcmliZXIoZGF0YU9iamVjdFVSTCwgbWVzc2FnZS5ib2R5LnN1YnNjcmliZXIpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBnZXRNeUVtYWlscygpIHtcbiAgICBsZXQgaWRlbnRpdGllcyA9IHRoaXMuaWRNb2R1bGUuZ2V0SWRlbnRpdGllcygpO1xuICAgIGxldCBlbWFpbHMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgaW4gaWRlbnRpdGllcykge1xuICAgICAgZW1haWxzLnB1c2goZ2V0VXNlckVtYWlsRnJvbVVSTChpZGVudGl0aWVzW2ldLmlkZW50aXR5KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVtYWlscztcbiAgfVxuXG4gIGdldE15SHlwZXJ0aWVzKCkge1xuICAgIGxldCBoeXBlcnRpZXMgPSB0aGlzLnJ1bnRpbWVSZWdpc3RyeS5oeXBlcnRpZXNMaXN0O1xuICAgIGxldCBoeXBlcnRpZXNOYW1lcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSBpbiBoeXBlcnRpZXMpIHtcbiAgICAgIGxldCBoeXBlcnR5TmFtZSA9IGh5cGVydGllc1tpXS5vYmplY3ROYW1lO1xuICAgICAgaWYgKGh5cGVydGllc05hbWVzLmluZGV4T2YoaHlwZXJ0eU5hbWUpID09PSAtMSkge1xuICAgICAgICBoeXBlcnRpZXNOYW1lcy5wdXNoKGh5cGVydHlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaHlwZXJ0aWVzTmFtZXM7XG4gIH1cblxuICBnZXRTZXJ2aWNlUHJvdmlkZXJQb2xpY3kobWVzc2FnZSwgaXNJbmNvbWluZykge1xuICAgIGxldCBwb2xpY3k7XG5cbiAgICBpZiAoaXNJbmNvbWluZykge1xuICAgICAgbGV0IHRvSHlwZXJ0eSA9IHRoaXMucnVudGltZVJlZ2lzdHJ5LmdldEh5cGVydHlOYW1lKG1lc3NhZ2UudG8pO1xuICAgICAgcG9saWN5ID0gdGhpcy5zZXJ2aWNlUHJvdmlkZXJQb2xpY3lbdG9IeXBlcnR5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGZyb21IeXBlcnR5ID0gdGhpcy5ydW50aW1lUmVnaXN0cnkuZ2V0SHlwZXJ0eU5hbWUobWVzc2FnZS5mcm9tKTtcbiAgICAgIHBvbGljeSA9IHRoaXMuc2VydmljZVByb3ZpZGVyUG9saWN5W2Zyb21IeXBlcnR5XTtcbiAgICB9XG4gICAgcmV0dXJuIHBvbGljeTtcbiAgfVxuXG4gIGlzRnJvbVJlbW90ZVNNKGZyb20pIHtcbiAgICBsZXQgc3BsaXRGcm9tID0gZnJvbS5zcGxpdCgnOi8vJyk7XG4gICAgcmV0dXJuIHNwbGl0RnJvbVswXSA9PT0gJ3J1bnRpbWUnICYmIGZyb20gIT09IHRoaXMucnVudGltZVJlZ2lzdHJ5LnJ1bnRpbWVVUkwgKyAnL3NtJztcbiAgfVxuXG4gIF9pc1RvU2V0SUQobWVzc2FnZSkge1xuICAgIGxldCBzY2hlbWFzVG9JZ25vcmUgPSBbJ2RvbWFpbi1pZHAnLCAncnVudGltZScsICdkb21haW4nXTtcbiAgICBsZXQgc3BsaXRGcm9tID0gKG1lc3NhZ2UuZnJvbSkuc3BsaXQoJzovLycpO1xuICAgIGxldCBmcm9tU2NoZW1hID0gc3BsaXRGcm9tWzBdO1xuXG4gICAgcmV0dXJuIHNjaGVtYXNUb0lnbm9yZS5pbmRleE9mKGZyb21TY2hlbWEpID09PSAtMTtcbiAgfVxuXG4gIGdldFVSTCh1cmwpIHtcbiAgICBsZXQgc3BsaXRVUkwgPSB1cmwuc3BsaXQoJy8nKTtcbiAgICByZXR1cm4gc3BsaXRVUkxbMF0gKyAnLy8nICsgc3BsaXRVUkxbMl0gKyAnLycgKyBzcGxpdFVSTFszXTtcbiAgfVxuXG4gIF9nZXRJZGVudGl0eShtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UudHlwZSA9PT0gJ3VwZGF0ZScpIHtcbiAgICAgIHJldHVybiB0aGlzLmlkTW9kdWxlLmdldElkZW50aXR5T2ZIeXBlcnR5KG1lc3NhZ2UuYm9keS5zb3VyY2UpO1xuICAgIH1cblxuICAgIGlmIChtZXNzYWdlLnR5cGUgPT09ICdyZXNwb25zZScgJiYgbWVzc2FnZS5ib2R5LnNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5pZE1vZHVsZS5nZXRJZGVudGl0eU9mSHlwZXJ0eShtZXNzYWdlLmJvZHkuc291cmNlKTtcbiAgICB9XG5cbiAgICBpZiAoZGl2aWRlVVJMKG1lc3NhZ2UuZnJvbSkudHlwZSA9PT0gJ2h5cGVydHknKSB7XG4gICAgICByZXR1cm4gdGhpcy5pZE1vZHVsZS5nZXRJZGVudGl0eU9mSHlwZXJ0eShtZXNzYWdlLmZyb20pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5pZE1vZHVsZS5nZXRJZGVudGl0eU9mSHlwZXJ0eSh0aGlzLmdldFVSTChtZXNzYWdlLmZyb20pKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgKiBJZGVudGlmaWVzIHRoZSBtZXNzYWdlcyB0byBiZSBmb3J3YXJkZWQgdG8gdGhlIElkZW50aXR5IE1vZHVsZSBmb3JcbiAgKiBlbmNyeXB0aW9uL2RlY3J5cHRpb24gYW5kIGludGVncml0eSB2YWxpZGF0aW9uLlxuICAqIEBwYXJhbSB7TWVzc2FnZX0gICAgbWVzc2FnZVxuICAqIEByZXR1cm5zIHtib29sZWFufSAgcmV0dXJucyB0cnVlIGlmIHRoZSBtZXNzYWdlIHJlcXVpcmVzIGVuY3J5cHRpb24vZGVjcnlwdGlvblxuICAqICAgICAgICAgICAgICAgICAgICAgb3IgaWYgaXRzIHR5cGUgZXF1YWxzICdoYW5kc2hha2UnOyBmYWxzZSBvdGhlcndpc2VcbiAgKi9cbiAgX2lzVG9DeXBoZXJNb2R1bGUobWVzc2FnZSkge1xuICAgIGxldCBpc0NyZWF0ZSA9IG1lc3NhZ2UudHlwZSA9PT0gJ2NyZWF0ZSc7XG4gICAgbGV0IGlzRnJvbUh5cGVydHkgPSBkaXZpZGVVUkwobWVzc2FnZS5mcm9tKS50eXBlID09PSAnaHlwZXJ0eSc7XG4gICAgbGV0IGlzVG9IeXBlcnR5ID0gZGl2aWRlVVJMKG1lc3NhZ2UudG8pLnR5cGUgPT09ICdoeXBlcnR5JztcbiAgICBsZXQgaXNUb0RhdGFPYmplY3QgPSBpc0RhdGFPYmplY3RVUkwobWVzc2FnZS50byk7XG5cbiAgICByZXR1cm4gKGlzQ3JlYXRlICYmIGlzRnJvbUh5cGVydHkgJiYgaXNUb0h5cGVydHkpIHx8IChpc0NyZWF0ZSAmJiBpc0Zyb21IeXBlcnR5ICYmIGlzVG9EYXRhT2JqZWN0KSB8fCBtZXNzYWdlLnR5cGUgPT09ICdoYW5kc2hha2UnIHx8IG1lc3NhZ2UudHlwZSA9PT0gJ3VwZGF0ZSc7XG4gIH1cblxuICAvKipcbiAgKiBDcmVhdGVzIGEgZ3JvdXAgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAgKiBAcGFyYW0gIHtTdHJpbmd9ICBncm91cE5hbWVcbiAgKi9cbiAgX2xvYWRVc2VyUG9saWNpZXMoKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cbiAgICAgIF90aGlzLnN0b3JhZ2VNYW5hZ2VyLmdldCgncmV0aGluazp1c2VyUG9saWNpZXMnKS50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgICBsZXQgcG9saWNpZXMgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHBvbGljaWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBmb3IgKGxldCBpIGluIHBvbGljaWVzKSB7XG4gICAgICAgICAgICB0aGlzLnBlcC5hZGRQb2xpY3koJ1VTRVInLCBpLCBwb2xpY2llc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gIH1cblxuICBfZ2V0TGFzdENvbXBvbmVudE9mVVJMKHVybCkge1xuICAgIGxldCBzcGxpdCA9IHVybC5zcGxpdCgnLycpO1xuICAgIHJldHVybiBzcGxpdFtzcGxpdC5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIF9nZXRQb2xpY2llc0pTT04ocG9saWNpZXMpIHtcbiAgICBmb3IgKGxldCBpIGluIHBvbGljaWVzKSB7XG4gICAgICBsZXQgY29tYmluaW5nQWxnb3JpdGhtID0gcG9saWNpZXNbaV0uY29tYmluaW5nQWxnb3JpdGhtO1xuICAgICAgaWYgKGNvbWJpbmluZ0FsZ29yaXRobSBpbnN0YW5jZW9mIEJsb2NrT3ZlcnJpZGVzKSB7XG4gICAgICAgIHBvbGljaWVzW2ldLmNvbWJpbmluZ0FsZ29yaXRobSA9ICdibG9ja092ZXJyaWRlcyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY29tYmluaW5nQWxnb3JpdGhtIGluc3RhbmNlb2YgQWxsb3dPdmVycmlkZXMpIHtcbiAgICAgICAgICBwb2xpY2llc1tpXS5jb21iaW5pbmdBbGdvcml0aG0gPSAnYWxsb3dPdmVycmlkZXMnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjb21iaW5pbmdBbGdvcml0aG0gaW5zdGFuY2VvZiBGaXJzdEFwcGxpY2FibGUpIHtcbiAgICAgICAgICAgIHBvbGljaWVzW2ldLmNvbWJpbmluZ0FsZ29yaXRobSA9ICdmaXJzdEFwcGxpY2FibGUnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb2xpY2llc1tpXS5jb21iaW5pbmdBbGdvcml0aG0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvbGljaWVzO1xuICB9XG5cbiAgc2F2ZUFjdGl2ZVBvbGljeSgpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIF90aGlzLnN0b3JhZ2VNYW5hZ2VyLnNldCgncmV0aGluazphY3RpdmVQb2xpY3knLCAwLCB0aGlzLmFjdGl2ZVVzZXJQb2xpY3kpLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHNhdmVHcm91cHMoKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBfdGhpcy5zdG9yYWdlTWFuYWdlci5zZXQoJ3JldGhpbms6Z3JvdXBzJywgMCwgdGhpcy5ncm91cHMpLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHNhdmVQb2xpY2llcyhzb3VyY2UsIHBvbGljeSwga2V5KSB7XG4gICAgbGV0IHBvbGljaWVzSnNvbjtcblxuICAgIHN3aXRjaCAoc291cmNlKSB7XG4gICAgICBjYXNlICdVU0VSJzpcbiAgICAgICAgcG9saWNpZXNKc29uID0gSlNPTi5zdHJpbmdpZnkodGhpcy51c2VyUG9saWNpZXMpO1xuICAgICAgICBwb2xpY2llc0pzb24gPSB0aGlzLl9nZXRQb2xpY2llc0pTT04oSlNPTi5wYXJzZShwb2xpY2llc0pzb24pKTtcbiAgICAgICAgdGhpcy5zdG9yYWdlTWFuYWdlci5zZXQoJ3JldGhpbms6dXNlclBvbGljaWVzJywgMCwgcG9saWNpZXNKc29uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdTRVJWSUNFX1BST1ZJREVSJzpcbiAgICAgICAgaWYgKHBvbGljeSAhPT0gdW5kZWZpbmVkICYga2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnNlcnZpY2VQcm92aWRlclBvbGljeVtrZXldID0gcG9saWN5O1xuICAgICAgICB9XG4gICAgICAgIHBvbGljaWVzSnNvbiA9IEpTT04uc3RyaW5naWZ5KHRoaXMuc2VydmljZVByb3ZpZGVyUG9saWN5KTtcbiAgICAgICAgcG9saWNpZXNKc29uID0gdGhpcy5fZ2V0UG9saWNpZXNKU09OKEpTT04ucGFyc2UocG9saWNpZXNKc29uKSk7XG4gICAgICAgIHRoaXMuc3RvcmFnZU1hbmFnZXIuc2V0KCdyZXRoaW5rOnNwUG9saWNpZXMnLCAwLCBwb2xpY2llc0pzb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IEVycm9yKCdVbmtub3duIHBvbGljeSBzb3VyY2U6ICcgKyBzb3VyY2UpO1xuICAgIH1cbiAgfVxuXG4gIGdldEdyb3Vwc05hbWVzKCkge1xuICAgIGxldCBteUdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuICAgIGxldCBncm91cHNOYW1lcyA9IFtdO1xuICAgIGlmIChteUdyb3VwcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IgKGxldCBncm91cE5hbWUgaW4gbXlHcm91cHMpIHtcbiAgICAgICAgZ3JvdXBzTmFtZXMucHVzaChncm91cE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ3JvdXBzTmFtZXM7XG4gIH1cblxuICBnZXRHcm91cChncm91cE5hbWUsIGRlc3RpbmF0aW9uKSB7XG4gICAgbGV0IG1lbWJlcnMgPSBbXTtcblxuICAgIGlmIChncm91cE5hbWUgPT09ICdwcmVhdXRob3Jpc2VkJykge1xuICAgICAgbGV0IGRhdGFPYmplY3RVUkwgPSBkZXN0aW5hdGlvbi5zcGxpdCgnLycpO1xuICAgICAgZGF0YU9iamVjdFVSTC5wb3AoKTtcbiAgICAgIGRhdGFPYmplY3RVUkwgPSBkYXRhT2JqZWN0VVJMWzBdICsgJy8vJyArIGRhdGFPYmplY3RVUkxbMl07XG4gICAgICBtZW1iZXJzID0gdGhpcy5ydW50aW1lUmVnaXN0cnkuZ2V0UHJlQXV0aFN1YnNjcmliZXJzKGRhdGFPYmplY3RVUkwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5ncm91cHNbZ3JvdXBOYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1lbWJlcnMgPSB0aGlzLmdyb3Vwc1tncm91cE5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtZW1iZXJzO1xuICB9XG5cbiAgLyoqXG4gICogQ3JlYXRlcyBhIGdyb3VwIHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gICogQHBhcmFtICB7U3RyaW5nfSAgZ3JvdXBOYW1lXG4gICovXG4gIGNyZWF0ZUdyb3VwKGdyb3VwTmFtZSkge1xuICAgIHRoaXMuZ3JvdXBzW2dyb3VwTmFtZV0gPSBbXTtcbiAgICB0aGlzLnNhdmVHcm91cHMoKTtcbiAgfVxuXG4gIGRlbGV0ZUdyb3VwKGdyb3VwTmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLmdyb3Vwc1tncm91cE5hbWVdO1xuICAgIHRoaXMuc2F2ZUdyb3VwcygpO1xuICB9XG5cbiAgLyoqXG4gICogQWRkcyB0aGUgZ2l2ZW4gdXNlciBlbWFpbCB0byB0aGUgZ3JvdXAgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAgKiBAcGFyYW0gIHtTdHJpbmd9ICB1c2VyRW1haWxcbiAgKiBAcGFyYW0gIHtTdHJpbmd9ICBncm91cE5hbWVcbiAgKi9cbiAgYWRkVG9Hcm91cChncm91cE5hbWUsIHVzZXJFbWFpbCkge1xuICAgIGxldCBteUdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuICAgIGlmIChteUdyb3Vwc1tncm91cE5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChteUdyb3Vwc1tncm91cE5hbWVdLmluZGV4T2YodXNlckVtYWlsKSA9PT0gLTEpIHtcbiAgICAgICAgbXlHcm91cHNbZ3JvdXBOYW1lXS5wdXNoKHVzZXJFbWFpbCk7XG4gICAgICAgIHRoaXMuc2F2ZUdyb3VwcygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcignR3JvdXAgXCInICsgZ3JvdXBOYW1lICsgJ1wiIGRvZXMgbm90IGV4aXN0IScpO1xuICAgIH1cbiAgfVxuXG4gIHJlbW92ZUZyb21Hcm91cChncm91cE5hbWUsIHVzZXJFbWFpbCkge1xuICAgIGxldCBncm91cCA9IHRoaXMuZ3JvdXBzW2dyb3VwTmFtZV07XG5cbiAgICBncm91cC5zcGxpY2UoZ3JvdXAuaW5kZXhPZih1c2VyRW1haWwpLCAxKTtcbiAgICB0aGlzLnNhdmVHcm91cHMoKTtcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFJ1bnRpbWVDb3JlQ3R4O1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDE2IFBUIElub3Zhw6fDo28gZSBTaXN0ZW1hcyBTQVxuKiBDb3B5cmlnaHQgMjAxNiBJTkVTQy1JRFxuKiBDb3B5cmlnaHQgMjAxNiBRVU9CSVMgTkVUV09SS1MgU0xcbiogQ29weXJpZ2h0IDIwMTYgRlJBVU5IT0ZFUi1HRVNFTExTQ0hBRlQgWlVSIEZPRVJERVJVTkcgREVSIEFOR0VXQU5EVEVOIEZPUlNDSFVORyBFLlZcbiogQ29weXJpZ2h0IDIwMTYgT1JBTkdFIFNBXG4qIENvcHlyaWdodCAyMDE2IERldXRzY2hlIFRlbGVrb20gQUdcbiogQ29weXJpZ2h0IDIwMTYgQXBpemVlXG4qIENvcHlyaWdodCAyMDE2IFRFQ0hOSVNDSEUgVU5JVkVSU0lUQVQgQkVSTElOXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbioqL1xuaW1wb3J0IFJlZ2lzdHJ5RGF0YU1vZGVsIGZyb20gJy4vUmVnaXN0cnlEYXRhTW9kZWwnO1xuXG4vKipcbiogICBAYXV0aG9yOiBHaWwgRGlhcyAoZ2lsLmRpYXNAdGVjbmljby51bGlzYm9hLnB0KVxuKiAgIEh5cGVydHlJbnN0YW5jZSBEYXRhIE1vZGVsIHVzZWQgdG8gbW9kZWwgaW5zdGFuY2VzIG9mIEh5cGVydGllcyBydW5uaW5nIGluIGRldmljZXMgYW5kIHNlcnZlcnMuXG4qL1xuY2xhc3MgSHlwZXJ0eUluc3RhbmNlIGV4dGVuZHMgUmVnaXN0cnlEYXRhTW9kZWwge1xuXG4gIGNvbnN0cnVjdG9yKGlkLCB1cmwsIGRlc2NyaXB0b3JVUkwsZGVzY3JpcHRvciwgaHlwZXJ0eVVSTCwgdXNlciwgZ3VpZCwgcnVudGltZSwgY29udGV4dCkge1xuICAgIHN1cGVyKGlkLCB1cmwsIGRlc2NyaXB0b3JVUkwpO1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG4gICAgX3RoaXMuX2Rlc2NyaXB0b3IgPSBkZXNjcmlwdG9yO1xuICAgIF90aGlzLl9oeXBlcnR5VVJMID0gaHlwZXJ0eVVSTDtcbiAgICBfdGhpcy5fdXNlciA9IHVzZXI7XG4gICAgX3RoaXMuX2d1aWQgPSBndWlkO1xuICAgIF90aGlzLl9ydW50aW1lID0gcnVudGltZTtcbiAgICBfdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIH1cblxuICBzZXQgdXNlcihpZGVudGl0eSkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG4gICAgX3RoaXMudXNlciA9IGlkZW50aXR5O1xuICB9XG5cbiAgZ2V0IHVzZXIoKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcbiAgICByZXR1cm4gX3RoaXMuX3VzZXI7XG4gIH1cblxuICBnZXQgaHlwZXJ0eVVSTCgpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuICAgIHJldHVybiBfdGhpcy5faHlwZXJ0eVVSTDtcbiAgfVxuXG4gIGdldCBkZXNjcmlwdG9yKCkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG4gICAgcmV0dXJuIF90aGlzLl9kZXNjcmlwdG9yO1xuICB9XG5cbiAgZ2V0IG9iamVjdE5hbWUoKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcbiAgICByZXR1cm4gX3RoaXMuX2Rlc2NyaXB0b3IuX29iamVjdE5hbWU7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSHlwZXJ0eUluc3RhbmNlO1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDE2IFBUIElub3Zhw6fDo28gZSBTaXN0ZW1hcyBTQVxuKiBDb3B5cmlnaHQgMjAxNiBJTkVTQy1JRFxuKiBDb3B5cmlnaHQgMjAxNiBRVU9CSVMgTkVUV09SS1MgU0xcbiogQ29weXJpZ2h0IDIwMTYgRlJBVU5IT0ZFUi1HRVNFTExTQ0hBRlQgWlVSIEZPRVJERVJVTkcgREVSIEFOR0VXQU5EVEVOIEZPUlNDSFVORyBFLlZcbiogQ29weXJpZ2h0IDIwMTYgT1JBTkdFIFNBXG4qIENvcHlyaWdodCAyMDE2IERldXRzY2hlIFRlbGVrb20gQUdcbiogQ29weXJpZ2h0IDIwMTYgQXBpemVlXG4qIENvcHlyaWdodCAyMDE2IFRFQ0hOSVNDSEUgVU5JVkVSU0lUQVQgQkVSTElOXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbioqL1xuaW1wb3J0IEFkZHJlc3NBbGxvY2F0aW9uIGZyb20gJy4uL2FsbG9jYXRpb24vQWRkcmVzc0FsbG9jYXRpb24nO1xuaW1wb3J0IEh5cGVydHlJbnN0YW5jZSBmcm9tICcuL0h5cGVydHlJbnN0YW5jZSc7XG5cbmltcG9ydCB7TWVzc2FnZUZhY3Rvcnl9IGZyb20gJ3NlcnZpY2UtZnJhbWV3b3JrL2Rpc3QvTWVzc2FnZUZhY3RvcnknO1xuaW1wb3J0IHtkaXZpZGVVUkx9IGZyb20gJy4uL3V0aWxzL3V0aWxzLmpzJztcblxuY29uc3QgU1RBVFVTID0geyBERVBMT1lFRDogJ2RlcGxveWVkJywgUFJPR1JFU1M6ICdpbi1wcm9ncmVzcycgfTtcblxuLyppbXBvcnQgSWRlbnRpdHlNYW5hZ2VyIGZyb20gJy4vSWRlbnRpdHlNYW5hZ2VyJztcbmltcG9ydCBEaXNjb3ZlcnkgZnJvbSAnLi9EaXNjb3ZlcnknOyovXG5cbi8qKlxuKiBSdW50aW1lIFJlZ2lzdHJ5IEludGVyZmFjZVxuKi9cbmNsYXNzIFJlZ2lzdHJ5IHtcblxuICAvKipcbiAgKiBUbyBpbml0aWFsaXNlIHRoZSBSdW50aW1lIFJlZ2lzdHJ5IHdpdGggdGhlIFJ1bnRpbWVVUkwgdGhhdCB3aWxsIGJlIHRoZSBiYXNpcyB0byBkZXJpdmUgdGhlIGludGVybmFsIHJ1bnRpbWUgYWRkcmVzc2VzIHdoZW4gYWxsb2NhdGluZyBhZGRyZXNzZXMgdG8gaW50ZXJuYWwgcnVudGltZSBjb21wb25lbnQuIEluIGFkZGl0aW9uLCB0aGUgUmVnaXN0cnkgZG9tYWluIGJhY2stZW5kIHRvIGJlIHVzZWQgdG8gcmVtb3RlbHkgcmVnaXN0ZXIgUnVudGltZSBjb21wb25lbnRzLCBpcyBhbHNvIHBhc3NlZCBhcyBpbnB1dCBwYXJhbWV0ZXIuXG4gICogQHBhcmFtICB7TWVzc2FnZUJ1c30gICAgICAgICAgbXNnYnVzICAgICAgICAgICAgICAgIG1zZ2J1c1xuICAqIEBwYXJhbSAge0h5cGVydHlSdW50aW1lVVJMfSAgIHJ1bnRpbWVVUkwgICAgICAgICAgICBydW50aW1lVVJMXG4gICogQHBhcmFtICB7QXBwU2FuZGJveH0gICAgICAgICAgYXBwU2FuZGJveCAgICAgICAgICAgIGFwcFNhbmRib3hcbiAgKiBAcGFyYW0gIHtydW50aW1lQ2F0YWxvZ3VlfSAgICBydW50aW1lQ2F0YWxvZ3VlICAgICAgcnVudGltZUNhdGFsb2d1ZVxuICAqIEBwYXJhbSAge0RvbWFpblVSTH0gICAgICAgICAgIHJlbW90ZVJlZ2lzdHJ5ICAgICAgICByZW1vdGVSZWdpc3RyeVxuICAqIEBwYXJhbSAge3N0b3JhZ2VNYW5hZ2VyfSAgICAgIHN0b3JhZ2VNYW5hZ2VyXG4gICovXG4gIGNvbnN0cnVjdG9yKHJ1bnRpbWVVUkwsIGFwcFNhbmRib3gsIGlkZW50aXR5TW9kdWxlLCBydW50aW1lQ2F0YWxvZ3VlLCBydW50aW1lQ2FwYWJpbGl0aWVzLCBzdG9yYWdlTWFuYWdlciwgcmVtb3RlUmVnaXN0cnkpIHtcblxuICAgIC8vIGhvdyBzb21lIGZ1bmN0aW9ucyByZWNlaXZlIHRoZSBwYXJhbWV0ZXJzIGZvciBleGFtcGxlOlxuICAgIC8vIG5ldyBSZWdpc3RyeSgnaHlwZXJ0eS1ydW50aW1lOi8vc3AxLzEyMycsIGFwcFNhbmRib3gsIGlkTW9kdWxlLCByZW1vdGVSZWdpc3RyeSk7XG4gICAgLy8gcmVnaXN0cnkucmVnaXN0ZXJTdHViKHNhbmRib3gsICdzcDEnKTtcbiAgICAvLyByZWdpc3RyeS5yZWdpc3Rlckh5cGVydHkoc2FuZEJveCwgJ2h5cGVydHktcnVudGltZTovL3NwMS8xMjMnKTtcbiAgICAvLyByZWdpc3RyeS5yZXNvbHZlKCdoeXBlcnR5LXJ1bnRpbWU6Ly9zcDEvMTIzJyk7XG5cbiAgICBpZiAoIXJ1bnRpbWVVUkwpIHRocm93IG5ldyBFcnJvcigncnVudGltZVVSTCBpcyBtaXNzaW5nLicpO1xuICAgIGlmICghc3RvcmFnZU1hbmFnZXIpIHRocm93IG5ldyBFcnJvcignc3RvcmFnZU1hbmFnZXIgaXMgbWlzc2luZy4nKTtcbiAgICAvKmlmICghcmVtb3RlUmVnaXN0cnkpIHRocm93IG5ldyBFcnJvcigncmVtb3RlUmVnaXN0cnkgaXMgbWlzc2luZycpOyovXG5cbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgX3RoaXMucmVnaXN0cnlVUkwgPSBydW50aW1lVVJMICsgJy9yZWdpc3RyeS8nO1xuICAgIF90aGlzLmFwcFNhbmRib3ggPSBhcHBTYW5kYm94O1xuICAgIF90aGlzLnJ1bnRpbWVVUkwgPSBydW50aW1lVVJMO1xuICAgIF90aGlzLnJ1bnRpbWVDYXRhbG9ndWUgPSBydW50aW1lQ2F0YWxvZ3VlO1xuICAgIF90aGlzLnJlbW90ZVJlZ2lzdHJ5ID0gcmVtb3RlUmVnaXN0cnk7XG4gICAgX3RoaXMuaWRNb2R1bGUgPSBpZGVudGl0eU1vZHVsZTtcbiAgICBfdGhpcy5zdG9yYWdlTWFuYWdlciA9IHN0b3JhZ2VNYW5hZ2VyO1xuICAgIF90aGlzLnJ1bnRpbWVDYXBhYmlsaXRpZXMgPSBydW50aW1lQ2FwYWJpbGl0aWVzO1xuICAgIF90aGlzLmlkZW50aWZpZXIgPSBNYXRoLmZsb29yKChNYXRoLnJhbmRvbSgpICogMTAwMDApICsgMSk7XG5cbiAgICAvLyB0aGUgZXhwaXJlcyBpbiAzNjAwLCByZXByZXNlbnRzIDEgaG91clxuICAgIC8vdGhlIGV4cGlyZXMgaXMgaW4gc2Vjb25kcywgdW5pdCBvZiBtZWFzdXJlIHJlY2VpdmVkIGJ5IHRoZSBkb21haW4gcmVnaXN0cnlcbiAgICBfdGhpcy5leHBpcmVzVGltZSA9IDM2MDA7XG5cbiAgICBfdGhpcy5oeXBlcnRpZXNMaXN0VG9SZW1vdmUgPSB7fTtcbiAgICBfdGhpcy5oeXBlcnRpZXNMaXN0ID0gW107XG4gICAgX3RoaXMucHJvdG9zdHVic0xpc3QgPSB7fTtcbiAgICBfdGhpcy5pZHBQcm94eUxpc3QgPSB7fTtcbiAgICBfdGhpcy5kYXRhT2JqZWN0TGlzdCA9IHt9O1xuICAgIF90aGlzLnN1YnNjcmliZWREYXRhT2JqZWN0TGlzdCA9IHt9O1xuICAgIF90aGlzLnNhbmRib3hlc0xpc3QgPSB7c2FuZGJveDoge30sIGFwcFNhbmRib3g6IHt9IH07XG4gICAgX3RoaXMucGVwTGlzdCA9IHt9O1xuXG4gICAgX3RoaXMuX2RvbWFpbiA9IGRpdmlkZVVSTChfdGhpcy5yZWdpc3RyeVVSTCkuZG9tYWluO1xuICAgIF90aGlzLnNhbmRib3hlc0xpc3QuYXBwU2FuZGJveFtydW50aW1lVVJMXSA9IGFwcFNhbmRib3g7XG4gICAgbGV0IG1zZ0ZhY3RvcnkgPSBuZXcgTWVzc2FnZUZhY3RvcnkoJ2ZhbHNlJywgJ3t9Jyk7XG4gICAgX3RoaXMubWVzc2FnZUZhY3RvcnkgPSBtc2dGYWN0b3J5O1xuICB9XG5cbiAgc2V0IGxvYWRlcihsb2FkZXIpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuICAgIF90aGlzLl9sb2FkZXIgPSBsb2FkZXI7XG4gIH1cblxuICBnZXQgbG9hZGVyKCkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG4gICAgcmV0dXJuIF90aGlzLl9sb2FkZXI7XG4gIH1cblxuICAvKipcbiAgKiByZXR1cm4gdGhlIG1lc3NhZ2VCdXMgaW4gdGhpcyBSZWdpc3RyeVxuICAqIEBwYXJhbSB7TWVzc2FnZUJ1c30gICAgICAgICAgIG1lc3NhZ2VCdXNcbiAgKi9cbiAgZ2V0IG1lc3NhZ2VCdXMoKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcbiAgICByZXR1cm4gX3RoaXMuX21lc3NhZ2VCdXM7XG4gIH1cblxuICAvKipcbiAgKiBTZXQgdGhlIG1lc3NhZ2VCdXMgaW4gdGhpcyBSZWdpc3RyeVxuICAqIEBwYXJhbSB7TWVzc2FnZUJ1c30gICAgICAgICAgIG1lc3NhZ2VCdXNcbiAgKi9cbiAgc2V0IG1lc3NhZ2VCdXMobWVzc2FnZUJ1cykge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG4gICAgX3RoaXMuX21lc3NhZ2VCdXMgPSBtZXNzYWdlQnVzO1xuXG4gICAgX3RoaXMuX21lc3NhZ2VCdXMuYWRkTGlzdGVuZXIoX3RoaXMucmVnaXN0cnlVUkwsIGZ1bmN0aW9uKG1zZykge1xuXG4gICAgICBsZXQgdXNlclVybCA9IF90aGlzLl9nZXRJZGVudGl0eUFzc29jaWF0ZWQobXNnLmJvZHkucmVzb3VyY2UsIG1zZy5ib2R5LmNyaXRlcmlhKTtcblxuICAgICAgbGV0IHJlcGx5ID0ge2lkOiBtc2cuaWQsIHR5cGU6ICdyZXNwb25zZScsIHRvOiBtc2cuZnJvbSwgZnJvbTogbXNnLnRvLCBib2R5OiB7cmVzb3VyY2U6IHVzZXJVcmx9fTtcbiAgICAgIHJlcGx5LmJvZHkuY29kZSA9ICh1c2VyVXJsKSA/IDIwMCA6IDQwNDtcblxuICAgICAgX3RoaXMuX21lc3NhZ2VCdXMucG9zdE1lc3NhZ2UocmVwbHkpO1xuICAgIH0pO1xuXG4gICAgLy8gYWxzbyBzZXQgdXAgbWVzc2FnZUJ1cyBpbiB0aGUgSWRlbnRpdHlNb2R1bGUgY29tcG9uZW50XG4gICAgLy8gVE9ETyByZWRlZmluZSBhIGJldHRlciB3YXkgdG8gYWRkIHRoZSBtZXNzYWdlQnVzIGluIHRoZSBJZE1vZHVsZVxuICAgIF90aGlzLmlkTW9kdWxlLm1lc3NhZ2VCdXMgPSBtZXNzYWdlQnVzO1xuXG4gICAgLy8gSW5zdGFsbCBBZGRyZXNzQWxsb2NhdGlvblxuICAgIGxldCBhZGRyZXNzQWxsb2NhdGlvbiA9IG5ldyBBZGRyZXNzQWxsb2NhdGlvbihfdGhpcy5yZWdpc3RyeVVSTCwgbWVzc2FnZUJ1cywgX3RoaXMpO1xuICAgIF90aGlzLmFkZHJlc3NBbGxvY2F0aW9uID0gYWRkcmVzc0FsbG9jYXRpb247XG5cbiAgfVxuXG4gIC8qKlxuICAqIGZ1bmN0aW9uIHRvIHJlcXVlc3QgYWJvdXQgdXNlcnMgcmVnaXN0ZXJlZCBpbiBkb21haW4gcmVnaXN0cnksIGFuZFxuICAqIHJldHVybiB0aGUgbGFzdCBoeXBlcnR5IGluc3RhbmNlIHJlZ2lzdGVyZWQgYnkgdGhlIHVzZXIuXG4gICogQHBhcmFtICB7ZW1haWx9ICAgICAgICAgICAgICBlbWFpbFxuICAqIEBwYXJhbSAge2RvbWFpbn0gICAgICAgICAgICBkb21haW4gKE9wdGlvbmFsKVxuICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgIFByb21pc2VcbiAgKi9cblxuICAvLyBUT0RPOiBpbXBsZW1lbnQgYSBjYWNoZSBzeXN0ZW1cbiAgZGlzY292ZXJIeXBlcnR5UGVyVXNlcihlbWFpbCwgZG9tYWluKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcbiAgICBsZXQgYWN0aXZlRG9tYWluO1xuXG4gICAgaWYgKCFkb21haW4pIHtcbiAgICAgIGFjdGl2ZURvbWFpbiA9IF90aGlzLl9kb21haW47XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjdGl2ZURvbWFpbiA9IGRvbWFpbjtcbiAgICB9XG5cbiAgICBsZXQgaWRlbnRpdHlVUkwgPSAndXNlcjovLycgKyBlbWFpbC5zdWJzdHJpbmcoZW1haWwuaW5kZXhPZignQCcpICsgMSwgZW1haWwubGVuZ3RoKSArICcvJyArIGVtYWlsLnN1YnN0cmluZygwLCBlbWFpbC5pbmRleE9mKCdAJykpO1xuXG4gICAgLy8gbWVzc2FnZSB0byBxdWVyeSBkb21haW4gcmVnaXN0cnksIGFza2luZyBmb3IgYSB1c2VyIGh5cGVydHkuXG4gICAgbGV0IG1lc3NhZ2UgPSB7XG4gICAgICB0eXBlOiAncmVhZCcsIGZyb206IF90aGlzLnJlZ2lzdHJ5VVJMLCB0bzogJ2RvbWFpbjovL3JlZ2lzdHJ5LicgKyBhY3RpdmVEb21haW4gKyAnLycsIGJvZHk6IHsgcmVzb3VyY2U6IGlkZW50aXR5VVJMfVxuICAgIH07XG5cbiAgICBjb25zb2xlLmxvZygnTWVzc2FnZTogJywgbWVzc2FnZSwgYWN0aXZlRG9tYWluLCBpZGVudGl0eVVSTCk7XG5cbiAgICAvL2NvbnNvbGUubG9nKCdtZXNzYWdlIFJFQUQnLCBtZXNzYWdlKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cbiAgICAgIF90aGlzLl9tZXNzYWdlQnVzLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIChyZXBseSkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnbWVzc2FnZSByZXBseScsIHJlcGx5KTtcblxuICAgICAgICBsZXQgaHlwZXJ0eTtcbiAgICAgICAgbGV0IG1vc3RSZWNlbnQ7XG4gICAgICAgIGxldCBsYXN0SHlwZXJ0eTtcbiAgICAgICAgbGV0IHZhbHVlID0gcmVwbHkuYm9keS52YWx1ZTtcblxuICAgICAgICBmb3IgKGh5cGVydHkgaW4gdmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWVbaHlwZXJ0eV0ubGFzdE1vZGlmaWVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChtb3N0UmVjZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbW9zdFJlY2VudCA9IG5ldyBEYXRlKHZhbHVlW2h5cGVydHldLmxhc3RNb2RpZmllZCk7XG4gICAgICAgICAgICAgIGxhc3RIeXBlcnR5ID0gaHlwZXJ0eTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxldCBoeXBlcnR5RGF0ZSA9IG5ldyBEYXRlKHZhbHVlW2h5cGVydHldLmxhc3RNb2RpZmllZCk7XG4gICAgICAgICAgICAgIGlmIChtb3N0UmVjZW50LmdldFRpbWUoKSA8IGh5cGVydHlEYXRlLmdldFRpbWUoKSkge1xuICAgICAgICAgICAgICAgIG1vc3RSZWNlbnQgPSBoeXBlcnR5RGF0ZTtcbiAgICAgICAgICAgICAgICBsYXN0SHlwZXJ0eSA9IGh5cGVydHk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZygnTGFzdCBIeXBlcnR5OiAnLCBsYXN0SHlwZXJ0eSwgbW9zdFJlY2VudCk7XG5cbiAgICAgICAgbGV0IGh5cGVydHlVUkwgPSBsYXN0SHlwZXJ0eTtcblxuICAgICAgICBpZiAoaHlwZXJ0eVVSTCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdCgnVXNlciBIeXBlcnR5IG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGlkUGFja2FnZSA9IHtcbiAgICAgICAgICBpZDogZW1haWwsXG4gICAgICAgICAgZGVzY3JpcHRvcjogdmFsdWVbaHlwZXJ0eVVSTF0uZGVzY3JpcHRvcixcbiAgICAgICAgICBoeXBlcnR5VVJMOiBoeXBlcnR5VVJMXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc29sZS5sb2coJz09PT4gaHlwZXJ0eURpc2NvdmVyeSBtZXNzYWdlQnVuZGxlOiAnLCBpZFBhY2thZ2UpO1xuICAgICAgICByZXNvbHZlKGlkUGFja2FnZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIF9nZXRJZGVudGl0eUFzc29jaWF0ZWQodHlwZSwgaHlwZXJ0eVVSTCkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG5cbiAgICBmb3IgKGxldCBoeXBlcnR5IGluIF90aGlzLmh5cGVydGllc0xpc3QpIHtcbiAgICAgIGxldCB2YWx1ZSA9IF90aGlzLmh5cGVydGllc0xpc3RbaHlwZXJ0eV07XG4gICAgICBpZiAodmFsdWUuX2h5cGVydHlVUkwgPT09IGh5cGVydHlVUkwpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAndXNlcm5hbWUnOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLl91c2VyLnVzZXJuYW1lO1xuICAgICAgICAgIGNhc2UgJ2NuJzpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5fdXNlci5jbjtcbiAgICAgICAgICBjYXNlICdsb2NhbGUnOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLl91c2VyLmxvY2FsZTtcbiAgICAgICAgICBjYXNlICdhdmF0YXInOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLl91c2VyLmF2YXRhcjtcbiAgICAgICAgICBjYXNlICd1c2VyVVJMJzpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5fdXNlci51c2VyVVJMO1xuICAgICAgICAgIGNhc2UgJy4nOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLl91c2VyO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgLyoqXG4gICogcXVlcnkgdGhlIGRvbWFpbiByZWdpc3RyeSBmb3IgaW5mb3JtYXRpb24gZnJvbSBhIGRhdGFPYmplY3QgVVJMXG4gICogQHBhcmFtICB7U3RyaW5nfSAgIHVybCAgICAgICAgICAgIGRhdGFPYmplY3QgVVJMXG4gICogQHJldHVybiB7SlNPTn0gICAgIGRhdGFPYmplY3QgICAgIGRhdGEgb2JqZWN0XG4gICovXG4gIGRpc2NvdmVyRGF0YU9iamVjdFBlclVSTCh1cmwsIGRvbWFpbikge1xuXG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblxuICAgICAgbGV0IGFjdGl2ZURvbWFpbjtcblxuICAgICAgaWYgKCFkb21haW4pIHtcbiAgICAgICAgYWN0aXZlRG9tYWluID0gX3RoaXMuX2RvbWFpbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2ZURvbWFpbiA9IGRvbWFpbjtcbiAgICAgIH1cblxuICAgICAgbGV0IG1zZyA9IHtcbiAgICAgICAgdHlwZTogJ3JlYWQnLCBmcm9tOiBfdGhpcy5yZWdpc3RyeVVSTCwgdG86ICdkb21haW46Ly9yZWdpc3RyeS4nICsgYWN0aXZlRG9tYWluICsgJy8nLCBib2R5OiB7IHJlc291cmNlOiB1cmwgfVxuICAgICAgfTtcblxuICAgICAgX3RoaXMuX21lc3NhZ2VCdXMucG9zdE1lc3NhZ2UobXNnLCAocmVwbHkpID0+IHtcblxuICAgICAgICBsZXQgZGF0YU9iamVjdCA9IHJlcGx5LmJvZHkudmFsdWU7XG5cbiAgICAgICAgaWYgKGRhdGFPYmplY3QpIHtcbiAgICAgICAgICByZXNvbHZlKGRhdGFPYmplY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdCgnRGF0YU9iamVjdCBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcmV0dXJuIHRoZSBzYW5kYm94IGluc3RhbmNlIHdoZXJlIHRoZSBBcHBsaWNhdGlvbiBpcyBleGVjdXRpbmcuIEl0IGlzIGFzc3VtZWQgdGhlcmUgaXMganVzdCBvbmUgQXBwIHBlciBSdW50aW1lIGluc3RhbmNlLlxuICAqL1xuICBnZXRBcHBTYW5kYm94KCkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG4gICAgcmV0dXJuIF90aGlzLmFwcFNhbmRib3g7XG4gIH1cblxuICAvKipcbiAgKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHVzZXIgYXNzb2NpYXRlZCB0byB0aGUgaHlwZXJ0eSBVUkxcbiAgKiBAcGFyYW0gICAge1N0cmluZ30gICAgaHlwZXJ0eVVSTCAgICAgIGh5cGVydHkgVVJMXG4gICogQHJldHVybiAgIHtTdHJpbmd9ICAgIHVzZXJVUkwgICAgICAgICB1c2VyIFVSTFxuICAqL1xuICBnZXRIeXBlcnR5T3duZXIoaHlwZXJ0eVVSTCkge1xuXG4gICAgbGV0IF90aGlzID0gdGhpcztcbiAgICBsZXQgdXNlclVSTDtcblxuICAgIGZvciAobGV0IGluZGV4IGluIF90aGlzLmh5cGVydGllc0xpc3QpIHtcbiAgICAgIGxldCBoeXBlcnR5ID0gX3RoaXMuaHlwZXJ0aWVzTGlzdFtpbmRleF07XG4gICAgICBpZiAoaHlwZXJ0eS5oeXBlcnR5VVJMID09PSBoeXBlcnR5VVJMKSB7XG4gICAgICAgIHVzZXJVUkwgPSBoeXBlcnR5LnVzZXIudXNlclVSTDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVzZXJVUkw7XG4gIH1cblxuICAvKipcbiAgKiByZXR1cm5zIHRoZSBoeXBlcnR5IE5hbWUgZnJvbSBhIGdpdmVuIHVybC4gVGhpcyB1cmwgY291bGQgYmUgZnJvbSBhIGRhdGFPYmplY3Qgb3IgaHlwZXJ0eVxuICAqIEBwYXJhbSAgICB7U3RyaW5nfSAgICB1cmwgICAgICBoeXBlcnR5IG9yIGRhdGFPYmplY3QgVVJMXG4gICogQHJldHVybiAgIHtTdHJpbmd9ICAgIGh5cGVydHlOYW1lICAgICBoeXBlcnR5IE5hbWVcbiAgKi9cbiAgZ2V0SHlwZXJ0eU5hbWUodXJsKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIGxldCBpc0h5cGVydHlVUkwgPSBkaXZpZGVVUkwodXJsKS50eXBlID09PSAnaHlwZXJ0eSc7XG5cbiAgICAvL3ZhbHVlIHRvIGJlIHJldHVybmVkIGluIHRoZSBlbmRcbiAgICBsZXQgaHlwZXJ0eU5hbWU7XG5cbiAgICAvL2lmIGlzIG5vdCBhbiBoeXBlcnR5LCBjaGVjayBpZiBpcyBhIGRhdGFPYmplY3QgYW5kIG9idGFpbiBoaXMgcmVwb3J0ZXJcbiAgICBsZXQgaHlwZXJ0eVVSTCA9IChpc0h5cGVydHlVUkwpID8gaHlwZXJ0eVVSTCA9IHVybCA6IF90aGlzLmdldFJlcG9ydGVyVVJMU3luY2hvbm91cyh1cmwpO1xuXG4gICAgZm9yIChsZXQgaW5kZXggaW4gX3RoaXMuaHlwZXJ0aWVzTGlzdCkge1xuICAgICAgbGV0IGh5cGVydHkgPSBfdGhpcy5oeXBlcnRpZXNMaXN0W2luZGV4XTtcbiAgICAgIGlmIChoeXBlcnR5Lmh5cGVydHlVUkwgPT09IGh5cGVydHlVUkwpIHtcbiAgICAgICAgaHlwZXJ0eU5hbWUgPSBoeXBlcnR5Lm9iamVjdE5hbWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaHlwZXJ0eU5hbWU7XG4gIH1cblxuICAvKipcbiAgKiBmdW5jdGlvbiB0byByZXR1cm4gdGhlIHJlcG9ydGVyVVJMIGFzc29jaWF0ZWQgd2l0aCB0aGUgZGF0YW9iamVjdCBVUkxcbiAgKiBAcGFyYW0gICAge1N0cmluZ30gICAgIGRhdGFPYmplY3RVUkwgICAgZGF0YU9iamVjdFVSTFxuICAqIEByZXR1cm4gICB7U3RyaW5nfSAgICAgcmVwb3J0ZXJVUkwgICAgICByZXBvcnRlclVSTFxuICAqL1xuICBnZXRSZXBvcnRlclVSTChkYXRhT2JqZWN0VVJMKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIGxldCBkYXRhT2JqZWN0ID0gX3RoaXMuZGF0YU9iamVjdExpc3RbZGF0YU9iamVjdFVSTF07XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBpZiAoZGF0YU9iamVjdCkge1xuICAgICAgICByZXNvbHZlKGRhdGFPYmplY3QucmVwb3J0ZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVqZWN0KCdObyByZXBvcnRlciB3YXMgZm91bmQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAqIGZ1bmN0aW9uIHRvIHJldHVybiB0aGUgcmVwb3J0ZXJVUkwgYXNzb2NpYXRlZCB3aXRoIHRoZSBkYXRhb2JqZWN0IFVSTC4gbm8gcHJvbWlzZSByZXR1cm5lZFxuICAqIEBwYXJhbSAgICB7U3RyaW5nfSAgICAgZGF0YU9iamVjdFVSTCAgICBkYXRhT2JqZWN0VVJMXG4gICogQHJldHVybiAgIHtTdHJpbmd9ICAgICByZXBvcnRlclVSTCAgICAgIHJlcG9ydGVyVVJMXG4gICovXG4gIGdldFJlcG9ydGVyVVJMU3luY2hvbm91cyhkYXRhT2JqZWN0VVJMKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIGxldCBkYXRhT2JqZWN0ID0gX3RoaXMuZGF0YU9iamVjdExpc3RbZGF0YU9iamVjdFVSTF07XG5cbiAgICByZXR1cm4gKGRhdGFPYmplY3QpID8gZGF0YU9iamVjdC5yZXBvcnRlciA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAqIHJldHVybnMgdGhlIGh5cGVydHkgVVJMIHRoYXQgc3Vic2NyaWJlZCB0aGUgZGF0YU9iamVjdFxuICAqIEBwYXJhbSAgICB7U3RyaW5nfSAgICAgdXJsICAgICAgICAgICAgdXJsIGZvcm1hdFxuICAqIEByZXR1cm4gICB7U3RyaW5nfSAgICBIeXBlcnR5IFVSTCBzdWJzY3JpYmVkIHRvIHRoZSBVUkxcbiAgKi9cbiAgZ2V0RGF0YU9iamVjdFN1YnNjcmliZXJIeXBlcnR5KHVybCkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG5cbiAgICByZXR1cm4gX3RoaXMuc3Vic2NyaWJlZERhdGFPYmplY3RMaXN0W3VybF07XG4gIH1cblxuICAvKipcbiAgKiByZWdpc3RlciBhIGRlc2lyZWQgZGF0YU9iamVjdCB0byBzdWJzY3JpYmVcbiAgKiBAcGFyYW0gICAge1N0cmluZ30gICAgZGF0YU9iamVjdFVSTCAgICAgIGRhdGFPYmplY3QgVVJMXG4gICovXG4gIHJlZ2lzdGVyU3Vic2NyaWJlZERhdGFPYmplY3QoZGF0YU9iamVjdFVSTCwgaHlwZXJ0eVVSTCkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKF90aGlzLnN1YnNjcmliZWREYXRhT2JqZWN0TGlzdFtkYXRhT2JqZWN0VVJMXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBfdGhpcy5zdWJzY3JpYmVkRGF0YU9iamVjdExpc3RbZGF0YU9iamVjdFVSTF0gPSBoeXBlcnR5VVJMO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAqIEZ1bmN0aW9uIHRvIHJldHVybiB0aGUgbGlzdCBvZiBwcmUgYXV0aG9yaXNlZCB1c2VycyByZWNlaXZlZCBpbiB0aGUgY3JlYXRpb24gb2YgYSBkYXRhIG9iamVjdFxuICAqIEBwYXJhbSAgICB7U3RyaW5nfSAgICAgICAgICAgIGRhdGFPYmplY3RVUkwgICAgZGF0YU9iamVjdFVSTFxuICAqIEByZXR1cm4gICB7QXJyYXk8U3RyaW5nPn0gICAgIHByZUF1dGggICAgICAgICBMaXN0IG9mIHByZSBhdXRob3Jpc2VkIHVzZXJzXG4gICovXG4gIGdldFByZUF1dGhTdWJzY3JpYmVycyhkYXRhT2JqZWN0VVJMKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcbiAgICBsZXQgZGF0YU9iamVjdCA9IF90aGlzLmRhdGFPYmplY3RMaXN0W2RhdGFPYmplY3RVUkxdO1xuICAgIGxldCBwcmVBdXRoID0gW107XG5cbiAgICBpZiAoZGF0YU9iamVjdCkge1xuICAgICAgcHJlQXV0aCA9IGRhdGFPYmplY3QucHJlQXV0aDtcbiAgICB9XG4gICAgcmV0dXJuIHByZUF1dGg7XG4gIH1cblxuICAvKipcbiAgKiBzZW5kIHJlcXVlc3RzIHRvIHVucmVnaXN0ZXIgYWxsIGh5cGVydGllcyByZWdpc3RlcmVkIGluIGRvbWFpbiByZWdpc3RyeVxuICAqIEByZXR1cm4gICB7UHJvbWlzZX0gICAgIHJldHVybiBhIHByb21pc2UgaWYgdGhlIHJlc3VsdCBvZiB1bnJlZ2lzdHJhdGlvbiBhbGwgaHlwZXJ0aWVzXG4gICovXG4gIHVucmVnaXN0ZXJBbGxIeXBlcnRpZXMoKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIGxldCB1bnJlZ2lzdGVyUmVzdWx0cyA9IFtdO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUscmVqZWN0KSB7XG5cbiAgICAgIGZvciAobGV0IGluZGV4IGluIF90aGlzLmh5cGVydGllc0xpc3QpIHtcbiAgICAgICAgbGV0IGh5cGVydHkgPSBfdGhpcy5oeXBlcnRpZXNMaXN0W2luZGV4XTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IF90aGlzLnVucmVnaXN0ZXJIeXBlcnR5SW5zdGFuY2UoaHlwZXJ0eS51c2VyLnVzZXJVUkwsIGh5cGVydHkuaHlwZXJ0eVVSTCk7XG4gICAgICAgIHVucmVnaXN0ZXJSZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgIH1cblxuICAgICAgUHJvbWlzZS5hbGwodW5yZWdpc3RlclJlc3VsdHMpLnRoZW4oKCkgPT4ge1xuXG4gICAgICAgIHJlc29sdmUoJ3N1Y2Nlc3NmdWxseSB1bnJlZ2lzdGVyZWQgYWxsIGh5cGVydGllcycpO1xuICAgICAgfSwgZXJyb3IgPT4geyByZWplY3QoZXJyb3IpO30pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICogIGZ1bmN0aW9uIHRvIHVucmVnaXN0ZXIgYW4gaHlwZXJ0eUluc3RhbmNlIGluIHRoZSBEb21haW4gUmVnaXN0cnlcbiAgKiAgQHBhcmFtICAge1N0cmluZ30gICAgICB1c2VyICAgICAgICB1c2VyIHVybFxuICAqICBAcGFyYW0gICB7U3RyaW5nfSAgICAgIGh5cGVydHlJbnN0YW5jZSAgIEh5cGVydHlJbnNudGFuY2UgdXJsXG4gICpcbiAgKi9cbiAgdW5yZWdpc3Rlckh5cGVydHlJbnN0YW5jZSh1c2VyLCBoeXBlcnR5SW5zdGFuY2UpIHtcbiAgICAvL1RPRE8gd29ya2luZyBidXQgdGhlIHVzZXJcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgbGV0IG1lc3NhZ2UgPSB7IHR5cGU6ICdkZWxldGUnLCBmcm9tOiBfdGhpcy5yZWdpc3RyeVVSTCxcbiAgICAgICAgICAgICAgICAgICAgdG86ICdkb21haW46Ly9yZWdpc3RyeS4nICsgX3RoaXMuX2RvbWFpbiArICcvJyxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogeyB2YWx1ZToge3VzZXI6IHVzZXIsIHVybDogaHlwZXJ0eUluc3RhbmNlIH19fTtcblxuICAgIF90aGlzLl9tZXNzYWdlQnVzLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIChyZXBseSkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ3VucmVnaXN0ZXIgaHlwZXJ0eSBSZXBseScsIHJlcGx5KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAqICBmdW5jdGlvbiB0byBkZWxldGUgYW4gZGF0YU9iamVjdEluc3RhbmNlIGluIHRoZSBEb21haW4gUmVnaXN0cnlcbiAgKiAgQHBhcmFtICAge1N0cmluZ30gICAgbmFtZSAgICAgIERhdGFPYmplY3ROYW1lXG4gICovXG4gIGRlbGV0ZURhdGFPYmplY3RJbnN0YW5jZShuYW1lKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIGxldCBtZXNzYWdlID0geyB0eXBlOiAnZGVsZXRlJywgZnJvbTogX3RoaXMucmVnaXN0cnlVUkwsXG4gICAgICAgICAgICAgICAgICAgIHRvOiAnZG9tYWluOi8vcmVnaXN0cnkuJyArIF90aGlzLl9kb21haW4gKyAnLycsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHsgdmFsdWU6IHtuYW1lOiBuYW1lfX19O1xuXG4gICAgX3RoaXMuX21lc3NhZ2VCdXMucG9zdE1lc3NhZ2UobWVzc2FnZSwgKHJlcGx5KSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygndW5yZWdpc3RlciBkYXRhT2JqZWN0IFJlcGx5JywgcmVwbHkpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICogRnVuY3Rpb24gdG8gdXBkYXRlIGFuIEh5cGVydHlcbiAgKi9cbiAgdXBkYXRlSHlwZXJ0eUluc3RhbmNlKHJlc291cmNlLCB2YWx1ZSkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG5cbiAgICBsZXQgbWVzc2FnZSA9IHsgdHlwZTogJ1VQREFURScsIGZyb206IF90aGlzLnJlZ2lzdHJ5VVJMLFxuICAgICAgICAgICAgICAgICAgICB0bzogJ2RvbWFpbjovL3JlZ2lzdHJ5LicgKyBfdGhpcy5fZG9tYWluICsgJy8nLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7IHJlc291cmNlOiByZXNvdXJjZSwgdmFsdWU6IHZhbHVlfX07XG5cbiAgICBfdGhpcy5fbWVzc2FnZUJ1cy5wb3N0LnBvc3RNZXNzYWdlKG1lc3NhZ2UsIChyZXBseSkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ1VwZGF0ZWQgaHlwZXJ0eSByZXBseScsIHJlcGx5KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAqIHJlZ2lzdGVyIGEgbmV3IHN1YnNjcmliZXIgaW4gdGhlIGRhdGFPYmplY3QgcmVnaXN0ZXJlZFxuICAqIEBwYXJhbSAge1N0cmluZ30gICBkYXRhT2JqZWN0VVJMICAgIGRhdGFPYmplY3QgVVJMXG4gICogQHBhcmFtICB7U3RyaW5nfSAgIHN1YnNjcmliZXJVUkwgICAgc3Vic2NyaWJlciBVUkxcbiAgKi9cbiAgcmVnaXN0ZXJTdWJzY3JpYmVyKGRhdGFPYmplY3RVUkwsIHN1YnNjcmliZXJVUkwpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuICAgIGxldCBkYXRhT2JqZWN0ID0gX3RoaXMuZGF0YU9iamVjdExpc3RbZGF0YU9iamVjdFVSTF07XG5cbiAgICBpZiAoZGF0YU9iamVjdCkge1xuICAgICAgZGF0YU9iamVjdC5zdWJzY3JpYmVycy5wdXNoKHN1YnNjcmliZXJVUkwpO1xuICAgICAgX3RoaXMuZGF0YU9iamVjdExpc3RbZGF0YU9iamVjdFVSTF0gPSBkYXRhT2JqZWN0O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAqIGdldCB0aGUgc3Vic2NyaWJlcnMgcmVnaXN0ZXJlZCB3aXRoaW4gYSBkYXRhT2JqZWN0XG4gICogQHBhcmFtICB7U3RyaW5nfSAgICAgICAgICBkYXRhT2JqZWN0VVJMICAgIGRhdGFPYmplY3QgVVJMXG4gICogQHBhcmFtICB7QXJyYXk8U3RyaW5nPn0gICBTdWJzdHJpYmVycyBMaXN0XG4gICovXG4gIGdldERhdGFPYmplY3RTdWJzY3JpYmVycyhkYXRhT2JqZWN0VVJMKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcbiAgICBsZXQgZGF0YU9iamVjdCA9IF90aGlzLmRhdGFPYmplY3RMaXN0W2RhdGFPYmplY3RVUkxdO1xuXG4gICAgaWYgKGRhdGFPYmplY3QpIHtcbiAgICAgIHJldHVybiBkYXRhT2JqZWN0LnN1YnNjcmliZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyAnTm8gZGF0YU9iamVjdCB3YXMgZm91bmQnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAqIFRvIHJlZ2lzdGVyIGEgbmV3IERhdGEgT2JqZWN0IGluIHRoZSBydW50aW1lIHdoaWNoIHJldHVybnMgdGhlIGRhdGFPYmplY3RVUkwgYWxsb2NhdGVkIHRvIHRoZSBuZXcgRGF0YSBPYmplY3QuXG4gICogQHBhcmFtICB7U3RyaW5nfSAgICAgIGlkZW50aWZpZXIgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyXG4gICogQHBhcmFtICB7U3RyaW5nfSAgICAgIGRhdGFPYmplY3RzY2hlbWEgICAgICAgICAgICBkYXRhT2JqZWN0c2NoZW1hXG4gICogQHBhcmFtICB7U3RyaW5nfSAgICAgIGRhdGFPYmplY3RVcmwgICAgICAgICAgICAgICBkYXRhT2JqZWN0VXJsXG4gICogQHBhcmFtIHtTdHJpbmd9ICAgICAgZGF0YU9iamVjdFJlcG9ydGVyICAgICAgICAgICBkYXRhT2JqZWN0UmVwb3J0ZXJcbiAgKiBAcGFyYW0gIHtBcnJheX0gICAgIHJlc291cmNlcyAgICAgICAgICAgICAgICAgICAgIGRhdGFPYmplY3QgcmVzb3VyY2VzXG4gICogQHBhcmFtICB7QXJyYXl9ICAgICBhdXRob3Jpc2UgICAgICAgICAgICAgICAgICAgICBsaXN0IG9mIHByZSBhdXRob3Jpc2VkIGF1dGhvcmlzZWQgSURzXG4gICovXG4gIHJlZ2lzdGVyRGF0YU9iamVjdChpZGVudGlmaWVyLCBkYXRhT2JqZWN0c2NoZW1hLCBkYXRhT2JqZWN0VXJsLCBkYXRhT2JqZWN0UmVwb3J0ZXIsIHJlc291cmNlcywgYWRkcmVzc1VSTCwgYXV0aG9yaXNlKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblxuICAgICAgbGV0IGRhdGFTY2hlbWUgPSBbXTtcbiAgICAgIGxldCBmaWx0ZXJlZERhdGFTY2hlbWUgPSBkYXRhT2JqZWN0VXJsLnNwbGl0KCc6Jyk7XG4gICAgICBkYXRhU2NoZW1lLnB1c2goZmlsdGVyZWREYXRhU2NoZW1lWzBdKTtcblxuICAgICAgX3RoaXMuc3RvcmFnZU1hbmFnZXIuZ2V0KCdyZWdpc3RyeTpEYXRhT2JqZWN0VVJMcycpLnRoZW4oKHVybHNMaXN0KSA9PiB7XG5cbiAgICAgICAgaWYgKCF1cmxzTGlzdCkge1xuICAgICAgICAgIHVybHNMaXN0ID0ge307XG4gICAgICAgIH1cblxuICAgICAgICAvL3VwZGF0ZSB0aGUgbGlzdCB3aXRoIHRoZSBuZXcgZWxlbWVudHNcbiAgICAgICAgdXJsc0xpc3RbaWRlbnRpZmllciArIGRhdGFPYmplY3RzY2hlbWEgKyByZXNvdXJjZXMgKyBkYXRhT2JqZWN0UmVwb3J0ZXJdID0gYWRkcmVzc1VSTC5hZGRyZXNzO1xuXG4gICAgICAgIC8vbWVzc2FnZSB0byByZWdpc3RlciB0aGUgbmV3IGh5cGVydHksIHdpdGhpbiB0aGUgZG9tYWluIHJlZ2lzdHJ5XG4gICAgICAgIGxldCBtZXNzYWdlVmFsdWUgPSB7bmFtZTogaWRlbnRpZmllciwgcmVzb3VyY2VzOiByZXNvdXJjZXMsIGRhdGFTY2hlbWVzOiBkYXRhU2NoZW1lLCBzY2hlbWE6IGRhdGFPYmplY3RzY2hlbWEsIHVybDogZGF0YU9iamVjdFVybCwgZXhwaXJlczogX3RoaXMuZXhwaXJlc1RpbWUsIHJlcG9ydGVyOiBkYXRhT2JqZWN0UmVwb3J0ZXIsIHByZUF1dGg6IGF1dGhvcmlzZSwgc3Vic2NyaWJlcnM6IFtdfTtcblxuICAgICAgICBsZXQgbWVzc2FnZTtcblxuICAgICAgICBpZiAoYWRkcmVzc1VSTC5uZXdBZGRyZXNzKSB7XG5cbiAgICAgICAgICBjb25zb2xlLmxvZygncmVnaXN0ZXJpbmcgbmV3IGRhdGEgb2JqZWN0IFVSTCcsIGRhdGFPYmplY3RVcmwpO1xuXG4gICAgICAgICAgbWVzc2FnZSA9IHt0eXBlOidjcmVhdGUnLCBmcm9tOiBfdGhpcy5yZWdpc3RyeVVSTCwgdG86ICdkb21haW46Ly9yZWdpc3RyeS4nICsgX3RoaXMucmVnaXN0cnlEb21haW4gKyAnLycsIGJvZHk6IHt2YWx1ZTogbWVzc2FnZVZhbHVlLCBwb2xpY3k6ICdwb2xpY3knfX07XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIGNvbnNvbGUubG9nKCdyZWdpc3RlcmluZyBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgZGF0YSBvYmplY3QgVVJMJywgZGF0YU9iamVjdFVybCk7XG5cbiAgICAgICAgICAvKm1lc3NhZ2VWYWx1ZSA9IHtuYW1lOiBpZGVudGlmaWVyLCByZXNvdXJjZXM6IHJlc291cmNlcywgZGF0YVNjaGVtZXM6IGRhdGFTY2hlbWUsIHNjaGVtYTogZGF0YU9iamVjdHNjaGVtYSwgdXJsOiBkYXRhT2JqZWN0VXJsLCBleHBpcmVzOiBfdGhpcy5leHBpcmVzVGltZSwgcmVwb3J0ZXI6IGRhdGFPYmplY3RSZXBvcnRlciwgcHJlQXV0aDogYXV0aG9yaXNlLCBzdWJzY3JpYmVyczogW119O1xuXG4gICAgICAgICAgbWVzc2FnZSA9IHt0eXBlOidjcmVhdGUnLCBmcm9tOiBfdGhpcy5yZWdpc3RyeVVSTCwgdG86ICdkb21haW46Ly9yZWdpc3RyeS4nICsgX3RoaXMucmVnaXN0cnlEb21haW4gKyAnLycsIGJvZHk6IHt2YWx1ZTogbWVzc2FnZVZhbHVlLCBwb2xpY3k6ICdwb2xpY3knfX07Ki9cblxuICAgICAgICAgIG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICB0eXBlOiAndXBkYXRlJyxcbiAgICAgICAgICAgIHRvOiAnZG9tYWluOi8vcmVnaXN0cnkuJyArIF90aGlzLnJlZ2lzdHJ5RG9tYWluICsgJy8nLFxuICAgICAgICAgICAgZnJvbTogX3RoaXMucmVnaXN0cnlVUkwsXG4gICAgICAgICAgICBib2R5OiB7cmVzb3VyY2U6IGRhdGFPYmplY3RVcmwsIHZhbHVlOiAnbGl2ZScsIGF0dHJpYnV0ZTogJ3N0YXR1cyd9XG4gICAgICAgICAgfTtcblxuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuZGF0YU9iamVjdExpc3RbZGF0YU9iamVjdFVybF0gPSBtZXNzYWdlVmFsdWU7XG5cbiAgICAgICAgLy8gc3RlcCB0byBvYnRhaW4gdGhlIGxpc3Qgb2YgYWxsIFVSTCByZWdpc3RlcmVkIHRvIHVwZGF0ZWQgd2l0aCB0aGUgbmV3IG9uZS5cbiAgICAgICAgX3RoaXMuc3RvcmFnZU1hbmFnZXIuc2V0KCdyZWdpc3RyeTpEYXRhT2JqZWN0VVJMcycsIDAsIHVybHNMaXN0KS50aGVuKCgpID0+IHtcblxuICAgICAgICAgIC8qbGV0IG1lc3NhZ2UgPSBfdGhpcy5tZXNzYWdlRmFjdG9yeS5jcmVhdGVDcmVhdGVNZXNzYWdlUmVxdWVzdChcbiAgICAgICAgICAgIF90aGlzLnJlZ2lzdHJ5VVJMLFxuICAgICAgICAgICAgJ2RvbWFpbjovL3JlZ2lzdHJ5LicgKyBfdGhpcy5yZWdpc3RyeURvbWFpbiArICcvJyxcbiAgICAgICAgICAgIG1lc3NhZ2VWYWx1ZSxcbiAgICAgICAgICAgICdwb2xpY3knXG4gICAgICAgICAgKTsqL1xuXG4gICAgICAgICAgX3RoaXMuX21lc3NhZ2VCdXMucG9zdE1lc3NhZ2UobWVzc2FnZSwgKHJlcGx5KSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnPT09PiByZWdpc3RlckRhdGFPYmplY3QgUmVwbHk6ICcsIHJlcGx5KTtcbiAgICAgICAgICAgIGlmIChyZXBseS5ib2R5LmNvZGUgPT09IDIwMCkge1xuICAgICAgICAgICAgICByZXNvbHZlKCdvaycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVqZWN0KCdlcnJvciBvbiByZWdpc3RlciBEYXRhT2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBfZ2V0UmVzb3VyY2VzQW5kU2NoZW1lcyhkZXNjcmlwdG9yKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KT0+IHtcblxuICAgICAgbGV0IHJlc291cmNlcztcblxuICAgICAgLy8gY2hlY2sgaWYgdGhlIGh5cGVydHkgcmVzb3VyY2VzIGlzIGEgdmVjdG9yIG9yIGEgc3RyaW5nXG4gICAgICAvLyBUT0RPIGRlbGV0ZSBsYXRlciB3aGVuIGNhdGFsb2d1ZSBpcyBmaXhlZFxuICAgICAgaWYgKHR5cGVvZiAoZGVzY3JpcHRvci5oeXBlcnR5VHlwZSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJlc291cmNlcyA9IFtdO1xuICAgICAgICByZXNvdXJjZXMucHVzaChkZXNjcmlwdG9yLmh5cGVydHlUeXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc291cmNlcyA9IGRlc2NyaXB0b3IuaHlwZXJ0eVR5cGU7XG4gICAgICB9XG5cbiAgICAgIGxldCBkZXNjcmlwdG9yRGF0YVNjaGVtYSA9IGRlc2NyaXB0b3IuZGF0YU9iamVjdHM7XG4gICAgICBsZXQgZGF0YVNjaGVtYXNBcnJheSA9IFtdO1xuXG4gICAgICAvL3RoaXMgd2lsbCBjcmVhdGUgYSBhcnJheSB3aXRoIGEgUHJvbWlzZSBpbiBlYWNoIHBvc2l0aW9uXG4gICAgICBmb3IgKGxldCBpbmRleCBpbiBkZXNjcmlwdG9yRGF0YVNjaGVtYSkge1xuICAgICAgICBkYXRhU2NoZW1hc0FycmF5LnB1c2goX3RoaXMucnVudGltZUNhdGFsb2d1ZS5nZXREYXRhU2NoZW1hRGVzY3JpcHRvcihkZXNjcmlwdG9yRGF0YVNjaGVtYVtpbmRleF0pKTtcbiAgICAgIH1cblxuICAgICAgLy8gYXMgc29vbiBhcyB0aGUgcHJldmlvdXMgYXJyYXkgaXMgY29tcGxldGVkLCB0aGlzIHdpbGwgd2FpdCBmb3IgdGhlIHJlc29sdmUgb2YgYWxsIHByb21pc2VzIGluIHRoZSBhcnJheVxuICAgICAgUHJvbWlzZS5hbGwoZGF0YVNjaGVtYXNBcnJheSkudGhlbihmdW5jdGlvbihkYXRhU2NoZW1hcykge1xuXG4gICAgICAgIGxldCBmaWx0ZXJlZERhdGFTY2hlbWFzID0gW107XG4gICAgICAgIGZvciAobGV0IGluZGV4IGluIGRhdGFTY2hlbWFzKSB7XG4gICAgICAgICAgbGV0IGRhdGFTY2hlbWEgPSBkYXRhU2NoZW1hc1tpbmRleF07XG4gICAgICAgICAgZmlsdGVyZWREYXRhU2NoZW1hcy5wdXNoKGRhdGFTY2hlbWEuc291cmNlUGFja2FnZS5zb3VyY2VDb2RlLnByb3BlcnRpZXMuc2NoZW1lLmNvbnN0YW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKCdIeXBlcnR5IFNjaGVtYXMnLCBmaWx0ZXJlZERhdGFTY2hlbWFzKTtcbiAgICAgICAgY29uc29sZS5sb2coJ0h5cGVydHkgcmVzb3VyY2VzJywgcmVzb3VyY2VzKTtcblxuICAgICAgICByZXNvbHZlKHtyZXNvdXJjZXM6IHJlc291cmNlcywgZGF0YVNjaGVtYTogZmlsdGVyZWREYXRhU2NoZW1hc30pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgKiBtZXRob2QgdGhhdCByZXR1cm5zIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBIeXBlcnR5IG9yIERhdGFPYmplY3RzIFVSTFMsIGZvciBnaXZlbiBjaGFyYWN0ZXJpc3RpY3NcbiAgKiBAcGFyYW0gIHtKU09OfSAgICAgICAgaW5mbyAgICAgICAgICAgb2JqZWN0IG9yIGh5cGVydHkgY2hhcmF0ZXJpc3RpY3MgaW5mb1xuICAqIEByZXR1cm4ge2FkZHJlc3NVUkx9ICBhZGRyZXNzVVJMICAgICByZXR1cm4gdGhlIFVSTCBpZiB0aGVyZSBpcyBhbnkgcHJldmlvdXN5IHJlZ2lzdGVyZWQgVVJMLCByZXR1cm4gdW5kZWZpbmVkIG90aGVyd2lzZVxuICAqL1xuICBjaGVja1JlZ2lzdGVyZWRVUkxzKGluZm8pIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgbGV0IG9iamVjdFR5cGUgPSAoaW5mby5yZXBvcnRlcikgPyAncmVnaXN0cnk6RGF0YU9iamVjdFVSTHMnIDogJ3JlZ2lzdHJ5Okh5cGVydHlVUkxzJztcblxuICAgICAgX3RoaXMuc3RvcmFnZU1hbmFnZXIuZ2V0KG9iamVjdFR5cGUpLnRoZW4oKHVybHNMaXN0KSA9PiB7XG5cbiAgICAgICAgaWYgKCF1cmxzTGlzdCkge1xuICAgICAgICAgIHVybHNMaXN0ID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqZWN0VHlwZSA9PT0gJ3JlZ2lzdHJ5Okh5cGVydHlVUkxzJykge1xuICAgICAgICAgIF90aGlzLl9nZXRSZXNvdXJjZXNBbmRTY2hlbWVzKGluZm8pLnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodXJsc0xpc3RbdmFsdWUucmVzb3VyY2VzICsgdmFsdWUuZGF0YVNjaGVtYV0pIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3JldXNhZ2Ugb2YgaHlwZXJ0eSBVUkwnKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodXJsc0xpc3RbdmFsdWUucmVzb3VyY2VzICsgdmFsdWUuZGF0YVNjaGVtYV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ25vIGh5cGVydHkgVVJMIHdhcyBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgJyk7XG4gICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBsZXQgY2hhcmFjdGVyaXN0aWNzID0gaW5mby5uYW1lICsgaW5mby5zY2hlbWEgKyBpbmZvLnJlc291cmNlcyArIGluZm8ucmVwb3J0ZXI7XG5cbiAgICAgICAgICBpZiAodXJsc0xpc3RbY2hhcmFjdGVyaXN0aWNzXSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ3JldXNhZ2Ugb2YgZGF0YU9iamVjdCBVUkwnKTtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHVybHNMaXN0W2NoYXJhY3RlcmlzdGljc10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnbm8gZGF0YU9iamVjdCBVUkwgd2FzIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfSk7XG5cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAqIFRvIHJlZ2lzdGVyIGEgbmV3IEh5cGVydHkgaW4gdGhlIHJ1bnRpbWUgd2hpY2ggcmV0dXJucyB0aGUgSHlwZXJ0eVVSTCBhbGxvY2F0ZWQgdG8gdGhlIG5ldyBIeXBlcnR5LlxuICAqIEBwYXJhbSAge1NhbmRib3h9ICAgICAgICAgICAgIHNhbmRib3ggICAgICAgICAgICAgICBzYW5kYm94XG4gICogQHBhcmFtICB7SHlwZXJ0eUNhdGFsb2d1ZVVSTH0gSHlwZXJ0eUNhdGFsb2d1ZVVSTCAgIGRlc2NyaXB0b3JcbiAgKiBAcmV0dXJuIHtIeXBlcnR5VVJMfSAgICAgICAgICBIeXBlcnR5VVJMXG4gICovXG4gIHJlZ2lzdGVySHlwZXJ0eShzYW5kYm94LCBkZXNjcmlwdG9yVVJMLCBkZXNjcmlwdG9yLCBhZGRyZXNzVVJMKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIGxldCBoeXBlcnR5Q2FwYWJpbGl0aWVzO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXG4gICAgICAvL2Fzc3VtaW5nIGRlc2NyaXB0b3IgY29tZSBpbiB0aGlzIGZvcm1hdCwgdGhlIHNlcnZpY2UtcHJvdmlkZXItZG9tYWluIHVybCBpcyByZXRyaWV2ZWQgYnkgYSBzcGxpdCBpbnN0cnVjdGlvblxuICAgICAgLy9oeXBlcnR5LWNhdGFsb2d1ZTovLzxzZXJ2aWNlLXByb3ZpZGVyLWRvbWFpbj4vPGNhdGFsb2d1ZS1vYmplY3QtaWRlbnRpZmllcj5cbiAgICAgIGxldCBkb21haW5VcmwgPSBkaXZpZGVVUkwoZGVzY3JpcHRvclVSTCkuZG9tYWluO1xuXG4gICAgICBpZiAoZG9tYWluVXJsLmluY2x1ZGVzKCdjYXRhbG9ndWUnKSkge1xuICAgICAgICBkb21haW5VcmwgPSBkb21haW5VcmwucmVwbGFjZSgnY2F0YWxvZ3VlLicsICcnKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuaWRNb2R1bGUuZ2V0SWRlbnRpdHlBc3NlcnRpb24oKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICBsZXQgdXNlclByb2ZpbGUgPSByZXN1bHQudXNlclByb2ZpbGU7XG4gICAgICAgIGxldCBpZGVudGl0eVVSTCA9IHVzZXJQcm9maWxlLnVzZXJVUkw7XG5cbiAgICAgICAgaWYgKF90aGlzLl9tZXNzYWdlQnVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZWplY3QoJ01lc3NhZ2VCdXMgbm90IGZvdW5kIG9uIHJlZ2lzdGVyU3R1YicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vY2FsbCBjaGVjayBpZiB0aGUgcHJvdG9zdHViIGV4aXN0XG4gICAgICAgICAgX3RoaXMucmVzb2x2ZSgnaHlwZXJ0eS1ydW50aW1lOi8vJyArIGRvbWFpblVybCkudGhlbihmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnN0b3JhZ2VNYW5hZ2VyLmdldCgncmVnaXN0cnk6SHlwZXJ0eVVSTHMnKTtcbiAgICAgICAgICB9KS50aGVuKCh1cmxzTGlzdCkgPT4ge1xuXG4gICAgICAgICAgICBfdGhpcy5fZ2V0UmVzb3VyY2VzQW5kU2NoZW1lcyhkZXNjcmlwdG9yKS50aGVuKCh2YWx1ZSkgPT4ge1xuXG4gICAgICAgICAgICAgIGh5cGVydHlDYXBhYmlsaXRpZXMgPSB2YWx1ZTtcblxuICAgICAgICAgICAgICBpZiAoIXVybHNMaXN0KSB7XG4gICAgICAgICAgICAgICAgdXJsc0xpc3QgPSB7fTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHVybHNMaXN0W2h5cGVydHlDYXBhYmlsaXRpZXMucmVzb3VyY2VzICsgaHlwZXJ0eUNhcGFiaWxpdGllcy5kYXRhU2NoZW1hXSA9IGFkZHJlc3NVUkwuYWRkcmVzcztcbiAgICAgICAgICAgICAgX3RoaXMuc3RvcmFnZU1hbmFnZXIuc2V0KCdyZWdpc3RyeTpIeXBlcnR5VVJMcycsIDAsIHVybHNMaXN0KS50aGVuKCgpID0+IHtcblxuICAgICAgICAgICAgICAgIF90aGlzLnJlZ2lzdHJ5RG9tYWluID0gZG9tYWluVXJsO1xuXG4gICAgICAgICAgICAgICAgLy9jaGVjayB3aGV0aGVyIHRoZSByZWNlaXZlZCBzYW5ib3ggZSBBcHBsaWNhdGlvblNhbmRib3ggb3IgYSBub3JtYWwgc2FuZGJveFxuICAgICAgICAgICAgICAgIGlmIChzYW5kYm94LnR5cGUgPT09ICdhcHAnKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5zYW5kYm94ZXNMaXN0LmFwcFNhbmRib3hbYWRkcmVzc1VSTC5hZGRyZXNzWzBdXSA9IHNhbmRib3g7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzYW5kYm94LnR5cGUgPT09ICdub3JtYWwnKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5zYW5kYm94ZXNMaXN0LnNhbmRib3hbYWRkcmVzc1VSTC5hZGRyZXNzWzBdXSA9IHNhbmRib3g7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlamVjdCgnV3JvbmcgU2FuZGJveFR5cGUnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgaHlwZXJ0eSA9IG5ldyBIeXBlcnR5SW5zdGFuY2UoX3RoaXMuaWRlbnRpZmllciwgX3RoaXMucmVnaXN0cnlVUkwsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvclVSTCwgZGVzY3JpcHRvciwgYWRkcmVzc1VSTC5hZGRyZXNzWzBdLCB1c2VyUHJvZmlsZSk7XG5cbiAgICAgICAgICAgICAgICBoeXBlcnR5Ll9yZXNvdXJjZXMgPSBoeXBlcnR5Q2FwYWJpbGl0aWVzLnJlc291cmNlcztcbiAgICAgICAgICAgICAgICBoeXBlcnR5Ll9kYXRhU2NoZW1lcyA9IGh5cGVydHlDYXBhYmlsaXRpZXMuZGF0YVNjaGVtYTtcbiAgICAgICAgICAgICAgICBfdGhpcy5oeXBlcnRpZXNMaXN0LnB1c2goaHlwZXJ0eSk7XG5cbiAgICAgICAgICAgICAgICAvL21lc3NhZ2UgdG8gcmVnaXN0ZXIgdGhlIG5ldyBoeXBlcnR5LCB3aXRoaW4gdGhlIGRvbWFpbiByZWdpc3RyeVxuICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlVmFsdWU7XG4gICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2U7XG5cbiAgICAgICAgICAgICAgICBpZiAoYWRkcmVzc1VSTC5uZXdBZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygncmVnaXN0ZXJpbmcgbmV3IEh5cGVydHkgVVJMJywgYWRkcmVzc1VSTC5hZGRyZXNzWzBdKTtcblxuICAgICAgICAgICAgICAgICAgbWVzc2FnZVZhbHVlID0ge3VzZXI6IGlkZW50aXR5VVJMLCAgZGVzY3JpcHRvcjogZGVzY3JpcHRvclVSTCwgdXJsOiBhZGRyZXNzVVJMLmFkZHJlc3NbMF0sIGV4cGlyZXM6IF90aGlzLmV4cGlyZXNUaW1lLCByZXNvdXJjZXM6IGh5cGVydHlDYXBhYmlsaXRpZXMucmVzb3VyY2VzLCBkYXRhU2NoZW1lczogaHlwZXJ0eUNhcGFiaWxpdGllcy5kYXRhU2NoZW1hfTtcblxuICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IHt0eXBlOidjcmVhdGUnLCBmcm9tOiBfdGhpcy5yZWdpc3RyeVVSTCwgdG86ICdkb21haW46Ly9yZWdpc3RyeS4nICsgX3RoaXMucmVnaXN0cnlEb21haW4gKyAnLycsIGJvZHk6IHt2YWx1ZTogbWVzc2FnZVZhbHVlLCBwb2xpY3k6ICdwb2xpY3knfX07XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3JlZ2lzdGVyaW5nIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBIeXBlcnR5IFVSTCcsIGFkZHJlc3NVUkwuYWRkcmVzc1swXSk7XG5cbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPVxuICAgICAgICAgICAgICAgICAgICB7dHlwZTogJ3VwZGF0ZScsXG4gICAgICAgICAgICAgICAgICAgICB0bzogJ2RvbWFpbjovL3JlZ2lzdHJ5LicgKyBfdGhpcy5yZWdpc3RyeURvbWFpbiArICcvJyxcbiAgICAgICAgICAgICAgICAgICAgIGZyb206IF90aGlzLnJlZ2lzdHJ5VVJMLFxuICAgICAgICAgICAgICAgICAgICAgYm9keToge3Jlc291cmNlOiBhZGRyZXNzVVJMLmFkZHJlc3NbMF0vKiwgdmFsdWU6ICdsaXZlJywgYXR0cmlidXRlOiAnc3RhdHVzJyovfVxuICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKmxldCBtZXNzYWdlID0gX3RoaXMubWVzc2FnZUZhY3RvcnkuY3JlYXRlQ3JlYXRlTWVzc2FnZVJlcXVlc3QoXG4gICAgICAgICAgICAgICAgICBfdGhpcy5yZWdpc3RyeVVSTCxcbiAgICAgICAgICAgICAgICAgICdkb21haW46Ly9yZWdpc3RyeS4nICsgX3RoaXMucmVnaXN0cnlEb21haW4gKyAnLycsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlVmFsdWUsXG4gICAgICAgICAgICAgICAgICAncG9saWN5J1xuICAgICAgICAgICAgICAgICk7Ki9cblxuICAgICAgICAgICAgICAgIF90aGlzLl9tZXNzYWdlQnVzLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIChyZXBseSkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJz09PT4gUmVnaXN0ZXJIeXBlcnR5IFJlcGx5OiAnLCByZXBseSk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChyZXBseS5ib2R5LmNvZGUgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGFkZHJlc3NVUkwuYWRkcmVzc1swXSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoJ0ZhaWxlZCB0byByZWdpc3RlciBhbiBIeXBlcnR5Jyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvL3RpbWVyIHRvIGtlZXAgdGhlIHJlZ2lzdHJhdGlvbiBhbGl2ZVxuICAgICAgICAgICAgICAgIC8vIHRoZSB0aW1lIGlzIGRlZmluZWQgYnkgYSBsaXR0bGUgbGVzcyB0aGFuIGhhbGYgb2YgdGhlIGV4cGlyZXMgdGltZSBkZWZpbmVkXG4gICAgICAgICAgICAgICAgbGV0IGtlZXBBbGl2ZVRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgIC8qbGV0IG1lc3NhZ2UgPSBfdGhpcy5tZXNzYWdlRmFjdG9yeS5jcmVhdGVDcmVhdGVNZXNzYWdlUmVxdWVzdChcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVnaXN0cnlVUkwsXG4gICAgICAgICAgICAgICAgICAgICdkb21haW46Ly9yZWdpc3RyeS4nICsgX3RoaXMucmVnaXN0cnlEb21haW4gKyAnLycsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ3BvbGljeSdcbiAgICAgICAgICAgICAgICAgICk7Ki9cblxuICAgICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSB7dHlwZTondXBkYXRlJywgZnJvbTogX3RoaXMucmVnaXN0cnlVUkwsIHRvOiAnZG9tYWluOi8vcmVnaXN0cnkuJyArIF90aGlzLnJlZ2lzdHJ5RG9tYWluICsgJy8nLCBib2R5OiB7IHJlc291cmNlOiBhZGRyZXNzVVJMLmFkZHJlc3NbMF19fTtcblxuICAgICAgICAgICAgICAgICAgX3RoaXMuX21lc3NhZ2VCdXMucG9zdE1lc3NhZ2UobWVzc2FnZSwgKHJlcGx5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCc9PT0+IEtlZXBBbGl2ZSBSZXBseTogJywgcmVwbHkpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwoKChfdGhpcy5leHBpcmVzVGltZSAvIDEuMSkgLyAyKSAqIDEwMDApKTtcblxuICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQWRkcmVzcyBSZWFzb246ICcsIHJlYXNvbik7XG4gICAgICAgICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICByZWplY3QoJ0ZhaWxlZCB0byBvYnRhaW4gYW4gaWRlbnRpdHknLCBlcnIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgKiBUbyB1bnJlZ2lzdGVyIGEgcHJldmlvdXNseSByZWdpc3RlcmVkIEh5cGVydHlcbiAgKiBAcGFyYW0gIHtIeXBlcnR5VVJMfSAgICAgICAgICBIeXBlcnR5VVJMIHVybCAgICAgICAgdXJsXG4gICovXG4gIHVucmVnaXN0ZXJIeXBlcnR5KHVybCkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSxyZWplY3QpIHtcblxuICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICBsZXQgaW5kZXggPSAwO1xuXG4gICAgICBmb3JcdChpbmRleCA9IDA7IGluZGV4IDwgX3RoaXMuaHlwZXJ0aWVzTGlzdC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgbGV0IGh5cGVydHkgPSBfdGhpcy5oeXBlcnRpZXNMaXN0W2luZGV4XTtcbiAgICAgICAgaWYgKGh5cGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChoeXBlcnR5Lmh5cGVydHlVUkwgPT09IHVybCkge1xuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3VuZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmVqZWN0KCdIeXBlcnR5IG5vdCBmb3VuZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIF90aGlzLmh5cGVydGllc0xpc3RbaW5kZXhdO1xuICAgICAgICByZXNvbHZlKCdIeXBlcnR5IHN1Y2Nlc3NmdWxseSBkZWxldGVkJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgfVxuXG4gIC8qKlxuICAqIFRvIGRpc2NvdmVyIHByb3RvY29sIHN0dWJzIGF2YWlsYWJsZSBpbiB0aGUgcnVudGltZSBmb3IgYSBjZXJ0YWluIGRvbWFpbi4gSWYgYXZhaWxhYmxlLCBpdCByZXR1cm5zIHRoZSBydW50aW1lIHVybCBmb3IgdGhlIHByb3RvY29sIHN0dWIgdGhhdCBjb25uZWN0cyB0byB0aGUgcmVxdWVzdGVkIGRvbWFpbi4gUmVxdWlyZWQgYnkgdGhlIHJ1bnRpbWUgQlVTIHRvIHJvdXRlIG1lc3NhZ2VzIHRvIHJlbW90ZSBzZXJ2ZXJzIG9yIHBlZXJzIChkbyB3ZSBuZWVkIHNvbWV0aGluZyBzaW1pbGFyIGZvciBIeXBlcnRpZXM/KS5cbiAgKiBAcGFyYW0gIHtEb21haW5VUkx9ICAgICAgICAgICBEb21haW5VUkwgICAgICAgICAgICB1cmxcbiAgKiBAcmV0dXJuIHtSdW50aW1lVVJMfSAgICAgICAgICAgUnVudGltZVVSTFxuICAqL1xuICBkaXNjb3ZlclByb3Rvc3R1Yih1cmwpIHtcbiAgICBpZiAoIXVybCkgdGhyb3cgbmV3IEVycm9yKCdQYXJhbWV0ZXIgdXJsIG5lZWRlZCcpO1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSxyZWplY3QpIHtcblxuICAgICAgbGV0IGRpdmlkZWRVUkwgPSBkaXZpZGVVUkwodXJsKTtcbiAgICAgIGxldCBkb21haW5VUkwgPSBkaXZpZGVkVVJMLmRvbWFpbjtcblxuICAgICAgaWYgKF90aGlzLnByb3Rvc3R1YnNMaXN0Lmhhc093blByb3BlcnR5KGRvbWFpblVSTCkgJiYgX3RoaXMucHJvdG9zdHVic0xpc3RbZG9tYWluVVJMXS5zdGF0dXMgPT09IFNUQVRVUy5ERVBMT1lFRCkge1xuICAgICAgICByZXNvbHZlKF90aGlzLnByb3Rvc3R1YnNMaXN0W2RvbWFpblVSTF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMucHJvdG9zdHVic0xpc3RbZG9tYWluVVJMXSA9IHtcbiAgICAgICAgICBzdGF0dXM6IFNUQVRVUy5QUk9HUkVTU1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlamVjdCgncmVxdWVzdFVwZGF0ZSBjb3VsZG5cXCd0IGdldCB0aGUgUHJvdG9zdHViVVJMJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBUbyByZWdpc3RlciBhIG5ldyBQcm90b2NvbCBTdHViIGluIHRoZSBydW50aW1lIGluY2x1ZGluZyBhcyBpbnB1dCBwYXJhbWV0ZXJzIHRoZSBmdW5jdGlvbiB0byBwb3N0TWVzc2FnZSwgdGhlIERvbWFpblVSTCB0aGF0IGlzIGNvbm5lY3RlZCB3aXRoIHRoZSBzdHViLCB3aGljaCByZXR1cm5zIHRoZSBSdW50aW1lVVJMIGFsbG9jYXRlZCB0byB0aGUgbmV3IFByb3RvY29sU3R1Yi5cbiAgICogQHBhcmFtIHtTYW5kYm94fSAgICAgICAgU2FuZGJveFxuICAgKiBAcGFyYW0gIHtEb21haW5VUkx9ICAgICBEb21haW5VUkwgc2VydmljZSBwcm92aWRlciBkb21haW5cbiAgICogQHJldHVybiB7UnVudGltZVByb3RvU3R1YlVSTH1cbiAgICovXG4gIHJlZ2lzdGVyU3R1YihzYW5kYm94LCBkb21haW5VUkwpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUscmVqZWN0KSB7XG5cbiAgICAgIGxldCBydW50aW1lUHJvdG9TdHViVVJMO1xuXG4gICAgICAvL2NoZWNrIGlmIG1lc3NhZ2VCdXMgaXMgcmVnaXN0ZXJlZCBpbiByZWdpc3RyeSBvciBub3RcbiAgICAgIGlmIChfdGhpcy5fbWVzc2FnZUJ1cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlamVjdCgnTWVzc2FnZUJ1cyBub3QgZm91bmQgb24gcmVnaXN0ZXJTdHViJyk7XG4gICAgICB9XG5cbiAgICAgIC8vVE9ETyBpbXBsZW1lbnQgYSB1bmlxdWUgbnVtYmVyIGZvciB0aGUgcHJvdG9zdHViVVJMXG4gICAgICBpZiAoIWRvbWFpblVSTC5pbmRleE9mKCdtc2ctbm9kZS4nKSkge1xuICAgICAgICBkb21haW5VUkwgPSBkb21haW5VUkwuc3Vic3RyaW5nKGRvbWFpblVSTC5pbmRleE9mKCcuJykgKyAxKTtcbiAgICAgIH1cblxuICAgICAgcnVudGltZVByb3RvU3R1YlVSTCA9ICdtc2ctbm9kZS4nICsgZG9tYWluVVJMICsgJy9wcm90b3N0dWIvJyArIE1hdGguZmxvb3IoKE1hdGgucmFuZG9tKCkgKiAxMDAwMCkgKyAxKTtcblxuICAgICAgLy8gVE9ETzogT3B0aW1pemUgdGhpc1xuICAgICAgLy8gUHJveHk7XG4gICAgICBfdGhpcy5wcm90b3N0dWJzTGlzdFtkb21haW5VUkxdID0ge1xuICAgICAgICB1cmw6IHJ1bnRpbWVQcm90b1N0dWJVUkwsXG4gICAgICAgIHN0YXR1czogU1RBVFVTLkRFUExPWUVEXG4gICAgICB9O1xuXG4gICAgICAvLyBfdGhpcy5wcm90b3N0dWJzTGlzdFtkb21haW5VUkxdID0gcnVudGltZVByb3RvU3R1YlVSTDtcbiAgICAgIF90aGlzLnNhbmRib3hlc0xpc3Quc2FuZGJveFtydW50aW1lUHJvdG9TdHViVVJMXSA9IHNhbmRib3g7XG5cbiAgICAgIC8vIHNhbmRib3guYWRkTGlzdGVuZXIoJyonLCBmdW5jdGlvbihtc2cpIHtcbiAgICAgIC8vICAgX3RoaXMuX21lc3NhZ2VCdXMucG9zdE1lc3NhZ2UobXNnKTtcbiAgICAgIC8vIH0pO1xuXG4gICAgICByZXNvbHZlKHJ1bnRpbWVQcm90b1N0dWJVUkwpO1xuXG4gICAgICBfdGhpcy5fbWVzc2FnZUJ1cy5hZGRMaXN0ZW5lcihydW50aW1lUHJvdG9TdHViVVJMICsgJy9zdGF0dXMnLCAobXNnKSA9PiB7XG4gICAgICAgIGlmIChtc2cucmVzb3VyY2UgPT09IG1zZy50byArICcvc3RhdHVzJykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdSdW50aW1lUHJvdG9zdHViVVJML3N0YXR1cyBtZXNzYWdlOiAnLCBtc2cuYm9keS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gIH1cblxuICAvKipcbiAgKiBUbyB1bnJlZ2lzdGVyIGEgcHJldmlvdXNseSByZWdpc3RlcmVkIHByb3RvY29sIHN0dWJcbiAgKiBAcGFyYW0gIHtIeXBlcnR5UnVudGltZVVSTH0gICBIeXBlcnR5UnVudGltZVVSTCAgICAgaHlwZXJ0eVJ1bnRpbWVVUkxcbiAgKi9cbiAgdW5yZWdpc3RlclN0dWIoaHlwZXJ0eVJ1bnRpbWVVUkwpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXG4gICAgICBpZiAoX3RoaXMucHJvdG9zdHVic0xpc3QuaGFzT3duUHJvcGVydHkoaHlwZXJ0eVJ1bnRpbWVVUkwpKSB7XG4gICAgICAgIGRlbGV0ZSBfdGhpcy5wcm90b3N0dWJzTGlzdFtoeXBlcnR5UnVudGltZVVSTF07XG4gICAgICAgIHJlc29sdmUoJ1Byb3Rvc3R1YlVSTCByZW1vdmVkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWplY3QoJ0Vycm9yIG9uIHVucmVnaXN0ZXJTdHViOiBIeXBlcnR5IG5vdCBmb3VuZCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvIHJlZ2lzdGVyIGEgbmV3IElkZW50aXR5IFByb3ZpZGVyIHByb3h5IGluIHRoZSBydW50aW1lIGluY2x1ZGluZyBhcyBpbnB1dCBwYXJhbWV0ZXJzIHRoZSBmdW5jdGlvbiB0byBwb3N0TWVzc2FnZSwgdGhlIERvbWFpblVSTCB0aGF0IGlzIGNvbm5lY3RlZCB3aXRoIHRoZSBzdHViLCB3aGljaCByZXR1cm5zIHRoZSBSdW50aW1lVVJMIGFsbG9jYXRlZCB0byB0aGUgbmV3IFByb3RvY29sU3R1Yi5cbiAgICogQHBhcmFtIHtTYW5kYm94fSAgICAgICAgU2FuZGJveFxuICAgKiBAcGFyYW0gIHtEb21haW5VUkx9ICAgICBEb21haW5VUkwgc2VydmljZSBwcm92aWRlciBkb21haW5cbiAgICogQHJldHVybiB7UnVudGltZUlkcFByb3h5VVJMfVxuICAgKi9cbiAgcmVnaXN0ZXJJZHBQcm94eShzYW5kYm94LCBkb21haW5VUkwpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUscmVqZWN0KSB7XG5cbiAgICAgIGxldCBpZHBQcm94eVN0dWJVUkw7XG5cbiAgICAgIC8vY2hlY2sgaWYgbWVzc2FnZUJ1cyBpcyByZWdpc3RlcmVkIGluIHJlZ2lzdHJ5IG9yIG5vdFxuICAgICAgaWYgKF90aGlzLl9tZXNzYWdlQnVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVqZWN0KCdNZXNzYWdlQnVzIG5vdCBmb3VuZCBvbiByZWdpc3RlclN0dWInKTtcbiAgICAgIH1cblxuICAgICAgaWRwUHJveHlTdHViVVJMID0gJ2RvbWFpbi1pZHA6Ly8nICsgZG9tYWluVVJMICsgJy9zdHViLycgKyBNYXRoLmZsb29yKChNYXRoLnJhbmRvbSgpICogMTAwMDApICsgMSk7XG5cbiAgICAgIC8vIFRPRE86IE9wdGltaXplIHRoaXNcbiAgICAgIF90aGlzLmlkcFByb3h5TGlzdFtkb21haW5VUkxdID0ge1xuICAgICAgICB1cmw6IGlkcFByb3h5U3R1YlVSTCxcbiAgICAgICAgc3RhdHVzOiBTVEFUVVMuUFJPR1JFU1NcbiAgICAgIH07XG5cbiAgICAgIF90aGlzLnNhbmRib3hlc0xpc3Quc2FuZGJveFtpZHBQcm94eVN0dWJVUkxdID0gc2FuZGJveDtcblxuICAgICAgLy8gc2FuZGJveC5hZGRMaXN0ZW5lcignKicsIGZ1bmN0aW9uKG1zZykge1xuICAgICAgLy8gICBfdGhpcy5fbWVzc2FnZUJ1cy5wb3N0TWVzc2FnZShtc2cpO1xuICAgICAgLy8gfSk7XG5cbiAgICAgIHJlc29sdmUoaWRwUHJveHlTdHViVVJMKTtcblxuICAgICAgX3RoaXMuX21lc3NhZ2VCdXMuYWRkTGlzdGVuZXIoaWRwUHJveHlTdHViVVJMICsgJy9zdGF0dXMnLCAobXNnKSA9PiB7XG4gICAgICAgIGlmIChtc2cucmVzb3VyY2UgPT09IG1zZy50byArICcvc3RhdHVzJykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdpZHBQcm94eVN0dWJVUkwvc3RhdHVzIG1lc3NhZ2U6ICcsIG1zZy5ib2R5LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgKiBUbyBkaXNjb3ZlciBpZHBQcm94eSBzdHVicyBhdmFpbGFibGUgaW4gdGhlIHJ1bnRpbWUgZm9yIGEgY2VydGFpbiBkb21haW4uIElmIGF2YWlsYWJsZSwgaXQgcmV0dXJucyB0aGUgcnVudGltZSB1cmwgZm9yIHRoZSBpZHBQcm94eSBzdHViIHRoYXQgY29ubmVjdHMgdG8gdGhlIHJlcXVlc3RlZCBkb21haW4uIFJlcXVpcmVkIGJ5IHRoZSBydW50aW1lIEJVUyB0byByb3V0ZSBtZXNzYWdlcyB0byByZW1vdGUgc2VydmVycyBvciBwZWVyc1xuICAqIEBwYXJhbSAge0RvbWFpblVSTH0gICAgICAgICAgIERvbWFpblVSTCAgICAgICAgICAgIHVybFxuICAqIEByZXR1cm4ge1J1bnRpbWVVUkx9ICAgICAgICAgICBSdW50aW1lVVJMICAgICAgICAgaWRwUHJveHlVcmxcbiAgKi9cbiAgZGlzY292ZXJJZHBQcm94eSh1cmwpIHtcbiAgICBpZiAoIXVybCkgdGhyb3cgbmV3IEVycm9yKCdQYXJhbWV0ZXIgdXJsIG5lZWRlZCcpO1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cbiAgICAgIGxldCBkaXZpZGVkVVJMID0gZGl2aWRlVVJMKHVybCk7XG4gICAgICBsZXQgZG9tYWluVVJMID0gZGl2aWRlZFVSTC5kb21haW47XG5cbiAgICAgIGlmIChfdGhpcy5pZHBQcm94eUxpc3QuaGFzT3duUHJvcGVydHkoZG9tYWluVVJMKSAmJiBfdGhpcy5pZHBQcm94eUxpc3RbZG9tYWluVVJMXS5zdGF0dXMgPT09IFNUQVRVUy5ERVBMT1lFRCkge1xuICAgICAgICByZXNvbHZlKF90aGlzLmlkcFByb3h5TGlzdFtkb21haW5VUkxdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IE9wdGltaXplIHRoaXNcbiAgICAgICAgX3RoaXMuaWRwUHJveHlMaXN0W2RvbWFpblVSTF0gPSB7XG4gICAgICAgICAgc3RhdHVzOiBTVEFUVVMuUFJPR1JFU1NcbiAgICAgICAgfTtcbiAgICAgICAgcmVqZWN0KCdyZXF1ZXN0VXBkYXRlIGNvdWxkblxcJ3QgZ2V0IHRoZSBpZHBQcm94eVVSTCcpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIH1cblxuICAvKipcbiAgKiBUbyByZWdpc3RlciBhIG5ldyBQb2xpY3kgRW5mb3JjZXIgaW4gdGhlIHJ1bnRpbWUgaW5jbHVkaW5nIGFzIGlucHV0IHBhcmFtZXRlcnMgdGhlIGZ1bmN0aW9uIHRvIHBvc3RNZXNzYWdlLCB0aGUgSHlwZXJ0eVVSTCBhc3NvY2lhdGVkIHdpdGggdGhlIFBFUCwgd2hpY2ggcmV0dXJucyB0aGUgUnVudGltZVVSTCBhbGxvY2F0ZWQgdG8gdGhlIG5ldyBQb2xpY3kgRW5mb3JjZXIgY29tcG9uZW50LlxuICAqIEBwYXJhbSAge01lc3NhZ2UuTWVzc2FnZX0gcG9zdE1lc3NhZ2UgcG9zdE1lc3NhZ2VcbiAgKiBAcGFyYW0gIHtIeXBlcnR5VVJMfSAgICAgICAgICBIeXBlcnR5VVJMICAgICAgICAgICAgaHlwZXJ0eVxuICAqIEByZXR1cm4ge0h5cGVydHlSdW50aW1lVVJMfSAgIEh5cGVydHlSdW50aW1lVVJMXG4gICovXG4gIHJlZ2lzdGVyUEVQKHBvc3RNZXNzYWdlLCBoeXBlcnR5KSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLHJlamVjdCkge1xuICAgICAgLy9UT0RPIGNoZWNrIHdoYXQgcGFyYW1ldGVyIGluIHRoZSBwb3N0TWVzc2FnZSB0aGUgcGVwIGlzLlxuICAgICAgX3RoaXMucGVwTGlzdFtoeXBlcnR5XSA9IHBvc3RNZXNzYWdlO1xuICAgICAgcmVzb2x2ZSgnUEVQIHJlZ2lzdGVyZWQgd2l0aCBzdWNjZXNzJyk7XG4gICAgfSk7XG5cbiAgfVxuXG4gIC8qKlxuICAqIFRvIHVucmVnaXN0ZXIgYSBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgcHJvdG9jb2wgc3R1YlxuICAqIEBwYXJhbSAge0h5cGVydHlSdW50aW1lVVJMfSAgIEh5cGVydHlSdW50aW1lVVJMICAgICBIeXBlcnR5UnVudGltZVVSTFxuICAqL1xuICB1bnJlZ2lzdGVyUEVQKEh5cGVydHlSdW50aW1lVVJMKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLHJlamVjdCkge1xuXG4gICAgICBsZXQgcmVzdWx0ID0gX3RoaXMucGVwTGlzdFtIeXBlcnR5UnVudGltZVVSTF07XG5cbiAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZWplY3QoJ1BlcCBOb3QgZm91bmQuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKCdQRVAgc3VjY2Vzc2Z1bGx5IHJlbW92ZWQuJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgfVxuXG4gIC8qKlxuICAqIFRvIHJlY2VpdmUgc3RhdHVzIGV2ZW50cyBmcm9tIGNvbXBvbmVudHMgcmVnaXN0ZXJlZCBpbiB0aGUgUmVnaXN0cnkuXG4gICogQHBhcmFtICB7TWVzc2FnZS5NZXNzYWdlfSAgICAgTWVzc2FnZS5NZXNzYWdlICAgICAgIGV2ZW50XG4gICovXG4gIG9uRXZlbnQoZXZlbnQpIHtcbiAgICAvLyBUT0RPIGJvZHkuLi5cbiAgICBjb25zb2xlLmxvZygnb25FdmVudCcpO1xuICB9XG5cbiAgLyoqXG4gICogVG8gZGlzY292ZXIgc2FuZGJveGVzIGF2YWlsYWJsZSBpbiB0aGUgcnVudGltZSBmb3IgYSBjZXJ0YWluIGRvbWFpbi4gUmVxdWlyZWQgYnkgdGhlIHJ1bnRpbWUgVUEgdG8gYXZvaWQgbW9yZSB0aGFuIG9uZSBzYW5kYm94IGZvciB0aGUgc2FtZSBkb21haW4uXG4gICogQHBhcmFtICB7RG9tYWluVVJMfSBEb21haW5VUkwgdXJsXG4gICogQHJldHVybiB7UnVudGltZVNhbmRib3h9ICAgICAgICAgICBSdW50aW1lU2FuZGJveFxuICAqL1xuICBnZXRTYW5kYm94KHVybCkge1xuICAgIGlmICghdXJsKSB0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtZXRlciB1cmwgbmVlZGVkJyk7XG4gICAgY29uc29sZS5sb2coJ2dldFNhbmRib3g6ICcsIHVybCk7XG5cbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLHJlamVjdCkge1xuXG4gICAgICBsZXQgcmVxdWVzdDtcblxuICAgICAgLy9maXJzdCB0cnkgdG8gZmluZCB0aGUgdXJsIGluIHRoZSBhcHBTYW5kYm94IGxpc3RcbiAgICAgIHJlcXVlc3QgPSBfdGhpcy5zYW5kYm94ZXNMaXN0LmFwcFNhbmRib3hbdXJsXTtcblxuICAgICAgLy9pZiBubyBhcHBTYW5kYm94IHdhcyBmb3VuZCwgdHJ5IHRvIHNlYXJjaCBpbiB0aGUgbm9ybWFsIHNhbmRib3hlcyBsaXN0XG4gICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgcmVxdWVzdCA9IF90aGlzLnNhbmRib3hlc0xpc3Quc2FuZGJveFt1cmxdO1xuXG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuXG4gICAgICAgICAgbGV0IGRvbWFpbiA9IGRpdmlkZVVSTCh1cmwpLmRvbWFpbjtcblxuICAgICAgICAgIC8vIHNlYXJjaCBpbiB0aGUgc2FuZGJveGVzIGxpc3QgZm9yIGEgZW50cnkgY29udGFpbmluZyB0aGUgZG9tYWluIGdpdmVuXG4gICAgICAgICAgZm9yIChsZXQgc2FuZGJveCBpbiBfdGhpcy5zYW5kYm94ZXNMaXN0LnNhbmRib3gpIHtcbiAgICAgICAgICAgIGlmIChzYW5kYm94LmluY2x1ZGVzKGRvbWFpbikpIHtcbiAgICAgICAgICAgICAgcmVxdWVzdCA9IF90aGlzLnNhbmRib3hlc0xpc3Quc2FuZGJveFtzYW5kYm94XTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZWplY3QoJ25vIHNhbmRib3ggZm91bmQgZm9yOiAnICsgdXJsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUocmVxdWVzdCk7XG4gICAgICB9XG5cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAqIFRvIHZlcmlmeSBpZiBzb3VyY2UgaXMgdmFsaWQgYW5kIHRvIHJlc29sdmUgdGFyZ2V0IHJ1bnRpbWUgdXJsIGFkZHJlc3MgaWYgbmVlZGVkIChlZyBwcm90b3N0dWIgcnVudGltZSB1cmwgaW4gY2FzZSB0aGUgbWVzc2FnZSBpcyB0byBiZSBkaXNwYXRjaGVkIHRvIGEgcmVtb3RlIGVuZHBvaW50KS5cbiAgKiBAcGFyYW0gIHtVUkwuVVJMfSAgdXJsICAgICAgIHVybFxuICAqIEByZXR1cm4ge1Byb21pc2U8VVJMLlVSTD59ICAgICAgICAgICAgICAgICBQcm9taXNlIDxVUkwuVVJMPlxuICAqL1xuICByZXNvbHZlKHVybCkge1xuICAgIGNvbnNvbGUubG9nKCdyZXNvbHZlICcgKyB1cmwpO1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICAvL3NwbGl0IHRoZSB1cmwgdG8gZmluZCB0aGUgZG9tYWluVVJMLiBkZWFscyB3aXRoIHRoZSB1cmwgZm9yIGV4YW1wbGUgYXM6XG4gICAgICAvL1wiaHlwZXJ0eS1ydW50aW1lOi8vc3AxL3Byb3Rvc3R1Yi8xMjNcIixcbiAgICAgIGxldCBkaXZpZGVkVVJMID0gZGl2aWRlVVJMKHVybCk7XG4gICAgICBsZXQgZG9tYWluVXJsID0gZGl2aWRlZFVSTC5kb21haW47XG4gICAgICBsZXQgdHlwZSA9IGRpdmlkZWRVUkwudHlwZTtcblxuICAgICAgLy8gcmVzb2x2ZSB0aGUgZG9tYWluIHByb3Rvc3R1YiBpbiBjYXNlIG9mIGEgbWVzc2FnZSB0byBnbG9iYWwgcmVnaXN0cnlcbiAgICAgIGlmICh1cmwuaW5jbHVkZXMoJ2dsb2JhbDovL3JlZ2lzdHJ5JykpIHtcbiAgICAgICAgZG9tYWluVXJsID0gX3RoaXMuX2RvbWFpbjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkb21haW5VcmwuaW5kZXhPZignbXNnLW5vZGUuJykgfHwgIWRvbWFpblVybC5pbmRleE9mKCdyZWdpc3RyeS4nKSkge1xuICAgICAgICBkb21haW5VcmwgPSBkb21haW5Vcmwuc3Vic3RyaW5nKGRvbWFpblVybC5pbmRleE9mKCcuJykgKyAxKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHJlZ2lzdHJlZENvbXBvbmVudDtcbiAgICAgIGlmICh0eXBlID09PSAnZG9tYWluLWlkcCcpIHtcbiAgICAgICAgcmVnaXN0cmVkQ29tcG9uZW50ICA9IF90aGlzLmlkcFByb3h5TGlzdC5oYXNPd25Qcm9wZXJ0eShkb21haW5VcmwpID8gX3RoaXMuaWRwUHJveHlMaXN0W2RvbWFpblVybF0gOiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZ2lzdHJlZENvbXBvbmVudCAgPSBfdGhpcy5wcm90b3N0dWJzTGlzdC5oYXNPd25Qcm9wZXJ0eShkb21haW5VcmwpID8gX3RoaXMucHJvdG9zdHVic0xpc3RbZG9tYWluVXJsXSA6IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVnaXN0cmVkQ29tcG9uZW50ICYmIHJlZ2lzdHJlZENvbXBvbmVudC5oYXNPd25Qcm9wZXJ0eSgnc3RhdHVzJykgJiYgcmVnaXN0cmVkQ29tcG9uZW50LnN0YXR1cyA9PT0gU1RBVFVTLkRFUExPWUVEKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnUmVzb2x2ZWQ6ICcsIHJlZ2lzdHJlZENvbXBvbmVudC51cmwpO1xuICAgICAgICByZXNvbHZlKHJlZ2lzdHJlZENvbXBvbmVudC51cmwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdkb21haW4taWRwJykge1xuICAgICAgICAgIC8vIF90aGlzLnRyaWdnZXIoJ3J1bnRpbWU6bG9hZElkcFByb3h5JywgZG9tYWluVXJsKTtcblxuICAgICAgICAgIF90aGlzLl9sb2FkZXIubG9hZElkcFByb3h5KGRvbWFpblVybCkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICByZWdpc3RyZWRDb21wb25lbnQgID0gX3RoaXMuaWRwUHJveHlMaXN0W2RvbWFpblVybF07XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJ1Jlc29sdmVkIElEUFByb3h5OiAnLCByZWdpc3RyZWRDb21wb25lbnQsIHJlc3VsdCk7XG4gICAgICAgICAgICBfdGhpcy5pZHBQcm94eUxpc3RbZG9tYWluVXJsXS5zdGF0dXMgPSBTVEFUVVMuREVQTE9ZRUQ7XG4gICAgICAgICAgICByZXNvbHZlKHJlZ2lzdHJlZENvbXBvbmVudC51cmwpO1xuICAgICAgICAgIH0pLmNhdGNoKChyZWFzb24pID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlc29sdmluZyBJRFBQcm94eTogJywgcmVhc29uKTtcbiAgICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gX3RoaXMudHJpZ2dlcigncnVudGltZTpsb2FkU3R1YicsIGRvbWFpblVybCk7XG5cbiAgICAgICAgICBfdGhpcy5fbG9hZGVyLmxvYWRTdHViKGRvbWFpblVybCkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICByZWdpc3RyZWRDb21wb25lbnQgID0gX3RoaXMucHJvdG9zdHVic0xpc3RbZG9tYWluVXJsXTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnUmVzb2x2ZWQgUHJvdG9zdHViOiAnLCByZWdpc3RyZWRDb21wb25lbnQsIHJlc3VsdCk7XG4gICAgICAgICAgICBfdGhpcy5wcm90b3N0dWJzTGlzdFtkb21haW5VcmxdLnN0YXR1cyA9IFNUQVRVUy5ERVBMT1lFRDtcbiAgICAgICAgICAgIHJlc29sdmUocmVnaXN0cmVkQ29tcG9uZW50LnVybCk7XG4gICAgICAgICAgfSkuY2F0Y2goKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVzb2x2aW5nIFByb3Rvc3R1YjogJywgcmVhc29uKTtcbiAgICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0pO1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVnaXN0cnk7XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTYgUFQgSW5vdmHDp8OjbyBlIFNpc3RlbWFzIFNBXG4qIENvcHlyaWdodCAyMDE2IElORVNDLUlEXG4qIENvcHlyaWdodCAyMDE2IFFVT0JJUyBORVRXT1JLUyBTTFxuKiBDb3B5cmlnaHQgMjAxNiBGUkFVTkhPRkVSLUdFU0VMTFNDSEFGVCBaVVIgRk9FUkRFUlVORyBERVIgQU5HRVdBTkRURU4gRk9SU0NIVU5HIEUuVlxuKiBDb3B5cmlnaHQgMjAxNiBPUkFOR0UgU0FcbiogQ29weXJpZ2h0IDIwMTYgRGV1dHNjaGUgVGVsZWtvbSBBR1xuKiBDb3B5cmlnaHQgMjAxNiBBcGl6ZWVcbiogQ29weXJpZ2h0IDIwMTYgVEVDSE5JU0NIRSBVTklWRVJTSVRBVCBCRVJMSU5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKiovXG4vKipcbiogICBAYXV0aG9yOiBHaWwgRGlhcyAoZ2lsLmRpYXNAdGVjbmljby51bGlzYm9hLnB0KVxuKiAgIFJlZ2lzdHJ5IERhdGEgTW9kZWwgaW5jbHVkZXMgYWxsIE9iamVjdHMgdG8gYmUgaGFuZGxlZCBieSB0aGUgUmVnaXN0cnkgZnVuY3Rpb25hbGl0eSBpbmNsdWRpbmdcbiovXG5jbGFzcyBSZWdpc3RyeURhdGFNb2RlbCB7XG5cbiAgY29uc3RydWN0b3IoaWQsIHVybCwgZGVzY3JpcHRvclVSTCwgc3RhcnRpbmdUaW1lLCBsYXN0TW9kaWZpZWQsIHN0YXR1cywgc3R1YnMsIHN0dWJzQ29uZmlndXJhdGlvbikge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG5cbiAgICBfdGhpcy5faWQgPSBpZDtcbiAgICBfdGhpcy5fdXJsID0gdXJsO1xuICAgIF90aGlzLl9kZXNjcmlwdG9yVVJMID0gZGVzY3JpcHRvclVSTDtcbiAgICBfdGhpcy5fc3RhcnRpbmdUaW1lID0gc3RhcnRpbmdUaW1lO1xuICAgIF90aGlzLl9sYXN0TW9kaWZpZWQgPSBsYXN0TW9kaWZpZWQ7XG4gICAgX3RoaXMuX3N0YXR1cyA9IHN0YXR1cztcbiAgICBfdGhpcy5fc3R1YnMgPSBzdHVicztcbiAgICBfdGhpcy5fc3R1YnNDb25maWd1cmF0aW9uID0gc3R1YnNDb25maWd1cmF0aW9uO1xuICB9XG5cbiAgZ2V0IGlkKCkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG4gICAgcmV0dXJuIF90aGlzLl9pZDtcbiAgfVxuXG4gIGdldCB1cmwoKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcbiAgICByZXR1cm4gX3RoaXMuX3VybDtcbiAgfVxuXG4gIGdldCBkZXNjcmlwdG9yKCkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG4gICAgcmV0dXJuIF90aGlzLl9kZXNjcmlwdG9yVVJMO1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVnaXN0cnlEYXRhTW9kZWw7XG4iLCJpbXBvcnQge2RpdmlkZVVSTCwgZ2V0Q29uZmlndXJhdGlvblJlc291cmNlcywgYnVpbGRVUkx9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcblxuY2xhc3MgRGVzY3JpcHRvcnMge1xuXG4gIGNvbnN0cnVjdG9yKHJ1bnRpbWVVUkwsIGNhdGFsb2d1ZSwgcnVudGltZUNvbmZpZ3VyYXRpb24pIHtcbiAgICBpZiAoIXJ1bnRpbWVVUkwpIHRocm93IEVycm9yKCdUaGUgZGVzY3JpcHRvciBuZWVkIHRvIGtub3cgdGhlIHJ1bnRpbWUgdXJsIHRvIGJlIHVzZWQnKTtcbiAgICBpZiAoIWNhdGFsb2d1ZSkgdGhyb3cgRXJyb3IoJ1RoZSBkZXNjcmlwdG9yIG5lZWRzIHRoZSBjYXRhbG9ndWUgaW5zdGFuY2UnKTtcbiAgICBpZiAoIXJ1bnRpbWVDb25maWd1cmF0aW9uKSB0aHJvdyBFcnJvcignVGhlIGRlc2NyaXB0b3IgbmVlZHMgdGhlIHJ1bnRpbWUgY29uZmlndXJhdGlvbicpO1xuXG4gICAgdGhpcy5ydW50aW1lQ29uZmlndXJhdGlvbiA9IHJ1bnRpbWVDb25maWd1cmF0aW9uO1xuICAgIHRoaXMucnVudGltZVVSTCA9IHJ1bnRpbWVVUkw7XG4gICAgdGhpcy5jYXRhbG9ndWUgPSBjYXRhbG9ndWU7XG4gIH1cblxuICBnZXRIeXBlcnR5RGVzY3JpcHRvciAoaHlwZXJ0eVVSTCkge1xuICAgIHJldHVybiB0aGlzLmNhdGFsb2d1ZS5nZXRIeXBlcnR5RGVzY3JpcHRvcihoeXBlcnR5VVJMKTtcbiAgfVxuXG4gIGdldFN0dWJEZXNjcmlwdG9yIChzdHViVVJMKSB7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICBsZXQgZGl2aWRlZFVSTCA9IGRpdmlkZVVSTChzdHViVVJMKTtcbiAgICAgIGxldCBkb21haW4gPSBkaXZpZGVkVVJMLmRvbWFpbjtcbiAgICAgIGxldCBwcm90b3N0dWIgPSBkaXZpZGVkVVJMLmlkZW50aXR5O1xuICAgICAgbGV0IHByb3RvU3R1YlVSTDtcblxuICAgICAgbGV0IG9yaWdpbkRpdmlkZWRVUkwgPSBkaXZpZGVVUkwodGhpcy5ydW50aW1lVVJMKTtcbiAgICAgIGxldCBvcmlnaW5Eb21haW4gPSBvcmlnaW5EaXZpZGVkVVJMLmRvbWFpbjtcblxuICAgICAgaWYgKCFkb21haW4pIHtcbiAgICAgICAgZG9tYWluID0gaWRwUHJveHlVUkw7XG4gICAgICB9XG5cbiAgICAgIGlmICghcHJvdG9zdHViKSB7XG4gICAgICAgIHByb3Rvc3R1YiA9ICdkZWZhdWx0JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3Rvc3R1YiA9IHByb3Rvc3R1Yi5zdWJzdHJpbmcocHJvdG9zdHViLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgICAgIH1cblxuICAgICAgcHJvdG9TdHViVVJMID0gYnVpbGRVUkwodGhpcy5ydW50aW1lQ29uZmlndXJhdGlvbiwgJ2NhdGFsb2d1ZVVSTHMnLCAncHJvdG9jb2xzdHViJywgcHJvdG9zdHViKTtcbiAgICAgIGlmIChkb21haW4gIT09IHRoaXMucnVudGltZUNvbmZpZ3VyYXRpb24uZG9tYWluKSB7XG4gICAgICAgIGlmICghc3R1YlVSTC5pbmRleE9mKCdodHRwcycpIHx8ICFzdHViVVJMLmluZGV4T2YoJ2h5cGVydHktY2F0YWxvZ3VlJykpIHtcbiAgICAgICAgICBwcm90b1N0dWJVUkwgPSBzdHViVVJMO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgLy8gVE9ETzogY2hlY2sgaG93IHRvIGxvYWQgZm9ybSBkaWZmZXJlbnQgY29uZmlndXJhdGlvbiBkb21haW5cbiAgICAgICAgICBsZXQgcmVzb3VyY2UgPSBnZXRDb25maWd1cmF0aW9uUmVzb3VyY2VzKHRoaXMucnVudGltZUNvbmZpZ3VyYXRpb24sICdjYXRhbG9ndWVVUkxzJywgJ3Byb3RvY29sc3R1YicpO1xuICAgICAgICAgIHByb3RvU3R1YlVSTCA9IHJlc291cmNlLnByZWZpeCArIGRvbWFpbiArIHJlc291cmNlLnN1ZmZpeCArIHByb3Rvc3R1YjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygnTG9hZCBQcm90b2NvbFN0dWIgZm9yIGRvbWFpbiwgJyArIGRvbWFpbiArICcgOiAnLCBwcm90b1N0dWJVUkwpO1xuICAgICAgcmV0dXJuIHRoaXMuY2F0YWxvZ3VlLmdldFN0dWJEZXNjcmlwdG9yKHByb3RvU3R1YlVSTCkudGhlbigocmVzdWx0KSA9PiB7XG5cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuXG4gICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcblxuICAgICAgICBjb25zb2xlLmxvZygnRXJyb3I6ICcsIGVycm9yKTtcblxuICAgICAgICBwcm90b3N0dWIgPSBkb21haW47XG4gICAgICAgIGRvbWFpbiA9IG9yaWdpbkRvbWFpbjtcblxuICAgICAgICBsZXQgcmVzb3VyY2UgPSBnZXRDb25maWd1cmF0aW9uUmVzb3VyY2VzKHRoaXMucnVudGltZUNvbmZpZ3VyYXRpb24sICdjYXRhbG9ndWVVUkxzJywgJ3Byb3RvY29sc3R1YicpO1xuICAgICAgICBwcm90b1N0dWJVUkwgPSByZXNvdXJjZS5wcmVmaXggKyBkb21haW4gKyByZXNvdXJjZS5zdWZmaXggKyBwcm90b3N0dWI7XG5cbiAgICAgICAgY29uc29sZS5sb2coJ0ZhbGxiYWNrIC0+IExvYWQgUHJvdG9jb2xzdHViIGZvciBkb21haW4sICcgKyBkb21haW4gKyAnIDogJywgcHJvdG9zdHViKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2F0YWxvZ3VlLmdldFN0dWJEZXNjcmlwdG9yKHByb3RvU3R1YlVSTCk7XG4gICAgICB9KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfSkuY2F0Y2goKHJlYXNvbikgPT4ge1xuICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgIH0pO1xuXG4gICAgfSk7XG4gIH1cblxuICBnZXRJZHBQcm94eURlc2NyaXB0b3IoaWRwUHJveHlVUkwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICBsZXQgZGl2aWRlZFVSTCA9IGRpdmlkZVVSTChpZHBQcm94eVVSTCk7XG4gICAgICBsZXQgZG9tYWluID0gZGl2aWRlZFVSTC5kb21haW47XG4gICAgICBsZXQgaWRwcHJveHkgPSBkaXZpZGVkVVJMLmlkZW50aXR5O1xuXG4gICAgICBsZXQgb3JpZ2luRGl2aWRlZFVSTCA9IGRpdmlkZVVSTCh0aGlzLnJ1bnRpbWVVUkwpO1xuICAgICAgbGV0IG9yaWdpbkRvbWFpbiA9IG9yaWdpbkRpdmlkZWRVUkwuZG9tYWluO1xuXG4gICAgICBpZiAoIWRvbWFpbikge1xuICAgICAgICBkb21haW4gPSBpZHBQcm94eVVSTDtcbiAgICAgIH1cblxuICAgICAgaWYgKGRvbWFpbiA9PT0gb3JpZ2luRG9tYWluIHx8ICFpZHBwcm94eSkge1xuICAgICAgICBpZHBwcm94eSA9ICdkZWZhdWx0JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkcHByb3h5ID0gaWRwcHJveHkuc3Vic3RyaW5nKGlkcHByb3h5Lmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHJlc291cmNlID0gZ2V0Q29uZmlndXJhdGlvblJlc291cmNlcyh0aGlzLnJ1bnRpbWVDb25maWd1cmF0aW9uLCAnY2F0YWxvZ3VlVVJMcycsICdpZHBQcm94eScpO1xuXG4gICAgICBpZHBQcm94eVVSTCA9IHJlc291cmNlLnByZWZpeCArIGRvbWFpbiArIHJlc291cmNlLnN1ZmZpeCArIGlkcHByb3h5O1xuICAgICAgY29uc29sZS5sb2coJ0xvYWQgSWRwIFByb3h5IGZvciBkb21haW4sICcgKyBkb21haW4gKyAnIDogJywgaWRwUHJveHlVUkwpO1xuICAgICAgcmV0dXJuIHRoaXMuY2F0YWxvZ3VlLmdldElkcFByb3h5RGVzY3JpcHRvcihpZHBQcm94eVVSTCkudGhlbigocmVzdWx0KSA9PiB7XG5cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuXG4gICAgICB9KS5jYXRjaCgoKSA9PiB7XG5cbiAgICAgICAgaWRwcHJveHkgPSBkb21haW47XG4gICAgICAgIGRvbWFpbiA9IG9yaWdpbkRvbWFpbjtcblxuICAgICAgICBpZHBQcm94eVVSTCA9IGJ1aWxkVVJMKHRoaXMucnVudGltZUNvbmZpZ3VyYXRpb24sICdjYXRhbG9ndWVVUkxzJywgJ2lkcFByb3h5JywgaWRwcHJveHkpO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdMb2FkIElkcCBQcm94eSBmb3IgZG9tYWluLCAnICsgZG9tYWluICsgJyA6ICcsIGlkcFByb3h5VVJMKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2F0YWxvZ3VlLmdldElkcFByb3h5RGVzY3JpcHRvcihpZHBQcm94eVVSTCk7XG4gICAgICB9KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfSkuY2F0Y2goKHJlYXNvbikgPT4ge1xuICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgIH0pO1xuXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGVzY3JpcHRvcnM7XG4iLCJpbXBvcnQge2RpdmlkZVVSTCwgZW1wdHlPYmplY3R9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCBEZXNjcmlwdG9ycyBmcm9tICcuL0Rlc2NyaXB0b3JzJztcbmltcG9ydCBBZGRyZXNzQWxsb2NhdGlvbiBmcm9tICcuLi9hbGxvY2F0aW9uL0FkZHJlc3NBbGxvY2F0aW9uJztcblxuY2xhc3MgTG9hZGVyIHtcblxuICBjb25zdHJ1Y3RvcihydW50aW1lQ29uZmlndXJhdGlvbikge1xuICAgIGlmICghcnVudGltZUNvbmZpZ3VyYXRpb24pIHRocm93IEVycm9yKCdUaGUgZGVzY3JpcHRvciBuZWVkIHRvIGtub3cgdGhlIHJ1bnRpbWUgY29uZmlndXJhdGlvbicpO1xuICAgIHRoaXMucnVudGltZUNvbmZpZ3VyYXRpb24gPSBydW50aW1lQ29uZmlndXJhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgcnVudGltZSB1cmxcbiAgICogQHBhcmFtICB7c3RyaW5nfSB2YWx1ZSBydW50aW1lVVJMXG4gICAqL1xuICBzZXQgcnVudGltZVVSTCh2YWx1ZSkge1xuICAgIHRoaXMuX3J1bnRpbWVVUkwgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgcnVudGltZSB1cmxcbiAgICogQHJldHVybiB7c3RyaW5nfSB2YWx1ZSBydW50aW1lVVJMXG4gICAqL1xuICBnZXQgcnVudGltZVVSTCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcnVudGltZVVSTDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgUmVnaXN0cnkgY29tcG9uZW50XG4gICAqIEBwYXJhbSAge1JlZ2lzdHJ5fSB2YWx1ZSBSZWdpc3RyeSBDb21wb25lbnRcbiAgICovXG4gIHNldCByZWdpc3RyeSh2YWx1ZSkge1xuICAgIHRoaXMuX3JlZ2lzdHJ5ID0gdmFsdWU7XG5cbiAgICAvLyBJbnN0YWxsIEFkZHJlc3NBbGxvY2F0aW9uXG4gICAgbGV0IGFkZHJlc3NBbGxvY2F0aW9uID0gbmV3IEFkZHJlc3NBbGxvY2F0aW9uKHRoaXMuX3J1bnRpbWVVUkwsIHRoaXMuX21lc3NhZ2VzQnVzLCB0aGlzLl9yZWdpc3RyeSk7XG4gICAgdGhpcy5fYWRkcmVzc0FsbG9jYXRpb24gPSBhZGRyZXNzQWxsb2NhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgUmVnaXN0cnkgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge1JlZ2lzdHJ5fSBSZWdpc3RyeSBjb21wb25lbnRcbiAgICovXG4gIGdldCByZWdpc3RyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVnaXN0cnk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IFJ1bnRpbWUgQ2F0YWxvZ3VlIENvbXBvbmVudFxuICAgKiBAcGFyYW0gIHtSdW50aW1lQ2F0YWxvZ3VlfSB2YWx1ZSBydW50aW1lIGNhdGFsb2d1ZSBjb21wb25lbnRcbiAgICovXG4gIHNldCBydW50aW1lQ2F0YWxvZ3VlKHZhbHVlKSB7XG4gICAgdGhpcy5fcnVudGltZUNhdGFsb2d1ZSA9IHZhbHVlO1xuXG4gICAgdGhpcy5kZXNjcmlwdG9ycyA9IG5ldyBEZXNjcmlwdG9ycyh0aGlzLl9ydW50aW1lVVJMLCB2YWx1ZSwgdGhpcy5ydW50aW1lQ29uZmlndXJhdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogR2V0IFJ1bnRpbWUgQ2F0YWxvZ3VlIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtSdW50aW1lQ2F0YWxvZ3VlfSBSdW50aW1lIENhdGFsb2d1ZSBjb21wb25lbnRcbiAgICovXG4gIGdldCBydW50aW1lQ2F0YWxvZ3VlKCkge1xuICAgIHJldHVybiB0aGlzLl9ydW50aW1lQ2F0YWxvZ3VlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBNZXNzYWdlIEJ1cyBjb21wb25lbnRcbiAgICogQHBhcmFtICB7TWVzc2FnZUJ1c30gdmFsdWUgTWVzc2FnZSBidXMgY29tcG9uZW50XG4gICAqL1xuICBzZXQgbWVzc2FnZUJ1cyh2YWx1ZSkge1xuICAgIHRoaXMuX21lc3NhZ2VzQnVzID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IE1lc3NhZ2UgQnVzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtNZXNzYWdlQnVzfSBNZXNzYWdlIEJ1cyBjb21wb25lbnRcbiAgICovXG4gIGdldCBtZXNzYWdlQnVzKCkge1xuICAgIHJldHVybiB0aGlzLl9tZXNzYWdlc0J1cztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgUnVudGltZSBGYWN0b3J5IGNvbXBvbmVudFxuICAgKiBAcGFyYW0gIHtydW50aW1lRmFjdG9yeX0gdmFsdWUgRmFjdG9yeSBpbmNsdWRlcyB0aGUgc3BlY2lmaWMgaW1wbGVtZW50YXRpb25zIGZvciBlYWNoIGVudmlyb25tZW50XG4gICAqL1xuICBzZXQgcnVudGltZUZhY3RvcnkodmFsdWUpIHtcbiAgICB0aGlzLl9ydW50aW1lRmFjdG9yeSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBSdW50aW1lIEZhY3RvcnkgY29tcG9uZW50XG4gICAqIEByZXR1cm4ge3J1bnRpbWVGYWN0b3J5fSBSdW50aW1lIEZhY3RvcnkgY29tcG9uZW50XG4gICAqL1xuICBnZXQgcnVudGltZUZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3J1bnRpbWVGYWN0b3J5O1xuICB9XG5cbiAgLyoqXG4gICogRGVwbG95IEh5cGVydHkgZnJvbSBDYXRhbG9ndWUgVVJMXG4gICogQHBhcmFtICB7VVJMLkh5cGVydHlDYXRhbG9ndWVVUkx9ICAgIGh5cGVydHkgaHlwZXJ0eURlc2NyaXB0b3IgdXJsO1xuICAqL1xuICBsb2FkSHlwZXJ0eShoeXBlcnR5RGVzY3JpcHRvclVSTCkge1xuXG4gICAgaWYgKCF0aGlzLl9yZWFkeVRvVXNlKCkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWh5cGVydHlEZXNjcmlwdG9yVVJMKSB0aHJvdyBuZXcgRXJyb3IoJ0h5cGVydHkgZGVzY3JpcHRvciB1cmwgcGFyYW1ldGVyIGlzIG5lZWRlZCcpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgbGV0IF9oeXBlcnR5VVJMO1xuICAgICAgbGV0IF9oeXBlcnR5U2FuZGJveDtcbiAgICAgIGxldCBfaHlwZXJ0eURlc2NyaXB0b3I7XG4gICAgICBsZXQgX2h5cGVydHlTb3VyY2VQYWNrYWdlO1xuICAgICAgbGV0IGhhdmVFcnJvciA9IGZhbHNlO1xuXG4gICAgICBsZXQgZXJyb3JSZWFzb24gPSAocmVhc29uKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NvbWV0aGluZyBmYWlsZWQgb24gdGhlIGRlcGxveSBoeXBlcnR5OiAnLCByZWFzb24pO1xuICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgIH07XG5cbiAgICAgIGxldCBoYW5kbGVFcnJvciA9IChyZWFzb24pID0+IHtcbiAgICAgICAgaGF2ZUVycm9yID0gdHJ1ZTtcbiAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICB9O1xuXG4gICAgICAvLyBHZXQgSHlwZXJ0eSBkZXNjcmlwdG9yXG4gICAgICAvLyBUT0RPOiB0aGUgcmVxdWVzdCBNb2R1bGUgc2hvdWxkIGJlIGNoYW5nZWQsXG4gICAgICAvLyBiZWNhdXNlIGF0IHRoaXMgbW9tZW50IGl0IGlzIGluY29tcGF0aWJsZSB3aXRoIG5vZGVqcztcbiAgICAgIC8vIFByb2JhYmx5IHdlIG5lZWQgdG8gcGFzcyBhIGZhY3RvcnkgbGlrZSB3ZSBkbyBmb3Igc2FuZGJveGVzO1xuICAgICAgY29uc29sZS5pbmZvKCctLS0tLS0tLS0tLS0tLS0tLS0gSHlwZXJ0eSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nKTtcbiAgICAgIGNvbnNvbGUuaW5mbygnR2V0IGh5cGVydHkgZGVzY3JpcHRvciBmb3IgOicsIGh5cGVydHlEZXNjcmlwdG9yVVJMKTtcbiAgICAgIHJldHVybiB0aGlzLmRlc2NyaXB0b3JzLmdldEh5cGVydHlEZXNjcmlwdG9yKGh5cGVydHlEZXNjcmlwdG9yVVJMKVxuICAgICAgLnRoZW4oKGh5cGVydHlEZXNjcmlwdG9yKSA9PiB7XG4gICAgICAgIC8vIGF0IHRoaXMgcG9pbnQsIHdlIGhhdmUgY29tcGxldGVkIFwic3RlcCAyIGFuZCAzXCIgYXMgc2hvd24gaW4gaHR0cHM6Ly9naXRodWIuY29tL3JlVEhJTkstcHJvamVjdC9jb3JlLWZyYW1ld29yay9ibG9iL21hc3Rlci9kb2NzL3NwZWNzL3J1bnRpbWUvZHluYW1pYy12aWV3L2Jhc2ljcy9kZXBsb3ktaHlwZXJ0eS5tZFxuICAgICAgICBjb25zb2xlLmluZm8oJzE6IHJldHVybiBoeXBlcnR5IGRlc2NyaXB0b3InKTtcblxuICAgICAgICAvLyBoeXBlcnR5IGNvbnRhaW5zIHRoZSBmdWxsIHBhdGggb2YgdGhlIGNhdGFsb2d1ZSBVUkwsIGUuZy5cbiAgICAgICAgLy8gY2F0YWxvZ3VlLnJldGhpbmsuZXUvLndlbGwta25vd24vLi4uLi4uLi4uLlxuICAgICAgICBfaHlwZXJ0eURlc2NyaXB0b3IgPSBoeXBlcnR5RGVzY3JpcHRvcjtcblxuICAgICAgICBsZXQgc291cmNlUGFja2FnZVVSTCA9IGh5cGVydHlEZXNjcmlwdG9yLnNvdXJjZVBhY2thZ2VVUkw7XG5cbiAgICAgICAgaWYgKHNvdXJjZVBhY2thZ2VVUkwgPT09ICcvc291cmNlUGFja2FnZScpIHtcbiAgICAgICAgICByZXR1cm4gaHlwZXJ0eURlc2NyaXB0b3Iuc291cmNlUGFja2FnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCB0aGUgaHlwZXJ0eSBzb3VyY2UgY29kZVxuICAgICAgICByZXR1cm4gdGhpcy5ydW50aW1lQ2F0YWxvZ3VlLmdldFNvdXJjZVBhY2thZ2VGcm9tVVJMKHNvdXJjZVBhY2thZ2VVUkwpO1xuICAgICAgfSwgaGFuZGxlRXJyb3IpXG4gICAgICAudGhlbigoc291cmNlUGFja2FnZSkgPT4ge1xuICAgICAgICBpZiAoaGF2ZUVycm9yKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgY29uc29sZS5pbmZvKCcyOiByZXR1cm4gaHlwZXJ0eSBzb3VyY2UgY29kZScpO1xuXG4gICAgICAgIC8vIGF0IHRoaXMgcG9pbnQsIHdlIGhhdmUgY29tcGxldGVkIFwic3RlcCA0IGFuZCA1XCIgYXMgc2hvd24gaW4gaHR0cHM6Ly9naXRodWIuY29tL3JlVEhJTkstcHJvamVjdC9jb3JlLWZyYW1ld29yay9ibG9iL21hc3Rlci9kb2NzL3NwZWNzL3J1bnRpbWUvZHluYW1pYy12aWV3L2Jhc2ljcy9kZXBsb3ktaHlwZXJ0eS5tZFxuXG4gICAgICAgIF9oeXBlcnR5U291cmNlUGFja2FnZSA9IHNvdXJjZVBhY2thZ2U7XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gc3RlcHMgNiAtLSA5IGFyZSBza2lwcGVkLlxuICAgICAgICAvLyBUT0RPOiBvbiByZWxlYXNlIG9mIGNvcmUgMC4yO1xuICAgICAgICAvLyBUT0RPOiBQcm9taXNlIHRvIGNoZWNrIHRoZSBwb2xpY3kgZW5naW5lXG5cbiAgICAgICAgLy8gbW9jay11cCBjb2RlO1xuICAgICAgICAvLyB0ZW1wb3JhcnkgY29kZSwgb25seVxuICAgICAgICBsZXQgcG9saWN5ID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gcG9saWN5O1xuICAgICAgfSwgaGFuZGxlRXJyb3IpXG4gICAgICAudGhlbigocG9saWN5UmVzdWx0KSA9PiB7XG4gICAgICAgIGlmIChoYXZlRXJyb3IpIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc29sZS5pbmZvKCczOiByZXR1cm4gcG9saWN5IGVuZ2luZSByZXN1bHQnICsgcG9saWN5UmVzdWx0KTtcblxuICAgICAgICAvLyB3ZSBoYXZlIGNvbXBsZXRlZCBzdGVwIDYgdG8gOSBvZiBodHRwczovL2dpdGh1Yi5jb20vcmVUSElOSy1wcm9qZWN0L2NvcmUtZnJhbWV3b3JrL2Jsb2IvbWFzdGVyL2RvY3Mvc3BlY3MvcnVudGltZS9keW5hbWljLXZpZXcvYmFzaWNzL2RlcGxveS1oeXBlcnR5Lm1kIHJpZ2h0IG5vdy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gU3RlcHMgNiAtLSA5XG4gICAgICAgIC8vIEFzIGEgcmVzdWx0IG9mIHRoZSBzaXBwZWQgc3RlcHMsIHdlIGtub3cgYXQgdGhpcyBwb2ludCBpZiB3ZSBleGVjdXRlXG4gICAgICAgIC8vIGluU2FtZVNhbmRib3ggb3Igbm90LlxuICAgICAgICAvL1xuXG4gICAgICAgIC8vIEZvciB0ZXN0aW5nLCBqdXN0IGFzc3VtZSB3ZSBleGVjdXRlIGluIHNhbWUgU2FuZGJveC5cbiAgICAgICAgbGV0IGluU2FtZVNhbmRib3ggPSB0cnVlO1xuICAgICAgICBsZXQgc2FuZGJveDtcblxuICAgICAgICBpZiAoaW5TYW1lU2FuZGJveCkge1xuXG4gICAgICAgICAgLy8gdGhpcyBkb24ndCBuZWVkIGJlIGEgUHJvbWlzZTtcbiAgICAgICAgICBzYW5kYm94ID0gdGhpcy5yZWdpc3RyeS5nZXRBcHBTYW5kYm94KCk7XG5cbiAgICAgICAgICAvLyB3ZSBoYXZlIGNvbXBsZXRlZCBzdGVwIDExIGhlcmUuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBsZXQgZG9tYWluID0gZGl2aWRlVVJMKGh5cGVydHlEZXNjcmlwdG9yVVJMKS5kb21haW47XG5cbiAgICAgICAgICAvLyBnZXRTYW5kYm94LCB0aGlzIHdpbGwgcmV0dXJuIGEgcHJvbWlzZTtcbiAgICAgICAgICBzYW5kYm94ID0gdGhpcy5yZWdpc3RyeS5nZXRTYW5kYm94KGRvbWFpbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGlzIHdpbGwgcmV0dXJuIHRoZSBzYW5kYm94IG9yIG9uZSBwcm9taXNlIHRvIGdldFNhbmRib3g7XG4gICAgICAgIHJldHVybiBzYW5kYm94O1xuICAgICAgfSwgaGFuZGxlRXJyb3IpXG4gICAgICAudGhlbigoc2FuZGJveCkgPT4ge1xuICAgICAgICBpZiAoaGF2ZUVycm9yKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnNDogcmV0dXJuIHRoZSBzYW5kYm94Jywgc2FuZGJveCk7XG5cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBzYW5kYm94IGluZGVwZW50ZWx5IGlmIGl0IHJ1bm5pbmcgaW4gdGhlIHNhbWUgc2FuZGJveCBvciBub3RcbiAgICAgICAgLy8gd2UgaGF2ZSBjb21wbGV0ZWQgc3RlcCAxNCBoZXJlLlxuICAgICAgICByZXR1cm4gc2FuZGJveDtcbiAgICAgIH0sIChyZWFzb24pID0+IHtcbiAgICAgICAgaWYgKGhhdmVFcnJvcikgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zb2xlLmVycm9yKCc0LjE6IFRyeSB0byByZWdpc3RlciBhIG5ldyBzYW5kYm94Jyk7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHNhbmRib3ggaXMgcmVnaXN0ZWQgZm9yIHRoaXMgaHlwZXJ0eSBkZXNjcmlwdG9yIHVybDtcbiAgICAgICAgLy8gTWFrZSBTdGVwcyB4eHggLS0tIHh4eFxuICAgICAgICAvLyBJbnN0YW50aWF0ZSB0aGUgU2FuZGJveFxuICAgICAgICBsZXQgc2FuZGJveCA9IHRoaXMuX3J1bnRpbWVGYWN0b3J5LmNyZWF0ZVNhbmRib3goKTtcblxuICAgICAgICBzYW5kYm94LmFkZExpc3RlbmVyKCcqJywgKG1zZykgPT4ge1xuICAgICAgICAgIHRoaXMubWVzc2FnZUJ1cy5wb3N0TWVzc2FnZShtc2cpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc2FuZGJveDtcbiAgICAgIH0sIGhhbmRsZUVycm9yKVxuICAgICAgLnRoZW4oKHNhbmRib3gpID0+IHtcbiAgICAgICAgaWYgKGhhdmVFcnJvcikgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zb2xlLmluZm8oJzU6IHJldHVybiBzYW5kYm94IGFuZCByZWdpc3RlcicpO1xuXG4gICAgICAgIF9oeXBlcnR5U2FuZGJveCA9IHNhbmRib3g7XG5cbiAgICAgICAgbGV0IG51bWJlck9mQWRkcmVzc2VzID0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZHJlc3NBbGxvY2F0aW9uLmNyZWF0ZSh0aGlzLl9yZWdpc3RyeS5fZG9tYWluLCBudW1iZXJPZkFkZHJlc3NlcywgX2h5cGVydHlEZXNjcmlwdG9yLCAnaHlwZXJ0eScpO1xuICAgICAgfSwgaGFuZGxlRXJyb3IpXG4gICAgICAudGhlbigoYWRkcmVzc2VzKSA9PiB7XG4gICAgICAgIGlmIChoYXZlRXJyb3IpIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc29sZS5pbmZvKCc2OiByZXR1cm4gdGhlIGFkZHJlc3NlcyBmb3IgdGhlIGh5cGVydHknKTtcblxuICAgICAgICAvLyBSZWdpc3RlciBoeXBlcnR5XG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5LnJlZ2lzdGVySHlwZXJ0eShfaHlwZXJ0eVNhbmRib3gsIGh5cGVydHlEZXNjcmlwdG9yVVJMLCBfaHlwZXJ0eURlc2NyaXB0b3IsIGFkZHJlc3Nlcyk7XG4gICAgICB9LCBoYW5kbGVFcnJvcilcbiAgICAgIC50aGVuKChoeXBlcnR5VVJMKSA9PiB7XG4gICAgICAgIGlmIChoYXZlRXJyb3IpIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc29sZS5pbmZvKCc3OiBIeXBlcnR5IHVybCwgYWZ0ZXIgcmVnaXN0ZXIgaHlwZXJ0eScsIGh5cGVydHlVUkwpO1xuXG4gICAgICAgIC8vIHdlIGhhdmUgY29tcGxldGVkIHN0ZXAgMTYgb2YgaHR0cHM6Ly9naXRodWIuY29tL3JlVEhJTkstcHJvamVjdC9jb3JlLWZyYW1ld29yay9ibG9iL21hc3Rlci9kb2NzL3NwZWNzL3J1bnRpbWUvZHluYW1pYy12aWV3L2Jhc2ljcy9kZXBsb3ktaHlwZXJ0eS5tZCByaWdodCBub3cuXG4gICAgICAgIF9oeXBlcnR5VVJMID0gaHlwZXJ0eVVSTDtcblxuICAgICAgICAvLyBFeHRlbmQgb3JpZ2luYWwgaHlwZXJ0eSBjb25maWd1cmF0aW9uO1xuICAgICAgICBsZXQgY29uZmlndXJhdGlvbiA9IHt9O1xuICAgICAgICBpZiAoIWVtcHR5T2JqZWN0KF9oeXBlcnR5RGVzY3JpcHRvci5jb25maWd1cmF0aW9uKSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25maWd1cmF0aW9uID0gT2JqZWN0LmFzc2lnbih7fSwgSlNPTi5wYXJzZShfaHlwZXJ0eURlc2NyaXB0b3IuY29uZmlndXJhdGlvbikpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb24gPSBfaHlwZXJ0eURlc2NyaXB0b3IuY29uZmlndXJhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlndXJhdGlvbi5ydW50aW1lVVJMID0gdGhpcy5fcnVudGltZVVSTDtcblxuICAgICAgICAvLyBXZSB3aWxsIGRlcGxveSB0aGUgY29tcG9uZW50IC0gc3RlcCAxNyBvZiBodHRwczovL2dpdGh1Yi5jb20vcmVUSElOSy1wcm9qZWN0L2NvcmUtZnJhbWV3b3JrL2Jsb2IvbWFzdGVyL2RvY3Mvc3BlY3MvcnVudGltZS9keW5hbWljLXZpZXcvYmFzaWNzL2RlcGxveS1oeXBlcnR5Lm1kIHJpZ2h0IG5vdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBfaHlwZXJ0eVNhbmRib3guZGVwbG95Q29tcG9uZW50KF9oeXBlcnR5U291cmNlUGFja2FnZS5zb3VyY2VDb2RlLCBfaHlwZXJ0eVVSTCwgY29uZmlndXJhdGlvbik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBvbiBkZXBsb3kgY29tcG9uZW50OicsIGUpO1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfSwgaGFuZGxlRXJyb3IpXG4gICAgICAudGhlbigoZGVwbG95Q29tcG9uZW50U3RhdHVzKSA9PiB7XG4gICAgICAgIGlmIChoYXZlRXJyb3IpIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc29sZS5pbmZvKCc4OiBEZXBsb3kgY29tcG9uZW50IHN0YXR1cyBmb3IgaHlwZXJ0eTogJywgZGVwbG95Q29tcG9uZW50U3RhdHVzKTtcblxuICAgICAgICAvLyB3ZSBoYXZlIGNvbXBsZXRlZCBzdGVwIDE5IGh0dHBzOi8vZ2l0aHViLmNvbS9yZVRISU5LLXByb2plY3QvY29yZS1mcmFtZXdvcmsvYmxvYi9tYXN0ZXIvZG9jcy9zcGVjcy9ydW50aW1lL2R5bmFtaWMtdmlldy9iYXNpY3MvZGVwbG95LWh5cGVydHkubWQgcmlnaHQgbm93LlxuXG4gICAgICAgIC8vIEFkZCB0aGUgbWVzc2FnZSBidXMgbGlzdGVuZXIgdG8gdGhlIGFwcFNhbmRib3ggb3IgaHlwZXJ0U2FuZGJveDtcbiAgICAgICAgdGhpcy5tZXNzYWdlQnVzLmFkZExpc3RlbmVyKF9oeXBlcnR5VVJMLCAobXNnKSA9PiB7XG4gICAgICAgICAgX2h5cGVydHlTYW5kYm94LnBvc3RNZXNzYWdlKG1zZyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHdlIGhhdmUgY29tcGxldGVkIHN0ZXAgMjAgb2YgaHR0cHM6Ly9naXRodWIuY29tL3JlVEhJTkstcHJvamVjdC9jb3JlLWZyYW1ld29yay9ibG9iL21hc3Rlci9kb2NzL3NwZWNzL3J1bnRpbWUvZHluYW1pYy12aWV3L2Jhc2ljcy9kZXBsb3ktaHlwZXJ0eS5tZCByaWdodCBub3cuXG4gICAgICAgIGxldCBoeXBlcnR5ID0ge1xuICAgICAgICAgIHJ1bnRpbWVIeXBlcnR5VVJMOiBfaHlwZXJ0eVVSTCxcbiAgICAgICAgICBzdGF0dXM6IGRlcGxveUNvbXBvbmVudFN0YXR1c1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlc29sdmUoaHlwZXJ0eSk7XG5cbiAgICAgICAgLy8gd2UgaGF2ZSBjb21wbGV0ZWQgc3RlcCAyMSBodHRwczovL2dpdGh1Yi5jb20vcmVUSElOSy1wcm9qZWN0L2NvcmUtZnJhbWV3b3JrL2Jsb2IvbWFzdGVyL2RvY3Mvc3BlY3MvcnVudGltZS9keW5hbWljLXZpZXcvYmFzaWNzL2RlcGxveS1oeXBlcnR5Lm1kIHJpZ2h0IG5vdy5cbiAgICAgICAgY29uc29sZS5pbmZvKCctLS0tLS0tLS0tLS0tLS0tLS0gRU5EIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScpO1xuICAgICAgfSwgaGFuZGxlRXJyb3IpXG4gICAgICAuY2F0Y2goZXJyb3JSZWFzb24pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICogRGVwbG95IFN0dWIgZnJvbSBDYXRhbG9ndWUgVVJMIG9yIGRvbWFpbiB1cmxcbiAgKiBAcGFyYW0gIHtVUkwuVVJMfSAgICAgZG9tYWluICAgICAgICAgIGRvbWFpblxuICAqL1xuICBsb2FkU3R1Yihwcm90b3N0dWJVUkwpIHtcblxuICAgIGlmICghdGhpcy5fcmVhZHlUb1VzZSgpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFwcm90b3N0dWJVUkwpIHRocm93IG5ldyBFcnJvcignUHJvdG9TdHViIGRlc2NyaXB0b3IgdXJsIHBhcmFtZXRlciBpcyBuZWVkZWQnKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cbiAgICAgIGxldCBkb21haW4gPSBkaXZpZGVVUkwocHJvdG9zdHViVVJMKS5kb21haW47XG5cbiAgICAgIGlmICghZG9tYWluKSB7XG4gICAgICAgIGRvbWFpbiA9IHByb3Rvc3R1YlVSTDtcbiAgICAgIH1cblxuICAgICAgbGV0IF9zdHViU2FuZGJveDtcbiAgICAgIGxldCBfc3R1YkRlc2NyaXB0b3I7XG4gICAgICBsZXQgX3J1bnRpbWVQcm90b1N0dWJVUkw7XG4gICAgICBsZXQgX3N0dWJTb3VyY2VQYWNrYWdlO1xuICAgICAgbGV0IGhhdmVFcnJvciA9IGZhbHNlO1xuXG4gICAgICBsZXQgZXJyb3JSZWFzb24gPSAocmVhc29uKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NvbWV0aGluZyBmYWlsZWQgb24gdGhlIGRlcGxveSBvZiBwcm90b2NvbHN0dWI6ICcsIHJlYXNvbik7XG4gICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgfTtcblxuICAgICAgbGV0IGhhbmRsZUVycm9yID0gKHJlYXNvbikgPT4ge1xuICAgICAgICBoYXZlRXJyb3IgPSB0cnVlO1xuICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIERpc2NvdmVyIFByb3RvY29sIFN0dWJcbiAgICAgIGNvbnNvbGUuaW5mbygnLS0tLS0tLS0tLS0tLS0tLS0tLSBQcm90b1N0dWIgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuJyk7XG4gICAgICBjb25zb2xlLmluZm8oJ0Rpc2NvdmVyIG9yIENyZWF0ZSBhIG5ldyBQcm90b1N0dWIgZm9yIGRvbWFpbjogJywgZG9tYWluKTtcbiAgICAgIHRoaXMucmVnaXN0cnkuZGlzY292ZXJQcm90b3N0dWIoZG9tYWluKS50aGVuKChydW50aW1lUHJvdG9TdHViVVJMKSA9PiB7XG4gICAgICAgIC8vIElzIHJlZ2lzdGVkP1xuICAgICAgICBjb25zb2xlLmluZm8oJzEuIFByb3RvIFN0dWIgRGlzY292ZXJlZCBmb3IgJywgZG9tYWluLCAnOiAnLCBydW50aW1lUHJvdG9TdHViVVJMKTtcblxuICAgICAgICAvLyB3ZSBoYXZlIGNvbXBsZXRlZCBzdGVwIDIgaHR0cHM6Ly9naXRodWIuY29tL3JlVEhJTkstcHJvamVjdC9jb3JlLWZyYW1ld29yay9ibG9iL21hc3Rlci9kb2NzL3NwZWNzL3J1bnRpbWUvZHluYW1pYy12aWV3L2Jhc2ljcy9kZXBsb3ktcHJvdG9zdHViLm1kXG5cbiAgICAgICAgLy8gVE9ETzogQ2hlY2sgaWYgdGhlIHN0YXR1cyBpcyBzYXZlZCBpbiB0aGUgc3RhdHVzIG9mIHNhbmRib3g7XG4gICAgICAgIC8vIGxldCBzdHViID0ge1xuICAgICAgICAvLyAgIHJ1bnRpbWVQcm90b1N0dWJVUkw6IHJ1bnRpbWVQcm90b1N0dWJVUkwsXG4gICAgICAgIC8vICAgc3RhdHVzOiAnZGVwbG95ZWQnXG4gICAgICAgIC8vIH07XG4gICAgICAgIGxldCBzdHViID0gdGhpcy5yZWdpc3RyeS5wcm90b3N0dWJzTGlzdFtkb21haW5dO1xuICAgICAgICByZXNvbHZlKHN0dWIpO1xuICAgICAgICBjb25zb2xlLmluZm8oJy0tLS0tLS0tLS0tLS0tLS0tLS0gRU5EIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbicpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaCgocmVhc29uKSA9PiB7XG5cbiAgICAgICAgLy8gaXMgbm90IHJlZ2lzdGVkP1xuICAgICAgICBjb25zb2xlLmluZm8oJzEuIFByb3RvIFN0dWIgbm90IGZvdW5kICcgKyByZWFzb24pO1xuXG4gICAgICAgIC8vIHdlIGhhdmUgY29tcGxldGVkIHN0ZXAgMyBodHRwczovL2dpdGh1Yi5jb20vcmVUSElOSy1wcm9qZWN0L2NvcmUtZnJhbWV3b3JrL2Jsb2IvbWFzdGVyL2RvY3Mvc3BlY3MvcnVudGltZS9keW5hbWljLXZpZXcvYmFzaWNzL2RlcGxveS1wcm90b3N0dWIubWRcblxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGdldCBQcm90b1N0dWIgZGVzY3JpcHRvciBzdGVwIDQgaHR0cHM6Ly9naXRodWIuY29tL3JlVEhJTkstcHJvamVjdC9jb3JlLWZyYW1ld29yay9ibG9iL21hc3Rlci9kb2NzL3NwZWNzL3J1bnRpbWUvZHluYW1pYy12aWV3L2Jhc2ljcy9kZXBsb3ktcHJvdG9zdHViLm1kXG4gICAgICAgIHRoaXMuZGVzY3JpcHRvcnMuZ2V0U3R1YkRlc2NyaXB0b3IocHJvdG9zdHViVVJMKVxuICAgICAgICAudGhlbigoc3R1YkRlc2NyaXB0b3IpID0+IHtcbiAgICAgICAgICBpZiAoaGF2ZUVycm9yKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgY29uc29sZS5pbmZvKCcyLiByZXR1cm4gdGhlIFByb3RvU3R1YiBkZXNjcmlwdG9yJyk7XG5cbiAgICAgICAgICAvLyB3ZSBoYXZlIGNvbXBsZXRlZCBzdGVwIDUgaHR0cHM6Ly9naXRodWIuY29tL3JlVEhJTkstcHJvamVjdC9jb3JlLWZyYW1ld29yay9ibG9iL21hc3Rlci9kb2NzL3NwZWNzL3J1bnRpbWUvZHluYW1pYy12aWV3L2Jhc2ljcy9kZXBsb3ktcHJvdG9zdHViLm1kXG4gICAgICAgICAgX3N0dWJEZXNjcmlwdG9yID0gc3R1YkRlc2NyaXB0b3I7XG5cbiAgICAgICAgICBsZXQgc291cmNlUGFja2FnZVVSTCA9IHN0dWJEZXNjcmlwdG9yLnNvdXJjZVBhY2thZ2VVUkw7XG5cbiAgICAgICAgICBpZiAoc291cmNlUGFja2FnZVVSTCA9PT0gJy9zb3VyY2VQYWNrYWdlJykge1xuICAgICAgICAgICAgcmV0dXJuIHN0dWJEZXNjcmlwdG9yLnNvdXJjZVBhY2thZ2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gd2UgbmVlZCB0byBnZXQgUHJvdG9TdHViIFNvdXJjZSBjb2RlIGZyb20gZGVzY3JpcHRvciAtIHN0ZXAgNiBodHRwczovL2dpdGh1Yi5jb20vcmVUSElOSy1wcm9qZWN0L2NvcmUtZnJhbWV3b3JrL2Jsb2IvbWFzdGVyL2RvY3Mvc3BlY3MvcnVudGltZS9keW5hbWljLXZpZXcvYmFzaWNzL2RlcGxveS1wcm90b3N0dWIubWRcbiAgICAgICAgICByZXR1cm4gdGhpcy5ydW50aW1lQ2F0YWxvZ3VlLmdldFNvdXJjZVBhY2thZ2VGcm9tVVJMKHNvdXJjZVBhY2thZ2VVUkwpO1xuICAgICAgICB9LCBoYW5kbGVFcnJvcilcbiAgICAgICAgLmNhdGNoKGVycm9yUmVhc29uKVxuICAgICAgICAudGhlbigoc3R1YlNvdXJjZVBhY2thZ2UpID0+IHtcbiAgICAgICAgICBpZiAoaGF2ZUVycm9yKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgY29uc29sZS5pbmZvKCczLiByZXR1cm4gdGhlIFByb3RvU3R1YiBTb3VyY2UgQ29kZScpO1xuXG4gICAgICAgICAgLy8gd2UgaGF2ZSBjb21wbGV0ZWQgc3RlcCA3IGh0dHBzOi8vZ2l0aHViLmNvbS9yZVRISU5LLXByb2plY3QvY29yZS1mcmFtZXdvcmsvYmxvYi9tYXN0ZXIvZG9jcy9zcGVjcy9ydW50aW1lL2R5bmFtaWMtdmlldy9iYXNpY3MvZGVwbG95LXByb3Rvc3R1Yi5tZFxuXG4gICAgICAgICAgX3N0dWJTb3VyY2VQYWNrYWdlID0gc3R1YlNvdXJjZVBhY2thZ2U7XG5cbiAgICAgICAgICAvLyBUT0RPOiBDaGVjayBvbiBQRVAgKHBvbGljeSBFbmdpbmUpIGlmIHdlIG5lZWQgdGhlIHNhbmRib3ggYW5kIGNoZWNrIGlmIHRoZSBTYW5kYm94IEZhY3RvcnkgaGF2ZSB0aGUgY29udGV4dCBzYW5kYm94O1xuICAgICAgICAgIGxldCBwb2xpY3kgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBwb2xpY3k7XG4gICAgICAgIH0sIGhhbmRsZUVycm9yKVxuICAgICAgICAudGhlbigocG9saWN5KSA9PiB7XG4gICAgICAgICAgaWYgKGhhdmVFcnJvcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgLy8gdGhpcyB3aWxsIHJldHVybiB0aGUgc2FuZGJveCBvciBvbmUgcHJvbWlzZSB0byBnZXRTYW5kYm94O1xuICAgICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5LmdldFNhbmRib3goZG9tYWluKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oKHN0dWJTYW5kYm94KSA9PiB7XG4gICAgICAgICAgaWYgKGhhdmVFcnJvcikgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGNvbnNvbGUuaW5mbygnNC4gaWYgdGhlIHNhbmRib3ggaXMgcmVnaXN0ZXJlZCB0aGVuIHJldHVybiB0aGUgc2FuZGJveCAnLCBzdHViU2FuZGJveCk7XG5cbiAgICAgICAgICAvLyB3ZSBoYXZlIGNvbXBsZXRlZCBzdGVwIHh4eCBodHRwczovL2dpdGh1Yi5jb20vcmVUSElOSy1wcm9qZWN0L2NvcmUtZnJhbWV3b3JrL2Jsb2IvbWFzdGVyL2RvY3Mvc3BlY3MvcnVudGltZS9keW5hbWljLXZpZXcvYmFzaWNzL2RlcGxveS1wcm90b3N0dWIubWRcblxuICAgICAgICAgIF9zdHViU2FuZGJveCA9IHN0dWJTYW5kYm94O1xuICAgICAgICAgIHJldHVybiBzdHViU2FuZGJveDtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChyZWFzb24pID0+IHtcbiAgICAgICAgICBpZiAoaGF2ZUVycm9yKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgY29uc29sZS5pbmZvKCc1LiBTYW5kYm94IHdhcyBub3QgZm91bmQsIGNyZWF0aW5nIGEgbmV3IG9uZSAnLCByZWFzb24pO1xuXG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHNhbmRib3ggaXMgcmVnaXN0ZWQgZm9yIHRoaXMgc3R1YiBkZXNjcmlwdG9yIHVybDtcbiAgICAgICAgICAvLyBNYWtlIFN0ZXBzIHh4eCAtLS0geHh4XG4gICAgICAgICAgLy8gSW5zdGFudGlhdGUgdGhlIFNhbmRib3hcbiAgICAgICAgICBsZXQgc2FuZGJveCA9IHRoaXMuX3J1bnRpbWVGYWN0b3J5LmNyZWF0ZVNhbmRib3goKTtcbiAgICAgICAgICBzYW5kYm94LmFkZExpc3RlbmVyKCcqJywgKG1zZykgPT4ge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlQnVzLnBvc3RNZXNzYWdlKG1zZyk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gc2FuZGJveDtcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oKHNhbmRib3gpID0+IHtcbiAgICAgICAgICBpZiAoaGF2ZUVycm9yKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgY29uc29sZS5pbmZvKCc2LiByZXR1cm4gdGhlIHNhbmRib3ggaW5zdGFuY2UgYW5kIHJlZ2lzdGVyJywgc2FuZGJveCwgJ3RvIGRvbWFpbiAnLCBkb21haW4pO1xuXG4gICAgICAgICAgX3N0dWJTYW5kYm94ID0gc2FuZGJveDtcblxuICAgICAgICAgIC8vIHdlIG5lZWQgcmVnaXN0ZXIgc3R1YiBvbiByZWdpc3RyeSAtIHN0ZXAgeHh4IGh0dHBzOi8vZ2l0aHViLmNvbS9yZVRISU5LLXByb2plY3QvY29yZS1mcmFtZXdvcmsvYmxvYi9tYXN0ZXIvZG9jcy9zcGVjcy9ydW50aW1lL2R5bmFtaWMtdmlldy9iYXNpY3MvZGVwbG95LXByb3Rvc3R1Yi5tZFxuICAgICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5LnJlZ2lzdGVyU3R1Yihfc3R1YlNhbmRib3gsIGRvbWFpbik7XG4gICAgICAgIH0sIGhhbmRsZUVycm9yKVxuICAgICAgICAudGhlbigocnVudGltZVByb3RvU3R1YlVSTCkgPT4ge1xuICAgICAgICAgIGlmIChoYXZlRXJyb3IpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBjb25zb2xlLmluZm8oJzcuIHJldHVybiB0aGUgcnVudGltZSBwcm90b3N0dWIgdXJsOiAnLCBydW50aW1lUHJvdG9TdHViVVJMKTtcblxuICAgICAgICAgIC8vIHdlIGhhdmUgY29tcGxldGVkIHN0ZXAgeHh4IGh0dHBzOi8vZ2l0aHViLmNvbS9yZVRISU5LLXByb2plY3QvY29yZS1mcmFtZXdvcmsvYmxvYi9tYXN0ZXIvZG9jcy9zcGVjcy9ydW50aW1lL2R5bmFtaWMtdmlldy9iYXNpY3MvZGVwbG95LXByb3Rvc3R1Yi5tZFxuXG4gICAgICAgICAgX3J1bnRpbWVQcm90b1N0dWJVUkwgPSBydW50aW1lUHJvdG9TdHViVVJMO1xuXG4gICAgICAgICAgLy8gRXh0ZW5kIG9yaWdpbmFsIGh5cGVydHkgY29uZmlndXJhdGlvbjtcbiAgICAgICAgICBsZXQgY29uZmlndXJhdGlvbiA9IHt9O1xuICAgICAgICAgIGlmICghZW1wdHlPYmplY3QoX3N0dWJEZXNjcmlwdG9yLmNvbmZpZ3VyYXRpb24pKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25maWd1cmF0aW9uID0gT2JqZWN0LmFzc2lnbih7fSwgSlNPTi5wYXJzZShfc3R1YkRlc2NyaXB0b3IuY29uZmlndXJhdGlvbikpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjb25maWd1cmF0aW9uID0gX3N0dWJEZXNjcmlwdG9yLmNvbmZpZ3VyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uZmlndXJhdGlvbi5ydW50aW1lVVJMID0gdGhpcy5fcnVudGltZVVSTDtcblxuICAgICAgICAgIC8vIERlcGxveSBDb21wb25lbnQgc3RlcCB4eHhcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdHViU2FuZGJveC5kZXBsb3lDb21wb25lbnQoX3N0dWJTb3VyY2VQYWNrYWdlLnNvdXJjZUNvZGUsIHJ1bnRpbWVQcm90b1N0dWJVUkwsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIG9uIGRlcGxveSBjb21wb25lbnQ6JywgZSk7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVFcnJvcilcbiAgICAgICAgLnRoZW4oKGRlcGxveUNvbXBvbmVudFN0YXR1cykgPT4ge1xuICAgICAgICAgIGlmIChoYXZlRXJyb3IpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBjb25zb2xlLmluZm8oJzg6IHJldHVybiBkZXBsb3kgY29tcG9uZW50IGZvciBzYW5kYm94IHN0YXR1czogJywgZGVwbG95Q29tcG9uZW50U3RhdHVzKTtcblxuICAgICAgICAgIC8vIHdlIGhhdmUgY29tcGxldGVkIHN0ZXAgeHh4IGh0dHBzOi8vZ2l0aHViLmNvbS9yZVRISU5LLXByb2plY3QvY29yZS1mcmFtZXdvcmsvYmxvYi9tYXN0ZXIvZG9jcy9zcGVjcy9ydW50aW1lL2R5bmFtaWMtdmlldy9iYXNpY3MvZGVwbG95LXByb3Rvc3R1Yi5tZFxuXG4gICAgICAgICAgLy8gQWRkIHRoZSBtZXNzYWdlIGJ1cyBsaXN0ZW5lclxuICAgICAgICAgIHRoaXMubWVzc2FnZUJ1cy5hZGRMaXN0ZW5lcihfcnVudGltZVByb3RvU3R1YlVSTCwgKG1zZykgPT4ge1xuICAgICAgICAgICAgX3N0dWJTYW5kYm94LnBvc3RNZXNzYWdlKG1zZyk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyB3ZSBoYXZlIGNvbXBsZXRlZCBzdGVwIHh4eCBodHRwczovL2dpdGh1Yi5jb20vcmVUSElOSy1wcm9qZWN0L2NvcmUtZnJhbWV3b3JrL2Jsb2IvbWFzdGVyL2RvY3Mvc3BlY3MvcnVudGltZS9keW5hbWljLXZpZXcvYmFzaWNzL2RlcGxveS1wcm90b3N0dWIubWRcbiAgICAgICAgICBsZXQgc3R1YiA9IHRoaXMucmVnaXN0cnkucHJvdG9zdHVic0xpc3RbZG9tYWluXTtcblxuICAgICAgICAgIC8vIC8vIExvYWQgU3R1YiBmdW5jdGlvbiByZXNvbHZlZCB3aXRoIHN1Y2Nlc3M7XG4gICAgICAgICAgLy8gbGV0IHN0dWIgPSB7XG4gICAgICAgICAgLy8gICBydW50aW1lUHJvdG9TdHViVVJMOiBfcnVudGltZVByb3RvU3R1YlVSTCxcbiAgICAgICAgICAvLyAgIHN0YXR1czogZGVwbG95Q29tcG9uZW50U3RhdHVzXG4gICAgICAgICAgLy8gfTtcblxuICAgICAgICAgIGNvbnNvbGUubG9nKCdEZXBsb3llZDogJywgc3R1YiwgZG9tYWluLCB0aGlzLnJlZ2lzdHJ5LnByb3Rvc3R1YnNMaXN0KTtcblxuICAgICAgICAgIHJlc29sdmUoc3R1Yik7XG4gICAgICAgICAgY29uc29sZS5pbmZvKCctLS0tLS0tLS0tLS0tLS0tLS0tIEVORCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4nKTtcblxuICAgICAgICB9LCBoYW5kbGVFcnJvcilcbiAgICAgICAgLmNhdGNoKGVycm9yUmVhc29uKTtcblxuICAgICAgfSk7XG5cbiAgICB9KTtcblxuICB9XG5cbiAgLyoqXG4gICogRGVwbG95IGlkcFByb3h5IGZyb20gQ2F0YWxvZ3VlIFVSTCBvciBkb21haW4gdXJsXG4gICogQHBhcmFtICB7VVJMLlVSTH0gICAgIGRvbWFpbiAgICAgICAgICBkb21haW5cbiAgKi9cbiAgbG9hZElkcFByb3h5KGlkcFByb3h5VVJMKSB7XG5cbiAgICBpZiAoIXRoaXMuX3JlYWR5VG9Vc2UoKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghaWRwUHJveHlVUkwpIHRocm93IG5ldyBFcnJvcignSWRwUHJveHkgZGVzY3JpcHRvciB1cmwgcGFyYW1ldGVyIGlzIG5lZWRlZCcpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgbGV0IGRvbWFpbiA9IGRpdmlkZVVSTChpZHBQcm94eVVSTCkuZG9tYWluO1xuXG4gICAgICBpZiAoIWRvbWFpbikge1xuICAgICAgICBkb21haW4gPSBpZHBQcm94eVVSTDtcbiAgICAgIH1cblxuICAgICAgbGV0IF9wcm94eVNhbmRib3g7XG4gICAgICBsZXQgX3Byb3h5RGVzY3JpcHRvcjtcbiAgICAgIGxldCBfcnVudGltZUlkcFByb3h5VVJMO1xuICAgICAgbGV0IF9wcm94eVNvdXJjZVBhY2thZ2U7XG4gICAgICBsZXQgaGF2ZUVycm9yID0gZmFsc2U7XG5cbiAgICAgIGxldCBlcnJvclJlYXNvbiA9IChyZWFzb24pID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcignU29tZXRoaW5nIGZhaWxlZCBvbiB0aGUgZGVwbG95IG9mIElkcFByb3h5OiAnLCByZWFzb24pO1xuICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgIH07XG5cbiAgICAgIGxldCBoYW5kbGVFcnJvciA9IChyZWFzb24pID0+IHtcbiAgICAgICAgaGF2ZUVycm9yID0gdHJ1ZTtcbiAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICB9O1xuXG4gICAgICAvLyBEaXNjb3ZlciBJRFBQcm94eVxuICAgICAgY29uc29sZS5pbmZvKCctLS0tLS0tLS0tLS0tLS0tLS0tIElEUCBQcm94eSBEZXBsb3kgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuJyk7XG4gICAgICBjb25zb2xlLmluZm8oJ0Rpc2NvdmVyIG9yIENyZWF0ZSBhIG5ldyBJZHBQcm94eSBmb3IgZG9tYWluL1VSTDogJywgZG9tYWluKTtcbiAgICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5LmRpc2NvdmVySWRwUHJveHkoZG9tYWluKVxuICAgICAgLnRoZW4oKHJ1bnRpbWVJZHBQcm94eVVSTCkgPT4ge1xuICAgICAgICAvLyBJcyByZWdpc3RlZD9cbiAgICAgICAgY29uc29sZS5pbmZvKCcxLiBJRFBQcm94eSBEaXNjb3ZlcmVkOiAnLCBydW50aW1lSWRwUHJveHlVUkwpO1xuXG4gICAgICAgIC8vIHdlIGhhdmUgY29tcGxldGVkIHN0ZXAgMiBodHRwczovL2dpdGh1Yi5jb20vcmVUSElOSy1wcm9qZWN0L2NvcmUtZnJhbWV3b3JrL2Jsb2IvbWFzdGVyL2RvY3Mvc3BlY3MvcnVudGltZS9keW5hbWljLXZpZXcvYmFzaWNzL2RlcGxveS1wcm90b3N0dWIubWRcblxuICAgICAgICBsZXQgaWRwUHJveHkgPSB0aGlzLnJlZ2lzdHJ5LmlkcFByb3h5TGlzdFtkb21haW5dO1xuICAgICAgICBjb25zb2xlLmxvZygnRGVwbG95ZWQ6ICcsIGlkcFByb3h5KTtcblxuICAgICAgICByZXNvbHZlKGlkcFByb3h5KTtcbiAgICAgICAgY29uc29sZS5pbmZvKCctLS0tLS0tLS0tLS0tLS0tLS0tIEVORCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4nKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKHJlYXNvbikgPT4ge1xuXG4gICAgICAgIC8vIGlzIG5vdCByZWdpc3RlZD9cbiAgICAgICAgY29uc29sZS5pbmZvKCcxLiBJZHBQcm94eSBub3QgZm91bmQ6JywgcmVhc29uKTtcblxuICAgICAgICAvLyB3ZSBoYXZlIGNvbXBsZXRlZCBzdGVwIDMgaHR0cHM6Ly9naXRodWIuY29tL3JlVEhJTkstcHJvamVjdC9jb3JlLWZyYW1ld29yay9ibG9iL21hc3Rlci9kb2NzL3NwZWNzL3J1bnRpbWUvZHluYW1pYy12aWV3L2Jhc2ljcy9kZXBsb3ktcHJvdG9zdHViLm1kXG5cbiAgICAgICAgLy8gd2UgbmVlZCB0byBnZXQgUHJvdG9TdHViIGRlc2NyaXB0b3Igc3RlcCA0IGh0dHBzOi8vZ2l0aHViLmNvbS9yZVRISU5LLXByb2plY3QvY29yZS1mcmFtZXdvcmsvYmxvYi9tYXN0ZXIvZG9jcy9zcGVjcy9ydW50aW1lL2R5bmFtaWMtdmlldy9iYXNpY3MvZGVwbG95LXByb3Rvc3R1Yi5tZFxuICAgICAgICB0aGlzLmRlc2NyaXB0b3JzLmdldElkcFByb3h5RGVzY3JpcHRvcihpZHBQcm94eVVSTClcbiAgICAgICAgLnRoZW4oKHByb3h5RGVzY3JpcHRvcikgPT4ge1xuXG4gICAgICAgICAgY29uc29sZS5pbmZvKCcyLiBSZXR1cm4gdGhlIElEUFByb3h5IGRlc2NyaXB0b3InKTtcblxuICAgICAgICAgIC8vIHdlIGhhdmUgY29tcGxldGVkIHN0ZXAgNSBodHRwczovL2dpdGh1Yi5jb20vcmVUSElOSy1wcm9qZWN0L2NvcmUtZnJhbWV3b3JrL2Jsb2IvbWFzdGVyL2RvY3Mvc3BlY3MvcnVudGltZS9keW5hbWljLXZpZXcvYmFzaWNzL2RlcGxveS1wcm90b3N0dWIubWRcbiAgICAgICAgICBfcHJveHlEZXNjcmlwdG9yID0gcHJveHlEZXNjcmlwdG9yO1xuXG4gICAgICAgICAgbGV0IHNvdXJjZVBhY2thZ2VVUkwgPSBwcm94eURlc2NyaXB0b3Iuc291cmNlUGFja2FnZVVSTDtcblxuICAgICAgICAgIGlmIChzb3VyY2VQYWNrYWdlVVJMID09PSAnL3NvdXJjZVBhY2thZ2UnKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJveHlEZXNjcmlwdG9yLnNvdXJjZVBhY2thZ2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gd2UgbmVlZCB0byBnZXQgUHJvdG9TdHViIFNvdXJjZSBjb2RlIGZyb20gZGVzY3JpcHRvciAtIHN0ZXAgNiBodHRwczovL2dpdGh1Yi5jb20vcmVUSElOSy1wcm9qZWN0L2NvcmUtZnJhbWV3b3JrL2Jsb2IvbWFzdGVyL2RvY3Mvc3BlY3MvcnVudGltZS9keW5hbWljLXZpZXcvYmFzaWNzL2RlcGxveS1wcm90b3N0dWIubWRcbiAgICAgICAgICByZXR1cm4gdGhpcy5ydW50aW1lQ2F0YWxvZ3VlLmdldFNvdXJjZVBhY2thZ2VGcm9tVVJMKHNvdXJjZVBhY2thZ2VVUkwpO1xuICAgICAgICB9LCBoYW5kbGVFcnJvcilcbiAgICAgICAgLnRoZW4oKHNvdXJjZVBhY2thZ2UpID0+IHtcbiAgICAgICAgICBpZiAoaGF2ZUVycm9yKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgY29uc29sZS5pbmZvKCczLiByZXR1cm4gdGhlIElEUFByb3h5IHNvdXJjZSBwYWNrYWdlJyk7XG5cbiAgICAgICAgICAvLyB3ZSBoYXZlIGNvbXBsZXRlZCBzdGVwIDcgaHR0cHM6Ly9naXRodWIuY29tL3JlVEhJTkstcHJvamVjdC9jb3JlLWZyYW1ld29yay9ibG9iL21hc3Rlci9kb2NzL3NwZWNzL3J1bnRpbWUvZHluYW1pYy12aWV3L2Jhc2ljcy9kZXBsb3ktcHJvdG9zdHViLm1kXG5cbiAgICAgICAgICBfcHJveHlTb3VyY2VQYWNrYWdlID0gc291cmNlUGFja2FnZTtcblxuICAgICAgICAgIC8vIFRPRE86IENoZWNrIG9uIFBFUCAocG9saWN5IEVuZ2luZSkgaWYgd2UgbmVlZCB0aGUgc2FuZGJveCBhbmQgY2hlY2sgaWYgdGhlIFNhbmRib3ggRmFjdG9yeSBoYXZlIHRoZSBjb250ZXh0IHNhbmRib3g7XG4gICAgICAgICAgbGV0IHBvbGljeSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHBvbGljeTtcbiAgICAgICAgfSwgaGFuZGxlRXJyb3IpXG4gICAgICAgIC50aGVuKChwb2xpY3kpID0+IHtcbiAgICAgICAgICBpZiAoaGF2ZUVycm9yKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAvLyB0aGlzIHdpbGwgcmV0dXJuIHRoZSBzYW5kYm94IG9yIG9uZSBwcm9taXNlIHRvIGdldFNhbmRib3g7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0cnkuZ2V0U2FuZGJveChkb21haW4pO1xuICAgICAgICB9KVxuICAgICAgICAudGhlbigocHJveHlTYW5kYm94KSA9PiB7XG4gICAgICAgICAgaWYgKGhhdmVFcnJvcikgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGNvbnNvbGUuaW5mbygnNC4gaWYgdGhlIHNhbmRib3ggaXMgcmVnaXN0ZXJlZCB0aGVuIHJldHVybiB0aGUgc2FuZGJveCcsIHByb3h5U2FuZGJveCk7XG5cbiAgICAgICAgICBfcHJveHlTYW5kYm94ID0gcHJveHlTYW5kYm94O1xuICAgICAgICAgIHJldHVybiBwcm94eVNhbmRib3g7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgocmVhc29uKSA9PiB7XG4gICAgICAgICAgaWYgKGhhdmVFcnJvcikgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGNvbnNvbGUuaW5mbygnNS4gU2FuZGJveCB3YXMgbm90IGZvdW5kLCBjcmVhdGluZyBhIG5ldyBvbmUnLCByZWFzb24pO1xuXG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHNhbmRib3ggaXMgcmVnaXN0ZWQgZm9yIHRoaXMgcHJveHkgZGVzY3JpcHRvciB1cmw7XG4gICAgICAgICAgLy8gTWFrZSBTdGVwcyB4eHggLS0tIHh4eFxuICAgICAgICAgIC8vIEluc3RhbnRpYXRlIHRoZSBTYW5kYm94XG4gICAgICAgICAgbGV0IHNhbmRib3ggPSB0aGlzLl9ydW50aW1lRmFjdG9yeS5jcmVhdGVTYW5kYm94KCk7XG4gICAgICAgICAgc2FuZGJveC5hZGRMaXN0ZW5lcignKicsIChtc2cpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZUJ1cy5wb3N0TWVzc2FnZShtc2cpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIHNhbmRib3g7XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKChzYW5kYm94KSA9PiB7XG4gICAgICAgICAgaWYgKGhhdmVFcnJvcikgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGNvbnNvbGUuaW5mbygnNi4gcmV0dXJuIHRoZSBzYW5kYm94IGluc3RhbmNlIGFuZCByZWdpc3RlcicsIHNhbmRib3gsICd0byBkb21haW4gJywgZG9tYWluKTtcblxuICAgICAgICAgIF9wcm94eVNhbmRib3ggPSBzYW5kYm94O1xuXG4gICAgICAgICAgLy8gd2UgbmVlZCByZWdpc3RlciBzdHViIG9uIHJlZ2lzdHJ5IC0gc3RlcCB4eHggaHR0cHM6Ly9naXRodWIuY29tL3JlVEhJTkstcHJvamVjdC9jb3JlLWZyYW1ld29yay9ibG9iL21hc3Rlci9kb2NzL3NwZWNzL3J1bnRpbWUvZHluYW1pYy12aWV3L2Jhc2ljcy9kZXBsb3ktcHJvdG9zdHViLm1kXG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0cnkucmVnaXN0ZXJJZHBQcm94eShzYW5kYm94LCBkb21haW4pO1xuICAgICAgICB9LCBoYW5kbGVFcnJvcilcbiAgICAgICAgLnRoZW4oKHJ1bnRpbWVJZHBQcm94eVVSTCkgPT4ge1xuICAgICAgICAgIGlmIChoYXZlRXJyb3IpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBjb25zb2xlLmluZm8oJzcuIFJldHVybiB0aGUgcnVudGltZSBJZHAgUHJveHkgVVJMOiAnLCBydW50aW1lSWRwUHJveHlVUkwpO1xuXG4gICAgICAgICAgLy8gd2UgaGF2ZSBjb21wbGV0ZWQgc3RlcCB4eHggaHR0cHM6Ly9naXRodWIuY29tL3JlVEhJTkstcHJvamVjdC9jb3JlLWZyYW1ld29yay9ibG9iL21hc3Rlci9kb2NzL3NwZWNzL3J1bnRpbWUvZHluYW1pYy12aWV3L2Jhc2ljcy9kZXBsb3ktcHJvdG9zdHViLm1kXG5cbiAgICAgICAgICBfcnVudGltZUlkcFByb3h5VVJMID0gcnVudGltZUlkcFByb3h5VVJMO1xuXG4gICAgICAgICAgLy8gRXh0ZW5kIG9yaWdpbmFsIGh5cGVydHkgY29uZmlndXJhdGlvbjtcbiAgICAgICAgICBsZXQgY29uZmlndXJhdGlvbiA9IHt9O1xuICAgICAgICAgIGlmICghZW1wdHlPYmplY3QoX3Byb3h5RGVzY3JpcHRvci5jb25maWd1cmF0aW9uKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uZmlndXJhdGlvbiA9IE9iamVjdC5hc3NpZ24oe30sIEpTT04ucGFyc2UoX3Byb3h5RGVzY3JpcHRvci5jb25maWd1cmF0aW9uKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbmZpZ3VyYXRpb24gPSBfcHJveHlEZXNjcmlwdG9yLmNvbmZpZ3VyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbmZpZ3VyYXRpb24ucnVudGltZVVSTCA9IHRoaXMuX3J1bnRpbWVVUkw7XG5cbiAgICAgICAgICAvLyBEZXBsb3kgQ29tcG9uZW50IHN0ZXAgeHh4XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBfcHJveHlTYW5kYm94LmRlcGxveUNvbXBvbmVudChfcHJveHlTb3VyY2VQYWNrYWdlLnNvdXJjZUNvZGUsIHJ1bnRpbWVJZHBQcm94eVVSTCwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igb24gZGVwbG95IGNvbXBvbmVudDonLCBlKTtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZUVycm9yKVxuICAgICAgICAudGhlbigoZGVwbG95Q29tcG9uZW50U3RhdHVzKSA9PiB7XG4gICAgICAgICAgaWYgKGhhdmVFcnJvcikgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGNvbnNvbGUuaW5mbygnODogcmV0dXJuIGRlcGxveSBjb21wb25lbnQgZm9yIHNhbmRib3ggc3RhdHVzOiAnLCBkZXBsb3lDb21wb25lbnRTdGF0dXMpO1xuXG4gICAgICAgICAgLy8gd2UgaGF2ZSBjb21wbGV0ZWQgc3RlcCB4eHggaHR0cHM6Ly9naXRodWIuY29tL3JlVEhJTkstcHJvamVjdC9jb3JlLWZyYW1ld29yay9ibG9iL21hc3Rlci9kb2NzL3NwZWNzL3J1bnRpbWUvZHluYW1pYy12aWV3L2Jhc2ljcy9kZXBsb3ktcHJvdG9zdHViLm1kXG5cbiAgICAgICAgICAvLyBBZGQgdGhlIG1lc3NhZ2UgYnVzIGxpc3RlbmVyXG4gICAgICAgICAgdGhpcy5tZXNzYWdlQnVzLmFkZExpc3RlbmVyKF9ydW50aW1lSWRwUHJveHlVUkwsIChtc2cpID0+IHtcbiAgICAgICAgICAgIF9wcm94eVNhbmRib3gucG9zdE1lc3NhZ2UobXNnKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIHdlIGhhdmUgY29tcGxldGVkIHN0ZXAgeHh4IGh0dHBzOi8vZ2l0aHViLmNvbS9yZVRISU5LLXByb2plY3QvY29yZS1mcmFtZXdvcmsvYmxvYi9tYXN0ZXIvZG9jcy9zcGVjcy9ydW50aW1lL2R5bmFtaWMtdmlldy9iYXNpY3MvZGVwbG95LXByb3Rvc3R1Yi5tZFxuXG4gICAgICAgICAgLy8gTG9hZCBTdHViIGZ1bmN0aW9uIHJlc29sdmVkIHdpdGggc3VjY2VzcztcbiAgICAgICAgICAvLyBsZXQgaWRwUHJveHkgPSB7XG4gICAgICAgICAgLy8gICBydW50aW1lSWRwUHJveHlVUkw6IF9ydW50aW1lSWRwUHJveHlVUkwsXG4gICAgICAgICAgLy8gICBzdGF0dXM6IGRlcGxveUNvbXBvbmVudFN0YXR1c1xuICAgICAgICAgIC8vIH07XG5cbiAgICAgICAgICB0aGlzLnJlZ2lzdHJ5LmlkcFByb3h5TGlzdFtkb21haW5dLnN0YXR1cyA9ICdkZXBsb3llZCc7XG4gICAgICAgICAgbGV0IGlkcFByb3h5ID0gdGhpcy5yZWdpc3RyeS5pZHBQcm94eUxpc3RbZG9tYWluXTtcblxuICAgICAgICAgIGNvbnNvbGUubG9nKCdEZXBsb3llZDogJywgaWRwUHJveHkpO1xuXG4gICAgICAgICAgcmVzb2x2ZShpZHBQcm94eSk7XG4gICAgICAgICAgY29uc29sZS5pbmZvKCctLS0tLS0tLS0tLS0tLS0tLS0tIEVORCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4nKTtcblxuICAgICAgICB9LCBoYW5kbGVFcnJvcilcbiAgICAgICAgLmNhdGNoKGVycm9yUmVhc29uKTtcbiAgICAgIH0pO1xuXG4gICAgfSk7XG4gIH1cblxuICAvLyBDaGVjayBpZiB0aGUgbG9hZGVyIGlzIHJlYWR5IHRvIGxvYWQgYWxsIGNvbXBvbmVudHNcbiAgX3JlYWR5VG9Vc2UoKSB7XG5cbiAgICBsZXQgc3RhdHVzID0gZmFsc2U7XG5cbiAgICBpZiAoIXRoaXMuX3J1bnRpbWVVUkwpIHRocm93IG5ldyBFcnJvcignVGhlIGxvYWRlciBuZWVkIHRoZSBydW50aW1lIHVybCBhZGRyZXNzJyk7XG4gICAgaWYgKCF0aGlzLl9tZXNzYWdlc0J1cykgdGhyb3cgbmV3IEVycm9yKCdUaGUgbG9hZGVyIG5lZWQgdGhlIG1lc3NhZ2VCdXMgY29tcG9uZW50Jyk7XG4gICAgaWYgKCF0aGlzLl9ydW50aW1lQ2F0YWxvZ3VlKSB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBsb2FkZXIgbmVlZCB0aGUgcnVudGltZUNhdGFsb2d1ZSBjb21wb25lbnQnKTtcbiAgICBpZiAoIXRoaXMuX3JlZ2lzdHJ5KSB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBsb2FkZXIgbmVlZCB0aGUgcmVnaXN0cnkgY29tcG9uZW50Jyk7XG4gICAgaWYgKCF0aGlzLl9ydW50aW1lRmFjdG9yeSkgdGhyb3cgbmV3IEVycm9yKCdUaGUgbG9hZGVyIG5lZWQgdGhlIHJ1bnRpbWUgZmFjdG9yeSBjb21wb25lbnQnKTtcblxuICAgIHN0YXR1cyA9IHRydWU7XG4gICAgcmV0dXJuIHN0YXR1cztcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IExvYWRlcjtcbiIsIi8qKlxuKiBDb3B5cmlnaHQgMjAxNiBQVCBJbm92YcOnw6NvIGUgU2lzdGVtYXMgU0FcbiogQ29weXJpZ2h0IDIwMTYgSU5FU0MtSURcbiogQ29weXJpZ2h0IDIwMTYgUVVPQklTIE5FVFdPUktTIFNMXG4qIENvcHlyaWdodCAyMDE2IEZSQVVOSE9GRVItR0VTRUxMU0NIQUZUIFpVUiBGT0VSREVSVU5HIERFUiBBTkdFV0FORFRFTiBGT1JTQ0hVTkcgRS5WXG4qIENvcHlyaWdodCAyMDE2IE9SQU5HRSBTQVxuKiBDb3B5cmlnaHQgMjAxNiBEZXV0c2NoZSBUZWxla29tIEFHXG4qIENvcHlyaWdodCAyMDE2IEFwaXplZVxuKiBDb3B5cmlnaHQgMjAxNiBURUNITklTQ0hFIFVOSVZFUlNJVEFUIEJFUkxJTlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qKi9cblxuaW1wb3J0ICdiYWJlbC1wb2x5ZmlsbCc7XG5cbi8vTWFpbiBkZXBlbmRlY2llc1xuaW1wb3J0IFJlZ2lzdHJ5IGZyb20gJy4uL3JlZ2lzdHJ5L1JlZ2lzdHJ5JztcbmltcG9ydCBJZGVudGl0eU1vZHVsZSBmcm9tICcuLi9pZGVudGl0eS9JZGVudGl0eU1vZHVsZSc7XG5pbXBvcnQgUEVQIGZyb20gJy4uL3BvbGljeS9QRVAnO1xuaW1wb3J0IE1lc3NhZ2VCdXMgZnJvbSAnLi4vYnVzL01lc3NhZ2VCdXMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVHVUlEIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xuXG5pbXBvcnQgTG9hZGVyIGZyb20gJy4vTG9hZGVyJztcbmltcG9ydCB7IHJ1bnRpbWVDb25maWd1cmF0aW9uIH0gZnJvbSAnLi9ydW50aW1lQ29uZmlndXJhdGlvbic7XG4vLyBpbXBvcnQgR3JhcGhDb25uZWN0b3IgZnJvbSAnLi4vZ3JhcGhjb25uZWN0b3IvR3JhcGhDb25uZWN0b3InO1xuXG5pbXBvcnQgU3luY2hlck1hbmFnZXIgZnJvbSAnLi4vc3luY2hlci9TeW5jaGVyTWFuYWdlcic7XG5pbXBvcnQgUnVudGltZUNvcmVDdHggZnJvbSAnLi4vcG9saWN5L2NvbnRleHQvUnVudGltZUNvcmVDdHgnO1xuLyoqXG4gKiBSdW50aW1lIFVzZXIgQWdlbnQgSW50ZXJmYWNlIHdpbGwgcHJvY2VzcyBhbGwgdGhlIGRlcGVuZGVjaWVzIG9mIHRoZSBjb3JlIHJ1bnRpbWU7XG4gKiBAYXV0aG9yIFZpdG9yIFNpbHZhIFt2aXRvci10LXNpbHZhQHRlbGVjb20ucHRdXG4gKiBAdmVyc2lvbiAwLjQuMFxuICpcbiAqIEBwcm9wZXJ0eSB7cnVudGltZUZhY3Rvcnl9IHJ1bnRpbWVGYWN0b3J5IC0gU3BlY2lmaWMgaW1wbGVtZW50YXRpb24gZm9yIGFsbCBlbnZpcm9ubWVudHM7XG4gKiBAcHJvcGVydHkge1J1bnRpbWVDYXRhbG9ndWV9IHJ1bnRpbWVDYXRhbG9ndWUgLSBDYXRhbG9ndWUgb2YgY29tcG9uZW50cyBjYW4gYmUgaW5zdGFsbGVkO1xuICogQHByb3BlcnR5IHtydW50aW1lVVJMfSBydW50aW1lVVJMIC0gVGhpcyBpZGVudGlmeSB0aGUgY29yZSBydW50aW1lLCBzaG91bGQgYmUgdW5pcXVlO1xuICogQHByb3BlcnR5IHtJZGVudGl0eU1vZHVsZX0gaWRlbnRpdHlNb2R1bGUgLSBJZGVudGl0eSBNb2R1bGU7XG4gKiBAcHJvcGVydHkge1BFUH0gcG9saWN5RW5naW5lIC0gUG9saWN5IEVuZ2luZSBNb2R1bGU7XG4gKiBAcHJvcGVydHkge1JlZ2lzdHJ5fSByZWdpc3RyeSAtIFJlZ2lzdHJ5IE1vZHVsZTtcbiAqIEBwcm9wZXJ0eSB7TWVzc2FnZUJ1c30gbWVzc2FnZUJ1cyAtIE1lc3NhZ2UgQnVzIGlzIHVzZWQgbGlrZSBhIHJvdXRlciB0byByZWRpcmVjdCB0aGUgbWVzc2FnZXMgZnJvbSBvbmUgY29tcG9uZW50IHRvIG90aGVyKHMpXG4gKiBAcHJvcGVydHkge0dyYXBoQ29ubmVjdG9yfSBncmFwaENvbm5lY3RvciAtIEdyYXBoIENvbm5lY3RvciBoYW5kbGluZyBHVUlEIGFuZCBjb250YWN0c1xuICovXG5jbGFzcyBSdW50aW1lVUEge1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgUnVudGltZSBVc2VyIEFnZW50XG4gICAqIEBwYXJhbSB7cnVudGltZUZhY3Rvcnl9IHJ1bnRpbWVGYWN0b3J5IC0gU3BlY2lmaWMgaW1wbGVtZW50YXRpb24gZm9yIHRoZSBlbnZpcm9ubWVudCB3aGVyZSB0aGUgY29yZSBydW50aW1lIHdpbGwgcnVuO1xuICAgKiBAcGFyYW0ge2RvbWFpbn0gZG9tYWluVVJMIC0gc3BlY2lmeSB0aGUgZG9tYWluIGJhc2UgZm9yIHRoZSBydW50aW1lO1xuICAgKi9cbiAgY29uc3RydWN0b3IocnVudGltZUZhY3RvcnksIGRvbWFpbikge1xuXG4gICAgaWYgKCFydW50aW1lRmFjdG9yeSkgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2FuZGJveCBmYWN0b3J5IGlzIGEgbmVlZGVkIHBhcmFtZXRlcicpO1xuICAgIGlmICghZG9tYWluKSB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBuZWVkIHRoZSBkb21haW4gb2YgcnVudGltZScpO1xuXG4gICAgLy8gQ29uZmlndXJhdGlvbiBvYmplY3Qgd2l0aCBpbmZvcm1hdGlvbiByZWxhdGVkIHdpdGggc2VydmVyc1xuICAgIHRoaXMucnVudGltZUNvbmZpZ3VyYXRpb24gPSBPYmplY3QuYXNzaWduKHtkb21haW46IGRvbWFpbn0sIHJ1bnRpbWVDb25maWd1cmF0aW9uKTtcblxuICAgIHRoaXMucnVudGltZUZhY3RvcnkgPSBydW50aW1lRmFjdG9yeTtcbiAgICB0aGlzLnJ1bnRpbWVDYXRhbG9ndWUgPSBydW50aW1lRmFjdG9yeS5jcmVhdGVSdW50aW1lQ2F0YWxvZ3VlKCk7XG5cbiAgICBpZiAodHlwZW9mIHJ1bnRpbWVGYWN0b3J5LmNyZWF0ZVJ1bnRpbWVDYXRhbG9ndWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMucGVyc2lzdGVuY2VNYW5hZ2VyID0gcnVudGltZUZhY3RvcnkuY3JlYXRlUnVudGltZUNhdGFsb2d1ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoZWNrIHlvdXIgUnVudGltZSBGYWN0b3J5IGJlY2F1c2UgaXQgbmVlZCB0aGUgUnVudGltZSBDYXRhbG9ndWUgaW1wbGVtZW50YXRpb24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJ1bnRpbWVGYWN0b3J5LnBlcnNpc3RlbmNlTWFuYWdlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5wZXJzaXN0ZW5jZU1hbmFnZXIgPSBydW50aW1lRmFjdG9yeS5wZXJzaXN0ZW5jZU1hbmFnZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGVjayB5b3VyIFJ1bnRpbWUgRmFjdG9yeSBiZWNhdXNlIGl0IG5lZWQgdGhlIFBlcnNpc3RlbmNlIE1hbmFnZXIgaW1wbGVtZW50YXRpb24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJ1bnRpbWVGYWN0b3J5LnN0b3JhZ2VNYW5hZ2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLnN0b3JhZ2VNYW5hZ2VyID0gcnVudGltZUZhY3Rvcnkuc3RvcmFnZU1hbmFnZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGVjayB5b3VyIFJ1bnRpbWUgRmFjdG9yeSBiZWNhdXNlIGl0IG5lZWQgdGhlIFN0b3JhZ2UgTWFuYWdlciBpbXBsZW1lbnRhdGlvbicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJ1bnRpbWVGYWN0b3J5LnJ1bnRpbWVDYXBhYmlsaXRpZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMucnVudGltZUNhcGFiaWxpdGllcyA9IHJ1bnRpbWVGYWN0b3J5LnJ1bnRpbWVDYXBhYmlsaXRpZXModGhpcy5zdG9yYWdlTWFuYWdlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuaW5mbygnQ2hlY2sgeW91ciBSdW50aW1lRmFjdG9yeSBiZWNhdXNlIGl0IG5lZWQgdGhlIFJ1bnRpbWUgQ2FwYWJpbGl0aWVzIGltcGxlbWVudGF0aW9uJyk7XG4gICAgfVxuXG4gIH1cblxuICBpbml0KCkge1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgdGhpcy5kb21haW4gPSB0aGlzLnJ1bnRpbWVDb25maWd1cmF0aW9uLmRvbWFpbjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGdldENhcGFiaWxpdGllcyA9IHRoaXMucnVudGltZUNhcGFiaWxpdGllcy5nZXRSdW50aW1lQ2FwYWJpbGl0aWVzKCk7XG4gICAgICAgIGxldCBnZXRSdW50aW1lVVJMID0gdGhpcy5zdG9yYWdlTWFuYWdlci5nZXQoJ3J1bnRpbWU6VVJMJyk7XG5cbiAgICAgICAgUHJvbWlzZS5hbGwoW2dldFJ1bnRpbWVVUkwsIGdldENhcGFiaWxpdGllc10pLnRoZW4oKHJlc3VsdHMpID0+IHtcblxuICAgICAgICAgIHRoaXMucnVudGltZVVSTCA9IHJlc3VsdHNbMF0gPyByZXN1bHRzWzBdLnJ1bnRpbWVVUkwgOiByZXN1bHRzWzBdO1xuICAgICAgICAgIGlmICghdGhpcy5ydW50aW1lVVJMKSB7XG4gICAgICAgICAgICB0aGlzLnJ1bnRpbWVVUkwgPSAncnVudGltZTovLycgKyB0aGlzLmRvbWFpbiArICcvJyArIGdlbmVyYXRlR1VJRCgpO1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlTWFuYWdlci5zZXQoJ3J1bnRpbWU6VVJMJywgMSwge3J1bnRpbWVVUkw6IHRoaXMucnVudGltZVVSTH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuY2FwYWJpbGl0aWVzID0gcmVzdWx0c1sxXTtcblxuICAgICAgICAgIHJldHVybiB0aGlzLl9sb2FkQ29tcG9uZW50cygpO1xuXG4gICAgICAgIH0pLnRoZW4oKHN0YXR1cykgPT4ge1xuICAgICAgICAgIHJlc29sdmUoc3RhdHVzKTtcbiAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRVJST1I6ICcsIGVycm9yKTtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9KTtcblxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG5cbiAgICB9KTtcblxuICB9XG5cbiAgX2xvYWRDb21wb25lbnRzKCkge1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgdHJ5IHtcblxuICAgICAgICAvLyBQcmVwYXJlIHRoZSBsb2FkZXIgdG8gbG9hZCB0aGUgaHlwZXJ0aWVzLCBwcm90b3N0dWJzIGFuZCBpZHBwcm94eTtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgTG9hZGVyKHRoaXMucnVudGltZUNvbmZpZ3VyYXRpb24pO1xuXG4gICAgICAgIC8vIEluc3RhbnRpYXRlIHRoZSBpZGVudGl0eSBNb2R1bGVcbiAgICAgICAgdGhpcy5pZGVudGl0eU1vZHVsZSA9IG5ldyBJZGVudGl0eU1vZHVsZSh0aGlzLnJ1bnRpbWVVUkwsIHRoaXMucnVudGltZUNhcGFiaWxpdGllcywgdGhpcy5zdG9yYWdlTWFuYWdlcik7XG5cbiAgICAgICAgLy8gVXNlIHRoZSBzYW5kYm94IGZhY3RvcnkgdG8gY3JlYXRlIGFuIEFwcFNhbmRib3g7XG4gICAgICAgIC8vIEluIHRoZSBmdXR1cmUgY2FuIGJlIGRlY2lkZWQgYnkgcG9saWN5RW5naW5lIGlmIHdlIG5lZWRcbiAgICAgICAgLy8gY3JlYXRlIGEgQXBwU2FuZGJveCBvciBub3Q7XG4gICAgICAgIGxldCBhcHBTYW5kYm94ID0gdGhpcy5ydW50aW1lRmFjdG9yeS5jcmVhdGVBcHBTYW5kYm94KCk7XG5cbiAgICAgICAgLy8gSW5zdGFudGlhdGUgdGhlIFJlZ2lzdHJ5IE1vZHVsZVxuICAgICAgICB0aGlzLnJlZ2lzdHJ5ID0gbmV3IFJlZ2lzdHJ5KHRoaXMucnVudGltZVVSTCwgYXBwU2FuZGJveCwgdGhpcy5pZGVudGl0eU1vZHVsZSwgdGhpcy5ydW50aW1lQ2F0YWxvZ3VlLCB0aGlzLnJ1bnRpbWVDYXBhYmlsaXRpZXMsIHRoaXMuc3RvcmFnZU1hbmFnZXIpO1xuXG4gICAgICAgIC8vIFNldCB0aGUgbG9hZGVyIHRvIGxvYWQgSHlwZXJ0aWVzLCBTdHVicyBhbmQgSWRwUHJveGllc1xuICAgICAgICB0aGlzLnJlZ2lzdHJ5LmxvYWRlciA9IHRoaXMubG9hZGVyO1xuXG4gICAgICAgIC8vIEluc3RhbnRpYXRlIHRoZSBNZXNzYWdlIEJ1c1xuICAgICAgICB0aGlzLm1lc3NhZ2VCdXMgPSBuZXcgTWVzc2FnZUJ1cyh0aGlzLnJlZ2lzdHJ5KTtcblxuICAgICAgICAvLyBJbnN0YW50aWF0ZSB0aGUgUG9saWN5IEVuZ2luZVxuICAgICAgICB0aGlzLnBvbGljeUVuZ2luZSA9IG5ldyBQRVAobmV3IFJ1bnRpbWVDb3JlQ3R4KHRoaXMuaWRlbnRpdHlNb2R1bGUsIHRoaXMucmVnaXN0cnksIHRoaXMuc3RvcmFnZU1hbmFnZXIpKTtcblxuICAgICAgICB0aGlzLm1lc3NhZ2VCdXMucGlwZWxpbmUuaGFuZGxlcnMgPSBbXG5cbiAgICAgICAgICAvLyBQb2xpY3kgbWVzc2FnZSBhdXRob3Jpc2VcbiAgICAgICAgICAoY3R4KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBvbGljeUVuZ2luZS5hdXRob3Jpc2UoY3R4Lm1zZykudGhlbigoY2hhbmdlZE1ncykgPT4ge1xuICAgICAgICAgICAgICBjdHgubXNnID0gY2hhbmdlZE1ncztcbiAgICAgICAgICAgICAgY3R4Lm5leHQoKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKChyZWFzb24pID0+IHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihyZWFzb24pO1xuICAgICAgICAgICAgICBjdHguZmFpbChyZWFzb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICBdO1xuXG4gICAgICAgIC8vIEFkZCB0byBBcHAgU2FuZGJveCB0aGUgbGlzdGVuZXI7XG4gICAgICAgIGFwcFNhbmRib3guYWRkTGlzdGVuZXIoJyonLCAobXNnKSA9PiB7XG4gICAgICAgICAgdGhpcy5tZXNzYWdlQnVzLnBvc3RNZXNzYWdlKG1zZyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFJlZ2lzdGVyIG1lc3NhZ2VCdXMgb24gUmVnaXN0cnlcbiAgICAgICAgdGhpcy5yZWdpc3RyeS5tZXNzYWdlQnVzID0gdGhpcy5tZXNzYWdlQnVzO1xuXG4gICAgICAgIC8vIFJlZ2lzdGVyIHJlZ2lzdHJ5IG9uIElkZW50aXR5TW9kdWxlXG4gICAgICAgIHRoaXMuaWRlbnRpdHlNb2R1bGUucmVnaXN0cnkgPSB0aGlzLnJlZ2lzdHJ5O1xuXG4gICAgICAgIC8vIFVzZSBzYW5kYm94IGZhY3RvcnkgdG8gdXNlIHNwZWNpZmljIG1ldGhvZHNcbiAgICAgICAgLy8gYW5kIHNldCB0aGUgbWVzc2FnZSBidXMgdG8gdGhlIGZhY3RvcnlcbiAgICAgICAgdGhpcy5ydW50aW1lRmFjdG9yeS5tZXNzYWdlQnVzID0gdGhpcy5tZXNzYWdlQnVzO1xuXG4gICAgICAgIC8vIEluc3RhbmNpYXRlIHRoZSBTeW5jaGVyTWFuYWdlcjtcbiAgICAgICAgdGhpcy5zeW5jaGVyTWFuYWdlciA9IG5ldyBTeW5jaGVyTWFuYWdlcih0aGlzLnJ1bnRpbWVVUkwsIHRoaXMubWVzc2FnZUJ1cywgdGhpcy5yZWdpc3RyeSwgdGhpcy5ydW50aW1lQ2F0YWxvZ3VlLCB0aGlzLnN0b3JhZ2VNYW5hZ2VyKTtcblxuICAgICAgICAvLyBTZXQgaW50byBsb2FkZXIgdGhlIG5lZWRlZCBjb21wb25lbnRzO1xuICAgICAgICB0aGlzLmxvYWRlci5ydW50aW1lVVJMID0gdGhpcy5ydW50aW1lVVJMO1xuICAgICAgICB0aGlzLmxvYWRlci5tZXNzYWdlQnVzID0gdGhpcy5tZXNzYWdlQnVzO1xuICAgICAgICB0aGlzLmxvYWRlci5yZWdpc3RyeSA9IHRoaXMucmVnaXN0cnk7XG4gICAgICAgIHRoaXMubG9hZGVyLnJ1bnRpbWVDYXRhbG9ndWUgPSB0aGlzLnJ1bnRpbWVDYXRhbG9ndWU7XG4gICAgICAgIHRoaXMubG9hZGVyLnJ1bnRpbWVGYWN0b3J5ID0gdGhpcy5ydW50aW1lRmFjdG9yeTtcblxuICAgICAgICAvLyBJbnN0YW50aWF0ZSB0aGUgR3JhcGggQ29ubmVjdG9yXG4gICAgICAgIC8vIF90aGlzLmdyYXBoQ29ubmVjdG9yID0gbmV3IEdyYXBoQ29ubmVjdG9yKF90aGlzLnJ1bnRpbWVVUkwsIF90aGlzLm1lc3NhZ2VCdXMpO1xuXG4gICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cblxuICAgIH0pO1xuXG4gIH1cblxuICAvKipcbiAgKiBEZXBsb3kgSHlwZXJ0eSBmcm9tIENhdGFsb2d1ZSBVUkxcbiAgKiBAcGFyYW0gIHtVUkwuSHlwZXJ0eUNhdGFsb2d1ZVVSTH0gICAgaHlwZXJ0eSBoeXBlcnR5RGVzY3JpcHRvciB1cmw7XG4gICovXG4gIGxvYWRIeXBlcnR5KGh5cGVydHlEZXNjcmlwdG9yVVJMKSB7XG5cbiAgICBpZiAoIWh5cGVydHlEZXNjcmlwdG9yVVJMKSB0aHJvdyBuZXcgRXJyb3IoJ0h5cGVydHkgZGVzY3JpcHRvciB1cmwgcGFyYW1ldGVyIGlzIG5lZWRlZCcpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgdGhpcy5sb2FkZXIubG9hZEh5cGVydHkoaHlwZXJ0eURlc2NyaXB0b3JVUkwpXG4gICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKHJlYXNvbikgPT4ge1xuICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgIH0pO1xuXG4gICAgfSk7XG5cbiAgfVxuXG4gIC8qKlxuICAqIERlcGxveSBTdHViIGZyb20gQ2F0YWxvZ3VlIFVSTCBvciBkb21haW4gdXJsXG4gICogQHBhcmFtICB7VVJMLlVSTH0gICAgIGRvbWFpbiAgICAgICAgICBkb21haW5cbiAgKi9cbiAgbG9hZFN0dWIocHJvdG9zdHViVVJMKSB7XG5cbiAgICBpZiAoIXByb3Rvc3R1YlVSTCkgdGhyb3cgbmV3IEVycm9yKCdQcm90b1N0dWIgZGVzY3JpcHRvciB1cmwgcGFyYW1ldGVyIGlzIG5lZWRlZCcpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgdGhpcy5sb2FkZXIubG9hZFN0dWIocHJvdG9zdHViVVJMKVxuICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChyZWFzb24pID0+IHtcbiAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICB9KTtcblxuICAgIH0pO1xuXG4gIH1cblxuICAvKipcbiAgKiBEZXBsb3kgaWRwUHJveHkgZnJvbSBDYXRhbG9ndWUgVVJMIG9yIGRvbWFpbiB1cmxcbiAgKiBAcGFyYW0gIHtVUkwuVVJMfSAgICAgZG9tYWluICAgICAgICAgIGRvbWFpblxuICAqL1xuICBsb2FkSWRwUHJveHkoaWRwUHJveHlVUkwpIHtcblxuICAgIGlmICghaWRwUHJveHlVUkwpIHRocm93IG5ldyBFcnJvcignVGhlIElEUCBQcm94eSBVUkwgaXMgYSBuZWVkZWQgcGFyYW1ldGVyLCBjb3VsZCBiZSBhIERPTUFJTiBvciBhIFVSTCcpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMubG9hZGVyLmxvYWRJZHBQcm94eShpZHBQcm94eVVSTClcbiAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaCgocmVhc29uKSA9PiB7XG4gICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGNsb3NlIGFsbCB0aGUgcnVudGltZTsgVW5yZWdpc3RlciBhbGwgaHlwZXJ0aWVzO1xuICAgKiBAcmV0dXJuIHtQcm9taXNlPEJvb2xlYW4+fSByZXN1bHQgb2YgdGhlIGNsb3NlIG1ldGhvZCwgd2l0aCB0cnVlIG9yIGZhbHNlIHRvIHRoZSBvcGVyYXRpb24gc3VjY2VzcztcbiAgICovXG4gIGNsb3NlKCkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG5cbiAgICBjb25zb2xlLmluZm8oJ1VucmVnaXN0ZXIgYWxsIGh5cGVydGllcycpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblxuICAgICAgX3RoaXMucmVnaXN0cnkudW5yZWdpc3RlckFsbEh5cGVydGllcygpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnQWxsIHRoZSBoeXBlcnRpZXMgYXJlIHVucmVnaXN0ZWQgd2l0aCBTdWNjZXNzOicsIHJlc3VsdCk7XG4gICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHVucmVnaXN0ZXIgdGhlIGh5cGVydGllcycsIHJlYXNvbik7XG4gICAgICAgIHJlamVjdChmYWxzZSk7XG4gICAgICB9KTtcblxuICAgIH0pO1xuXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBSdW50aW1lVUE7XG4iLCJleHBvcnQgY29uc3QgcnVudGltZUNvbmZpZ3VyYXRpb24gPSB7XG5cbiAgcnVudGltZVVSTFM6IHtcbiAgICByZWdpc3RyeToge1xuICAgICAgcHJlZml4OiAnaHlwZXJ0eS1ydW50aW1lOi8vJyxcbiAgICAgIHN1ZmZpeDogJ3JlZ2lzdHJ5J1xuICAgIH0sXG4gICAgaWRlbnRpdHlNb2R1bGU6IHtcbiAgICAgIHByZWZpeDogJ2h5cGVydHktcnVudGltZTovLycsXG4gICAgICBzdWZmaXg6ICcvaWRtJ1xuICAgIH0sXG4gICAgcnVudGltZVVBOiB7XG4gICAgICBwcmVmaXg6ICdoeXBlcnR5LXJ1bnRpbWU6Ly8nLFxuICAgICAgc3VmZml4OiAnL3VhJ1xuICAgIH0sXG4gICAgY2F0YWxvZ3VlOiB7XG4gICAgICBwcmVmaXg6ICdoeXBlcnR5LXJ1bnRpbWU6Ly8nLFxuICAgICAgc3VmZml4OiAnL2NhdGFsb2d1ZSdcbiAgICB9LFxuICAgIGdyYXBoQ29ubmVjdG9yOiB7XG4gICAgICBwcmVmaXg6ICdoeXBlcnR5LXJ1bnRpbWU6Ly8nLFxuICAgICAgc3VmZml4OiAnL2dyYXBoJ1xuICAgIH0sXG4gICAgc3luY01hbmFnZXI6IHtcbiAgICAgIHByZWZpeDogJ2h5cGVydHktcnVudGltZTovLycsXG4gICAgICBzdWZmaXg6ICcvc20nXG4gICAgfVxuICB9LFxuICBjYXRhbG9ndWVVUkxzOiB7XG4gICAgcHJvdG9jb2xzdHViOiB7XG4gICAgICBwcmVmaXg6ICdoeXBlcnR5LWNhdGFsb2d1ZTovL2NhdGFsb2d1ZS4nLFxuICAgICAgc3VmZml4OiAnLy53ZWxsLWtub3duL3Byb3RvY29sc3R1Yi8nLFxuICAgICAgZmFsbGJhY2s6ICdoeXBlcnR5LWNhdGFsb2d1ZTovL2NhdGFsb2d1ZS4lZG9tYWluJS8ud2VsbC1rbm93bi9wcm90b2NvbHN0dWIvJ1xuICAgIH0sXG4gICAgaWRwUHJveHk6IHtcbiAgICAgIHByZWZpeDogJ2h5cGVydHktY2F0YWxvZ3VlOi8vY2F0YWxvZ3VlLicsXG4gICAgICBzdWZmaXg6ICcvLndlbGwta25vd24vaWRwLXByb3h5LycsXG4gICAgICBmYWxsYmFjazogJ2h5cGVydHktY2F0YWxvZ3VlOi8vY2F0YWxvZ3VlLiVkb21haW4lLy53ZWxsLWtub3duL2lkcC1wcm94eS8nXG4gICAgfVxuICB9LFxuICBtc2dOb2RlVVJMOiB7XG4gICAgcHJlZml4OiAnZG9tYWluOi8vbXNnLW5vZGUuJyxcbiAgICBzdWZmaXg6ICcnLFxuICAgIGh5cGVydHlBZGRyZXNzQWxsb2NhdGlvbjogJy9oeXBlcnR5LWFkZHJlc3MtYWxsb2NhdGlvbicsXG4gICAgb2JqZWN0QWRkcmVzc0FsbG9jYXRpb246ICcvb2JqZWN0LWFkZHJlc3MtYWxsb2NhdGlvbicsXG4gICAgc3Vic2NyaXB0aW9uTWFuYWdlbWVudDogJy9zbSdcbiAgfSxcbiAgZG9tYWluUmVnaXN0cnlVUkw6IHtcbiAgICBwcmVmaXg6ICdkb21haW46Ly9yZWdpc3RyeS4nLFxuICAgIHN1ZmZpeDogJydcbiAgfSxcbiAgZ2xvYmFsUmVnaXN0cnlVUkw6ICdnbG9iYWw6Ly9yZWdpc3RyeS4nXG59O1xuIiwiaW1wb3J0IHsgZGl2aWRlVVJMIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IFN1YnNjcmlwdGlvbiBmcm9tICcuL1N1YnNjcmlwdGlvbic7XG5cbmNsYXNzIE9ic2VydmVyT2JqZWN0IHtcblxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIHVybCwgY2hpbGRyZW5zKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIF90aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgX3RoaXMuX3VybCA9IHVybDtcbiAgICBfdGhpcy5fY2hpbGRyZW5zID0gY2hpbGRyZW5zO1xuXG4gICAgX3RoaXMuX3N0b3JhZ2VNYW5hZ2VyID0gcGFyZW50Ll9zdG9yYWdlTWFuYWdlcjtcblxuICAgIF90aGlzLl9idXMgPSBwYXJlbnQuX2J1cztcblxuICAgIF90aGlzLl9zdWJzY3JpcHRpb25zID0ge307XG4gICAgX3RoaXMuX3N0b3JhZ2VTdWJzY3JpcHRpb25zID0ge307XG4gIH1cblxuICBfbmV3U3Vic2NyaXB0aW9uKGh5cGVydHkpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgX3RoaXMuX3N1YnNjcmlwdGlvbnNbaHlwZXJ0eV0gPSBuZXcgU3Vic2NyaXB0aW9uKF90aGlzLl9idXMsIGh5cGVydHksIF90aGlzLl91cmwsIF90aGlzLl9jaGlsZHJlbnMsIGZhbHNlKTtcbiAgfVxuXG4gIGFkZFN1YnNjcmlwdGlvbihoeXBlcnR5KSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIF90aGlzLl9uZXdTdWJzY3JpcHRpb24oaHlwZXJ0eSk7XG4gIH1cblxuICByZW1vdmVTdWJzY3JpcHRpb24oaHlwZXJ0eSkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG5cbiAgICBsZXQgZG9tYWluID0gZGl2aWRlVVJMKGh5cGVydHkpLmRvbWFpbjtcbiAgICBsZXQgb2JqVVJMU3Vic2NyaXB0aW9uID0gX3RoaXMuX3VybCArICcvc3Vic2NyaXB0aW9uJztcblxuICAgIGxldCBzdWJzY3JpcHRpb24gPSBfdGhpcy5fc3Vic2NyaXB0aW9uc1toeXBlcnR5XTtcbiAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAvL0ZMT1ctT1VUOiBtZXNzYWdlIHNlbnQgdG8gcmVtb3RlIFJlcG9ydGVyT2JqZWN0IC0+IF9vblJlbW90ZVVuU3Vic2NyaWJlXG4gICAgICBfdGhpcy5fYnVzLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogJ3Vuc3Vic2NyaWJlJywgZnJvbTogX3RoaXMuX3BhcmVudC5fdXJsLCB0bzogb2JqVVJMU3Vic2NyaXB0aW9uLFxuICAgICAgICBib2R5OiB7IHJlc291cmNlOiBfdGhpcy5fdXJsIH1cbiAgICAgIH0pO1xuXG4gICAgICAvL1RPRE86IHNob3VsZCBJIHdhaXQgZm9yIHJlc3BvbnNlIGJlZm9yZSB1bnN1YnNjcmliZSBvbiBtc2ctbm9kZVxuICAgICAgLy9GTE9XLU9VVDogbWVzc2FnZSBzZW50IHRvIG1zZy1ub2RlIFN1YnNjcmlwdGlvbk1hbmFnZXIgY29tcG9uZW50XG4gICAgICBfdGhpcy5fYnVzLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogJ3Vuc3Vic2NyaWJlJywgZnJvbTogX3RoaXMuX3BhcmVudC5fdXJsLCB0bzogJ2RvbWFpbjovL21zZy1ub2RlLicgKyBkb21haW4gKyAnL3NtJyxcbiAgICAgICAgYm9keTogeyByZXNvdXJjZTogX3RoaXMuX3VybCwgY2hpbGRyZW5SZXNvdXJjZXM6IF90aGlzLl9jaGlsZHJlbnMgfVxuICAgICAgfSk7XG5cbiAgICAgIHN1YnNjcmlwdGlvbi5fcmVsZWFzZUxpc3RlbmVycygpO1xuICAgICAgZGVsZXRlIF90aGlzLl9zdWJzY3JpcHRpb25zW2h5cGVydHldO1xuICAgIH1cbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IE9ic2VydmVyT2JqZWN0O1xuIiwiaW1wb3J0IHsgZGl2aWRlVVJMIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IFN1YnNjcmlwdGlvbiBmcm9tICcuL1N1YnNjcmlwdGlvbic7XG5cbmNsYXNzIFJlcG9ydGVyT2JqZWN0IHtcblxuICBjb25zdHJ1Y3RvcihwYXJlbnQsIG93bmVyLCB1cmwpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgX3RoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICBfdGhpcy5fb3duZXIgPSBvd25lcjtcbiAgICBfdGhpcy5fdXJsID0gdXJsO1xuXG4gICAgX3RoaXMuX2J1cyA9IHBhcmVudC5fYnVzO1xuICAgIF90aGlzLl9zdG9yYWdlTWFuYWdlciA9IHBhcmVudC5fc3RvcmFnZU1hbmFnZXI7XG5cbiAgICBfdGhpcy5fZG9tYWluID0gZGl2aWRlVVJMKG93bmVyKS5kb21haW47XG4gICAgX3RoaXMuX29ialN1YnNjcmlwdG9yVVJMID0gX3RoaXMuX3VybCArICcvc3Vic2NyaXB0aW9uJztcblxuICAgIF90aGlzLl9zdWJzY3JpcHRpb25zID0ge307XG4gICAgX3RoaXMuX2NoaWxkcmVucyA9IFtdO1xuICAgIF90aGlzLl9jaGlsZHJlbkxpc3RlbmVycyA9IFtdO1xuXG4gICAgX3RoaXMuX2ZvcndhcmRzID0ge307XG5cbiAgICBfdGhpcy5fYWxsb2NhdGVMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIF9hbGxvY2F0ZUxpc3RlbmVycygpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy9hZGQgc3Vic2NyaXB0aW9uIGxpc3RlbmVyLi4uXG4gICAgX3RoaXMuX3N1YnNjcmlwdGlvbkxpc3RlbmVyID0gX3RoaXMuX2J1cy5hZGRMaXN0ZW5lcihfdGhpcy5fb2JqU3Vic2NyaXB0b3JVUkwsIChtc2cpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKF90aGlzLl9vYmpTdWJzY3JpcHRvclVSTCArICctUkNWOiAnLCBtc2cpO1xuICAgICAgc3dpdGNoIChtc2cudHlwZSkge1xuICAgICAgICBjYXNlICdzdWJzY3JpYmUnOiBfdGhpcy5fb25SZW1vdGVTdWJzY3JpYmUobXNnKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3Vuc3Vic2NyaWJlJzogX3RoaXMuX29uUmVtb3RlVW5TdWJzY3JpYmUobXNnKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3Jlc3BvbnNlJzogX3RoaXMuX29uUmVtb3RlUmVzcG9uc2UobXNnKTsgYnJlYWs7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBsZXQgY2hhbmdlVVJMID0gX3RoaXMuX3VybCArICcvY2hhbmdlcyc7XG4gICAgX3RoaXMuX2NoYW5nZUxpc3RlbmVyID0gX3RoaXMuX2J1cy5hZGRMaXN0ZW5lcihjaGFuZ2VVUkwsIChtc2cpID0+IHtcbiAgICAgIC8vVE9ETzogd2hhdCB0b2RvIGhlcmU/IFNhdmUgY2hhbmdlcz9cbiAgICAgIGlmIChtc2cuYm9keS5hdHRyaWJ1dGUpIHtcbiAgICAgICAgX3RoaXMuX3BhcmVudC5fc3RvcmVEYXRhT2JqZWN0cy51cGRhdGVEYXRhKF90aGlzLl91cmwsICdkYXRhJywgbXNnLmJvZHkuYXR0cmlidXRlLCBtc2cuYm9keS52YWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZygnU3luY2hlck1hbmFnZXItJyArIGNoYW5nZVVSTCArICctUkNWOiAnLCBtc2cpO1xuICAgIH0pO1xuICB9XG5cbiAgcmVzdW1lU3Vic2NyaXB0aW9ucyhzdWJzY3JpcHRpb25zKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIE9iamVjdC5rZXlzKHN1YnNjcmlwdGlvbnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgbGV0IGh5cGVydHlVUkwgPSBzdWJzY3JpcHRpb25zW2tleV07XG4gICAgICAvLyBjb25zb2xlLmxvZygnUkVTVU1FOiAnLCBoeXBlcnR5VVJMLCBfdGhpcy5fc3Vic2NyaXB0aW9uc1toeXBlcnR5VVJMXSk7XG4gICAgICBpZiAoIV90aGlzLl9zdWJzY3JpcHRpb25zW2h5cGVydHlVUkxdKSB7XG4gICAgICAgIF90aGlzLl9zdWJzY3JpcHRpb25zW2h5cGVydHlVUkxdID0gbmV3IFN1YnNjcmlwdGlvbihfdGhpcy5fYnVzLCBfdGhpcy5fb3duZXIsIF90aGlzLl91cmwsIF90aGlzLl9jaGlsZHJlbnMsIHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIH1cblxuICBfcmVsZWFzZUxpc3RlbmVycygpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgX3RoaXMuX3N1YnNjcmlwdGlvbkxpc3RlbmVyLnJlbW92ZSgpO1xuXG4gICAgX3RoaXMuX2NoYW5nZUxpc3RlbmVyLnJlbW92ZSgpO1xuXG4gICAgX3RoaXMuX2NoaWxkcmVuTGlzdGVuZXJzLmZvckVhY2goKGNsKSA9PiB7XG4gICAgICBjbC5yZW1vdmUoKTtcbiAgICB9KTtcblxuICAgIE9iamVjdC5rZXlzKF90aGlzLl9mb3J3YXJkcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBfdGhpcy5mb3J3YXJkVW5TdWJzY3JpYmUoa2V5KTtcbiAgICB9KTtcblxuICAgIC8vcmVtb3ZlIGFsbCBzdWJzY3JpcHRpb25zXG4gICAgT2JqZWN0LmtleXMoX3RoaXMuX3N1YnNjcmlwdGlvbnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgX3RoaXMuX3N1YnNjcmlwdGlvbnNba2V5XS5fcmVsZWFzZUxpc3RlbmVycygpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgbGlzdGVuZXIgaW4gdGhlIG1zZy1ub2RlIGFuZCBpbiB0aGUgbG9jYWwgTWVzc2FnZUJ1cywgc28gdGhhdCBtZXNzYWdlcyBvbiB0aGlzIGFkZHJlc3MgYXJlIGZvcndhcmRlZCB0byB0aGUgcmVwb3J0ZXIgb2JqZWN0XG4gICAqIEBwYXJhbSAge3N0cmluZ30gYWRkcmVzcyAtIFVSTCB0byByZWdpc3RlciB0aGUgbGlzdGVuZXJzXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJldHVybiBQcm9taXNlIE9LIG9yIGVycm9yXG4gICAqL1xuICBmb3J3YXJkU3Vic2NyaWJlKGFkZHJlc3Nlcykge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG5cbiAgICAvL0ZMT1ctT1VUOiBtZXNzYWdlIHNlbnQgdG8gdGhlIG1zZy1ub2RlIFN1YnNjcmlwdGlvbk1hbmFnZXIgY29tcG9uZW50XG4gICAgbGV0IG5vZGVTdWJzY3JpYmVNc2cgPSB7XG4gICAgICB0eXBlOiAnc3Vic2NyaWJlJywgZnJvbTogX3RoaXMuX3BhcmVudC5fdXJsLCB0bzogJ2RvbWFpbjovL21zZy1ub2RlLicgKyBfdGhpcy5fZG9tYWluICsgJy9zbScsXG4gICAgICBib2R5OiB7IHN1YnNjcmliZTogYWRkcmVzc2VzLCBzb3VyY2U6IF90aGlzLl9vd25lciB9XG4gICAgfTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBfdGhpcy5fYnVzLnBvc3RNZXNzYWdlKG5vZGVTdWJzY3JpYmVNc2csIChyZXBseSkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnZm9yd2FyZC1zdWJzY3JpYmUtcmVzcG9uc2UocmVwb3J0ZXIpOiAnLCByZXBseSk7XG4gICAgICAgIGlmIChyZXBseS5ib2R5LmNvZGUgPT09IDIwMCkge1xuICAgICAgICAgIGxldCBuZXdGb3J3YXJkID0gX3RoaXMuX2J1cy5hZGRGb3J3YXJkKF90aGlzLl91cmwsIF90aGlzLl9vd25lcik7XG4gICAgICAgICAgX3RoaXMuX2ZvcndhcmRzW2FkZHJlc3Nlc1swXV0gPSBuZXdGb3J3YXJkO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QoJ0Vycm9yIG9uIG1zZy1ub2RlIHN1YnNjcmlwdGlvbjogJyArIHJlcGx5LmJvZHkuZGVzYyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVuUmVnaXN0ZXIgYSBsaXN0ZW5lciBpbiB0aGUgbXNnLW5vZGUgYW5kIGluIHRoZSBsb2NhbCBNZXNzYWdlQnVzLCBzbyB0aGF0IG1lc3NhZ2VzIG9uIHRoaXMgYWRkcmVzcyBhcmUgcmVtb3ZlZCBmcm9tIGZvcndhcmRcbiAgICogQHBhcmFtICB7c3RyaW5nfSBhZGRyZXNzIC0gVVJMIHRvIHVuLXJlZ2lzdGVyIHRoZSBsaXN0ZW5lcnNcbiAgICovXG4gIGZvcndhcmRVblN1YnNjcmliZShhZGRyZXNzKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIF90aGlzLl9mb3J3YXJkc1thZGRyZXNzXS5yZW1vdmUoKTtcbiAgICBkZWxldGUgX3RoaXMuX2ZvcndhcmRzW2FkZHJlc3NdO1xuXG4gICAgLy9GTE9XLU9VVDogbWVzc2FnZSBzZW50IHRvIHRoZSBtc2ctbm9kZSBTdWJzY3JpcHRpb25NYW5hZ2VyIGNvbXBvbmVudFxuICAgIGxldCBub2RlVW5TdWJzY3JpYmVNc2cgPSB7XG4gICAgICB0eXBlOiAndW5zdWJzY3JpYmUnLCBmcm9tOiBfdGhpcy5fcGFyZW50Ll91cmwsIHRvOiAnZG9tYWluOi8vbXNnLW5vZGUuJyArIF90aGlzLl9kb21haW4gKyAnL3NtJyxcbiAgICAgIGJvZHk6IHsgc3Vic2NyaWJlOiBbYWRkcmVzc10sIHNvdXJjZTogX3RoaXMuX293bmVyIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuX2J1cy5wb3N0TWVzc2FnZShub2RlVW5TdWJzY3JpYmVNc2cpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGxpc3RlbmVycyBmb3IgYSBsaXN0IG9mIGNoaWxkcmVucy4gUHVibGljIGNoYW5uZWxzIHVzZWQgdG8gdHJhbnNtaXQgbWVzc2FnZXMuXG4gICAqIEBwYXJhbSAge3N0cmluZ1tdfSBjaGlsZHJlbnMgLSBjaGFubmVscyB0byByZWdpc3RlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXR1cm4gUHJvbWlzZSBPSyBvciBlcnJvclxuICAgKi9cbiAgYWRkQ2hpbGRyZW5zKGNoaWxkcmVucykge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKGNoaWxkcmVucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBjaGlsZEJhc2VVUkwgPSBfdGhpcy5fdXJsICsgJy9jaGlsZHJlbi8nO1xuICAgICAgX3RoaXMuX2NoaWxkcmVucy5wdXNoKGNoaWxkcmVucyk7XG5cbiAgICAgIC8qXG4gICAgICBfdGhpcy5fY2hpbGRyZW5zLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgIGxldCBjaGlsZElkID0gY2hpbGRCYXNlVVJMICsgY2hpbGQ7XG5cbiAgICAgICAgbGV0IHNlbGZGb3J3YXJkID0gX3RoaXMuX2J1cy5hZGRGb3J3YXJkKGNoaWxkSWQsIG93bmVyKTtcbiAgICAgICAgX3RoaXMuX2NoaWxkcmVuTGlzdGVuZXJzLnB1c2goc2VsZkZvcndhcmQpO1xuICAgICAgfSk7Ki9cblxuICAgICAgbGV0IHN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICAgIGNoaWxkcmVucy5mb3JFYWNoKChjaGlsZCkgPT4gc3Vic2NyaXB0aW9ucy5wdXNoKGNoaWxkQmFzZVVSTCArIGNoaWxkKSk7XG5cbiAgICAgIC8vX3RoaXMuX3N0b3JhZ2VTdWJzY3JpcHRpb25zW190aGlzLl9vYmpTdWJzY3JpcHRvclVSTF0gPSB7dXJsOiBfdGhpcy5fdXJsLCBvd25lcjogX3RoaXMuX293bmVyLCBjaGlsZHJlbnM6IF90aGlzLl9jaGlsZHJlbnN9O1xuXG4gICAgICAvL0ZMT1ctT1VUOiBtZXNzYWdlIHNlbnQgdG8gdGhlIG1zZy1ub2RlIFN1YnNjcmlwdGlvbk1hbmFnZXIgY29tcG9uZW50XG4gICAgICBsZXQgbm9kZVN1YnNjcmliZU1zZyA9IHtcbiAgICAgICAgdHlwZTogJ3N1YnNjcmliZScsIGZyb206IF90aGlzLl9wYXJlbnQuX3VybCwgdG86ICdkb21haW46Ly9tc2ctbm9kZS4nICsgX3RoaXMuX2RvbWFpbiArICcvc20nLFxuICAgICAgICBib2R5OiB7IHN1YnNjcmliZTogc3Vic2NyaXB0aW9ucywgc291cmNlOiBfdGhpcy5fb3duZXIgfVxuICAgICAgfTtcblxuICAgICAgX3RoaXMuX2J1cy5wb3N0TWVzc2FnZShub2RlU3Vic2NyaWJlTXNnLCAocmVwbHkpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ25vZGUtc3Vic2NyaWJlLXJlc3BvbnNlKHJlcG9ydGVyKTogJywgcmVwbHkpO1xuICAgICAgICBpZiAocmVwbHkuYm9keS5jb2RlID09PSAyMDApIHtcblxuICAgICAgICAgIC8vYWRkIGNoaWxkcmVuIGxpc3RlbmVycyBvbiBsb2NhbCAuLi5cbiAgICAgICAgICBzdWJzY3JpcHRpb25zLmZvckVhY2goKGNoaWxkVVJMKSA9PiB7XG4gICAgICAgICAgICBsZXQgY2hpbGRMaXN0ZW5lciA9IF90aGlzLl9idXMuYWRkTGlzdGVuZXIoY2hpbGRVUkwsIChtc2cpID0+IHtcbiAgICAgICAgICAgICAgLy9UT0RPOiB3aGF0IHRvZG8gaGVyZT8gU2F2ZSBjaGlsZHJlbnM/XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTeW5jaGVyTWFuYWdlci0nICsgY2hpbGRVUkwgKyAnLVJDVjogJywgbXNnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMuX2NoaWxkcmVuTGlzdGVuZXJzLnB1c2goY2hpbGRMaXN0ZW5lcik7XG5cbiAgICAgICAgICAgIGxldCBzZWxmRm9yd2FyZCA9IF90aGlzLl9idXMuYWRkRm9yd2FyZChjaGlsZFVSTCwgX3RoaXMuX293bmVyKTtcbiAgICAgICAgICAgIF90aGlzLl9jaGlsZHJlbkxpc3RlbmVycy5wdXNoKHNlbGZGb3J3YXJkKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QoJ0Vycm9yIG9uIG1zZy1ub2RlIHN1YnNjcmlwdGlvbjogJyArIHJlcGx5LmJvZHkuZGVzYyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZGVsZXRlKCkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG4gICAgbGV0IGRvbWFpbiA9IGRpdmlkZVVSTChfdGhpcy5fb3duZXIpLmRvbWFpbjtcblxuICAgIC8vRkxPVy1PVVQ6IG1lc3NhZ2Ugc2VudCBkaXJlY3RseSB0byBhbGwgc3Vic2NyaWJlcnMgb2YgdGhlIHJlcG9ydGVyXG4gICAgX3RoaXMuX2J1cy5wb3N0TWVzc2FnZSh7XG4gICAgICB0eXBlOiAnZGVsZXRlJywgZnJvbTogX3RoaXMuX29ialN1YnNjcmlwdG9yVVJMLCB0bzogX3RoaXMuX3VybCArICcvY2hhbmdlcydcbiAgICB9KTtcblxuICAgIC8vRkxPVy1PVVQ6IG1lc3NhZ2Ugc2VudCB0byB0aGUgbXNnLW5vZGUgT2JqZWN0QWxsb2NhdGlvbk1hbmFnZXIgY29tcG9uZW50XG4gICAgX3RoaXMuX2J1cy5wb3N0TWVzc2FnZSh7XG4gICAgICB0eXBlOiAnZGVsZXRlJywgZnJvbTogX3RoaXMuX3BhcmVudC5fdXJsLCB0bzogJ2RvbWFpbjovL21zZy1ub2RlLicgKyBkb21haW4gKyAnL29iamVjdC1hZGRyZXNzLWFsbG9jYXRpb24nLFxuICAgICAgYm9keTogeyByZXNvdXJjZTogX3RoaXMuX3VybCwgY2hpbGRyZW5SZXNvdXJjZXM6IF90aGlzLl9jaGlsZHJlbnMgfVxuICAgIH0pO1xuXG4gICAgX3RoaXMuX3JlbGVhc2VMaXN0ZW5lcnMoKTtcbiAgICBkZWxldGUgX3RoaXMuX3BhcmVudC5fcmVwb3J0ZXJzW190aGlzLl91cmxdO1xuICB9XG5cbiAgX29uUmVtb3RlUmVzcG9uc2UobXNnKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIF90aGlzLl9idXMucG9zdE1lc3NhZ2Uoe1xuICAgICAgaWQ6IG1zZy5pZCwgdHlwZTogJ3Jlc3BvbnNlJywgZnJvbTogbXNnLnRvLCB0bzogX3RoaXMuX3VybCxcbiAgICAgIGJvZHk6IHsgY29kZTogbXNnLmJvZHkuY29kZSwgaWRlbnRpdHk6IG1zZy5ib2R5LmlkZW50aXR5LCBzb3VyY2U6IG1zZy5mcm9tIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vRkxPVy1JTjogbWVzc2FnZSByZWNlaXZlZCBmcm9tIFN5bmNoZXIgLT4gc3Vic2NyaWJlXG4gIF9vblJlbW90ZVN1YnNjcmliZShtc2cpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuICAgIGxldCBoeXBlcnR5VVJMID0gbXNnLmJvZHkuc3Vic2NyaWJlcjtcblxuICAgIC8vdmFsaWRhdGUgaWYgc3Vic2NyaXB0aW9uIGFscmVhZHkgZXhpc3RzP1xuICAgIGlmIChfdGhpcy5fc3Vic2NyaXB0aW9uc1toeXBlcnR5VVJMXSkge1xuICAgICAgLy8gbGV0IGVycm9yTXNnID0ge1xuICAgICAgLy8gICBpZDogbXNnLmlkLCB0eXBlOiAncmVzcG9uc2UnLCBmcm9tOiBtc2cudG8sIHRvOiBoeXBlcnR5VVJMLFxuICAgICAgLy8gICBib2R5OiB7IGNvZGU6IDUwMCwgZGVzYzogJ1N1YnNjcmlwdGlvbiBmb3IgKCcgKyBfdGhpcy5fdXJsICsgJyA6ICcgKyAgaHlwZXJ0eVVSTCArICcpIGFscmVhZHkgZXhpc3RzIScgfVxuICAgICAgLy8gfTtcbiAgICAgIC8vXG4gICAgICAvLyBfdGhpcy5fYnVzLnBvc3RNZXNzYWdlKGVycm9yTXNnKTtcbiAgICAgIC8vIHJldHVybjtcblxuICAgICAgLy8gbmV3IHZlcnNpb24gYmVjYXVzZSBvZiByZXVzYWdlXG4gICAgICBfdGhpcy5fc3Vic2NyaXB0aW9uc1toeXBlcnR5VVJMXS5fcmVsZWFzZUxpc3RlbmVycygpO1xuICAgIH1cblxuICAgIC8vYXNrIHRvIHN1YnNjcmliZSB0byBTeW5jaGVyPyAoZGVwZW5kcyBvbiB0aGUgb3BlcmF0aW9uIG1vZGUpXG4gICAgLy9UT0RPOiBnZXQgbW9kZSBmcm9tIG9iamVjdCFcbiAgICBsZXQgbW9kZSA9ICdzdWIvcHViJztcblxuICAgIGlmIChtb2RlID09PSAnc3ViL3B1YicpIHtcbiAgICAgIC8vRkxPVy1PVVQ6IG1lc3NhZ2Ugc2VudCB0byBsb2NhbCBoeXBlcnR5IGFkZHJlc3MgU3luY2hlciAtPiBfb25Gb3J3YXJkXG4gICAgICBsZXQgZm9yd2FyZE1zZyA9IHtcbiAgICAgICAgdHlwZTogJ2ZvcndhcmQnLCBmcm9tOiBfdGhpcy5fdXJsLCB0bzogX3RoaXMuX293bmVyLFxuICAgICAgICBib2R5OiB7IHR5cGU6IG1zZy50eXBlLCBmcm9tOiBoeXBlcnR5VVJMLCB0bzogX3RoaXMuX3VybCwgaWRlbnRpdHk6IG1zZy5ib2R5LmlkZW50aXR5IH1cbiAgICAgIH07XG5cbiAgICAgIF90aGlzLl9idXMucG9zdE1lc3NhZ2UoZm9yd2FyZE1zZywgKHJlcGx5KSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdmb3J3YXJkLXJlcGx5OiAnLCByZXBseSk7XG4gICAgICAgIGlmIChyZXBseS5ib2R5LmNvZGUgPT09IDIwMCkge1xuICAgICAgICAgIGlmICghX3RoaXMuX3N1YnNjcmlwdGlvbnNbaHlwZXJ0eVVSTF0pIHtcbiAgICAgICAgICAgIF90aGlzLl9zdWJzY3JpcHRpb25zW2h5cGVydHlVUkxdID0gbmV3IFN1YnNjcmlwdGlvbihfdGhpcy5fYnVzLCBfdGhpcy5fb3duZXIsIF90aGlzLl91cmwsIF90aGlzLl9jaGlsZHJlbnMsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0b3JlIGZvciBlYWNoIHJlcG9ydGVyIGh5cGVydHkgdGhlIGRhdGFPYmplY3RcbiAgICAgICAgbGV0IHVzZXJVUkw7XG4gICAgICAgIGlmIChtc2cuYm9keS5pZGVudGl0eSAmJiBtc2cuYm9keS5pZGVudGl0eS51c2VyUHJvZmlsZS51c2VyVVJMKSB7XG4gICAgICAgICAgdXNlclVSTCA9IG1zZy5ib2R5LmlkZW50aXR5LnVzZXJQcm9maWxlLnVzZXJVUkw7XG4gICAgICAgICAgX3RoaXMuX3BhcmVudC5fc3RvcmVEYXRhT2JqZWN0cy51cGRhdGUoX3RoaXMuX3VybCwgJ3N1YnNjcmliZXJVc2VycycsIHVzZXJVUkwpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuX3BhcmVudC5fc3RvcmVEYXRhT2JqZWN0cy51cGRhdGUoX3RoaXMuX3VybCwgJ3N1YnNjcmlwdGlvbnMnLCBoeXBlcnR5VVJMKTtcblxuICAgICAgICAvL0ZMT1ctT1VUOiBzdWJzY3JpcHRpb24gcmVzcG9uc2Ugc2VudCAoZm9yd2FyZCBmcm9tIGludGVybmFsIEh5cGVydHkpXG4gICAgICAgIF90aGlzLl9idXMucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIGlkOiBtc2cuaWQsIHR5cGU6ICdyZXNwb25zZScsIGZyb206IG1zZy50bywgdG86IG1zZy5mcm9tLFxuICAgICAgICAgIGJvZHk6IHJlcGx5LmJvZHlcbiAgICAgICAgfSk7XG5cbiAgICAgIH0pO1xuICAgIH1cblxuICB9XG5cbiAgLy9GTE9XLUlOOiBtZXNzYWdlIHJlY2VpdmVkIGZyb20gcmVtb3RlIE9ic2VydmVyT2JqZWN0IC0+IHJlbW92ZVN1YnNjcmlwdGlvblxuICBfb25SZW1vdGVVblN1YnNjcmliZShtc2cpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuICAgIGxldCBoeXBlcnR5VVJMID0gbXNnLmJvZHkuc3Vic2NyaWJlcjtcblxuICAgIGxldCBzdWJzY3JpcHRpb24gPSBfdGhpcy5fc3Vic2NyaXB0aW9uc1toeXBlcnR5VVJMXTtcbiAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICBzdWJzY3JpcHRpb24uX3JlbGVhc2VMaXN0ZW5lcnMoKTtcbiAgICAgIGRlbGV0ZSBfdGhpcy5fc3Vic2NyaXB0aW9uc1toeXBlcnR5VVJMXTtcblxuICAgICAgLy9UT0RPOiBzZW5kIHVuLXN1YnNjcmliZSBtZXNzYWdlIHRvIFN5bmNoZXI/IChkZXBlbmRzIG9uIHRoZSBvcGVyYXRpb24gbW9kZSlcbiAgICB9XG5cbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlcG9ydGVyT2JqZWN0O1xuIiwiY2xhc3MgU3RvcmVEYXRhT2JqZWN0cyB7XG5cbiAgY29uc3RydWN0b3Ioc3RvcmFnZU1hbmFnZXIpIHtcbiAgICBpZiAoIXN0b3JhZ2VNYW5hZ2VyKSB0aHJvdyBuZXcgRXJyb3IoJ1tTdG9yZSBEYXRhIE9iamVjdHNdIC0gTmVlZHMgdGhlIHN0b3JhZ2VNYW5hZ2VyIGNvbXBvbmVudCcpO1xuXG4gICAgdGhpcy5fc3RvcmFnZU1hbmFnZXIgPSBzdG9yYWdlTWFuYWdlcjtcbiAgICB0aGlzLl9zdG9yZURhdGFPYmplY3QgPSB7fTtcbiAgfVxuXG4gIHNldChyZXNvdXJjZSwgaXNSZXBvcnRlciwgc2NoZW1hLCBzdGF0dXMsIGRhdGEsIHN1YnNjcmlwdGlvbiwgY2hpbGRyZW4sIGNoaWxkcmVuUmVzb3VyY2VzLCBzdWJzY3JpYmVyVXNlcikge1xuXG4gICAgbGV0IHR5cGUgPSB0aGlzLl9nZXRUeXBlT2ZPYmplY3QoaXNSZXBvcnRlcik7XG4gICAgaWYgKCF0aGlzLl9zdG9yZURhdGFPYmplY3QuaGFzT3duUHJvcGVydHkodHlwZSkpIHRoaXMuX3N0b3JlRGF0YU9iamVjdFt0eXBlXSA9IHt9O1xuXG4gICAgaWYgKCF0aGlzLl9zdG9yZURhdGFPYmplY3RbdHlwZV0uaGFzT3duUHJvcGVydHkocmVzb3VyY2UpKSB7XG4gICAgICB0aGlzLl9zdG9yZURhdGFPYmplY3RbdHlwZV1bcmVzb3VyY2VdID0ge1xuICAgICAgICByZXNvdXJjZTogcmVzb3VyY2UsXG4gICAgICAgIGlzUmVwb3J0ZXI6IGlzUmVwb3J0ZXIsXG4gICAgICAgIHN1YnNjcmlwdGlvbnM6IFtdLFxuICAgICAgICBzdWJzY3JpYmVyVXNlcnM6IFtdXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChpc1JlcG9ydGVyKSB0aGlzLl9zdG9yZURhdGFPYmplY3RbdHlwZV1bcmVzb3VyY2VdLm93bmVyID0gc3Vic2NyaXB0aW9uO1xuXG4gICAgaWYgKGRhdGEpIHRoaXMuX3N0b3JlRGF0YU9iamVjdFt0eXBlXVtyZXNvdXJjZV0uZGF0YSA9IGRhdGE7XG4gICAgaWYgKHNjaGVtYSkgdGhpcy5fc3RvcmVEYXRhT2JqZWN0W3R5cGVdW3Jlc291cmNlXS5zY2hlbWEgPSBzY2hlbWE7XG4gICAgaWYgKHN0YXR1cykgdGhpcy5fc3RvcmVEYXRhT2JqZWN0W3R5cGVdW3Jlc291cmNlXS5zdGF0dXMgPSBzdGF0dXM7XG4gICAgaWYgKGNoaWxkcmVuKSB0aGlzLl9zdG9yZURhdGFPYmplY3RbdHlwZV1bcmVzb3VyY2VdLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgaWYgKGNoaWxkcmVuUmVzb3VyY2VzKSB0aGlzLl9zdG9yZURhdGFPYmplY3RbdHlwZV1bcmVzb3VyY2VdLmNoaWxkcmVuUmVzb3VyY2VzID0gY2hpbGRyZW5SZXNvdXJjZXM7XG5cbiAgICBjb25zb2xlLmxvZygnU0VUOicsIHN1YnNjcmlwdGlvbiwgIWlzUmVwb3J0ZXIpO1xuICAgIGlmIChzdWJzY3JpcHRpb24gJiYgIWlzUmVwb3J0ZXIpIHtcbiAgICAgIGlmICh0aGlzLl9zdG9yZURhdGFPYmplY3RbdHlwZV1bcmVzb3VyY2VdLnN1YnNjcmlwdGlvbnMuaW5kZXhPZihzdWJzY3JpcHRpb24pKSB0aGlzLl9zdG9yZURhdGFPYmplY3RbdHlwZV1bcmVzb3VyY2VdLnN1YnNjcmlwdGlvbnMucHVzaChzdWJzY3JpcHRpb24pO1xuICAgIH1cblxuICAgIGlmIChzdWJzY3JpYmVyVXNlcikge1xuICAgICAgaWYgKHRoaXMuX3N0b3JlRGF0YU9iamVjdFt0eXBlXVtyZXNvdXJjZV0uc3Vic2NyaWJlclVzZXJzLmluZGV4T2Yoc3Vic2NyaWJlclVzZXIpKSB0aGlzLl9zdG9yZURhdGFPYmplY3RbdHlwZV1bcmVzb3VyY2VdLnN1YnNjcmliZXJVc2Vycy5wdXNoKHN1YnNjcmliZXJVc2VyKTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnU0VUOiAnLCB0aGlzLl9zdG9yZURhdGFPYmplY3RbdHlwZV1bcmVzb3VyY2VdLCBzdWJzY3JpcHRpb24pO1xuXG4gICAgcmV0dXJuIHRoaXMuX3N0b3JhZ2VNYW5hZ2VyLnNldCgnc3luY2hlck1hbmFnZXI6T2JqZWN0VVJMcycsIDEsIHRoaXMuX3N0b3JlRGF0YU9iamVjdCk7XG5cbiAgfVxuXG4gIHVwZGF0ZURhdGEocmVzb3VyY2UsIGtleSwgYXR0cmlidXRlLCB2YWx1ZSwgaXNSZXBvcnRlciA9IHRydWUpIHtcbiAgICBsZXQgdHlwZSA9IHRoaXMuX2dldFR5cGVPZk9iamVjdChpc1JlcG9ydGVyKTtcblxuICAgIGlmICh0aGlzLl9zdG9yZURhdGFPYmplY3QuaGFzT3duUHJvcGVydHkodHlwZSkgJiYgdGhpcy5fc3RvcmVEYXRhT2JqZWN0W3R5cGVdW3Jlc291cmNlXSAmJiByZXNvdXJjZSAmJiBrZXkgJiYgdmFsdWUpIHtcblxuICAgICAgaWYgKGtleSA9PT0gJ3N1YnNjcmlwdGlvbnMnIHx8IGtleSA9PT0gJ3N1YnNjcmliZXJVc2VycycpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlVG9BcnJheShyZXNvdXJjZSwga2V5LCB2YWx1ZSwgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zdG9yZURhdGFPYmplY3RbdHlwZV1bcmVzb3VyY2VdW2tleV1bYXR0cmlidXRlXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fc3RvcmFnZU1hbmFnZXIuc2V0KCdzeW5jaGVyTWFuYWdlcjpPYmplY3RVUkxzJywgMSwgdGhpcy5fc3RvcmVEYXRhT2JqZWN0KTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAvL3Rocm93IG5ldyBFcnJvcignW1N0b3JlRGF0YU9iamVjdHNdIC0gQ2FuXFwndCB1cGRhdGUgdGhpcyAnICsgcmVzb3VyY2UgKyAnIHRvIHRoZSBrZXkgJyArIGtleSArICcgd2l0aCB2YWx1ZTogJyArIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGUocmVzb3VyY2UsIGtleSwgdmFsdWUsIGlzUmVwb3J0ZXIgPSB0cnVlKSB7XG4gICAgbGV0IHR5cGUgPSB0aGlzLl9nZXRUeXBlT2ZPYmplY3QoaXNSZXBvcnRlcik7XG5cbiAgICBpZiAodGhpcy5fc3RvcmVEYXRhT2JqZWN0Lmhhc093blByb3BlcnR5KHR5cGUpICYmIHRoaXMuX3N0b3JlRGF0YU9iamVjdFt0eXBlXVtyZXNvdXJjZV0gJiYgcmVzb3VyY2UgJiYga2V5ICYmIHZhbHVlKSB7XG5cbiAgICAgIGlmIChrZXkgPT09ICdzdWJzY3JpcHRpb25zJyB8fCBrZXkgPT09ICdzdWJzY3JpYmVyVXNlcnMnKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVRvQXJyYXkocmVzb3VyY2UsIGtleSwgdmFsdWUsIHR5cGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc3RvcmVEYXRhT2JqZWN0W3R5cGVdW3Jlc291cmNlXVtrZXldID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9zdG9yYWdlTWFuYWdlci5zZXQoJ3N5bmNoZXJNYW5hZ2VyOk9iamVjdFVSTHMnLCAxLCB0aGlzLl9zdG9yZURhdGFPYmplY3QpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vdGhyb3cgbmV3IEVycm9yKCdbU3RvcmVEYXRhT2JqZWN0c10gLSBDYW5cXCd0IHVwZGF0ZSB0aGlzICcgKyByZXNvdXJjZSArICcgdG8gdGhlIGtleSAnICsga2V5ICsgJyB3aXRoIHZhbHVlOiAnICsgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGRlbGV0ZShyZXNvdXJjZSwga2V5LCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9zdG9yZURhdGFPYmplY3RbcmVzb3VyY2VdICYmIHJlc291cmNlICYmIGtleSAmJiB2YWx1ZSkge1xuXG4gICAgICBpZiAoa2V5ID09PSAnc3Vic2NyaXB0aW9ucycgfHwga2V5ID09PSAnc3Vic2NyaWJlclVzZXJzJykge1xuICAgICAgICB0aGlzLl9yZW1vdmVGcm9tQXJyYXkocmVzb3VyY2UsIGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy5fc3RvcmVEYXRhT2JqZWN0W3Jlc291cmNlXVtrZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fc3RvcmFnZU1hbmFnZXIuc2V0KCdzeW5jaGVyTWFuYWdlcjpPYmplY3RVUkxzJywgMSwgdGhpcy5fc3RvcmVEYXRhT2JqZWN0KTtcblxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTdG9yZURhdGFPYmplY3RzXSAtIENhblxcJ3QgZGVsZXRlIHRoaXMgJyArIHJlc291cmNlICsgJyB0byB0aGUga2V5ICcgKyBrZXkgKyAnIHdpdGggdmFsdWU6ICcgKyB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRPRE86IGNoZWNrIGlmIHRoaXMgcHJvY2VzcyBpcyB2aWFibGUgYmVjYXVzZSB0aGUgc3RvcmFnZSBtYW5hZ2VyIGFiaWxpdHkgdG8gZGVsZXRlXG4gICAqIG5vdyB0aGUgc3RvcmFnZU1hbmFnZXIgb25seSBjYW4gZGVsZXRlIGFuIHNwZWNpZmljIGtleSwgYnV0IG5vdCB0aGUgc3BlY2lmaWMgdmFsdWUgaW5zaWRlIHRoYXQga2V5O1xuICAgKi9cbiAgZGVsZXRlUmVzb3VyY2UocmVzb3VyY2UpIHtcbiAgICBpZiAocmVzb3VyY2UpIHtcblxuICAgICAgcmV0dXJuIHRoaXMuZ2V0QWxsKCkudGhlbigoc3RvcmVkRGF0YU9iamVjdHMpID0+IHtcbiAgICAgICAgbGV0IHRtcCA9IHN0b3JlZERhdGFPYmplY3RzO1xuXG4gICAgICAgIGlmICh0bXAuaGFzT3duUHJvcGVydHkocmVzb3VyY2UpKSB7XG4gICAgICAgICAgZGVsZXRlIHRtcC5vYnNlcnZlcnNbcmVzb3VyY2VdO1xuICAgICAgICAgIGRlbGV0ZSB0bXAucmVwb3J0ZXJzW3Jlc291cmNlXTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcmFnZU1hbmFnZXIuc2V0KCdzeW5jaGVyTWFuYWdlcjpPYmplY3RVUkxzJywgMSwgdG1wKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbU3RvcmVEYXRhT2JqZWN0c10gLSBDYW5cXCd0IGRlbGV0ZSB0aGlzICcgKyByZXNvdXJjZSk7XG4gICAgfVxuXG4gIH1cblxuICBnZXRBbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3JhZ2VNYW5hZ2VyLmdldCgnc3luY2hlck1hbmFnZXI6T2JqZWN0VVJMcycpO1xuICB9XG5cbiAgZ2V0KHJlc291cmNlKSB7XG4gICAgaWYgKHRoaXMuX3N0b3JlRGF0YU9iamVjdFtyZXNvdXJjZV0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdG9yZURhdGFPYmplY3RbcmVzb3VyY2VdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tTdG9yZURhdGFPYmplY3RzXSAtIENhblxcJ3QgZmluZCB0aGlzICcgKyByZXNvdXJjZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqL1xuICBnZXRSZXNvdXJjZXNCeUNyaXRlcmlhKG1zZywgaXNSZXBvcnRlcikge1xuXG4gICAgY29uc29sZS5sb2coJ01TRzonLCBtc2cpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG5cbiAgICAgIGxldCB0eXBlID0gdGhpcy5fZ2V0VHlwZU9mT2JqZWN0KGlzUmVwb3J0ZXIpO1xuXG4gICAgICB0aGlzLmdldEFsbCgpLnRoZW4oKHN0b3JlZERhdGFPYmplY3RzKSA9PiB7XG5cbiAgICAgICAgaWYgKCFzdG9yZWREYXRhT2JqZWN0cykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdkb25cXCd0IGhhdmUgc3RvcmVkIGRhdGEgb2JqZWN0cycpO1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1zZy5ib2R5Lmhhc093blByb3BlcnR5KCdyZXN1bWUnKSAmJiAhbXNnLmJvZHkucmVzdW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBpZiB0aGUgbWVzc2FnZSBoYXZlIG90aGVyIGNyaXRlcmlhXG4gICAgICAgIC8vIGlmIG5vdCBzZWFyY2ggZm9yIG9uIHRoZSAnZnJvbScgb2YgdGhlIG1lc3NhZ2UuXG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGhhc1N1YnNjcmlwdGlvbiA9IHRoaXMuX2hhc1N1YnNjcmlwdGlvbihzdG9yZWREYXRhT2JqZWN0c1t0eXBlXSwgbXNnLmZyb20pO1xuICAgICAgICBsZXQgaXNPd25lciA9IHRoaXMuX2lzT3duZXIoc3RvcmVkRGF0YU9iamVjdHNbdHlwZV0sIG1zZy5mcm9tKTtcblxuICAgICAgICBpZiAobXNnLmhhc093blByb3BlcnR5KCdmcm9tJykgJiYgaGFzU3Vic2NyaXB0aW9uIHx8IGlzT3duZXIpIHtcbiAgICAgICAgICBsZXQgcmVzb3VyY2UgPSB0aGlzLl9nZXRSZXNvdXJjZXNCeVN1YnNjcmlwdGlvbihzdG9yZWREYXRhT2JqZWN0c1t0eXBlXSwgbXNnLmZyb20pO1xuICAgICAgICAgIGxldCBpZGVudGl0eUZvdW5kRGF0YSA9IHRoaXMuX2dldFJlc291cmNlc0J5SWRlbnRpdHkoc3RvcmVkRGF0YU9iamVjdHNbdHlwZV0sIG1zZy5ib2R5LmlkZW50aXR5KTtcbiAgICAgICAgICBsZXQgc2NoZW1hRm91bmREYXRhID0gdGhpcy5fZ2V0UmVzb3VyY2VzQnlTY2hlbWEoc3RvcmVkRGF0YU9iamVjdHNbdHlwZV0sIG1zZy5ib2R5LnNjaGVtYSk7XG4gICAgICAgICAgbGV0IGRhdGFGb3VuZCA9IHRoaXMuX2dldFJlc291cmNlc0J5RGF0YShzdG9yZWREYXRhT2JqZWN0c1t0eXBlXSwgbXNnLmJvZHkudmFsdWUpO1xuXG4gICAgICAgICAgLy8geW91IGNhbiBwYXNzIGFzIGFycmF5cyBhcyB5b3Ugd2FudC4uIGl0IHdpbGwgYmUgbWVyZ2VkIGluIG9uIHBsYWNlXG4gICAgICAgICAgLy8gcmVtb3ZlZCBkdXBsaWNhdGVzO1xuICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX2ludGVyc2VjdGlvbihpZGVudGl0eUZvdW5kRGF0YSwgc2NoZW1hRm91bmREYXRhLCBkYXRhRm91bmQsIHJlc291cmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpbml0ID0ge307XG4gICAgICAgIHJlc3VsdC5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICBsZXQgY3VycmVudElzUmVwb3J0ZXIgPSBzdG9yZWREYXRhT2JqZWN0c1t0eXBlXVtrZXldO1xuICAgICAgICAgIGluaXRba2V5XSA9IGN1cnJlbnRJc1JlcG9ydGVyO1xuICAgICAgICAgIHJldHVybiBpbml0O1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zb2xlLmxvZygnW1N0b3JlIERhdGEgT2JqZWN0c10gLSAnLCBpbml0KTtcblxuICAgICAgICByZXNvbHZlKGluaXQpO1xuICAgICAgfSk7XG5cbiAgICB9KTtcblxuICB9XG5cbiAgX2dldFJlc291cmNlc0J5SWRlbnRpdHkoc3RvcmVkRGF0YSwgdXNlclVSTCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzdG9yZWREYXRhKS5maWx0ZXIoKG9iamVjdFVSTCkgPT4ge1xuICAgICAgcmV0dXJuIHN0b3JlZERhdGFbb2JqZWN0VVJMXS5zdWJzY3JpYmVyVXNlcnMuZmlsdGVyKChjdXJyZW50KSA9PiB7XG4gICAgICAgIHJldHVybiBjdXJyZW50ID09PSB1c2VyVVJMO1xuICAgICAgfSkubGVuZ3RoO1xuICAgIH0pO1xuICB9XG5cbiAgX2dldFJlc291cmNlc0J5U3Vic2NyaXB0aW9uKHN0b3JlZERhdGEsIHN1YnNjcmlwdGlvbikge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzdG9yZWREYXRhKS5maWx0ZXIoKG9iamVjdFVSTCkgPT4ge1xuICAgICAgcmV0dXJuIHN0b3JlZERhdGFbb2JqZWN0VVJMXS5zdWJzY3JpcHRpb25zLmZpbHRlcigoY3VycmVudCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnQ3V1cmVudDonLCBjdXJyZW50LCBzdWJzY3JpcHRpb24pO1xuICAgICAgICByZXR1cm4gY3VycmVudCA9PT0gc3Vic2NyaXB0aW9uO1xuICAgICAgfSkubGVuZ3RoO1xuICAgIH0pO1xuXG4gIH1cblxuICBfZ2V0UmVzb3VyY2VzQnlTY2hlbWEoc3RvcmVkRGF0YSwgc2NoZW1hKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHN0b3JlZERhdGEpLmZpbHRlcigob2JqZWN0VVJMKSA9PiB7XG4gICAgICBsZXQgY3VycmVudE9iamVjdCA9IHN0b3JlZERhdGFbb2JqZWN0VVJMXTtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhjdXJyZW50T2JqZWN0KS5maWx0ZXIoKGtleSkgPT4ge1xuICAgICAgICByZXR1cm4ga2V5ID09PSAnc2NoZW1hJyAmJiBjdXJyZW50T2JqZWN0W2tleV0gPT09IHNjaGVtYTtcbiAgICAgIH0pLmxlbmd0aDtcbiAgICB9KTtcbiAgfVxuXG4gIF9nZXRSZXNvdXJjZXNCeURhdGEoc3RvcmVkRGF0YSwgZGF0YSkge1xuICAgIGlmICghZGF0YSkgcmV0dXJuIFtdO1xuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHN0b3JlZERhdGEpLmZpbHRlcigob2JqZWN0VVJMKSA9PiB7XG4gICAgICBsZXQgY3VycmVudE9iamVjdCA9IHN0b3JlZERhdGFbb2JqZWN0VVJMXS5kYXRhO1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGN1cnJlbnRPYmplY3QpLmZpbHRlcigoa2V5KSA9PiB7XG4gICAgICAgIC8vIHNlYXJjaCBvbiBzdG9yZURhdGFPYmplY3RzIGZvciBzcGVjaWZpYyBrZXkgcHJvdmlkZWQgZnJvbSBkYXRhO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoZGF0YSkuZmlsdGVyKHNlYXJjaEZvciA9PiB7XG4gICAgICAgICAgcmV0dXJuIGtleSA9PT0gc2VhcmNoRm9yICYmIGN1cnJlbnRPYmplY3Rba2V5XSA9PT0gZGF0YVtzZWFyY2hGb3JdO1xuICAgICAgICB9KS5sZW5ndGg7XG5cbiAgICAgIH0pLmxlbmd0aDtcbiAgICB9KTtcbiAgfVxuXG4gIF9oYXNTdWJzY3JpcHRpb24oc3RvcmVkRGF0YSwgc3Vic2NyaXB0aW9uKSB7XG4gICAgaWYgKCFzdG9yZWREYXRhKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc3RvcmVkRGF0YSkuZmlsdGVyKChvYmplY3RVUkwpID0+IHtcbiAgICAgIHJldHVybiBzdG9yZWREYXRhW29iamVjdFVSTF0uc3Vic2NyaXB0aW9ucy5maWx0ZXIoKGN1cnJlbnQpID0+IHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQgPT09IHN1YnNjcmlwdGlvbjtcbiAgICAgIH0pLmxlbmd0aDtcbiAgICB9KS5sZW5ndGggPiAwID8gdHJ1ZSA6IGZhbHNlO1xuICB9XG5cbiAgX2lzT3duZXIoc3RvcmVkRGF0YSwgdXJsKSB7XG4gICAgaWYgKCFzdG9yZWREYXRhKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc3RvcmVkRGF0YSkuZmlsdGVyKChvYmplY3RVUkwpID0+IHtcbiAgICAgIHJldHVybiBzdG9yZWREYXRhW29iamVjdFVSTF0ub3duZXIgPT09IHVybDtcbiAgICB9KS5sZW5ndGggPiAwID8gdHJ1ZSA6IGZhbHNlO1xuICB9XG5cbiAgX2ludGVyc2VjdGlvbigpIHtcbiAgICBsZXQgYXJncyA9IEFycmF5LmZyb20oYXJndW1lbnRzKTtcblxuICAgIGxldCByZXN1bHQgPSBhcmdzLnJlZHVjZSgoZmlyc3QsIHNlY29uZCkgPT4ge1xuICAgICAgcmV0dXJuIGZpcnN0LmNvbmNhdChzZWNvbmQpO1xuICAgIH0pLmZpbHRlcigodmFsdWUsIGluZGV4LCBzZWxmKSA9PiB7XG4gICAgICByZXR1cm4gc2VsZi5pbmRleE9mKHZhbHVlKSA9PT0gaW5kZXg7XG4gICAgfSk7XG4gICAgY29uc29sZS5sb2coJ1Jlc3VsdCBhbiB1bmlxdWUgYXJyYXkgb2Ygc3RyaW5nczogJywgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgX3VwZGF0ZVRvQXJyYXkocmVzb3VyY2UsIGtleSwgdmFsdWUsIHR5cGUpIHtcbiAgICBpZiAodGhpcy5fc3RvcmVEYXRhT2JqZWN0W3R5cGVdW3Jlc291cmNlXVtrZXldLmluZGV4T2YodmFsdWUpKSB0aGlzLl9zdG9yZURhdGFPYmplY3RbdHlwZV1bcmVzb3VyY2VdW2tleV0ucHVzaCh2YWx1ZSk7XG4gIH1cblxuICBfcmVtb3ZlRnJvbUFycmF5KHJlc291cmNlLCBrZXksIHZhbHVlKSB7XG4gICAgbGV0IGluZGV4T2ZWYWx1ZSA9IHRoaXMuX3N0b3JlRGF0YU9iamVjdFtyZXNvdXJjZV1ba2V5XS5pbmRleE9mKHZhbHVlKTtcbiAgICBpZiAoaW5kZXhPZlZhbHVlKSB0aGlzLl9zdG9yZURhdGFPYmplY3RbcmVzb3VyY2VdW2tleV0uc3BsaWNlKGluZGV4T2ZWYWx1ZSwgMSk7XG4gIH1cblxuICBfaGFzVmFsdWUob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIG9ialtrZXldID09PSB2YWx1ZTtcbiAgfVxuXG4gIF9nZXRUeXBlT2ZPYmplY3QoaXNSZXBvcnRlcikge1xuICAgIHJldHVybiBpc1JlcG9ydGVyID8gJ3JlcG9ydGVycycgOiAnb2JzZXJ2ZXJzJztcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFN0b3JlRGF0YU9iamVjdHM7XG4iLCJjbGFzcyBTdWJzY3JpcHRpb24ge1xuXG4gIGNvbnN0cnVjdG9yKGJ1cywgb3duZXIsIHVybCwgY2hpbGRyZW5zLCBpc1JlcG9ydGVyKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcbiAgICBsZXQgY2hpbGRCYXNlVVJMID0gdXJsICsgJy9jaGlsZHJlbi8nO1xuICAgIGxldCBjaGFuZ2VVUkwgPSB1cmwgKyAnL2NoYW5nZXMnO1xuXG4gICAgLy9wcm9jZXNzIGRlbGV0ZSBtZXNzYWdlXG4gICAgX3RoaXMuX2RlbGV0ZUxpc3RlbmVyID0gYnVzLmFkZExpc3RlbmVyKGNoYW5nZVVSTCwgKG1zZykgPT4ge1xuICAgICAgaWYgKG1zZy50eXBlID09PSAnZGVsZXRlJykge1xuICAgICAgICBjb25zb2xlLmxvZygnU3Vic2NyaXB0aW9uLURFTEVURTogJywgbXNnKTtcblxuICAgICAgICAvL0ZMT1ctT1VUOiBtZXNzYWdlIHNlbnQgdG8gYWxsIHN1YnNjcmliZXJzXG4gICAgICAgIGxldCBkZWxldGVNZXNzYWdlVG9IeXBlcnR5ID0ge1xuICAgICAgICAgIHR5cGU6ICdkZWxldGUnLCBmcm9tOiBtc2cuZnJvbSwgdG86IG93bmVyLFxuICAgICAgICAgIGJvZHk6IHsgaWRlbnRpdHk6IG1zZy5ib2R5LmlkZW50aXR5LCByZXNvdXJjZTogdXJsIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvL3NlbmQgZGVsZXRlIHRvIGh5cGVydHlcbiAgICAgICAgYnVzLnBvc3RNZXNzYWdlKGRlbGV0ZU1lc3NhZ2VUb0h5cGVydHksIChyZXBseSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdTdWJzY3JpcHRpb24tREVMRVRFLVJFUExZOiAnLCByZXBseSk7XG4gICAgICAgICAgaWYgKHJlcGx5LmJvZHkuY29kZSA9PT0gMjAwKSB7XG4gICAgICAgICAgICBfdGhpcy5fcmVsZWFzZUxpc3RlbmVycygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvL2FkZCBjaGFuZ2UgcHVibGlzaCBhZGRyZXNzIG9yIGZvcndhcmRcbiAgICBpZiAoaXNSZXBvcnRlcikge1xuICAgICAgX3RoaXMuX2NoYW5nZUxpc3RlbmVyID0gYnVzLmFkZFB1Ymxpc2goY2hhbmdlVVJMKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMuX2NoYW5nZUxpc3RlbmVyID0gYnVzLmFkZEZvcndhcmQoY2hhbmdlVVJMLCBvd25lcik7XG4gICAgfVxuXG4gICAgX3RoaXMuX2NoaWxkcmVuTGlzdGVuZXJzID0gW107XG4gICAgY2hpbGRyZW5zLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBsZXQgY2hpbGRJZCA9IGNoaWxkQmFzZVVSTCArIGNoaWxkO1xuXG4gICAgICAvL2FkZCBjaGlsZHJlbiBwdWJsaXNoIGFkZHJlc3NcbiAgICAgIGxldCBjaGlsZHJlbkZvcndhcmQgPSBidXMuYWRkUHVibGlzaChjaGlsZElkKTtcbiAgICAgIF90aGlzLl9jaGlsZHJlbkxpc3RlbmVycy5wdXNoKGNoaWxkcmVuRm9yd2FyZCk7XG5cbiAgICAgIC8vYWRkIHNlbGYgZm9yd2FyZCBpZiBhbiBvYnNlcnZlclxuICAgICAgaWYgKCFpc1JlcG9ydGVyKSB7XG4gICAgICAgIGxldCBzZWxmRm9yd2FyZCA9IGJ1cy5hZGRGb3J3YXJkKGNoaWxkSWQsIG93bmVyKTtcbiAgICAgICAgX3RoaXMuX2NoaWxkcmVuTGlzdGVuZXJzLnB1c2goc2VsZkZvcndhcmQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX3JlbGVhc2VMaXN0ZW5lcnMoKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIF90aGlzLl9kZWxldGVMaXN0ZW5lci5yZW1vdmUoKTtcblxuICAgIF90aGlzLl9jaGFuZ2VMaXN0ZW5lci5yZW1vdmUoKTtcblxuICAgIF90aGlzLl9jaGlsZHJlbkxpc3RlbmVycy5mb3JFYWNoKChmb3J3YXJkKSA9PiB7XG4gICAgICBmb3J3YXJkLnJlbW92ZSgpO1xuICAgIH0pO1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3Vic2NyaXB0aW9uO1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDE2IFBUIElub3Zhw6fDo28gZSBTaXN0ZW1hcyBTQVxuKiBDb3B5cmlnaHQgMjAxNiBJTkVTQy1JRFxuKiBDb3B5cmlnaHQgMjAxNiBRVU9CSVMgTkVUV09SS1MgU0xcbiogQ29weXJpZ2h0IDIwMTYgRlJBVU5IT0ZFUi1HRVNFTExTQ0hBRlQgWlVSIEZPRVJERVJVTkcgREVSIEFOR0VXQU5EVEVOIEZPUlNDSFVORyBFLlZcbiogQ29weXJpZ2h0IDIwMTYgT1JBTkdFIFNBXG4qIENvcHlyaWdodCAyMDE2IERldXRzY2hlIFRlbGVrb20gQUdcbiogQ29weXJpZ2h0IDIwMTYgQXBpemVlXG4qIENvcHlyaWdodCAyMDE2IFRFQ0hOSVNDSEUgVU5JVkVSU0lUQVQgQkVSTElOXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbioqL1xuaW1wb3J0IHsgZGl2aWRlVVJMIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IHsgc2NoZW1hVmFsaWRhdGlvbiB9IGZyb20gJy4uL3V0aWxzL3NjaGVtYVZhbGlkYXRpb24nO1xuXG5pbXBvcnQgQWRkcmVzc0FsbG9jYXRpb24gZnJvbSAnLi4vYWxsb2NhdGlvbi9BZGRyZXNzQWxsb2NhdGlvbic7XG5pbXBvcnQgUmVwb3J0ZXJPYmplY3QgZnJvbSAnLi9SZXBvcnRlck9iamVjdCc7XG5pbXBvcnQgT2JzZXJ2ZXJPYmplY3QgZnJvbSAnLi9PYnNlcnZlck9iamVjdCc7XG5cbmltcG9ydCB7TWVzc2FnZUZhY3Rvcnl9IGZyb20gJ3NlcnZpY2UtZnJhbWV3b3JrL2Rpc3QvTWVzc2FnZUZhY3RvcnknO1xuXG5pbXBvcnQgU3RvcmVEYXRhT2JqZWN0cyBmcm9tICcuL1N0b3JlRGF0YU9iamVjdHMnO1xuXG4vKipcbiAqIEBhdXRob3IgbWljYWVscGVkcm9zYUBnbWFpbC5jb21cbiAqIENvcmUgU3luY3Jvbml6YXRpb24gc3lzdGVtLlxuICovXG5jbGFzcyBTeW5jaGVyTWFuYWdlciB7XG4gIC8qIHByaXZhdGVcbiAgX3VybDogVVJMXG4gIF9idXM6IE1pbmlCdXNcbiAgX3JlZ2lzdHJ5OiBSZWdpc3RyeVxuICBfYWxsb2NhdG9yOiBBZGRyZXNzQWxsb2NhdGlvblxuXG4gIF9yZXBvcnRlcnM6IHsgT2JqZWN0VVJMOiBSZXBvcnRlck9iamVjdCB9XG4gIF9vYnNlcnZlcnM6IHsgT2JqZWN0VVJMOiBPYnNlcnZlck9iamVjdCB9XG4gICovXG5cbiAgY29uc3RydWN0b3IocnVudGltZVVSTCwgYnVzLCByZWdpc3RyeSwgY2F0YWxvZywgc3RvcmFnZU1hbmFnZXIsIGFsbG9jYXRvcikge1xuICAgIGlmICghcnVudGltZVVSTCkgdGhyb3cgbmV3IEVycm9yKCdbU3luY2hlciBNYW5hZ2VyXSAtIG5lZWRzIHRoZSBydW50aW1lVVJMIHBhcmFtZXRlcicpO1xuICAgIGlmICghYnVzKSB0aHJvdyBuZXcgRXJyb3IoJ1tTeW5jaGVyIE1hbmFnZXJdIC0gbmVlZHMgdGhlIE1lc3NhZ2VCdXMgaW5zdGFuY2UnKTtcbiAgICBpZiAoIXJlZ2lzdHJ5KSB0aHJvdyBuZXcgRXJyb3IoJ1tTeW5jaGVyIE1hbmFnZXJdIC0gbmVlZHMgdGhlIFJlZ2lzdHJ5IGluc3RhbmNlJyk7XG4gICAgaWYgKCFjYXRhbG9nKSB0aHJvdyBuZXcgRXJyb3IoJ1tTeW5jaGVyIE1hbmFnZXJdIC0gbmVlZHMgdGhlIFJ1bnRpbWVDYXRhbG9ndWUgaW5zdGFuY2UnKTtcbiAgICBpZiAoIXN0b3JhZ2VNYW5hZ2VyKSB0aHJvdyBuZXcgRXJyb3IoJ1tTeW5jaGVyIE1hbmFnZXJdIC0gbmVlZCB0aGUgc3RvcmFnZU1hbmFnZXIgaW5zdGFuY2UnKTtcblxuICAgIGxldCBfdGhpcyA9IHRoaXM7XG5cbiAgICBfdGhpcy5fYnVzID0gYnVzO1xuICAgIF90aGlzLl9yZWdpc3RyeSA9IHJlZ2lzdHJ5O1xuICAgIF90aGlzLl9jYXRhbG9nID0gY2F0YWxvZztcbiAgICBfdGhpcy5fc3RvcmFnZU1hbmFnZXIgPSBzdG9yYWdlTWFuYWdlcjtcblxuICAgIC8vVE9ETzogdGhlc2Ugc2hvdWxkIGJlIHNhdmVkIGluIHBlcnNpc3RlbmNlIGVuZ2luZT9cbiAgICBfdGhpcy5fdXJsID0gcnVudGltZVVSTCArICcvc20nO1xuICAgIF90aGlzLl9vYmplY3RVUkwgPSBydW50aW1lVVJMICsgJy9vYmplY3QtYWxsb2NhdGlvbic7XG5cbiAgICBfdGhpcy5fcmVwb3J0ZXJzID0ge307XG4gICAgX3RoaXMuX29ic2VydmVycyA9IHt9O1xuXG4gICAgX3RoaXMuX3N0b3JlRGF0YU9iamVjdHMgPSBuZXcgU3RvcmVEYXRhT2JqZWN0cyhzdG9yYWdlTWFuYWdlcik7XG5cbiAgICAvL1RPRE86IHRoaXMgc2hvdWxkIG5vdCBiZSBoYXJkY29kZWQhXG4gICAgX3RoaXMuX2RvbWFpbiA9IGRpdmlkZVVSTChydW50aW1lVVJMKS5kb21haW47XG5cbiAgICBfdGhpcy5fbWYgPSBuZXcgTWVzc2FnZUZhY3RvcnkoZmFsc2UsIHt9KTtcblxuICAgIGlmIChhbGxvY2F0b3IpIHtcbiAgICAgIF90aGlzLl9hbGxvY2F0b3IgPSBhbGxvY2F0b3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzLl9hbGxvY2F0b3IgPSBuZXcgQWRkcmVzc0FsbG9jYXRpb24oX3RoaXMuX29iamVjdFVSTCwgYnVzLCBfdGhpcy5fcmVnaXN0cnkpO1xuICAgIH1cblxuICAgIGJ1cy5hZGRMaXN0ZW5lcihfdGhpcy5fdXJsLCAobXNnKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnU3luY2hlck1hbmFnZXItUkNWOiAnLCBtc2cpO1xuICAgICAgc3dpdGNoIChtc2cudHlwZSkge1xuICAgICAgICBjYXNlICdjcmVhdGUnOiBfdGhpcy5fb25DcmVhdGUobXNnKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2RlbGV0ZSc6IF90aGlzLl9vbkRlbGV0ZShtc2cpOyBicmVhaztcbiAgICAgICAgY2FzZSAnc3Vic2NyaWJlJzogX3RoaXMuX29uTG9jYWxTdWJzY3JpYmUobXNnKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3Vuc3Vic2NyaWJlJzogX3RoaXMuX29uTG9jYWxVblN1YnNjcmliZShtc2cpOyBicmVhaztcbiAgICAgIH1cbiAgICB9KTtcblxuICB9XG5cbiAgZ2V0IHVybCgpIHsgcmV0dXJuIHRoaXMuX3VybDsgfVxuXG4gIC8vRkxPVy1JTjogbWVzc2FnZSByZWNlaXZlZCBmcm9tIFN5bmNoZXIgLT4gY3JlYXRlXG4gIF9vbkNyZWF0ZShtc2cpIHtcblxuICAgIGlmIChtc2cuYm9keS5oYXNPd25Qcm9wZXJ0eSgncmVzdW1lJykgJiYgIW1zZy5ib2R5LnJlc3VtZSB8fCAhbXNnLmJvZHkucmVzdW1lKSB7XG4gICAgICB0aGlzLl9uZXdDcmVhdGUobXNnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc3RvcmVEYXRhT2JqZWN0cy5nZXRSZXNvdXJjZXNCeUNyaXRlcmlhKG1zZywgdHJ1ZSkudGhlbigocmVzdWx0KSA9PiB7XG5cbiAgICAgICAgY29uc29sZS5sb2coJ1tTeW5jaGVyTWFuYWdlciAtIENyZWF0ZV0gLSBmaWx0ZXIgcmVzdWx0JywgcmVzdWx0LCBtc2cpO1xuXG4gICAgICAgIGlmIChyZXN1bHQgJiYgT2JqZWN0LmtleXMocmVzdWx0KS5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgICAvLyBUT0RPOiBzaG91bGQgcmV1c2UgdGhlIHN0b3JhZ2VkIGluZm9ybWF0aW9uXG4gICAgICAgICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKChvYmpVUkwpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbU3luY2hlck1hbmFnZXIgLSByZXN1bWUgQ3JlYXRlXSAtIHJldXNlIGN1cnJlbnQgb2JqZWN0IHVybDogJywgcmVzdWx0W29ialVSTF0pO1xuICAgICAgICAgICAgdGhpcy5fcmVzdW1lQ3JlYXRlKG1zZywgcmVzdWx0W29ialVSTF0pO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9mb3J3YXJkIHRvIGh5cGVydHk6XG4gICAgICAgICAgbGV0IHJlcGx5ID0ge307XG4gICAgICAgICAgcmVwbHkuaWQgPSBtc2cuaWQ7XG4gICAgICAgICAgcmVwbHkuZnJvbSA9IG1zZy50bztcbiAgICAgICAgICByZXBseS50byA9IG1zZy5mcm9tO1xuICAgICAgICAgIHJlcGx5LnR5cGUgPSAncmVzcG9uc2UnO1xuICAgICAgICAgIHJlcGx5LmJvZHkgPSB7XG4gICAgICAgICAgICBjb2RlOiA0MDQsXG4gICAgICAgICAgICBkZXNjOiAnTm8gZGF0YSBvYmplY3RzIHRvIGJlIHJlc3VtZWQnXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLl9idXMucG9zdE1lc3NhZ2UocmVwbHkpO1xuICAgICAgICB9XG5cbiAgICAgIH0pO1xuICAgIH1cblxuICB9XG5cbiAgX25ld0NyZWF0ZShtc2cpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgbGV0IG93bmVyID0gbXNnLmZyb207XG4gICAgbGV0IGRvbWFpbiA9IGRpdmlkZVVSTChtc2cuZnJvbSkuZG9tYWluO1xuXG4gICAgaWYgKG1zZy5ib2R5LnJlc291cmNlKSB7XG4gICAgICBfdGhpcy5fYXV0aG9yaXNlKG1zZywgbXNnLmJvZHkucmVzb3VyY2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vZ2V0IHNjaGVtYSBmcm9tIGNhdGFsb2d1ZSBhbmQgcGFyc2UgLT4gKHNjaGVtZSwgY2hpbGRyZW4pXG4gICAgX3RoaXMuX2NhdGFsb2cuZ2V0RGF0YVNjaGVtYURlc2NyaXB0b3IobXNnLmJvZHkuc2NoZW1hKS50aGVuKChkZXNjcmlwdG9yKSA9PiB7XG5cbiAgICAgIGxldCBwcm9wZXJ0aWVzID0gZGVzY3JpcHRvci5zb3VyY2VQYWNrYWdlLnNvdXJjZUNvZGUucHJvcGVydGllcztcbiAgICAgIGxldCBzY2hlbWUgPSBwcm9wZXJ0aWVzLnNjaGVtZSA/IHByb3BlcnRpZXMuc2NoZW1lLmNvbnN0YW50IDogJ3Jlc291cmNlJztcbiAgICAgIGxldCBjaGlsZHJlbnMgPSBwcm9wZXJ0aWVzLmNoaWxkcmVuID8gcHJvcGVydGllcy5jaGlsZHJlbi5jb25zdGFudCA6IFtdO1xuXG4gICAgICAvLyBEbyBzY2hlbWEgdmFsaWRhdGlvblxuICAgICAgLy8gVE9ETzogY2hlY2sgaWYgaXMgbmVlZCB0byBoYW5kbGUgd2l0aCB0aGUgcmVzdWx0IG9mIHZhbGlkYXRpb25cbiAgICAgIHNjaGVtYVZhbGlkYXRpb24oc2NoZW1lLCBkZXNjcmlwdG9yLCBtc2cuYm9keS52YWx1ZSk7XG5cbiAgICAgIGxldCBvYmplY3RJbmZvID0ge1xuICAgICAgICBuYW1lOiBtc2cuYm9keS52YWx1ZS5uYW1lLFxuICAgICAgICBzY2hlbWE6IG1zZy5ib2R5LnZhbHVlLnNjaGVtYSxcbiAgICAgICAgcmVwb3J0ZXI6IG1zZy5ib2R5LnZhbHVlLnJlcG9ydGVyLFxuICAgICAgICByZXNvdXJjZXM6IG1zZy5ib2R5LnZhbHVlLnJlc291cmNlc1xuICAgICAgfTtcblxuICAgICAgLy8gc2hvdWxkIHJlc3VzZSBkYXRhIG9iamVjdCB1cmwgaWYgaXQgcGFzc2VkXG4gICAgICBsZXQgcmV1c2VEYXRhT2JqZWN0ID0gbXNnLmJvZHkudmFsdWUucmVzb3VyY2U7XG5cbiAgICAgIC8vcmVxdWVzdCBhZGRyZXNzIGFsbG9jYXRpb24gb2YgYSBuZXcgb2JqZWN0IGZyb20gdGhlIG1zZy1ub2RlXG4gICAgICBfdGhpcy5fYWxsb2NhdG9yLmNyZWF0ZShkb21haW4sIDEsIG9iamVjdEluZm8sIHNjaGVtZSwgcmV1c2VEYXRhT2JqZWN0KS50aGVuKChhbGxvY2F0ZWQpID0+IHtcbiAgICAgICAgbGV0IG9ialVSTCA9IGFsbG9jYXRlZC5hZGRyZXNzWzBdO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdBTExPQ0FUT1IgQ1JFQVRFOicsIGFsbG9jYXRlZCk7XG5cbiAgICAgICAgbGV0IHN1YnNjcmlwdGlvblVSTCA9IG9ialVSTCArICcvc3Vic2NyaXB0aW9uJztcblxuICAgICAgICBjb25zb2xlLmxvZygnU3Vic2NyaXB0aW9uIFVSTCcsIHN1YnNjcmlwdGlvblVSTCk7XG5cbiAgICAgICAgLy9UbyByZWdpc3RlciB0aGUgZGF0YU9iamVjdCBpbiB0aGUgcnVudGltZVJlZ2lzdHJ5XG4gICAgICAgIGNvbnNvbGUuaW5mbygnUmVnaXN0ZXIgT2JqZWN0OiAnLCBtc2cuYm9keS52YWx1ZS5uYW1lLCBtc2cuYm9keS52YWx1ZS5zY2hlbWEsIG9ialVSTCwgbXNnLmJvZHkudmFsdWUucmVwb3J0ZXIsIG1zZy5ib2R5LnZhbHVlLnJlc291cmNlcyk7XG4gICAgICAgIF90aGlzLl9yZWdpc3RyeS5yZWdpc3RlckRhdGFPYmplY3QobXNnLmJvZHkudmFsdWUubmFtZSwgbXNnLmJvZHkudmFsdWUuc2NoZW1hLCBvYmpVUkwsIG1zZy5ib2R5LnZhbHVlLnJlcG9ydGVyLCBtc2cuYm9keS52YWx1ZS5yZXNvdXJjZXMsIGFsbG9jYXRlZCwgbXNnLmJvZHkuYXV0aG9yaXNlKS50aGVuKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ0RhdGFPYmplY3Qgc3VjY2Vzc2Z1bGx5IHJlZ2lzdGVyZWQnLCByZXNvbHZlKTtcblxuICAgICAgICAgIC8vYWxsIE9LIC0+IGNyZWF0ZSByZXBvcnRlciBhbmQgcmVnaXN0ZXIgbGlzdGVuZXJzXG4gICAgICAgICAgbGV0IHJlcG9ydGVyO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLl9yZXBvcnRlcnNbb2JqVVJMXSkge1xuICAgICAgICAgICAgcmVwb3J0ZXIgPSBuZXcgUmVwb3J0ZXJPYmplY3QoX3RoaXMsIG93bmVyLCBvYmpVUkwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXBvcnRlciA9IHRoaXMuX3JlcG9ydGVyc1tvYmpVUkxdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnNvbGUubG9nKCdbU3luY2hlck1hbmFnZXIgLSBuZXcgQ3JlYXRlXSAtICcsIG1zZyk7XG5cbiAgICAgICAgICBpZiAobXNnLmJvZHkuaGFzT3duUHJvcGVydHkoJ3N0b3JlJykgJiYgbXNnLmJvZHkuc3RvcmUpIHtcbiAgICAgICAgICAgIC8vIFN0b3JlIGZvciBlYWNoIHJlcG9ydGVyIGh5cGVydHkgdGhlIGRhdGFPYmplY3RcbiAgICAgICAgICAgIGxldCB1c2VyVVJMO1xuICAgICAgICAgICAgaWYgKG1zZy5ib2R5Lmhhc093blByb3BlcnR5KCdpZGVudGl0eScpICYmIG1zZy5ib2R5LmlkZW50aXR5LnVzZXJQcm9maWxlLnVzZXJVUkwpIHtcbiAgICAgICAgICAgICAgdXNlclVSTCA9IG1zZy5ib2R5LmlkZW50aXR5LnVzZXJQcm9maWxlLnVzZXJVUkw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF90aGlzLl9zdG9yZURhdGFPYmplY3RzLnNldChvYmpVUkwsIHRydWUsIG1zZy5ib2R5LnNjaGVtYSwgJ29uJywgbXNnLmJvZHkudmFsdWUsIG93bmVyLCBudWxsLCBjaGlsZHJlbnMsIHVzZXJVUkwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlcG9ydGVyLmZvcndhcmRTdWJzY3JpYmUoW29ialVSTCwgc3Vic2NyaXB0aW9uVVJMXSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICByZXBvcnRlci5hZGRDaGlsZHJlbnMoY2hpbGRyZW5zKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydGVyc1tvYmpVUkxdID0gcmVwb3J0ZXI7XG5cbiAgICAgICAgICAgICAgLy9GTE9XLU9VVDogbWVzc2FnZSByZXNwb25zZSB0byBTeW5jaGVyIC0+IGNyZWF0ZVxuICAgICAgICAgICAgICBfdGhpcy5fYnVzLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBpZDogbXNnLmlkLCB0eXBlOiAncmVzcG9uc2UnLCBmcm9tOiBtc2cudG8sIHRvOiBvd25lcixcbiAgICAgICAgICAgICAgICBib2R5OiB7IGNvZGU6IDIwMCwgcmVzb3VyY2U6IG9ialVSTCwgY2hpbGRyZW5SZXNvdXJjZXM6IGNoaWxkcmVucyB9XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIC8vc2VuZCBjcmVhdGUgdG8gYWxsIG9ic2VydmVycywgcmVzcG9uc2VzIHdpbGwgYmUgZGVsaXZlciB0byB0aGUgSHlwZXJ0eSBvd25lcj9cbiAgICAgICAgICAgICAgLy9zY2hlZHVsZSBmb3IgbmV4dCBjeWNsZSBuZWVkZWQsIGJlY2F1c2UgdGhlIFJlcG9ydGVyIHNob3VsZCBiZSBhdmFpbGFibGUuXG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vd2lsbCBpbnZpdGUgb3RoZXIgaHlwZXJ0aWVzXG4gICAgICAgICAgICAgICAgX3RoaXMuX2F1dGhvcmlzZShtc2csIG9ialVSTCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIH0pO1xuXG4gICAgICB9KTtcbiAgICB9KS5jYXRjaCgocmVhc29uKSA9PiB7XG4gICAgICAvL0ZMT1ctT1VUOiBlcnJvciBtZXNzYWdlIHJlc3BvbnNlIHRvIFN5bmNoZXIgLT4gY3JlYXRlXG4gICAgICBsZXQgcmVzcG9uc2VNc2cgPSB7XG4gICAgICAgIGlkOiBtc2cuaWQsIHR5cGU6ICdyZXNwb25zZScsIGZyb206IG1zZy50bywgdG86IG93bmVyLFxuICAgICAgICBib2R5OiB7IGNvZGU6IDUwMCwgZGVzYzogcmVhc29uIH1cbiAgICAgIH07XG5cbiAgICAgIF90aGlzLl9idXMucG9zdE1lc3NhZ2UocmVzcG9uc2VNc2cpO1xuICAgIH0pO1xuXG4gIH1cblxuICBfcmVzdW1lQ3JlYXRlKG1zZywgc3RvcmVkT2JqZWN0KSB7XG5cbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgbGV0IG93bmVyID0gbXNnLmZyb207XG4gICAgbGV0IHNjaGVtYSA9IHN0b3JlZE9iamVjdC5zY2hlbWE7XG4gICAgbGV0IHJlc291cmNlID0gc3RvcmVkT2JqZWN0LnJlc291cmNlO1xuICAgIGxldCBpbml0aWFsRGF0YSA9IHN0b3JlZE9iamVjdC5kYXRhO1xuXG4gICAgY29uc29sZS5sb2coJ1tTeW5jaGVyTWFuYWdlcl0gLSByZXN1bWVDcmVhdGUnLCBtc2cpO1xuXG4gICAgbGV0IGF1dGhNc2cgPSBtc2c7XG4gICAgYXV0aE1zZy5ib2R5LmF1dGhvcmlzZSA9IHN0b3JlZE9iamVjdC5zdWJzY3JpcHRpb25zO1xuXG4gICAgLy8gLy8gVE9ETzogQ2hlY2sgd2h5IHRoZSBfYXV0aG9yaXNlIGlzIGNhbGxlZDtcbiAgICAvLyBpZiAocmVzb3VyY2UpIHtcbiAgICAvLyAgIF90aGlzLl9hdXRob3Jpc2UoYXV0aE1zZywgcmVzb3VyY2UpO1xuICAgIC8vICAgcmV0dXJuO1xuICAgIC8vIH1cblxuICAgIC8vZ2V0IHNjaGVtYSBmcm9tIGNhdGFsb2d1ZSBhbmQgcGFyc2UgLT4gKHNjaGVtZSwgY2hpbGRyZW4pXG4gICAgX3RoaXMuX2NhdGFsb2cuZ2V0RGF0YVNjaGVtYURlc2NyaXB0b3Ioc2NoZW1hKS50aGVuKChkZXNjcmlwdG9yKSA9PiB7XG5cbiAgICAgIGxldCBwcm9wZXJ0aWVzID0gZGVzY3JpcHRvci5zb3VyY2VQYWNrYWdlLnNvdXJjZUNvZGUucHJvcGVydGllcztcbiAgICAgIGxldCBzY2hlbWUgPSBwcm9wZXJ0aWVzLnNjaGVtZSA/IHByb3BlcnRpZXMuc2NoZW1lLmNvbnN0YW50IDogJ3Jlc291cmNlJztcbiAgICAgIGxldCBjaGlsZHJlbnMgPSBwcm9wZXJ0aWVzLmNoaWxkcmVuID8gcHJvcGVydGllcy5jaGlsZHJlbi5jb25zdGFudCA6IFtdO1xuXG4gICAgICAvLyBEbyBzY2hlbWEgdmFsaWRhdGlvblxuICAgICAgLy8gVE9ETzogY2hlY2sgaWYgaXMgbmVlZCB0byBoYW5kbGUgd2l0aCB0aGUgcmVzdWx0IG9mIHZhbGlkYXRpb25cbiAgICAgIHNjaGVtYVZhbGlkYXRpb24oc2NoZW1lLCBkZXNjcmlwdG9yLCBpbml0aWFsRGF0YSk7XG5cbiAgICAgIC8vYWxsIE9LIC0+IGNyZWF0ZSByZXBvcnRlciBhbmQgcmVnaXN0ZXIgbGlzdGVuZXJzXG4gICAgICBsZXQgcmVwb3J0ZXI7XG5cbiAgICAgIGlmICghdGhpcy5fcmVwb3J0ZXJzW3Jlc291cmNlXSkge1xuICAgICAgICByZXBvcnRlciA9IG5ldyBSZXBvcnRlck9iamVjdChfdGhpcywgb3duZXIsIHJlc291cmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcG9ydGVyID0gdGhpcy5fcmVwb3J0ZXJzW3Jlc291cmNlXTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuX3JlcG9ydGVyc1tyZXNvdXJjZV0gPSByZXBvcnRlcjtcblxuICAgICAgcmVwb3J0ZXIucmVzdW1lU3Vic2NyaXB0aW9ucyhzdG9yZWRPYmplY3Quc3Vic2NyaXB0aW9ucyk7XG5cbiAgICAgIC8vRkxPVy1PVVQ6IG1lc3NhZ2UgcmVzcG9uc2UgdG8gU3luY2hlciAtPiBjcmVhdGVcbiAgICAgIF90aGlzLl9idXMucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBpZDogbXNnLmlkLCB0eXBlOiAncmVzcG9uc2UnLCBmcm9tOiBtc2cudG8sIHRvOiBvd25lcixcbiAgICAgICAgYm9keTogeyBjb2RlOiAyMDAsIHJlc291cmNlOiByZXNvdXJjZSwgY2hpbGRyZW5SZXNvdXJjZXM6IGNoaWxkcmVucywgc2NoZW1hOiBzY2hlbWEsIHZhbHVlOiBzdG9yZWRPYmplY3QuZGF0YSB9XG4gICAgICB9KTtcblxuICAgICAgLy8gLy9zZW5kIGNyZWF0ZSB0byBhbGwgb2JzZXJ2ZXJzLCByZXNwb25zZXMgd2lsbCBiZSBkZWxpdmVyIHRvIHRoZSBIeXBlcnR5IG93bmVyP1xuICAgICAgLy8gLy9zY2hlZHVsZSBmb3IgbmV4dCBjeWNsZSBuZWVkZWQsIGJlY2F1c2UgdGhlIFJlcG9ydGVyIHNob3VsZCBiZSBhdmFpbGFibGUuXG4gICAgICAvLyBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIC8vICAgLy93aWxsIGludml0ZSBvdGhlciBoeXBlcnRpZXNcbiAgICAgIC8vICAgX3RoaXMuX2F1dGhvcmlzZShhdXRoTXNnLCByZXNvdXJjZSk7XG4gICAgICAvLyB9KTtcblxuICAgIH0pO1xuICB9XG5cbiAgX2F1dGhvcmlzZShtc2csIG9ialVSTCkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG4gICAgbGV0IG9ialN1YnNjcmlwdG9yVVJMID0gb2JqVVJMICsgJy9zdWJzY3JpcHRpb24nO1xuXG4gICAgbXNnLmJvZHkuYXV0aG9yaXNlLmZvckVhY2goKGh5cGVydHlVUkwpID0+IHtcbiAgICAgIC8vRkxPVy1PVVQ6IHNlbmQgaW52aXRlcyB0byBsaXN0IG9mIHJlbW90ZSBTeW5jaGVyIC0+IF9vblJlbW90ZUNyZWF0ZSAtPiBvbk5vdGlmaWNhdGlvblxuICAgICAgX3RoaXMuX2J1cy5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6ICdjcmVhdGUnLCBmcm9tOiBvYmpTdWJzY3JpcHRvclVSTCwgdG86IGh5cGVydHlVUkwsXG4gICAgICAgIGJvZHk6IHsgaWRlbnRpdHk6IG1zZy5ib2R5LmlkZW50aXR5LCBzb3VyY2U6IG1zZy5mcm9tLCB2YWx1ZTogbXNnLmJvZHkudmFsdWUsIHNjaGVtYTogbXNnLmJvZHkuc2NoZW1hIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLy9GTE9XLUlOOiBtZXNzYWdlIHJlY2VpdmVkIGZyb20gRGF0YU9iamVjdFJlcG9ydGVyIC0+IGRlbGV0ZVxuICBfb25EZWxldGUobXNnKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIGxldCBvYmpVUkwgPSBtc2cuYm9keS5yZXNvdXJjZTtcblxuICAgIGxldCBvYmplY3QgPSBfdGhpcy5fcmVwb3J0ZXJzW29ialVSTF07XG4gICAgaWYgKG9iamVjdCkge1xuICAgICAgLy9UT0RPOiBpcyB0aGVyZSBhbnkgcG9saWN5IHZlcmlmaWNhdGlvbiBiZWZvcmUgZGVsZXRlP1xuICAgICAgb2JqZWN0LmRlbGV0ZSgpO1xuXG4gICAgICB0aGlzLl9zdG9yZURhdGFPYmplY3RzLmRlbGV0ZVJlc291cmNlKG9ialVSTCk7XG5cbiAgICAgIC8vVE9ETzogdW5yZWdpc3RlciBvYmplY3Q/XG4gICAgICBfdGhpcy5fYnVzLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgaWQ6IG1zZy5pZCwgdHlwZTogJ3Jlc3BvbnNlJywgZnJvbTogbXNnLnRvLCB0bzogbXNnLmZyb20sXG4gICAgICAgIGJvZHk6IHsgY29kZTogMjAwIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vRkxPVy1JTjogbWVzc2FnZSByZWNlaXZlZCBmcm9tIGxvY2FsIFN5bmNoZXIgLT4gc3Vic2NyaWJlXG4gIF9vbkxvY2FsU3Vic2NyaWJlKG1zZykge1xuXG4gICAgdGhpcy5fc3RvcmVEYXRhT2JqZWN0cy5nZXRSZXNvdXJjZXNCeUNyaXRlcmlhKG1zZywgZmFsc2UpLnRoZW4oKHJlc3VsdCkgPT4ge1xuXG4gICAgICBjb25zb2xlLmxvZygnW1N5bmNoZXJNYW5hZ2VyIC0gU3Vic2NyaWJlXSAtIGZpbHRlciByZXN1bHQnLCByZXN1bHQpO1xuXG4gICAgICBpZiAocmVzdWx0ICYmIE9iamVjdC5rZXlzKHJlc3VsdCkubGVuZ3RoID4gMCkge1xuXG4gICAgICAgIC8vIFRPRE86IHNob3VsZCByZXVzZSB0aGUgc3RvcmFnZWQgaW5mb3JtYXRpb25cbiAgICAgICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKChvYmpVUkwpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnW1N5bmNoZXJNYW5hZ2VyIC0gcmVzdW1lIFN1YnNjcmliZV0gLSByZXVzZSBjdXJyZW50IG9iamVjdCB1cmw6ICcsIHJlc3VsdFtvYmpVUkxdKTtcbiAgICAgICAgICB0aGlzLl9yZXN1bWVTdWJzY3JpcHRpb24obXNnLCByZXN1bHRbb2JqVVJMXSk7XG4gICAgICAgIH0pO1xuXG4gICAgICB9IGVsc2UgaWYgKG1zZy5ib2R5LnNjaGVtYSAmJiBtc2cuYm9keS5yZXNvdXJjZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnW1N5bmNoZXJNYW5hZ2VyIC0gbmV3IFN1YnNjcmliZV0gLSAnLCBtc2cuYm9keS5zY2hlbWEsIG1zZy5ib2R5LnJlc291cmNlKTtcbiAgICAgICAgdGhpcy5fbmV3U3Vic2NyaXB0aW9uKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL2ZvcndhcmQgdG8gaHlwZXJ0eTpcbiAgICAgICAgbGV0IHJlcGx5ID0ge307XG4gICAgICAgIHJlcGx5LmlkID0gbXNnLmlkO1xuICAgICAgICByZXBseS5mcm9tID0gbXNnLnRvO1xuICAgICAgICByZXBseS50byA9IG1zZy5mcm9tO1xuICAgICAgICByZXBseS50eXBlID0gJ3Jlc3BvbnNlJztcbiAgICAgICAgcmVwbHkuYm9keSA9IHtcbiAgICAgICAgICBjb2RlOiA0MDQsXG4gICAgICAgICAgZGVzYzogJ05vIGRhdGEgb2JqZWN0cyB0byBiZSByZXN1bWVkJ1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9idXMucG9zdE1lc3NhZ2UocmVwbHkpO1xuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgfVxuXG4gIF9uZXdTdWJzY3JpcHRpb24obXNnKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIGxldCBvYmpVUkwgPSBtc2cuYm9keS5yZXNvdXJjZTtcblxuICAgIGxldCBoeXBlcnR5VVJMID0gbXNnLmZyb207XG4gICAgbGV0IGRvbWFpbiA9IGRpdmlkZVVSTChvYmpVUkwpLmRvbWFpbjtcbiAgICBsZXQgb2JqVVJMU3Vic2NyaXB0aW9uID0gb2JqVVJMICsgJy9zdWJzY3JpcHRpb24nO1xuXG4gICAgbGV0IGNoaWxkQmFzZVVSTCA9IG9ialVSTCArICcvY2hpbGRyZW4vJztcblxuICAgIC8vZ2V0IHNjaGVtYSBmcm9tIGNhdGFsb2d1ZSBhbmQgcGFyc2UgLT4gKGNoaWxkcmVuKVxuICAgIF90aGlzLl9jYXRhbG9nLmdldERhdGFTY2hlbWFEZXNjcmlwdG9yKG1zZy5ib2R5LnNjaGVtYSkudGhlbigoZGVzY3JpcHRvcikgPT4ge1xuICAgICAgbGV0IHByb3BlcnRpZXMgPSBkZXNjcmlwdG9yLnNvdXJjZVBhY2thZ2Uuc291cmNlQ29kZS5wcm9wZXJ0aWVzO1xuICAgICAgbGV0IGNoaWxkcmVucyA9IHByb3BlcnRpZXMuY2hpbGRyZW4gPyBwcm9wZXJ0aWVzLmNoaWxkcmVuLmNvbnN0YW50IDogW107XG5cbiAgICAgIC8vY2hpbGRyZW4gYWRkcmVzc2VzXG4gICAgICBsZXQgc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgc3Vic2NyaXB0aW9ucy5wdXNoKG9ialVSTCArICcvY2hhbmdlcycpO1xuICAgICAgY2hpbGRyZW5zLmZvckVhY2goKGNoaWxkKSA9PiBzdWJzY3JpcHRpb25zLnB1c2goY2hpbGRCYXNlVVJMICsgY2hpbGQpKTtcblxuICAgICAgLy9GTE9XLU9VVDogc3Vic2NyaWJlIG1lc3NhZ2UgdG8gdGhlIG1zZy1ub2RlLCByZWdpc3RlcmluZyBsaXN0ZW5lcnMgb24gdGhlIGJyb2tlclxuICAgICAgbGV0IG5vZGVTdWJzY3JpYmVNc2cgPSB7XG4gICAgICAgIHR5cGU6ICdzdWJzY3JpYmUnLCBmcm9tOiBfdGhpcy5fdXJsLCB0bzogJ2RvbWFpbjovL21zZy1ub2RlLicgKyBkb21haW4gKyAnL3NtJyxcbiAgICAgICAgYm9keTogeyBpZGVudGl0eTogbXNnLmJvZHkuaWRlbnRpdHksIHN1YnNjcmliZTogc3Vic2NyaXB0aW9ucywgc291cmNlOiBoeXBlcnR5VVJMIH1cbiAgICAgIH07XG5cbiAgICAgIC8vc3Vic2NyaWJlIGluIG1zZy1ub2RlXG4gICAgICBfdGhpcy5fYnVzLnBvc3RNZXNzYWdlKG5vZGVTdWJzY3JpYmVNc2csIChyZXBseSkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnbm9kZS1zdWJzY3JpYmUtcmVzcG9uc2Uob2JzZXJ2ZXIpOiAnLCByZXBseSk7XG4gICAgICAgIGlmIChyZXBseS5ib2R5LmNvZGUgPT09IDIwMCkge1xuXG4gICAgICAgICAgLy9GTE9XLU9VVDogcmVwbHkgd2l0aCBwcm92aXNpb25hbCByZXNwb25zZVxuICAgICAgICAgIF90aGlzLl9idXMucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgaWQ6IG1zZy5pZCwgdHlwZTogJ3Jlc3BvbnNlJywgZnJvbTogbXNnLnRvLCB0bzogaHlwZXJ0eVVSTCxcbiAgICAgICAgICAgIGJvZHk6IHsgY29kZTogMTAwLCBjaGlsZHJlblJlc291cmNlczogY2hpbGRyZW5zLCBzY2hlbWE6IG1zZy5ib2R5LnNjaGVtYSwgcmVzb3VyY2U6IG1zZy5ib2R5LnJlc291cmNlIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vRkxPVy1PVVQ6IHN1YnNjcmliZSBtZXNzYWdlIHRvIHJlbW90ZSBSZXBvcnRlck9iamVjdCAtPiBfb25SZW1vdGVTdWJzY3JpYmVcbiAgICAgICAgICBsZXQgb2JqU3Vic2NyaWJlTXNnID0ge1xuICAgICAgICAgICAgdHlwZTogJ3N1YnNjcmliZScsIGZyb206IF90aGlzLl91cmwsIHRvOiBvYmpVUkxTdWJzY3JpcHRpb24sXG4gICAgICAgICAgICBib2R5OiB7IGlkZW50aXR5OiBub2RlU3Vic2NyaWJlTXNnLmJvZHkuaWRlbnRpdHksIHN1YnNjcmliZXI6IGh5cGVydHlVUkwgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvL3N1YnNjcmliZSB0byByZXBvcnRlciBTTVxuICAgICAgICAgIF90aGlzLl9idXMucG9zdE1lc3NhZ2Uob2JqU3Vic2NyaWJlTXNnLCAocmVwbHkpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdyZXBvcnRlci1zdWJzY3JpYmUtcmVzcG9uc2UtbmV3OiAnLCByZXBseSk7XG4gICAgICAgICAgICBpZiAocmVwbHkuYm9keS5jb2RlID09PSAyMDApIHtcblxuICAgICAgICAgICAgICBsZXQgb2JzZXJ2ZXIgPSBfdGhpcy5fb2JzZXJ2ZXJzW29ialVSTF07XG4gICAgICAgICAgICAgIGlmICghb2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlciA9IG5ldyBPYnNlcnZlck9iamVjdChfdGhpcywgb2JqVVJMLCBjaGlsZHJlbnMpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9vYnNlcnZlcnNbb2JqVVJMXSA9IG9ic2VydmVyO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKG1zZy5ib2R5Lmhhc093blByb3BlcnR5KCdzdG9yZScpICYmIG1zZy5ib2R5LnN0b3JlKSB7XG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgZm9yIGVhY2ggcmVwb3J0ZXIgaHlwZXJ0eSB0aGUgZGF0YU9iamVjdFxuICAgICAgICAgICAgICAgIGxldCB1c2VyVVJMO1xuICAgICAgICAgICAgICAgIGlmIChtc2cuYm9keS5oYXNPd25Qcm9wZXJ0eSgnaWRlbnRpdHknKSAmJiBtc2cuYm9keS5pZGVudGl0eS51c2VyUHJvZmlsZS51c2VyVVJMKSB7XG4gICAgICAgICAgICAgICAgICB1c2VyVVJMID0gbXNnLmJvZHkuaWRlbnRpdHkudXNlclByb2ZpbGUudXNlclVSTDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfdGhpcy5fc3RvcmVEYXRhT2JqZWN0cy5zZXQob2JqVVJMLCBmYWxzZSwgbXNnLmJvZHkuc2NoZW1hLCAnb24nLCB7fSwgaHlwZXJ0eVVSTCwgbnVsbCwgY2hpbGRyZW5zLCB1c2VyVVJMKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vcmVnaXN0ZXIgbmV3IGh5cGVydHkgc3Vic2NyaXB0aW9uXG4gICAgICAgICAgICAgIG9ic2VydmVyLmFkZFN1YnNjcmlwdGlvbihoeXBlcnR5VVJMKTtcblxuICAgICAgICAgICAgICAvL2ZvcndhcmQgdG8gaHlwZXJ0eTpcbiAgICAgICAgICAgICAgcmVwbHkuaWQgPSBtc2cuaWQ7XG4gICAgICAgICAgICAgIHJlcGx5LmZyb20gPSBfdGhpcy5fdXJsO1xuICAgICAgICAgICAgICByZXBseS50byA9IGh5cGVydHlVUkw7XG4gICAgICAgICAgICAgIHJlcGx5LmJvZHkuc2NoZW1hID0gbXNnLmJvZHkuc2NoZW1hO1xuICAgICAgICAgICAgICByZXBseS5ib2R5LnJlc291cmNlID0gbXNnLmJvZHkucmVzb3VyY2U7XG5cbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tzdWJzY3JpYmVdIC0gbmV3IHN1YnNjcmlwdGlvbjogJywgbXNnLCByZXBseSwgb2JzZXJ2ZXIpO1xuXG4gICAgICAgICAgICAgIHRoaXMuX2J1cy5wb3N0TWVzc2FnZShyZXBseSk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vbGlzdGVuZXIgcmVqZWN0ZWRcbiAgICAgICAgICBfdGhpcy5fYnVzLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGlkOiBtc2cuaWQsIHR5cGU6ICdyZXNwb25zZScsIGZyb206IG1zZy50bywgdG86IGh5cGVydHlVUkwsXG4gICAgICAgICAgICBib2R5OiByZXBseS5ib2R5XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgfSk7XG5cbiAgfVxuXG4gIF9yZXN1bWVTdWJzY3JpcHRpb24obXNnLCBzdG9yZWRPYmplY3QpIHtcbiAgICBsZXQgb2JqVVJMID0gc3RvcmVkT2JqZWN0LnJlc291cmNlO1xuICAgIGxldCBzY2hlbWEgPSBzdG9yZWRPYmplY3Quc2NoZW1hO1xuXG4gICAgbGV0IGh5cGVydHlVUkwgPSBtc2cuZnJvbTtcbiAgICBsZXQgb2JqVVJMU3Vic2NyaXB0aW9uID0gb2JqVVJMICsgJy9zdWJzY3JpcHRpb24nO1xuXG4gICAgbGV0IGNoaWxkQmFzZVVSTCA9IG9ialVSTCArICcvY2hpbGRyZW4vJztcblxuICAgIGNvbnNvbGUubG9nKCdbU3luY2hlck1hbmFnZXIgUmV1c2VTdWJzY3JpcHRpb25dIC0gb2JqVVJMOiAnLCBvYmpVUkwsICcgLSBzY2hlbWE6Jywgc2NoZW1hKTtcblxuICAgIC8vZ2V0IHNjaGVtYSBmcm9tIGNhdGFsb2d1ZSBhbmQgcGFyc2UgLT4gKGNoaWxkcmVuKVxuICAgIHRoaXMuX2NhdGFsb2cuZ2V0RGF0YVNjaGVtYURlc2NyaXB0b3Ioc2NoZW1hKS50aGVuKChkZXNjcmlwdG9yKSA9PiB7XG4gICAgICBsZXQgcHJvcGVydGllcyA9IGRlc2NyaXB0b3Iuc291cmNlUGFja2FnZS5zb3VyY2VDb2RlLnByb3BlcnRpZXM7XG4gICAgICBsZXQgY2hpbGRyZW5zID0gcHJvcGVydGllcy5jaGlsZHJlbiA/IHByb3BlcnRpZXMuY2hpbGRyZW4uY29uc3RhbnQgOiBbXTtcblxuICAgICAgLy9jaGlsZHJlbiBhZGRyZXNzZXNcbiAgICAgIGxldCBzdWJzY3JpcHRpb25zID0gW107XG4gICAgICBzdWJzY3JpcHRpb25zLnB1c2gob2JqVVJMICsgJy9jaGFuZ2VzJyk7XG4gICAgICBjaGlsZHJlbnMuZm9yRWFjaCgoY2hpbGQpID0+IHN1YnNjcmlwdGlvbnMucHVzaChjaGlsZEJhc2VVUkwgKyBjaGlsZCkpO1xuXG4gICAgICAvL0ZMT1ctT1VUOiBzdWJzY3JpYmUgbWVzc2FnZSB0byByZW1vdGUgUmVwb3J0ZXJPYmplY3QgLT4gX29uUmVtb3RlU3Vic2NyaWJlXG4gICAgICBsZXQgb2JqU3Vic2NyaWJlTXNnID0ge1xuICAgICAgICB0eXBlOiAnc3Vic2NyaWJlJywgZnJvbTogdGhpcy5fdXJsLCB0bzogb2JqVVJMU3Vic2NyaXB0aW9uLFxuICAgICAgICBib2R5OiB7IHN1YnNjcmliZXI6IGh5cGVydHlVUkwgfVxuICAgICAgfTtcblxuICAgICAgLy9zdWJzY3JpYmUgdG8gcmVwb3J0ZXIgU01cbiAgICAgIHRoaXMuX2J1cy5wb3N0TWVzc2FnZShvYmpTdWJzY3JpYmVNc2csIChyZXBseSkgPT4ge1xuXG4gICAgICAgIGxldCBvYnNlcnZlciA9IHRoaXMuX29ic2VydmVyc1tvYmpVUkxdO1xuICAgICAgICBpZiAoIW9ic2VydmVyKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIgPSBuZXcgT2JzZXJ2ZXJPYmplY3QodGhpcywgb2JqVVJMLCBjaGlsZHJlbnMpO1xuICAgICAgICAgIHRoaXMuX29ic2VydmVyc1tvYmpVUkxdID0gb2JzZXJ2ZXI7XG4gICAgICAgIH1cblxuICAgICAgICAvL3JlZ2lzdGVyIG5ldyBoeXBlcnR5IHN1YnNjcmlwdGlvblxuICAgICAgICBvYnNlcnZlci5hZGRTdWJzY3JpcHRpb24oaHlwZXJ0eVVSTCk7XG5cbiAgICAgICAgLy9mb3J3YXJkIHRvIGh5cGVydHk6XG4gICAgICAgIGxldCByZXNwb25zZSA9IHtcbiAgICAgICAgICBpZDogbXNnLmlkLCBmcm9tOiB0aGlzLl91cmwsIHRvOiBoeXBlcnR5VVJMLCB0eXBlOiAncmVzcG9uc2UnLFxuICAgICAgICAgIGJvZHk6IHJlcGx5LmJvZHlcbiAgICAgICAgfTtcblxuICAgICAgICByZXNwb25zZS5ib2R5LnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgcmVzcG9uc2UuYm9keS5yZXNvdXJjZSA9IG9ialVSTDtcblxuICAgICAgICBjb25zb2xlLmxvZygnW3N1YnNjcmliZV0gLSByZXN1bWUgc3Vic2NyaXB0aW9uOiAnLCBtc2csIHJlcGx5LCByZXNwb25zZSwgb2JzZXJ2ZXIpO1xuXG4gICAgICAgIHRoaXMuX2J1cy5wb3N0TWVzc2FnZShyZXNwb25zZSk7XG5cbiAgICAgIH0pO1xuXG4gICAgfSk7XG4gIH1cblxuICAvL0ZMT1ctSU46IG1lc3NhZ2UgcmVjZWl2ZWQgZnJvbSBsb2NhbCBEYXRhT2JqZWN0T2JzZXJ2ZXIgLT4gdW5zdWJzY3JpYmVcbiAgX29uTG9jYWxVblN1YnNjcmliZShtc2cpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gICAgbGV0IGh5cGVydHlVUkwgPSBtc2cuZnJvbTtcbiAgICBsZXQgb2JqVVJMID0gbXNnLmJvZHkucmVzb3VyY2U7XG5cbiAgICBsZXQgb2JzZXJ2ZXIgPSBfdGhpcy5fb2JzZXJ2ZXJzW29ialVSTF07XG4gICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICAvL1RPRE86IGlzIHRoZXJlIGFueSBwb2xpY3kgdmVyaWZpY2F0aW9uIGJlZm9yZSBkZWxldGU/XG4gICAgICBvYnNlcnZlci5yZW1vdmVTdWJzY3JpcHRpb24oaHlwZXJ0eVVSTCk7XG5cbiAgICAgIC8vVE9ETzogZGVzdHJveSBvYmplY3QgaW4gdGhlIHJlZ2lzdHJ5P1xuICAgICAgX3RoaXMuX2J1cy5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGlkOiBtc2cuaWQsIHR5cGU6ICdyZXNwb25zZScsIGZyb206IG1zZy50bywgdG86IG1zZy5mcm9tLFxuICAgICAgICBib2R5OiB7IGNvZGU6IDIwMCB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fc3RvcmVEYXRhT2JqZWN0cy5kZWxldGUob2JqVVJMLCAnc3Vic2NyaXB0aW9ucycsIGh5cGVydHlVUkwpO1xuXG4gICAgICAvL1RPRE86IHJlbW92ZSBPYmplY3QgaWYgbm8gbW9yZSBzdWJzY3JpcHRpb24/XG4gICAgICAvL2RlbGV0ZSBfdGhpcy5fb2JzZXJ2ZXJzW29ialVSTF07XG4gICAgfVxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3luY2hlck1hbmFnZXI7XG4iLCJpbXBvcnQgdHY0IGZyb20gJy4vdHY0JztcblxuZXhwb3J0IGZ1bmN0aW9uIHNjaGVtYVZhbGlkYXRpb24oc2NoZW1lLCBkZXNjcmlwdG9yLCB2YWx1ZSkge1xuXG4gIGNvbnNvbGUubG9nKCdTY2hlbWU6ICcsIHNjaGVtZSk7XG5cbiAgLy8gc2NoZW1hIHZhbGlkYXRpb25cbiAgY29uc29sZS5sb2coJ1J1bm5pbmcgb2JqZWN0IHZhbGlkYXRpb24uLi4nKTtcbiAgdHJ5IHtcbiAgICBsZXQgb2JqID0gdmFsdWU7XG4gICAgbGV0IHNjaGVtYSA9IGRlc2NyaXB0b3Iuc291cmNlUGFja2FnZS5zb3VyY2VDb2RlO1xuXG4gICAgLy8gYWRkIHN1cHBvcnQgZm9yIHNjaGVtYSByZWZlcmVuY2luZyBpdHNlbGZcbiAgICB0djQuYWRkU2NoZW1hKHNjaGVtYS5pZCwgc2NoZW1hKTtcblxuICAgIC8vIHZhbGlkYXRlXG4gICAgbGV0IHJlc3VsdCA9IHR2NC52YWxpZGF0ZU11bHRpcGxlKG9iaiwgc2NoZW1hKTtcblxuICAgIC8vIGRlbGV0ZSBlcnJvciBzdGFja3MgdG8gaW1wcm92ZSBsb2dnaW5nXG4gICAgcmVzdWx0LmVycm9ycy5mb3JFYWNoKChlcnJvcikgPT4ge1xuICAgICAgZGVsZXRlIGVycm9yLnN0YWNrO1xuICAgIH0pO1xuXG4gICAgLy8gcHJpbnQgbW9yZSBkZXRhaWxzIGFib3V0IHZhbGlkYXRpb24gaWYgaXQgZmFpbHMgb3Igc2NoZW1hIGNvbnRhaW5zICRyZWZzXG4gICAgaWYgKCFyZXN1bHQudmFsaWQgfHwgKHJlc3VsdC5taXNzaW5nLmxlbmd0aCA+IDApKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ09iamVjdCB2YWxpZGF0aW9uICcgKyAocmVzdWx0LnZhbGlkID8gJ3N1Y2NlZWRlZCwgYnV0IHNjaGVtYSBjb250YWluZWQgcmVmZXJlbmNlczonIDogJ2ZhaWxlZDonKSwgSlNPTi5zdHJpbmdpZnkocmVzdWx0LCBudWxsLCAyKSk7XG4gICAgICBjb25zb2xlLmRlYnVnKCdPYmplY3Q6JywgSlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCAyKSwgJ1xcclxcblNjaGVtYTonLCBKU09OLnN0cmluZ2lmeShzY2hlbWEsIG51bGwsIDIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coJ09iamVjdCB2YWxpZGF0aW9uIHN1Y2NlZWRlZCcpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUud2FybignRXJyb3IgZHVyaW5nIG9iamVjdCB2YWxpZGF0aW9uOicsIGUpO1xuICB9XG5cbn1cbiIsIi8qXG4gQXV0aG9yOiBHZXJhaW50IEx1ZmYgYW5kIG90aGVyc1xuIFllYXI6IDIwMTNcblxuIFRoaXMgY29kZSBpcyByZWxlYXNlZCBpbnRvIHRoZSBcInB1YmxpYyBkb21haW5cIiBieSBpdHMgYXV0aG9yKHMpLiAgQW55Ym9keSBtYXkgdXNlLCBhbHRlciBhbmQgZGlzdHJpYnV0ZSB0aGUgY29kZSB3aXRob3V0IHJlc3RyaWN0aW9uLiAgVGhlIGF1dGhvciBtYWtlcyBubyBndWFyYW50ZWVzLCBhbmQgdGFrZXMgbm8gbGlhYmlsaXR5IG9mIGFueSBraW5kIGZvciB1c2Ugb2YgdGhpcyBjb2RlLlxuXG4gSWYgeW91IGZpbmQgYSBidWcgb3IgbWFrZSBhbiBpbXByb3ZlbWVudCwgaXQgd291bGQgYmUgY291cnRlb3VzIHRvIGxldCB0aGUgYXV0aG9yIGtub3csIGJ1dCBpdCBpcyBub3QgY29tcHVsc29yeS5cbiAqL1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2tleXM/cmVkaXJlY3Rsb2NhbGU9ZW4tVVMmcmVkaXJlY3RzbHVnPUphdmFTY3JpcHQlMkZSZWZlcmVuY2UlMkZHbG9iYWxfT2JqZWN0cyUyRk9iamVjdCUyRmtleXNcbmlmICghT2JqZWN0LmtleXMpIHtcbiAgICBPYmplY3Qua2V5cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICAgICAgICBoYXNEb250RW51bUJ1ZyA9ICEoe3RvU3RyaW5nOiBudWxsfSkucHJvcGVydHlJc0VudW1lcmFibGUoJ3RvU3RyaW5nJyksXG4gICAgICAgICAgICBkb250RW51bXMgPSBbXG4gICAgICAgICAgICAgICAgJ3RvU3RyaW5nJyxcbiAgICAgICAgICAgICAgICAndG9Mb2NhbGVTdHJpbmcnLFxuICAgICAgICAgICAgICAgICd2YWx1ZU9mJyxcbiAgICAgICAgICAgICAgICAnaGFzT3duUHJvcGVydHknLFxuICAgICAgICAgICAgICAgICdpc1Byb3RvdHlwZU9mJyxcbiAgICAgICAgICAgICAgICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAgICAgICAgICAgICAgICdjb25zdHJ1Y3RvcidcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBkb250RW51bXNMZW5ndGggPSBkb250RW51bXMubGVuZ3RoO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iaiAhPT0gJ2Z1bmN0aW9uJyB8fCBvYmogPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Qua2V5cyBjYWxsZWQgb24gbm9uLW9iamVjdCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoYXNEb250RW51bUJ1Zykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9udEVudW1zTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqLCBkb250RW51bXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChkb250RW51bXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9KSgpO1xufVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2NyZWF0ZVxuaWYgKCFPYmplY3QuY3JlYXRlKSB7XG4gICAgT2JqZWN0LmNyZWF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEYoKSB7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPYmplY3QuY3JlYXRlIGltcGxlbWVudGF0aW9uIG9ubHkgYWNjZXB0cyBvbmUgcGFyYW1ldGVyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBvO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGKCk7XG4gICAgICAgIH07XG4gICAgfSkoKTtcbn1cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2lzQXJyYXk/cmVkaXJlY3Rsb2NhbGU9ZW4tVVMmcmVkaXJlY3RzbHVnPUphdmFTY3JpcHQlMkZSZWZlcmVuY2UlMkZHbG9iYWxfT2JqZWN0cyUyRkFycmF5JTJGaXNBcnJheVxuaWYgKCFBcnJheS5pc0FycmF5KSB7XG4gICAgQXJyYXkuaXNBcnJheSA9IGZ1bmN0aW9uICh2QXJnKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodkFyZykgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgICB9O1xufVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaW5kZXhPZj9yZWRpcmVjdGxvY2FsZT1lbi1VUyZyZWRpcmVjdHNsdWc9SmF2YVNjcmlwdCUyRlJlZmVyZW5jZSUyRkdsb2JhbF9PYmplY3RzJTJGQXJyYXklMkZpbmRleE9mXG5pZiAoIUFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ICovKSB7XG4gICAgICAgIGlmICh0aGlzID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XG4gICAgICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG4gPSAwO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIG4gPSBOdW1iZXIoYXJndW1lbnRzWzFdKTtcbiAgICAgICAgICAgIGlmIChuICE9PSBuKSB7IC8vIHNob3J0Y3V0IGZvciB2ZXJpZnlpbmcgaWYgaXQncyBOYU5cbiAgICAgICAgICAgICAgICBuID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobiAhPT0gMCAmJiBuICE9PSBJbmZpbml0eSAmJiBuICE9PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICBuID0gKG4gPiAwIHx8IC0xKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMobikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuID49IGxlbikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrID0gbiA+PSAwID8gbiA6IE1hdGgubWF4KGxlbiAtIE1hdGguYWJzKG4pLCAwKTtcbiAgICAgICAgZm9yICg7IGsgPCBsZW47IGsrKykge1xuICAgICAgICAgICAgaWYgKGsgaW4gdCAmJiB0W2tdID09PSBzZWFyY2hFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG59XG5cbi8vIEdydW5nZXkgT2JqZWN0LmlzRnJvemVuIGhhY2tcbmlmICghT2JqZWN0LmlzRnJvemVuKSB7XG4gICAgT2JqZWN0LmlzRnJvemVuID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIga2V5ID0gXCJ0djRfdGVzdF9mcm96ZW5fa2V5XCI7XG4gICAgICAgIHdoaWxlIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAga2V5ICs9IE1hdGgucmFuZG9tKCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9ialtrZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLy8gQmFzZWQgb246IGh0dHBzOi8vZ2l0aHViLmNvbS9nZXJhaW50bHVmZi91cmktdGVtcGxhdGVzLCBidXQgd2l0aCBhbGwgdGhlIGRlLXN1YnN0aXR1dGlvbiBzdHVmZiByZW1vdmVkXG5cbnZhciB1cmlUZW1wbGF0ZUdsb2JhbE1vZGlmaWVycyA9IHtcbiAgICBcIitcIjogdHJ1ZSxcbiAgICBcIiNcIjogdHJ1ZSxcbiAgICBcIi5cIjogdHJ1ZSxcbiAgICBcIi9cIjogdHJ1ZSxcbiAgICBcIjtcIjogdHJ1ZSxcbiAgICBcIj9cIjogdHJ1ZSxcbiAgICBcIiZcIjogdHJ1ZVxufTtcbnZhciB1cmlUZW1wbGF0ZVN1ZmZpY2VzID0ge1xuICAgIFwiKlwiOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBub3RSZWFsbHlQZXJjZW50RW5jb2RlKHN0cmluZykge1xuICAgIHJldHVybiBlbmNvZGVVUkkoc3RyaW5nKS5yZXBsYWNlKC8lMjVbMC05XVswLTldL2csIGZ1bmN0aW9uIChkb3VibGVFbmNvZGVkKSB7XG4gICAgICAgIHJldHVybiBcIiVcIiArIGRvdWJsZUVuY29kZWQuc3Vic3RyaW5nKDMpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiB1cmlUZW1wbGF0ZVN1YnN0aXR1dGlvbihzcGVjKSB7XG4gICAgdmFyIG1vZGlmaWVyID0gXCJcIjtcbiAgICBpZiAodXJpVGVtcGxhdGVHbG9iYWxNb2RpZmllcnNbc3BlYy5jaGFyQXQoMCldKSB7XG4gICAgICAgIG1vZGlmaWVyID0gc3BlYy5jaGFyQXQoMCk7XG4gICAgICAgIHNwZWMgPSBzcGVjLnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgdmFyIHNlcGFyYXRvciA9IFwiXCI7XG4gICAgdmFyIHByZWZpeCA9IFwiXCI7XG4gICAgdmFyIHNob3VsZEVzY2FwZSA9IHRydWU7XG4gICAgdmFyIHNob3dWYXJpYWJsZXMgPSBmYWxzZTtcbiAgICB2YXIgdHJpbUVtcHR5U3RyaW5nID0gZmFsc2U7XG4gICAgaWYgKG1vZGlmaWVyID09PSAnKycpIHtcbiAgICAgICAgc2hvdWxkRXNjYXBlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChtb2RpZmllciA9PT0gXCIuXCIpIHtcbiAgICAgICAgcHJlZml4ID0gXCIuXCI7XG4gICAgICAgIHNlcGFyYXRvciA9IFwiLlwiO1xuICAgIH0gZWxzZSBpZiAobW9kaWZpZXIgPT09IFwiL1wiKSB7XG4gICAgICAgIHByZWZpeCA9IFwiL1wiO1xuICAgICAgICBzZXBhcmF0b3IgPSBcIi9cIjtcbiAgICB9IGVsc2UgaWYgKG1vZGlmaWVyID09PSAnIycpIHtcbiAgICAgICAgcHJlZml4ID0gXCIjXCI7XG4gICAgICAgIHNob3VsZEVzY2FwZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAobW9kaWZpZXIgPT09ICc7Jykge1xuICAgICAgICBwcmVmaXggPSBcIjtcIjtcbiAgICAgICAgc2VwYXJhdG9yID0gXCI7XCI7XG4gICAgICAgIHNob3dWYXJpYWJsZXMgPSB0cnVlO1xuICAgICAgICB0cmltRW1wdHlTdHJpbmcgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAobW9kaWZpZXIgPT09ICc/Jykge1xuICAgICAgICBwcmVmaXggPSBcIj9cIjtcbiAgICAgICAgc2VwYXJhdG9yID0gXCImXCI7XG4gICAgICAgIHNob3dWYXJpYWJsZXMgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAobW9kaWZpZXIgPT09ICcmJykge1xuICAgICAgICBwcmVmaXggPSBcIiZcIjtcbiAgICAgICAgc2VwYXJhdG9yID0gXCImXCI7XG4gICAgICAgIHNob3dWYXJpYWJsZXMgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciB2YXJOYW1lcyA9IFtdO1xuICAgIHZhciB2YXJMaXN0ID0gc3BlYy5zcGxpdChcIixcIik7XG4gICAgdmFyIHZhclNwZWNzID0gW107XG4gICAgdmFyIHZhclNwZWNNYXAgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhckxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhck5hbWUgPSB2YXJMaXN0W2ldO1xuICAgICAgICB2YXIgdHJ1bmNhdGUgPSBudWxsO1xuICAgICAgICBpZiAodmFyTmFtZS5pbmRleE9mKFwiOlwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IHZhck5hbWUuc3BsaXQoXCI6XCIpO1xuICAgICAgICAgICAgdmFyTmFtZSA9IHBhcnRzWzBdO1xuICAgICAgICAgICAgdHJ1bmNhdGUgPSBwYXJzZUludChwYXJ0c1sxXSwgMTApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdWZmaWNlcyA9IHt9O1xuICAgICAgICB3aGlsZSAodXJpVGVtcGxhdGVTdWZmaWNlc1t2YXJOYW1lLmNoYXJBdCh2YXJOYW1lLmxlbmd0aCAtIDEpXSkge1xuICAgICAgICAgICAgc3VmZmljZXNbdmFyTmFtZS5jaGFyQXQodmFyTmFtZS5sZW5ndGggLSAxKV0gPSB0cnVlO1xuICAgICAgICAgICAgdmFyTmFtZSA9IHZhck5hbWUuc3Vic3RyaW5nKDAsIHZhck5hbWUubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhclNwZWMgPSB7XG4gICAgICAgICAgICB0cnVuY2F0ZTogdHJ1bmNhdGUsXG4gICAgICAgICAgICBuYW1lOiB2YXJOYW1lLFxuICAgICAgICAgICAgc3VmZmljZXM6IHN1ZmZpY2VzXG4gICAgICAgIH07XG4gICAgICAgIHZhclNwZWNzLnB1c2godmFyU3BlYyk7XG4gICAgICAgIHZhclNwZWNNYXBbdmFyTmFtZV0gPSB2YXJTcGVjO1xuICAgICAgICB2YXJOYW1lcy5wdXNoKHZhck5hbWUpO1xuICAgIH1cbiAgICB2YXIgc3ViRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsdWVGdW5jdGlvbikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhclNwZWNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmFyU3BlYyA9IHZhclNwZWNzW2ldO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVGdW5jdGlvbih2YXJTcGVjLm5hbWUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkgfHwgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4Kys7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PT0gc3RhcnRJbmRleCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBwcmVmaXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAoc2VwYXJhdG9yIHx8IFwiLFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmIChzaG93VmFyaWFibGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB2YXJTcGVjLm5hbWUgKyBcIj1cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB2YXJTcGVjLnN1ZmZpY2VzWycqJ10gPyAoc2VwYXJhdG9yIHx8IFwiLFwiKSA6IFwiLFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhclNwZWMuc3VmZmljZXNbJyonXSAmJiBzaG93VmFyaWFibGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHZhclNwZWMubmFtZSArIFwiPVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzaG91bGRFc2NhcGUgPyBlbmNvZGVVUklDb21wb25lbnQodmFsdWVbal0pLnJlcGxhY2UoLyEvZywgXCIlMjFcIikgOiBub3RSZWFsbHlQZXJjZW50RW5jb2RlKHZhbHVlW2pdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGlmIChzaG93VmFyaWFibGVzICYmICF2YXJTcGVjLnN1ZmZpY2VzWycqJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHZhclNwZWMubmFtZSArIFwiPVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdmFyU3BlYy5zdWZmaWNlc1snKiddID8gKHNlcGFyYXRvciB8fCBcIixcIikgOiBcIixcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gc2hvdWxkRXNjYXBlID8gZW5jb2RlVVJJQ29tcG9uZW50KGtleSkucmVwbGFjZSgvIS9nLCBcIiUyMVwiKSA6IG5vdFJlYWxseVBlcmNlbnRFbmNvZGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHZhclNwZWMuc3VmZmljZXNbJyonXSA/ICc9JyA6IFwiLFwiO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gc2hvdWxkRXNjYXBlID8gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlW2tleV0pLnJlcGxhY2UoLyEvZywgXCIlMjFcIikgOiBub3RSZWFsbHlQZXJjZW50RW5jb2RlKHZhbHVlW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHNob3dWYXJpYWJsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHZhclNwZWMubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0cmltRW1wdHlTdHJpbmcgfHwgdmFsdWUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIj1cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFyU3BlYy50cnVuY2F0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDAsIHZhclNwZWMudHJ1bmNhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc2hvdWxkRXNjYXBlID8gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKS5yZXBsYWNlKC8hL2csIFwiJTIxXCIpIDogbm90UmVhbGx5UGVyY2VudEVuY29kZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHN1YkZ1bmN0aW9uLnZhck5hbWVzID0gdmFyTmFtZXM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgIHN1YnN0aXR1dGlvbjogc3ViRnVuY3Rpb25cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBVcmlUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVcmlUZW1wbGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVcmlUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgfVxuICAgIHZhciBwYXJ0cyA9IHRlbXBsYXRlLnNwbGl0KFwie1wiKTtcbiAgICB2YXIgdGV4dFBhcnRzID0gW3BhcnRzLnNoaWZ0KCldO1xuICAgIHZhciBwcmVmaXhlcyA9IFtdO1xuICAgIHZhciBzdWJzdGl0dXRpb25zID0gW107XG4gICAgdmFyIHZhck5hbWVzID0gW107XG4gICAgd2hpbGUgKHBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHBhcnQgPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICB2YXIgc3BlYyA9IHBhcnQuc3BsaXQoXCJ9XCIpWzBdO1xuICAgICAgICB2YXIgcmVtYWluZGVyID0gcGFydC5zdWJzdHJpbmcoc3BlYy5sZW5ndGggKyAxKTtcbiAgICAgICAgdmFyIGZ1bmNzID0gdXJpVGVtcGxhdGVTdWJzdGl0dXRpb24oc3BlYyk7XG4gICAgICAgIHN1YnN0aXR1dGlvbnMucHVzaChmdW5jcy5zdWJzdGl0dXRpb24pO1xuICAgICAgICBwcmVmaXhlcy5wdXNoKGZ1bmNzLnByZWZpeCk7XG4gICAgICAgIHRleHRQYXJ0cy5wdXNoKHJlbWFpbmRlcik7XG4gICAgICAgIHZhck5hbWVzID0gdmFyTmFtZXMuY29uY2F0KGZ1bmNzLnN1YnN0aXR1dGlvbi52YXJOYW1lcyk7XG4gICAgfVxuICAgIHRoaXMuZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZUZ1bmN0aW9uKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0ZXh0UGFydHNbMF07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic3RpdHV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN1YnN0aXR1dGlvbiA9IHN1YnN0aXR1dGlvbnNbaV07XG4gICAgICAgICAgICByZXN1bHQgKz0gc3Vic3RpdHV0aW9uKHZhbHVlRnVuY3Rpb24pO1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRleHRQYXJ0c1tpICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHRoaXMudmFyTmFtZXMgPSB2YXJOYW1lcztcbiAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG59XG5cblVyaVRlbXBsYXRlLnByb3RvdHlwZSA9IHtcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZTtcbiAgICB9LFxuICAgIGZpbGxGcm9tT2JqZWN0OiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbGwoZnVuY3Rpb24gKHZhck5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmpbdmFyTmFtZV07XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG52YXIgVmFsaWRhdG9yQ29udGV4dCA9IGZ1bmN0aW9uIFZhbGlkYXRvckNvbnRleHQocGFyZW50LCBjb2xsZWN0TXVsdGlwbGUsIGVycm9yUmVwb3J0ZXIsIGNoZWNrUmVjdXJzaXZlLCB0cmFja1Vua25vd25Qcm9wZXJ0aWVzKSB7XG4gICAgdGhpcy5taXNzaW5nID0gW107XG4gICAgdGhpcy5taXNzaW5nTWFwID0ge307XG4gICAgdGhpcy5mb3JtYXRWYWxpZGF0b3JzID0gcGFyZW50ID8gT2JqZWN0LmNyZWF0ZShwYXJlbnQuZm9ybWF0VmFsaWRhdG9ycykgOiB7fTtcbiAgICB0aGlzLnNjaGVtYXMgPSBwYXJlbnQgPyBPYmplY3QuY3JlYXRlKHBhcmVudC5zY2hlbWFzKSA6IHt9O1xuICAgIHRoaXMuY29sbGVjdE11bHRpcGxlID0gY29sbGVjdE11bHRpcGxlO1xuICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgdGhpcy5oYW5kbGVFcnJvciA9IGNvbGxlY3RNdWx0aXBsZSA/IHRoaXMuY29sbGVjdEVycm9yIDogdGhpcy5yZXR1cm5FcnJvcjtcbiAgICBpZiAoY2hlY2tSZWN1cnNpdmUpIHtcbiAgICAgICAgdGhpcy5jaGVja1JlY3Vyc2l2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuc2Nhbm5lZCA9IFtdO1xuICAgICAgICB0aGlzLnNjYW5uZWRGcm96ZW4gPSBbXTtcbiAgICAgICAgdGhpcy5zY2FubmVkRnJvemVuU2NoZW1hcyA9IFtdO1xuICAgICAgICB0aGlzLnNjYW5uZWRGcm96ZW5WYWxpZGF0aW9uRXJyb3JzID0gW107XG4gICAgICAgIHRoaXMudmFsaWRhdGVkU2NoZW1hc0tleSA9ICd0djRfdmFsaWRhdGlvbl9pZCc7XG4gICAgICAgIHRoaXMudmFsaWRhdGlvbkVycm9yc0tleSA9ICd0djRfdmFsaWRhdGlvbl9lcnJvcnNfaWQnO1xuICAgIH1cbiAgICBpZiAodHJhY2tVbmtub3duUHJvcGVydGllcykge1xuICAgICAgICB0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMgPSB0cnVlO1xuICAgICAgICB0aGlzLmtub3duUHJvcGVydHlQYXRocyA9IHt9O1xuICAgICAgICB0aGlzLnVua25vd25Qcm9wZXJ0eVBhdGhzID0ge307XG4gICAgfVxuICAgIHRoaXMuZXJyb3JSZXBvcnRlciA9IGVycm9yUmVwb3J0ZXIgfHwgZGVmYXVsdEVycm9yUmVwb3J0ZXIoJ2VuJyk7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmVycm9yUmVwb3J0ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGVidWcnKTtcbiAgICB9XG4gICAgdGhpcy5kZWZpbmVkS2V5d29yZHMgPSB7fTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBwYXJlbnQuZGVmaW5lZEtleXdvcmRzKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmluZWRLZXl3b3Jkc1trZXldID0gcGFyZW50LmRlZmluZWRLZXl3b3Jkc1trZXldLnNsaWNlKDApO1xuICAgICAgICB9XG4gICAgfVxufTtcblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLmRlZmluZUtleXdvcmQgPSBmdW5jdGlvbiAoa2V5d29yZCwga2V5d29yZEZ1bmN0aW9uKSB7XG4gICAgdGhpcy5kZWZpbmVkS2V5d29yZHNba2V5d29yZF0gPSB0aGlzLmRlZmluZWRLZXl3b3Jkc1trZXl3b3JkXSB8fCBbXTtcbiAgICB0aGlzLmRlZmluZWRLZXl3b3Jkc1trZXl3b3JkXS5wdXNoKGtleXdvcmRGdW5jdGlvbik7XG59O1xuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlRXJyb3IgPSBmdW5jdGlvbiAoY29kZSwgbWVzc2FnZVBhcmFtcywgZGF0YVBhdGgsIHNjaGVtYVBhdGgsIHN1YkVycm9ycywgZGF0YSwgc2NoZW1hKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IFZhbGlkYXRpb25FcnJvcihjb2RlLCBtZXNzYWdlUGFyYW1zLCBkYXRhUGF0aCwgc2NoZW1hUGF0aCwgc3ViRXJyb3JzKTtcbiAgICBlcnJvci5tZXNzYWdlID0gdGhpcy5lcnJvclJlcG9ydGVyKGVycm9yLCBkYXRhLCBzY2hlbWEpO1xuICAgIHJldHVybiBlcnJvcjtcbn07XG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS5yZXR1cm5FcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHJldHVybiBlcnJvcjtcbn07XG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS5jb2xsZWN0RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5lcnJvcnMucHVzaChlcnJvcik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnByZWZpeEVycm9ycyA9IGZ1bmN0aW9uIChzdGFydEluZGV4LCBkYXRhUGF0aCwgc2NoZW1hUGF0aCkge1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgdGhpcy5lcnJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5lcnJvcnNbaV0gPSB0aGlzLmVycm9yc1tpXS5wcmVmaXhXaXRoKGRhdGFQYXRoLCBzY2hlbWFQYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUuYmFuVW5rbm93blByb3BlcnRpZXMgPSBmdW5jdGlvbiAoZGF0YSwgc2NoZW1hKSB7XG4gICAgZm9yICh2YXIgdW5rbm93blBhdGggaW4gdGhpcy51bmtub3duUHJvcGVydHlQYXRocykge1xuICAgICAgICB2YXIgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuVU5LTk9XTl9QUk9QRVJUWSwge3BhdGg6IHVua25vd25QYXRofSwgdW5rbm93blBhdGgsIFwiXCIsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLmFkZEZvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXQsIHZhbGlkYXRvcikge1xuICAgIGlmICh0eXBlb2YgZm9ybWF0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZm9ybWF0KSB7XG4gICAgICAgICAgICB0aGlzLmFkZEZvcm1hdChrZXksIGZvcm1hdFtrZXldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5mb3JtYXRWYWxpZGF0b3JzW2Zvcm1hdF0gPSB2YWxpZGF0b3I7XG59O1xuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUucmVzb2x2ZVJlZnMgPSBmdW5jdGlvbiAoc2NoZW1hLCB1cmxIaXN0b3J5KSB7XG4gICAgaWYgKHNjaGVtYVsnJHJlZiddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXJsSGlzdG9yeSA9IHVybEhpc3RvcnkgfHwge307XG4gICAgICAgIGlmICh1cmxIaXN0b3J5W3NjaGVtYVsnJHJlZiddXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5DSVJDVUxBUl9SRUZFUkVOQ0UsIHt1cmxzOiBPYmplY3Qua2V5cyh1cmxIaXN0b3J5KS5qb2luKCcsICcpfSwgJycsICcnLCBudWxsLCB1bmRlZmluZWQsIHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgdXJsSGlzdG9yeVtzY2hlbWFbJyRyZWYnXV0gPSB0cnVlO1xuICAgICAgICBzY2hlbWEgPSB0aGlzLmdldFNjaGVtYShzY2hlbWFbJyRyZWYnXSwgdXJsSGlzdG9yeSk7XG4gICAgfVxuICAgIHJldHVybiBzY2hlbWE7XG59O1xuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUuZ2V0U2NoZW1hID0gZnVuY3Rpb24gKHVybCwgdXJsSGlzdG9yeSkge1xuICAgIHZhciBzY2hlbWE7XG4gICAgaWYgKHRoaXMuc2NoZW1hc1t1cmxdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2NoZW1hID0gdGhpcy5zY2hlbWFzW3VybF07XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVSZWZzKHNjaGVtYSwgdXJsSGlzdG9yeSk7XG4gICAgfVxuICAgIHZhciBiYXNlVXJsID0gdXJsO1xuICAgIHZhciBmcmFnbWVudCA9IFwiXCI7XG4gICAgaWYgKHVybC5pbmRleE9mKCcjJykgIT09IC0xKSB7XG4gICAgICAgIGZyYWdtZW50ID0gdXJsLnN1YnN0cmluZyh1cmwuaW5kZXhPZihcIiNcIikgKyAxKTtcbiAgICAgICAgYmFzZVVybCA9IHVybC5zdWJzdHJpbmcoMCwgdXJsLmluZGV4T2YoXCIjXCIpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLnNjaGVtYXNbYmFzZVVybF0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHNjaGVtYSA9IHRoaXMuc2NoZW1hc1tiYXNlVXJsXTtcbiAgICAgICAgdmFyIHBvaW50ZXJQYXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGZyYWdtZW50KTtcbiAgICAgICAgaWYgKHBvaW50ZXJQYXRoID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlUmVmcyhzY2hlbWEsIHVybEhpc3RvcnkpO1xuICAgICAgICB9IGVsc2UgaWYgKHBvaW50ZXJQYXRoLmNoYXJBdCgwKSAhPT0gXCIvXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcnRzID0gcG9pbnRlclBhdGguc3BsaXQoXCIvXCIpLnNsaWNlKDEpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gcGFydHNbaV0ucmVwbGFjZSgvfjEvZywgXCIvXCIpLnJlcGxhY2UoL34wL2csIFwiflwiKTtcbiAgICAgICAgICAgIGlmIChzY2hlbWFbY29tcG9uZW50XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2NoZW1hID0gc2NoZW1hW2NvbXBvbmVudF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlUmVmcyhzY2hlbWEsIHVybEhpc3RvcnkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLm1pc3NpbmdbYmFzZVVybF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLm1pc3NpbmcucHVzaChiYXNlVXJsKTtcbiAgICAgICAgdGhpcy5taXNzaW5nW2Jhc2VVcmxdID0gYmFzZVVybDtcbiAgICAgICAgdGhpcy5taXNzaW5nTWFwW2Jhc2VVcmxdID0gYmFzZVVybDtcbiAgICB9XG59O1xuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUuc2VhcmNoU2NoZW1hcyA9IGZ1bmN0aW9uIChzY2hlbWEsIHVybCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzY2hlbWEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoU2NoZW1hcyhzY2hlbWFbaV0sIHVybCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLmlkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoaXNUcnVzdGVkVXJsKHVybCwgc2NoZW1hLmlkKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjaGVtYXNbc2NoZW1hLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NoZW1hc1tzY2hlbWEuaWRdID0gc2NoZW1hO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSBcImVudW1cIikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hW2tleV0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hTY2hlbWFzKHNjaGVtYVtrZXldLCB1cmwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIiRyZWZcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXJpID0gZ2V0RG9jdW1lbnRVcmkoc2NoZW1hW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXJpICYmIHRoaXMuc2NoZW1hc1t1cmldID09PSB1bmRlZmluZWQgJiYgdGhpcy5taXNzaW5nTWFwW3VyaV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taXNzaW5nTWFwW3VyaV0gPSB1cmk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUuYWRkU2NoZW1hID0gZnVuY3Rpb24gKHVybCwgc2NoZW1hKSB7XG4gICAgLy9vdmVybG9hZFxuICAgIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJyB8fCB0eXBlb2Ygc2NoZW1hID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAodHlwZW9mIHVybCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHVybC5pZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHNjaGVtYSA9IHVybDtcbiAgICAgICAgICAgIHVybCA9IHNjaGVtYS5pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodXJsID09PSBnZXREb2N1bWVudFVyaSh1cmwpICsgXCIjXCIpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGVtcHR5IGZyYWdtZW50XG4gICAgICAgIHVybCA9IGdldERvY3VtZW50VXJpKHVybCk7XG4gICAgfVxuICAgIHRoaXMuc2NoZW1hc1t1cmxdID0gc2NoZW1hO1xuICAgIGRlbGV0ZSB0aGlzLm1pc3NpbmdNYXBbdXJsXTtcbiAgICBub3JtU2NoZW1hKHNjaGVtYSwgdXJsKTtcbiAgICB0aGlzLnNlYXJjaFNjaGVtYXMoc2NoZW1hLCB1cmwpO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUuZ2V0U2NoZW1hTWFwID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtYXAgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5zY2hlbWFzKSB7XG4gICAgICAgIG1hcFtrZXldID0gdGhpcy5zY2hlbWFzW2tleV07XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS5nZXRTY2hlbWFVcmlzID0gZnVuY3Rpb24gKGZpbHRlclJlZ0V4cCkge1xuICAgIHZhciBsaXN0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuc2NoZW1hcykge1xuICAgICAgICBpZiAoIWZpbHRlclJlZ0V4cCB8fCBmaWx0ZXJSZWdFeHAudGVzdChrZXkpKSB7XG4gICAgICAgICAgICBsaXN0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLmdldE1pc3NpbmdVcmlzID0gZnVuY3Rpb24gKGZpbHRlclJlZ0V4cCkge1xuICAgIHZhciBsaXN0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMubWlzc2luZ01hcCkge1xuICAgICAgICBpZiAoIWZpbHRlclJlZ0V4cCB8fCBmaWx0ZXJSZWdFeHAudGVzdChrZXkpKSB7XG4gICAgICAgICAgICBsaXN0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLmRyb3BTY2hlbWFzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2NoZW1hcyA9IHt9O1xuICAgIHRoaXMucmVzZXQoKTtcbn07XG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm1pc3NpbmcgPSBbXTtcbiAgICB0aGlzLm1pc3NpbmdNYXAgPSB7fTtcbiAgICB0aGlzLmVycm9ycyA9IFtdO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVBbGwgPSBmdW5jdGlvbiAoZGF0YSwgc2NoZW1hLCBkYXRhUGF0aFBhcnRzLCBzY2hlbWFQYXRoUGFydHMsIGRhdGFQb2ludGVyUGF0aCkge1xuICAgIHZhciB0b3BMZXZlbDtcbiAgICBzY2hlbWEgPSB0aGlzLnJlc29sdmVSZWZzKHNjaGVtYSk7XG4gICAgaWYgKCFzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBWYWxpZGF0aW9uRXJyb3IpIHtcbiAgICAgICAgdGhpcy5lcnJvcnMucHVzaChzY2hlbWEpO1xuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cblxuICAgIHZhciBzdGFydEVycm9yQ291bnQgPSB0aGlzLmVycm9ycy5sZW5ndGg7XG4gICAgdmFyIGZyb3plbkluZGV4LCBzY2FubmVkRnJvemVuU2NoZW1hSW5kZXggPSBudWxsLCBzY2FubmVkU2NoZW1hc0luZGV4ID0gbnVsbDtcbiAgICBpZiAodGhpcy5jaGVja1JlY3Vyc2l2ZSAmJiBkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xuICAgICAgICB0b3BMZXZlbCA9ICF0aGlzLnNjYW5uZWQubGVuZ3RoO1xuICAgICAgICBpZiAoZGF0YVt0aGlzLnZhbGlkYXRlZFNjaGVtYXNLZXldKSB7XG4gICAgICAgICAgICB2YXIgc2NoZW1hSW5kZXggPSBkYXRhW3RoaXMudmFsaWRhdGVkU2NoZW1hc0tleV0uaW5kZXhPZihzY2hlbWEpO1xuICAgICAgICAgICAgaWYgKHNjaGVtYUluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzID0gdGhpcy5lcnJvcnMuY29uY2F0KGRhdGFbdGhpcy52YWxpZGF0aW9uRXJyb3JzS2V5XVtzY2hlbWFJbmRleF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3QuaXNGcm96ZW4oZGF0YSkpIHtcbiAgICAgICAgICAgIGZyb3plbkluZGV4ID0gdGhpcy5zY2FubmVkRnJvemVuLmluZGV4T2YoZGF0YSk7XG4gICAgICAgICAgICBpZiAoZnJvemVuSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyb3plblNjaGVtYUluZGV4ID0gdGhpcy5zY2FubmVkRnJvemVuU2NoZW1hc1tmcm96ZW5JbmRleF0uaW5kZXhPZihzY2hlbWEpO1xuICAgICAgICAgICAgICAgIGlmIChmcm96ZW5TY2hlbWFJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMgPSB0aGlzLmVycm9ycy5jb25jYXQodGhpcy5zY2FubmVkRnJvemVuVmFsaWRhdGlvbkVycm9yc1tmcm96ZW5JbmRleF1bZnJvemVuU2NoZW1hSW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Nhbm5lZC5wdXNoKGRhdGEpO1xuICAgICAgICBpZiAoT2JqZWN0LmlzRnJvemVuKGRhdGEpKSB7XG4gICAgICAgICAgICBpZiAoZnJvemVuSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZnJvemVuSW5kZXggPSB0aGlzLnNjYW5uZWRGcm96ZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lZEZyb3plbi5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lZEZyb3plblNjaGVtYXMucHVzaChbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzY2FubmVkRnJvemVuU2NoZW1hSW5kZXggPSB0aGlzLnNjYW5uZWRGcm96ZW5TY2hlbWFzW2Zyb3plbkluZGV4XS5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnNjYW5uZWRGcm96ZW5TY2hlbWFzW2Zyb3plbkluZGV4XVtzY2FubmVkRnJvemVuU2NoZW1hSW5kZXhdID0gc2NoZW1hO1xuICAgICAgICAgICAgdGhpcy5zY2FubmVkRnJvemVuVmFsaWRhdGlvbkVycm9yc1tmcm96ZW5JbmRleF1bc2Nhbm5lZEZyb3plblNjaGVtYUluZGV4XSA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFkYXRhW3RoaXMudmFsaWRhdGVkU2NoZW1hc0tleV0pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGF0YSwgdGhpcy52YWxpZGF0ZWRTY2hlbWFzS2V5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkYXRhLCB0aGlzLnZhbGlkYXRpb25FcnJvcnNLZXksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vSUUgNy84IHdvcmthcm91bmRcbiAgICAgICAgICAgICAgICAgICAgZGF0YVt0aGlzLnZhbGlkYXRlZFNjaGVtYXNLZXldID0gW107XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbdGhpcy52YWxpZGF0aW9uRXJyb3JzS2V5XSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNjYW5uZWRTY2hlbWFzSW5kZXggPSBkYXRhW3RoaXMudmFsaWRhdGVkU2NoZW1hc0tleV0ubGVuZ3RoO1xuICAgICAgICAgICAgZGF0YVt0aGlzLnZhbGlkYXRlZFNjaGVtYXNLZXldW3NjYW5uZWRTY2hlbWFzSW5kZXhdID0gc2NoZW1hO1xuICAgICAgICAgICAgZGF0YVt0aGlzLnZhbGlkYXRpb25FcnJvcnNLZXldW3NjYW5uZWRTY2hlbWFzSW5kZXhdID0gW107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZXJyb3JDb3VudCA9IHRoaXMuZXJyb3JzLmxlbmd0aDtcbiAgICB2YXIgZXJyb3IgPSB0aGlzLnZhbGlkYXRlQmFzaWMoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG4gICAgICAgIHx8IHRoaXMudmFsaWRhdGVOdW1lcmljKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuICAgICAgICB8fCB0aGlzLnZhbGlkYXRlU3RyaW5nKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuICAgICAgICB8fCB0aGlzLnZhbGlkYXRlQXJyYXkoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG4gICAgICAgIHx8IHRoaXMudmFsaWRhdGVPYmplY3QoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG4gICAgICAgIHx8IHRoaXMudmFsaWRhdGVDb21iaW5hdGlvbnMoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG4gICAgICAgIHx8IHRoaXMudmFsaWRhdGVIeXBlcm1lZGlhKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuICAgICAgICB8fCB0aGlzLnZhbGlkYXRlRm9ybWF0KGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuICAgICAgICB8fCB0aGlzLnZhbGlkYXRlRGVmaW5lZEtleXdvcmRzKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuICAgICAgICB8fCBudWxsO1xuXG4gICAgaWYgKHRvcExldmVsKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnNjYW5uZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuc2Nhbm5lZC5wb3AoKTtcbiAgICAgICAgICAgIGRlbGV0ZSBpdGVtW3RoaXMudmFsaWRhdGVkU2NoZW1hc0tleV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY2FubmVkRnJvemVuID0gW107XG4gICAgICAgIHRoaXMuc2Nhbm5lZEZyb3plblNjaGVtYXMgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAoZXJyb3IgfHwgZXJyb3JDb3VudCAhPT0gdGhpcy5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHdoaWxlICgoZGF0YVBhdGhQYXJ0cyAmJiBkYXRhUGF0aFBhcnRzLmxlbmd0aCkgfHwgKHNjaGVtYVBhdGhQYXJ0cyAmJiBzY2hlbWFQYXRoUGFydHMubGVuZ3RoKSkge1xuICAgICAgICAgICAgdmFyIGRhdGFQYXJ0ID0gKGRhdGFQYXRoUGFydHMgJiYgZGF0YVBhdGhQYXJ0cy5sZW5ndGgpID8gXCJcIiArIGRhdGFQYXRoUGFydHMucG9wKCkgOiBudWxsO1xuICAgICAgICAgICAgdmFyIHNjaGVtYVBhcnQgPSAoc2NoZW1hUGF0aFBhcnRzICYmIHNjaGVtYVBhdGhQYXJ0cy5sZW5ndGgpID8gXCJcIiArIHNjaGVtYVBhdGhQYXJ0cy5wb3AoKSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGVycm9yLnByZWZpeFdpdGgoZGF0YVBhcnQsIHNjaGVtYVBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcmVmaXhFcnJvcnMoZXJyb3JDb3VudCwgZGF0YVBhcnQsIHNjaGVtYVBhcnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNjYW5uZWRGcm96ZW5TY2hlbWFJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnNjYW5uZWRGcm96ZW5WYWxpZGF0aW9uRXJyb3JzW2Zyb3plbkluZGV4XVtzY2FubmVkRnJvemVuU2NoZW1hSW5kZXhdID0gdGhpcy5lcnJvcnMuc2xpY2Uoc3RhcnRFcnJvckNvdW50KTtcbiAgICB9IGVsc2UgaWYgKHNjYW5uZWRTY2hlbWFzSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgZGF0YVt0aGlzLnZhbGlkYXRpb25FcnJvcnNLZXldW3NjYW5uZWRTY2hlbWFzSW5kZXhdID0gdGhpcy5lcnJvcnMuc2xpY2Uoc3RhcnRFcnJvckNvdW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5oYW5kbGVFcnJvcihlcnJvcik7XG59O1xuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiAoZGF0YSwgc2NoZW1hKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEuZm9ybWF0ICE9PSAnc3RyaW5nJyB8fCAhdGhpcy5mb3JtYXRWYWxpZGF0b3JzW3NjaGVtYS5mb3JtYXRdKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgZXJyb3JNZXNzYWdlID0gdGhpcy5mb3JtYXRWYWxpZGF0b3JzW3NjaGVtYS5mb3JtYXRdLmNhbGwobnVsbCwgZGF0YSwgc2NoZW1hKTtcbiAgICBpZiAodHlwZW9mIGVycm9yTWVzc2FnZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGVycm9yTWVzc2FnZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5GT1JNQVRfQ1VTVE9NLCB7bWVzc2FnZTogZXJyb3JNZXNzYWdlfSwgJycsICcvZm9ybWF0JywgbnVsbCwgZGF0YSwgc2NoZW1hKTtcbiAgICB9IGVsc2UgaWYgKGVycm9yTWVzc2FnZSAmJiB0eXBlb2YgZXJyb3JNZXNzYWdlID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLkZPUk1BVF9DVVNUT00sIHttZXNzYWdlOiBlcnJvck1lc3NhZ2UubWVzc2FnZSB8fCBcIj9cIn0sIGVycm9yTWVzc2FnZS5kYXRhUGF0aCB8fCAnJywgZXJyb3JNZXNzYWdlLnNjaGVtYVBhdGggfHwgXCIvZm9ybWF0XCIsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlRGVmaW5lZEtleXdvcmRzID0gZnVuY3Rpb24gKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuZGVmaW5lZEtleXdvcmRzKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsaWRhdGlvbkZ1bmN0aW9ucyA9IHRoaXMuZGVmaW5lZEtleXdvcmRzW2tleV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsaWRhdGlvbkZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGZ1bmMgPSB2YWxpZGF0aW9uRnVuY3Rpb25zW2ldO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMoZGF0YSwgc2NoZW1hW2tleV0sIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcmVzdWx0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuS0VZV09SRF9DVVNUT00sIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHJlc3VsdFxuICAgICAgICAgICAgICAgIH0sICcnLCAnJywgbnVsbCwgZGF0YSwgc2NoZW1hKS5wcmVmaXhXaXRoKG51bGwsIGtleSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gcmVzdWx0LmNvZGU7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb2RlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUVycm9yQ29kZXNbY29kZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5kZWZpbmVkIGVycm9yIGNvZGUgKHVzZSBkZWZpbmVFcnJvcik6ICcgKyBjb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb2RlID0gRXJyb3JDb2Rlc1tjb2RlXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2RlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBjb2RlID0gRXJyb3JDb2Rlcy5LRVlXT1JEX0NVU1RPTTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2VQYXJhbXMgPSAodHlwZW9mIHJlc3VsdC5tZXNzYWdlID09PSAnb2JqZWN0JykgPyByZXN1bHQubWVzc2FnZSA6IHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHJlc3VsdC5tZXNzYWdlIHx8IFwiP1wiXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgc2NoZW1hUGF0aCA9IHJlc3VsdC5zY2hlbWFQYXRoIHx8IChcIi9cIiArIGtleS5yZXBsYWNlKC9+L2csICd+MCcpLnJlcGxhY2UoL1xcLy9nLCAnfjEnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoY29kZSwgbWVzc2FnZVBhcmFtcywgcmVzdWx0LmRhdGFQYXRoIHx8IG51bGwsIHNjaGVtYVBhdGgsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5mdW5jdGlvbiByZWN1cnNpdmVDb21wYXJlKEEsIEIpIHtcbiAgICBpZiAoQSA9PT0gQikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKEEgJiYgQiAmJiB0eXBlb2YgQSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgQiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShBKSAhPT0gQXJyYXkuaXNBcnJheShCKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoQSkpIHtcbiAgICAgICAgICAgIGlmIChBLmxlbmd0aCAhPT0gQi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlY3Vyc2l2ZUNvbXBhcmUoQVtpXSwgQltpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBrZXk7XG4gICAgICAgICAgICBmb3IgKGtleSBpbiBBKSB7XG4gICAgICAgICAgICAgICAgaWYgKEJba2V5XSA9PT0gdW5kZWZpbmVkICYmIEFba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGtleSBpbiBCKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFba2V5XSA9PT0gdW5kZWZpbmVkICYmIEJba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGtleSBpbiBBKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWN1cnNpdmVDb21wYXJlKEFba2V5XSwgQltrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlQmFzaWMgPSBmdW5jdGlvbiB2YWxpZGF0ZUJhc2ljKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChlcnJvciA9IHRoaXMudmFsaWRhdGVUeXBlKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSkge1xuICAgICAgICByZXR1cm4gZXJyb3IucHJlZml4V2l0aChudWxsLCBcInR5cGVcIik7XG4gICAgfVxuICAgIGlmIChlcnJvciA9IHRoaXMudmFsaWRhdGVFbnVtKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSkge1xuICAgICAgICByZXR1cm4gZXJyb3IucHJlZml4V2l0aChudWxsLCBcInR5cGVcIik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVUeXBlID0gZnVuY3Rpb24gdmFsaWRhdGVUeXBlKGRhdGEsIHNjaGVtYSkge1xuICAgIGlmIChzY2hlbWEudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgZGF0YVR5cGUgPSB0eXBlb2YgZGF0YTtcbiAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICBkYXRhVHlwZSA9IFwibnVsbFwiO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICBkYXRhVHlwZSA9IFwiYXJyYXlcIjtcbiAgICB9XG4gICAgdmFyIGFsbG93ZWRUeXBlcyA9IHNjaGVtYS50eXBlO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhbGxvd2VkVHlwZXMpKSB7XG4gICAgICAgIGFsbG93ZWRUeXBlcyA9IFthbGxvd2VkVHlwZXNdO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsb3dlZFR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0eXBlID0gYWxsb3dlZFR5cGVzW2ldO1xuICAgICAgICBpZiAodHlwZSA9PT0gZGF0YVR5cGUgfHwgKHR5cGUgPT09IFwiaW50ZWdlclwiICYmIGRhdGFUeXBlID09PSBcIm51bWJlclwiICYmIChkYXRhICUgMSA9PT0gMCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLklOVkFMSURfVFlQRSwge1xuICAgICAgICB0eXBlOiBkYXRhVHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IGFsbG93ZWRUeXBlcy5qb2luKFwiL1wiKVxuICAgIH0sICcnLCAnJywgbnVsbCwgZGF0YSwgc2NoZW1hKTtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlRW51bSA9IGZ1bmN0aW9uIHZhbGlkYXRlRW51bShkYXRhLCBzY2hlbWEpIHtcbiAgICBpZiAoc2NoZW1hW1wiZW51bVwiXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNjaGVtYVtcImVudW1cIl0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVudW1WYWwgPSBzY2hlbWFbXCJlbnVtXCJdW2ldO1xuICAgICAgICBpZiAocmVjdXJzaXZlQ29tcGFyZShkYXRhLCBlbnVtVmFsKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5FTlVNX01JU01BVENILCB7dmFsdWU6ICh0eXBlb2YgSlNPTiAhPT0gJ3VuZGVmaW5lZCcpID8gSlNPTi5zdHJpbmdpZnkoZGF0YSkgOiBkYXRhfSwgJycsICcnLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVOdW1lcmljID0gZnVuY3Rpb24gdmFsaWRhdGVOdW1lcmljKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdGVNdWx0aXBsZU9mKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuICAgICAgICB8fCB0aGlzLnZhbGlkYXRlTWluTWF4KGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuICAgICAgICB8fCB0aGlzLnZhbGlkYXRlTmFOKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuICAgICAgICB8fCBudWxsO1xufTtcblxudmFyIENMT1NFX0VOT1VHSF9MT1cgPSBNYXRoLnBvdygyLCAtNTEpO1xudmFyIENMT1NFX0VOT1VHSF9ISUdIID0gMSAtIENMT1NFX0VOT1VHSF9MT1c7XG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZU11bHRpcGxlT2YgPSBmdW5jdGlvbiB2YWxpZGF0ZU11bHRpcGxlT2YoZGF0YSwgc2NoZW1hKSB7XG4gICAgdmFyIG11bHRpcGxlT2YgPSBzY2hlbWEubXVsdGlwbGVPZiB8fCBzY2hlbWEuZGl2aXNpYmxlQnk7XG4gICAgaWYgKG11bHRpcGxlT2YgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHZhciByZW1haW5kZXIgPSAoZGF0YSAvIG11bHRpcGxlT2YpICUgMTtcbiAgICAgICAgaWYgKHJlbWFpbmRlciA+PSBDTE9TRV9FTk9VR0hfTE9XICYmIHJlbWFpbmRlciA8IENMT1NFX0VOT1VHSF9ISUdIKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLk5VTUJFUl9NVUxUSVBMRV9PRiwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRhLFxuICAgICAgICAgICAgICAgIG11bHRpcGxlT2Y6IG11bHRpcGxlT2ZcbiAgICAgICAgICAgIH0sICcnLCAnJywgbnVsbCwgZGF0YSwgc2NoZW1hKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlTWluTWF4ID0gZnVuY3Rpb24gdmFsaWRhdGVNaW5NYXgoZGF0YSwgc2NoZW1hKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hLm1pbmltdW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoZGF0YSA8IHNjaGVtYS5taW5pbXVtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLk5VTUJFUl9NSU5JTVVNLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGRhdGEsXG4gICAgICAgICAgICAgICAgbWluaW11bTogc2NoZW1hLm1pbmltdW1cbiAgICAgICAgICAgIH0sICcnLCAnL21pbmltdW0nLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEuZXhjbHVzaXZlTWluaW11bSAmJiBkYXRhID09PSBzY2hlbWEubWluaW11bSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5OVU1CRVJfTUlOSU1VTV9FWENMVVNJVkUsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGF0YSxcbiAgICAgICAgICAgICAgICBtaW5pbXVtOiBzY2hlbWEubWluaW11bVxuICAgICAgICAgICAgfSwgJycsICcvZXhjbHVzaXZlTWluaW11bScsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNjaGVtYS5tYXhpbXVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGRhdGEgPiBzY2hlbWEubWF4aW11bSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5OVU1CRVJfTUFYSU1VTSwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRhLFxuICAgICAgICAgICAgICAgIG1heGltdW06IHNjaGVtYS5tYXhpbXVtXG4gICAgICAgICAgICB9LCAnJywgJy9tYXhpbXVtJywgbnVsbCwgZGF0YSwgc2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0gJiYgZGF0YSA9PT0gc2NoZW1hLm1heGltdW0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuTlVNQkVSX01BWElNVU1fRVhDTFVTSVZFLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGRhdGEsXG4gICAgICAgICAgICAgICAgbWF4aW11bTogc2NoZW1hLm1heGltdW1cbiAgICAgICAgICAgIH0sICcnLCAnL2V4Y2x1c2l2ZU1heGltdW0nLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVOYU4gPSBmdW5jdGlvbiB2YWxpZGF0ZU5hTihkYXRhLCBzY2hlbWEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChpc05hTihkYXRhKSA9PT0gdHJ1ZSB8fCBkYXRhID09PSBJbmZpbml0eSB8fCBkYXRhID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5OVU1CRVJfTk9UX0FfTlVNQkVSLCB7dmFsdWU6IGRhdGF9LCAnJywgJy90eXBlJywgbnVsbCwgZGF0YSwgc2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZVN0cmluZyA9IGZ1bmN0aW9uIHZhbGlkYXRlU3RyaW5nKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdGVTdHJpbmdMZW5ndGgoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG4gICAgICAgIHx8IHRoaXMudmFsaWRhdGVTdHJpbmdQYXR0ZXJuKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuICAgICAgICB8fCBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVTdHJpbmdMZW5ndGggPSBmdW5jdGlvbiB2YWxpZGF0ZVN0cmluZ0xlbmd0aChkYXRhLCBzY2hlbWEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChzY2hlbWEubWluTGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgc2NoZW1hLm1pbkxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5TVFJJTkdfTEVOR1RIX1NIT1JULCB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBkYXRhLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBtaW5pbXVtOiBzY2hlbWEubWluTGVuZ3RoXG4gICAgICAgICAgICB9LCAnJywgJy9taW5MZW5ndGgnLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzY2hlbWEubWF4TGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gc2NoZW1hLm1heExlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5TVFJJTkdfTEVOR1RIX0xPTkcsIHtcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGRhdGEubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG1heGltdW06IHNjaGVtYS5tYXhMZW5ndGhcbiAgICAgICAgICAgIH0sICcnLCAnL21heExlbmd0aCcsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZVN0cmluZ1BhdHRlcm4gPSBmdW5jdGlvbiB2YWxpZGF0ZVN0cmluZ1BhdHRlcm4oZGF0YSwgc2NoZW1hKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiIHx8ICh0eXBlb2Ygc2NoZW1hLnBhdHRlcm4gIT09IFwic3RyaW5nXCIgJiYgIShzY2hlbWEucGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgcmVnZXhwO1xuICAgIGlmIChzY2hlbWEucGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZWdleHAgPSBzY2hlbWEucGF0dGVybjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBib2R5LCBmbGFncyA9ICcnO1xuICAgICAgICAvLyBDaGVjayBmb3IgcmVndWxhciBleHByZXNzaW9uIGxpdGVyYWxzXG4gICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTcuOC41XG4gICAgICAgIHZhciBsaXRlcmFsID0gc2NoZW1hLnBhdHRlcm4ubWF0Y2goL15cXC8oLispXFwvKFtpbWddKikkLyk7XG4gICAgICAgIGlmIChsaXRlcmFsKSB7XG4gICAgICAgICAgICBib2R5ID0gbGl0ZXJhbFsxXTtcbiAgICAgICAgICAgIGZsYWdzID0gbGl0ZXJhbFsyXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSBzY2hlbWEucGF0dGVybjtcbiAgICAgICAgfVxuICAgICAgICByZWdleHAgPSBuZXcgUmVnRXhwKGJvZHksIGZsYWdzKTtcbiAgICB9XG4gICAgaWYgKCFyZWdleHAudGVzdChkYXRhKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLlNUUklOR19QQVRURVJOLCB7cGF0dGVybjogc2NoZW1hLnBhdHRlcm59LCAnJywgJy9wYXR0ZXJuJywgbnVsbCwgZGF0YSwgc2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZUFycmF5ID0gZnVuY3Rpb24gdmFsaWRhdGVBcnJheShkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdGVBcnJheUxlbmd0aChkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcbiAgICAgICAgfHwgdGhpcy52YWxpZGF0ZUFycmF5VW5pcXVlSXRlbXMoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG4gICAgICAgIHx8IHRoaXMudmFsaWRhdGVBcnJheUl0ZW1zKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuICAgICAgICB8fCBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVBcnJheUxlbmd0aCA9IGZ1bmN0aW9uIHZhbGlkYXRlQXJyYXlMZW5ndGgoZGF0YSwgc2NoZW1hKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChzY2hlbWEubWluSXRlbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCBzY2hlbWEubWluSXRlbXMpIHtcbiAgICAgICAgICAgIGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLkFSUkFZX0xFTkdUSF9TSE9SVCwge1xuICAgICAgICAgICAgICAgIGxlbmd0aDogZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbWluaW11bTogc2NoZW1hLm1pbkl0ZW1zXG4gICAgICAgICAgICB9LCAnJywgJy9taW5JdGVtcycsIG51bGwsIGRhdGEsIHNjaGVtYSk7XG4gICAgICAgICAgICBpZiAodGhpcy5oYW5kbGVFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNjaGVtYS5tYXhJdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA+IHNjaGVtYS5tYXhJdGVtcykge1xuICAgICAgICAgICAgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuQVJSQVlfTEVOR1RIX0xPTkcsIHtcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGRhdGEubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG1heGltdW06IHNjaGVtYS5tYXhJdGVtc1xuICAgICAgICAgICAgfSwgJycsICcvbWF4SXRlbXMnLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVBcnJheVVuaXF1ZUl0ZW1zID0gZnVuY3Rpb24gdmFsaWRhdGVBcnJheVVuaXF1ZUl0ZW1zKGRhdGEsIHNjaGVtYSkge1xuICAgIGlmIChzY2hlbWEudW5pcXVlSXRlbXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBkYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3Vyc2l2ZUNvbXBhcmUoZGF0YVtpXSwgZGF0YVtqXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLkFSUkFZX1VOSVFVRSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2gxOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2gyOiBqXG4gICAgICAgICAgICAgICAgICAgIH0sICcnLCAnL3VuaXF1ZUl0ZW1zJywgbnVsbCwgZGF0YSwgc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZUFycmF5SXRlbXMgPSBmdW5jdGlvbiB2YWxpZGF0ZUFycmF5SXRlbXMoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpIHtcbiAgICBpZiAoc2NoZW1hLml0ZW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBlcnJvciwgaTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuaXRlbXMpKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA8IHNjaGVtYS5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPSB0aGlzLnZhbGlkYXRlQWxsKGRhdGFbaV0sIHNjaGVtYS5pdGVtc1tpXSwgW2ldLCBbXCJpdGVtc1wiLCBpXSwgZGF0YVBvaW50ZXJQYXRoICsgXCIvXCIgKyBpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzY2hlbWEuYWRkaXRpb25hbEl0ZW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5hZGRpdGlvbmFsSXRlbXMgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2NoZW1hLmFkZGl0aW9uYWxJdGVtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSAodGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLkFSUkFZX0FERElUSU9OQUxfSVRFTVMsIHt9LCAnLycgKyBpLCAnL2FkZGl0aW9uYWxJdGVtcycsIG51bGwsIGRhdGEsIHNjaGVtYSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvciA9IHRoaXMudmFsaWRhdGVBbGwoZGF0YVtpXSwgc2NoZW1hLmFkZGl0aW9uYWxJdGVtcywgW2ldLCBbXCJhZGRpdGlvbmFsSXRlbXNcIl0sIGRhdGFQb2ludGVyUGF0aCArIFwiL1wiICsgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgPSB0aGlzLnZhbGlkYXRlQWxsKGRhdGFbaV0sIHNjaGVtYS5pdGVtcywgW2ldLCBbXCJpdGVtc1wiXSwgZGF0YVBvaW50ZXJQYXRoICsgXCIvXCIgKyBpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlT2JqZWN0ID0gZnVuY3Rpb24gdmFsaWRhdGVPYmplY3QoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgIT09IFwib2JqZWN0XCIgfHwgZGF0YSA9PT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy52YWxpZGF0ZU9iamVjdE1pbk1heFByb3BlcnRpZXMoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG4gICAgICAgIHx8IHRoaXMudmFsaWRhdGVPYmplY3RSZXF1aXJlZFByb3BlcnRpZXMoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG4gICAgICAgIHx8IHRoaXMudmFsaWRhdGVPYmplY3RQcm9wZXJ0aWVzKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuICAgICAgICB8fCB0aGlzLnZhbGlkYXRlT2JqZWN0RGVwZW5kZW5jaWVzKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuICAgICAgICB8fCBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVPYmplY3RNaW5NYXhQcm9wZXJ0aWVzID0gZnVuY3Rpb24gdmFsaWRhdGVPYmplY3RNaW5NYXhQcm9wZXJ0aWVzKGRhdGEsIHNjaGVtYSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChzY2hlbWEubWluUHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCA8IHNjaGVtYS5taW5Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5PQkpFQ1RfUFJPUEVSVElFU19NSU5JTVVNLCB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHlDb3VudDoga2V5cy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbWluaW11bTogc2NoZW1hLm1pblByb3BlcnRpZXNcbiAgICAgICAgICAgIH0sICcnLCAnL21pblByb3BlcnRpZXMnLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzY2hlbWEubWF4UHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCA+IHNjaGVtYS5tYXhQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5PQkpFQ1RfUFJPUEVSVElFU19NQVhJTVVNLCB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHlDb3VudDoga2V5cy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbWF4aW11bTogc2NoZW1hLm1heFByb3BlcnRpZXNcbiAgICAgICAgICAgIH0sICcnLCAnL21heFByb3BlcnRpZXMnLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVPYmplY3RSZXF1aXJlZFByb3BlcnRpZXMgPSBmdW5jdGlvbiB2YWxpZGF0ZU9iamVjdFJlcXVpcmVkUHJvcGVydGllcyhkYXRhLCBzY2hlbWEpIHtcbiAgICBpZiAoc2NoZW1hLnJlcXVpcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzY2hlbWEucmVxdWlyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBzY2hlbWEucmVxdWlyZWRbaV07XG4gICAgICAgICAgICBpZiAoZGF0YVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuT0JKRUNUX1JFUVVJUkVELCB7a2V5OiBrZXl9LCAnJywgJy9yZXF1aXJlZC8nICsgaSwgbnVsbCwgZGF0YSwgc2NoZW1hKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYW5kbGVFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlT2JqZWN0UHJvcGVydGllcyA9IGZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0UHJvcGVydGllcyhkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aCkge1xuICAgIHZhciBlcnJvcjtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICB2YXIga2V5UG9pbnRlclBhdGggPSBkYXRhUG9pbnRlclBhdGggKyBcIi9cIiArIGtleS5yZXBsYWNlKC9+L2csICd+MCcpLnJlcGxhY2UoL1xcLy9nLCAnfjEnKTtcbiAgICAgICAgdmFyIGZvdW5kTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgaWYgKHNjaGVtYS5wcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQgJiYgc2NoZW1hLnByb3BlcnRpZXNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3VuZE1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChlcnJvciA9IHRoaXMudmFsaWRhdGVBbGwoZGF0YVtrZXldLCBzY2hlbWEucHJvcGVydGllc1trZXldLCBba2V5XSwgW1wicHJvcGVydGllc1wiLCBrZXldLCBrZXlQb2ludGVyUGF0aCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBwYXR0ZXJuS2V5IGluIHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKHBhdHRlcm5LZXkpO1xuICAgICAgICAgICAgICAgIGlmIChyZWdleHAudGVzdChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPSB0aGlzLnZhbGlkYXRlQWxsKGRhdGFba2V5XSwgc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzW3BhdHRlcm5LZXldLCBba2V5XSwgW1wicGF0dGVyblByb3BlcnRpZXNcIiwgcGF0dGVybktleV0sIGtleVBvaW50ZXJQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZm91bmRNYXRjaCkge1xuICAgICAgICAgICAgaWYgKHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tVbmtub3duUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmtub3duUHJvcGVydHlQYXRoc1trZXlQb2ludGVyUGF0aF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy51bmtub3duUHJvcGVydHlQYXRoc1trZXlQb2ludGVyUGF0aF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuT0JKRUNUX0FERElUSU9OQUxfUFJPUEVSVElFUywge2tleToga2V5fSwgJycsICcvYWRkaXRpb25hbFByb3BlcnRpZXMnLCBudWxsLCBkYXRhLCBzY2hlbWEpLnByZWZpeFdpdGgoa2V5LCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhbmRsZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA9IHRoaXMudmFsaWRhdGVBbGwoZGF0YVtrZXldLCBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMsIFtrZXldLCBbXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiXSwga2V5UG9pbnRlclBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHJhY2tVbmtub3duUHJvcGVydGllcyAmJiAhdGhpcy5rbm93blByb3BlcnR5UGF0aHNba2V5UG9pbnRlclBhdGhdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bmtub3duUHJvcGVydHlQYXRoc1trZXlQb2ludGVyUGF0aF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHJhY2tVbmtub3duUHJvcGVydGllcykge1xuICAgICAgICAgICAgdGhpcy5rbm93blByb3BlcnR5UGF0aHNba2V5UG9pbnRlclBhdGhdID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnVua25vd25Qcm9wZXJ0eVBhdGhzW2tleVBvaW50ZXJQYXRoXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlT2JqZWN0RGVwZW5kZW5jaWVzID0gZnVuY3Rpb24gdmFsaWRhdGVPYmplY3REZXBlbmRlbmNpZXMoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKHNjaGVtYS5kZXBlbmRlbmNpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb3IgKHZhciBkZXBLZXkgaW4gc2NoZW1hLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgaWYgKGRhdGFbZGVwS2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlcCA9IHNjaGVtYS5kZXBlbmRlbmNpZXNbZGVwS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlcCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtkZXBdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLk9CSkVDVF9ERVBFTkRFTkNZX0tFWSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogZGVwS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pc3Npbmc6IGRlcFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgJycsICcnLCBudWxsLCBkYXRhLCBzY2hlbWEpLnByZWZpeFdpdGgobnVsbCwgZGVwS2V5KS5wcmVmaXhXaXRoKG51bGwsIFwiZGVwZW5kZW5jaWVzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRlcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXF1aXJlZEtleSA9IGRlcFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW3JlcXVpcmVkS2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuT0JKRUNUX0RFUEVOREVOQ1lfS0VZLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogZGVwS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaXNzaW5nOiByZXF1aXJlZEtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sICcnLCAnLycgKyBpLCBudWxsLCBkYXRhLCBzY2hlbWEpLnByZWZpeFdpdGgobnVsbCwgZGVwS2V5KS5wcmVmaXhXaXRoKG51bGwsIFwiZGVwZW5kZW5jaWVzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhbmRsZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yID0gdGhpcy52YWxpZGF0ZUFsbChkYXRhLCBkZXAsIFtdLCBbXCJkZXBlbmRlbmNpZXNcIiwgZGVwS2V5XSwgZGF0YVBvaW50ZXJQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVDb21iaW5hdGlvbnMgPSBmdW5jdGlvbiB2YWxpZGF0ZUNvbWJpbmF0aW9ucyhkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aCkge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRlQWxsT2YoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpXG4gICAgICAgIHx8IHRoaXMudmFsaWRhdGVBbnlPZihkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aClcbiAgICAgICAgfHwgdGhpcy52YWxpZGF0ZU9uZU9mKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuICAgICAgICB8fCB0aGlzLnZhbGlkYXRlTm90KGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKVxuICAgICAgICB8fCBudWxsO1xufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVBbGxPZiA9IGZ1bmN0aW9uIHZhbGlkYXRlQWxsT2YoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpIHtcbiAgICBpZiAoc2NoZW1hLmFsbE9mID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBlcnJvcjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNjaGVtYS5hbGxPZi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3ViU2NoZW1hID0gc2NoZW1hLmFsbE9mW2ldO1xuICAgICAgICBpZiAoZXJyb3IgPSB0aGlzLnZhbGlkYXRlQWxsKGRhdGEsIHN1YlNjaGVtYSwgW10sIFtcImFsbE9mXCIsIGldLCBkYXRhUG9pbnRlclBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZUFueU9mID0gZnVuY3Rpb24gdmFsaWRhdGVBbnlPZihkYXRhLCBzY2hlbWEsIGRhdGFQb2ludGVyUGF0aCkge1xuICAgIGlmIChzY2hlbWEuYW55T2YgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIHZhciBzdGFydEVycm9yQ291bnQgPSB0aGlzLmVycm9ycy5sZW5ndGg7XG4gICAgdmFyIG9sZFVua25vd25Qcm9wZXJ0eVBhdGhzLCBvbGRLbm93blByb3BlcnR5UGF0aHM7XG4gICAgaWYgKHRoaXMudHJhY2tVbmtub3duUHJvcGVydGllcykge1xuICAgICAgICBvbGRVbmtub3duUHJvcGVydHlQYXRocyA9IHRoaXMudW5rbm93blByb3BlcnR5UGF0aHM7XG4gICAgICAgIG9sZEtub3duUHJvcGVydHlQYXRocyA9IHRoaXMua25vd25Qcm9wZXJ0eVBhdGhzO1xuICAgIH1cbiAgICB2YXIgZXJyb3JBdEVuZCA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzY2hlbWEuYW55T2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMudHJhY2tVbmtub3duUHJvcGVydGllcykge1xuICAgICAgICAgICAgdGhpcy51bmtub3duUHJvcGVydHlQYXRocyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5rbm93blByb3BlcnR5UGF0aHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3ViU2NoZW1hID0gc2NoZW1hLmFueU9mW2ldO1xuXG4gICAgICAgIHZhciBlcnJvckNvdW50ID0gdGhpcy5lcnJvcnMubGVuZ3RoO1xuICAgICAgICB2YXIgZXJyb3IgPSB0aGlzLnZhbGlkYXRlQWxsKGRhdGEsIHN1YlNjaGVtYSwgW10sIFtcImFueU9mXCIsIGldLCBkYXRhUG9pbnRlclBhdGgpO1xuXG4gICAgICAgIGlmIChlcnJvciA9PT0gbnVsbCAmJiBlcnJvckNvdW50ID09PSB0aGlzLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzID0gdGhpcy5lcnJvcnMuc2xpY2UoMCwgc3RhcnRFcnJvckNvdW50KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tVbmtub3duUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtub3duS2V5IGluIHRoaXMua25vd25Qcm9wZXJ0eVBhdGhzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZEtub3duUHJvcGVydHlQYXRoc1trbm93bktleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgb2xkVW5rbm93blByb3BlcnR5UGF0aHNba25vd25LZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciB1bmtub3duS2V5IGluIHRoaXMudW5rbm93blByb3BlcnR5UGF0aHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvbGRLbm93blByb3BlcnR5UGF0aHNbdW5rbm93bktleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZFVua25vd25Qcm9wZXJ0eVBhdGhzW3Vua25vd25LZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNvbnRpbnVlIGxvb3Bpbmcgc28gd2UgY2F0Y2ggYWxsIHRoZSBwcm9wZXJ0eSBkZWZpbml0aW9ucywgYnV0IHdlIGRvbid0IHdhbnQgdG8gcmV0dXJuIGFuIGVycm9yXG4gICAgICAgICAgICAgICAgZXJyb3JBdEVuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yLnByZWZpeFdpdGgobnVsbCwgXCJcIiArIGkpLnByZWZpeFdpdGgobnVsbCwgXCJhbnlPZlwiKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMudHJhY2tVbmtub3duUHJvcGVydGllcykge1xuICAgICAgICB0aGlzLnVua25vd25Qcm9wZXJ0eVBhdGhzID0gb2xkVW5rbm93blByb3BlcnR5UGF0aHM7XG4gICAgICAgIHRoaXMua25vd25Qcm9wZXJ0eVBhdGhzID0gb2xkS25vd25Qcm9wZXJ0eVBhdGhzO1xuICAgIH1cbiAgICBpZiAoZXJyb3JBdEVuZCkge1xuICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHRoaXMuZXJyb3JzLnNsaWNlKHN0YXJ0RXJyb3JDb3VudCkpO1xuICAgICAgICB0aGlzLmVycm9ycyA9IHRoaXMuZXJyb3JzLnNsaWNlKDAsIHN0YXJ0RXJyb3JDb3VudCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuQU5ZX09GX01JU1NJTkcsIHt9LCBcIlwiLCBcIi9hbnlPZlwiLCBlcnJvcnMsIGRhdGEsIHNjaGVtYSk7XG4gICAgfVxufTtcblxuVmFsaWRhdG9yQ29udGV4dC5wcm90b3R5cGUudmFsaWRhdGVPbmVPZiA9IGZ1bmN0aW9uIHZhbGlkYXRlT25lT2YoZGF0YSwgc2NoZW1hLCBkYXRhUG9pbnRlclBhdGgpIHtcbiAgICBpZiAoc2NoZW1hLm9uZU9mID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciB2YWxpZEluZGV4ID0gbnVsbDtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgdmFyIHN0YXJ0RXJyb3JDb3VudCA9IHRoaXMuZXJyb3JzLmxlbmd0aDtcbiAgICB2YXIgb2xkVW5rbm93blByb3BlcnR5UGF0aHMsIG9sZEtub3duUHJvcGVydHlQYXRocztcbiAgICBpZiAodGhpcy50cmFja1Vua25vd25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgIG9sZFVua25vd25Qcm9wZXJ0eVBhdGhzID0gdGhpcy51bmtub3duUHJvcGVydHlQYXRocztcbiAgICAgICAgb2xkS25vd25Qcm9wZXJ0eVBhdGhzID0gdGhpcy5rbm93blByb3BlcnR5UGF0aHM7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2NoZW1hLm9uZU9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMudW5rbm93blByb3BlcnR5UGF0aHMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMua25vd25Qcm9wZXJ0eVBhdGhzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YlNjaGVtYSA9IHNjaGVtYS5vbmVPZltpXTtcblxuICAgICAgICB2YXIgZXJyb3JDb3VudCA9IHRoaXMuZXJyb3JzLmxlbmd0aDtcbiAgICAgICAgdmFyIGVycm9yID0gdGhpcy52YWxpZGF0ZUFsbChkYXRhLCBzdWJTY2hlbWEsIFtdLCBbXCJvbmVPZlwiLCBpXSwgZGF0YVBvaW50ZXJQYXRoKTtcblxuICAgICAgICBpZiAoZXJyb3IgPT09IG51bGwgJiYgZXJyb3JDb3VudCA9PT0gdGhpcy5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodmFsaWRJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9ycyA9IHRoaXMuZXJyb3JzLnNsaWNlKDAsIHN0YXJ0RXJyb3JDb3VudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoRXJyb3JDb2Rlcy5PTkVfT0ZfTVVMVElQTEUsIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgxOiB2YWxpZEluZGV4LFxuICAgICAgICAgICAgICAgICAgICBpbmRleDI6IGlcbiAgICAgICAgICAgICAgICB9LCBcIlwiLCBcIi9vbmVPZlwiLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tVbmtub3duUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtub3duS2V5IGluIHRoaXMua25vd25Qcm9wZXJ0eVBhdGhzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZEtub3duUHJvcGVydHlQYXRoc1trbm93bktleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgb2xkVW5rbm93blByb3BlcnR5UGF0aHNba25vd25LZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciB1bmtub3duS2V5IGluIHRoaXMudW5rbm93blByb3BlcnR5UGF0aHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvbGRLbm93blByb3BlcnR5UGF0aHNbdW5rbm93bktleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZFVua25vd25Qcm9wZXJ0eVBhdGhzW3Vua25vd25LZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChlcnJvcikge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnRyYWNrVW5rbm93blByb3BlcnRpZXMpIHtcbiAgICAgICAgdGhpcy51bmtub3duUHJvcGVydHlQYXRocyA9IG9sZFVua25vd25Qcm9wZXJ0eVBhdGhzO1xuICAgICAgICB0aGlzLmtub3duUHJvcGVydHlQYXRocyA9IG9sZEtub3duUHJvcGVydHlQYXRocztcbiAgICB9XG4gICAgaWYgKHZhbGlkSW5kZXggPT09IG51bGwpIHtcbiAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh0aGlzLmVycm9ycy5zbGljZShzdGFydEVycm9yQ291bnQpKTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSB0aGlzLmVycm9ycy5zbGljZSgwLCBzdGFydEVycm9yQ291bnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihFcnJvckNvZGVzLk9ORV9PRl9NSVNTSU5HLCB7fSwgXCJcIiwgXCIvb25lT2ZcIiwgZXJyb3JzLCBkYXRhLCBzY2hlbWEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gdGhpcy5lcnJvcnMuc2xpY2UoMCwgc3RhcnRFcnJvckNvdW50KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5WYWxpZGF0b3JDb250ZXh0LnByb3RvdHlwZS52YWxpZGF0ZU5vdCA9IGZ1bmN0aW9uIHZhbGlkYXRlTm90KGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSB7XG4gICAgaWYgKHNjaGVtYS5ub3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIG9sZEVycm9yQ291bnQgPSB0aGlzLmVycm9ycy5sZW5ndGg7XG4gICAgdmFyIG9sZFVua25vd25Qcm9wZXJ0eVBhdGhzLCBvbGRLbm93blByb3BlcnR5UGF0aHM7XG4gICAgaWYgKHRoaXMudHJhY2tVbmtub3duUHJvcGVydGllcykge1xuICAgICAgICBvbGRVbmtub3duUHJvcGVydHlQYXRocyA9IHRoaXMudW5rbm93blByb3BlcnR5UGF0aHM7XG4gICAgICAgIG9sZEtub3duUHJvcGVydHlQYXRocyA9IHRoaXMua25vd25Qcm9wZXJ0eVBhdGhzO1xuICAgICAgICB0aGlzLnVua25vd25Qcm9wZXJ0eVBhdGhzID0ge307XG4gICAgICAgIHRoaXMua25vd25Qcm9wZXJ0eVBhdGhzID0ge307XG4gICAgfVxuICAgIHZhciBlcnJvciA9IHRoaXMudmFsaWRhdGVBbGwoZGF0YSwgc2NoZW1hLm5vdCwgbnVsbCwgbnVsbCwgZGF0YVBvaW50ZXJQYXRoKTtcbiAgICB2YXIgbm90RXJyb3JzID0gdGhpcy5lcnJvcnMuc2xpY2Uob2xkRXJyb3JDb3VudCk7XG4gICAgdGhpcy5lcnJvcnMgPSB0aGlzLmVycm9ycy5zbGljZSgwLCBvbGRFcnJvckNvdW50KTtcbiAgICBpZiAodGhpcy50cmFja1Vua25vd25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgIHRoaXMudW5rbm93blByb3BlcnR5UGF0aHMgPSBvbGRVbmtub3duUHJvcGVydHlQYXRocztcbiAgICAgICAgdGhpcy5rbm93blByb3BlcnR5UGF0aHMgPSBvbGRLbm93blByb3BlcnR5UGF0aHM7XG4gICAgfVxuICAgIGlmIChlcnJvciA9PT0gbnVsbCAmJiBub3RFcnJvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKEVycm9yQ29kZXMuTk9UX1BBU1NFRCwge30sIFwiXCIsIFwiL25vdFwiLCBudWxsLCBkYXRhLCBzY2hlbWEpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblZhbGlkYXRvckNvbnRleHQucHJvdG90eXBlLnZhbGlkYXRlSHlwZXJtZWRpYSA9IGZ1bmN0aW9uIHZhbGlkYXRlQ29tYmluYXRpb25zKGRhdGEsIHNjaGVtYSwgZGF0YVBvaW50ZXJQYXRoKSB7XG4gICAgaWYgKCFzY2hlbWEubGlua3MpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBlcnJvcjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNjaGVtYS5saW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGRvID0gc2NoZW1hLmxpbmtzW2ldO1xuICAgICAgICBpZiAobGRvLnJlbCA9PT0gXCJkZXNjcmliZWRieVwiKSB7XG4gICAgICAgICAgICB2YXIgdGVtcGxhdGUgPSBuZXcgVXJpVGVtcGxhdGUobGRvLmhyZWYpO1xuICAgICAgICAgICAgdmFyIGFsbFByZXNlbnQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0ZW1wbGF0ZS52YXJOYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlmICghKHRlbXBsYXRlLnZhck5hbWVzW2pdIGluIGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbFByZXNlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFsbFByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2NoZW1hVXJsID0gdGVtcGxhdGUuZmlsbEZyb21PYmplY3QoZGF0YSk7XG4gICAgICAgICAgICAgICAgdmFyIHN1YlNjaGVtYSA9IHtcIiRyZWZcIjogc2NoZW1hVXJsfTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPSB0aGlzLnZhbGlkYXRlQWxsKGRhdGEsIHN1YlNjaGVtYSwgW10sIFtcImxpbmtzXCIsIGldLCBkYXRhUG9pbnRlclBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLyBwYXJzZVVSSSgpIGFuZCByZXNvbHZlVXJsKCkgYXJlIGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMTA4ODg1MFxuLy8gICAtICByZWxlYXNlZCBhcyBwdWJsaWMgZG9tYWluIGJ5IGF1dGhvciAoXCJZYWZmbGVcIikgLSBzZWUgY29tbWVudHMgb24gZ2lzdFxuXG5mdW5jdGlvbiBwYXJzZVVSSSh1cmwpIHtcbiAgICB2YXIgbSA9IFN0cmluZyh1cmwpLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKS5tYXRjaCgvXihbXjpcXC8/I10rOik/KFxcL1xcLyg/OlteOkBdKig/OjpbXjpAXSopP0ApPygoW146XFwvPyNdKikoPzo6KFxcZCopKT8pKT8oW14/I10qKShcXD9bXiNdKik/KCNbXFxzXFxTXSopPy8pO1xuICAgIC8vIGF1dGhvcml0eSA9ICcvLycgKyB1c2VyICsgJzonICsgcGFzcyAnQCcgKyBob3N0bmFtZSArICc6JyBwb3J0XG4gICAgcmV0dXJuIChtID8ge1xuICAgICAgICBocmVmOiBtWzBdIHx8ICcnLFxuICAgICAgICBwcm90b2NvbDogbVsxXSB8fCAnJyxcbiAgICAgICAgYXV0aG9yaXR5OiBtWzJdIHx8ICcnLFxuICAgICAgICBob3N0OiBtWzNdIHx8ICcnLFxuICAgICAgICBob3N0bmFtZTogbVs0XSB8fCAnJyxcbiAgICAgICAgcG9ydDogbVs1XSB8fCAnJyxcbiAgICAgICAgcGF0aG5hbWU6IG1bNl0gfHwgJycsXG4gICAgICAgIHNlYXJjaDogbVs3XSB8fCAnJyxcbiAgICAgICAgaGFzaDogbVs4XSB8fCAnJ1xuICAgIH0gOiBudWxsKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVVybChiYXNlLCBocmVmKSB7Ly8gUkZDIDM5ODZcblxuICAgIGZ1bmN0aW9uIHJlbW92ZURvdFNlZ21lbnRzKGlucHV0KSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgICAgaW5wdXQucmVwbGFjZSgvXihcXC5cXC4/KFxcL3wkKSkrLywgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwvKFxcLihcXC98JCkpKy9nLCAnLycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwvXFwuXFwuJC8sICcvLi4vJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXC8/W15cXC9dKi9nLCBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgIGlmIChwID09PSAnLy4uJykge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucG9wKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gocCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQuam9pbignJykucmVwbGFjZSgvXlxcLy8sIGlucHV0LmNoYXJBdCgwKSA9PT0gJy8nID8gJy8nIDogJycpO1xuICAgIH1cblxuICAgIGhyZWYgPSBwYXJzZVVSSShocmVmIHx8ICcnKTtcbiAgICBiYXNlID0gcGFyc2VVUkkoYmFzZSB8fCAnJyk7XG5cbiAgICByZXR1cm4gIWhyZWYgfHwgIWJhc2UgPyBudWxsIDogKGhyZWYucHJvdG9jb2wgfHwgYmFzZS5wcm90b2NvbCkgK1xuICAgIChocmVmLnByb3RvY29sIHx8IGhyZWYuYXV0aG9yaXR5ID8gaHJlZi5hdXRob3JpdHkgOiBiYXNlLmF1dGhvcml0eSkgK1xuICAgIHJlbW92ZURvdFNlZ21lbnRzKGhyZWYucHJvdG9jb2wgfHwgaHJlZi5hdXRob3JpdHkgfHwgaHJlZi5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyA/IGhyZWYucGF0aG5hbWUgOiAoaHJlZi5wYXRobmFtZSA/ICgoYmFzZS5hdXRob3JpdHkgJiYgIWJhc2UucGF0aG5hbWUgPyAnLycgOiAnJykgKyBiYXNlLnBhdGhuYW1lLnNsaWNlKDAsIGJhc2UucGF0aG5hbWUubGFzdEluZGV4T2YoJy8nKSArIDEpICsgaHJlZi5wYXRobmFtZSkgOiBiYXNlLnBhdGhuYW1lKSkgK1xuICAgIChocmVmLnByb3RvY29sIHx8IGhyZWYuYXV0aG9yaXR5IHx8IGhyZWYucGF0aG5hbWUgPyBocmVmLnNlYXJjaCA6IChocmVmLnNlYXJjaCB8fCBiYXNlLnNlYXJjaCkpICtcbiAgICBocmVmLmhhc2g7XG59XG5cbmZ1bmN0aW9uIGdldERvY3VtZW50VXJpKHVyaSkge1xuICAgIHJldHVybiB1cmkuc3BsaXQoJyMnKVswXTtcbn1cblxuZnVuY3Rpb24gbm9ybVNjaGVtYShzY2hlbWEsIGJhc2VVcmkpIHtcbiAgICBpZiAoc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKGJhc2VVcmkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYmFzZVVyaSA9IHNjaGVtYS5pZDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2NoZW1hLmlkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBiYXNlVXJpID0gcmVzb2x2ZVVybChiYXNlVXJpLCBzY2hlbWEuaWQpO1xuICAgICAgICAgICAgc2NoZW1hLmlkID0gYmFzZVVyaTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNjaGVtYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG5vcm1TY2hlbWEoc2NoZW1hW2ldLCBiYXNlVXJpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hWyckcmVmJ10gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBzY2hlbWFbJyRyZWYnXSA9IHJlc29sdmVVcmwoYmFzZVVyaSwgc2NoZW1hWyckcmVmJ10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09IFwiZW51bVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1TY2hlbWEoc2NoZW1hW2tleV0sIGJhc2VVcmkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdEVycm9yUmVwb3J0ZXIobGFuZ3VhZ2UpIHtcbiAgICBsYW5ndWFnZSA9IGxhbmd1YWdlIHx8ICdlbic7XG5cbiAgICB2YXIgZXJyb3JNZXNzYWdlcyA9IGxhbmd1YWdlc1tsYW5ndWFnZV07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHZhciBtZXNzYWdlVGVtcGxhdGUgPSBlcnJvck1lc3NhZ2VzW2Vycm9yLmNvZGVdIHx8IEVycm9yTWVzc2FnZXNEZWZhdWx0W2Vycm9yLmNvZGVdO1xuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2VUZW1wbGF0ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlVua25vd24gZXJyb3IgY29kZSBcIiArIGVycm9yLmNvZGUgKyBcIjogXCIgKyBKU09OLnN0cmluZ2lmeShlcnJvci5tZXNzYWdlUGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWVzc2FnZVBhcmFtcyA9IGVycm9yLnBhcmFtcztcbiAgICAgICAgLy8gQWRhcHRlZCBmcm9tIENyb2NrZm9yZCdzIHN1cHBsYW50KClcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VUZW1wbGF0ZS5yZXBsYWNlKC9cXHsoW157fV0qKVxcfS9nLCBmdW5jdGlvbiAod2hvbGUsIHZhck5hbWUpIHtcbiAgICAgICAgICAgIHZhciBzdWJWYWx1ZSA9IG1lc3NhZ2VQYXJhbXNbdmFyTmFtZV07XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHN1YlZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2Ygc3ViVmFsdWUgPT09ICdudW1iZXInID8gc3ViVmFsdWUgOiB3aG9sZTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cblxudmFyIEVycm9yQ29kZXMgPSB7XG4gICAgSU5WQUxJRF9UWVBFOiAwLFxuICAgIEVOVU1fTUlTTUFUQ0g6IDEsXG4gICAgQU5ZX09GX01JU1NJTkc6IDEwLFxuICAgIE9ORV9PRl9NSVNTSU5HOiAxMSxcbiAgICBPTkVfT0ZfTVVMVElQTEU6IDEyLFxuICAgIE5PVF9QQVNTRUQ6IDEzLFxuICAgIC8vIE51bWVyaWMgZXJyb3JzXG4gICAgTlVNQkVSX01VTFRJUExFX09GOiAxMDAsXG4gICAgTlVNQkVSX01JTklNVU06IDEwMSxcbiAgICBOVU1CRVJfTUlOSU1VTV9FWENMVVNJVkU6IDEwMixcbiAgICBOVU1CRVJfTUFYSU1VTTogMTAzLFxuICAgIE5VTUJFUl9NQVhJTVVNX0VYQ0xVU0lWRTogMTA0LFxuICAgIE5VTUJFUl9OT1RfQV9OVU1CRVI6IDEwNSxcbiAgICAvLyBTdHJpbmcgZXJyb3JzXG4gICAgU1RSSU5HX0xFTkdUSF9TSE9SVDogMjAwLFxuICAgIFNUUklOR19MRU5HVEhfTE9ORzogMjAxLFxuICAgIFNUUklOR19QQVRURVJOOiAyMDIsXG4gICAgLy8gT2JqZWN0IGVycm9yc1xuICAgIE9CSkVDVF9QUk9QRVJUSUVTX01JTklNVU06IDMwMCxcbiAgICBPQkpFQ1RfUFJPUEVSVElFU19NQVhJTVVNOiAzMDEsXG4gICAgT0JKRUNUX1JFUVVJUkVEOiAzMDIsXG4gICAgT0JKRUNUX0FERElUSU9OQUxfUFJPUEVSVElFUzogMzAzLFxuICAgIE9CSkVDVF9ERVBFTkRFTkNZX0tFWTogMzA0LFxuICAgIC8vIEFycmF5IGVycm9yc1xuICAgIEFSUkFZX0xFTkdUSF9TSE9SVDogNDAwLFxuICAgIEFSUkFZX0xFTkdUSF9MT05HOiA0MDEsXG4gICAgQVJSQVlfVU5JUVVFOiA0MDIsXG4gICAgQVJSQVlfQURESVRJT05BTF9JVEVNUzogNDAzLFxuICAgIC8vIEN1c3RvbS91c2VyLWRlZmluZWQgZXJyb3JzXG4gICAgRk9STUFUX0NVU1RPTTogNTAwLFxuICAgIEtFWVdPUkRfQ1VTVE9NOiA1MDEsXG4gICAgLy8gU2NoZW1hIHN0cnVjdHVyZVxuICAgIENJUkNVTEFSX1JFRkVSRU5DRTogNjAwLFxuICAgIC8vIE5vbi1zdGFuZGFyZCB2YWxpZGF0aW9uIG9wdGlvbnNcbiAgICBVTktOT1dOX1BST1BFUlRZOiAxMDAwXG59O1xudmFyIEVycm9yQ29kZUxvb2t1cCA9IHt9O1xuZm9yICh2YXIga2V5IGluIEVycm9yQ29kZXMpIHtcbiAgICBFcnJvckNvZGVMb29rdXBbRXJyb3JDb2Rlc1trZXldXSA9IGtleTtcbn1cbnZhciBFcnJvck1lc3NhZ2VzRGVmYXVsdCA9IHtcbiAgICBJTlZBTElEX1RZUEU6IFwiSW52YWxpZCB0eXBlOiB7dHlwZX0gKGV4cGVjdGVkIHtleHBlY3RlZH0pXCIsXG4gICAgRU5VTV9NSVNNQVRDSDogXCJObyBlbnVtIG1hdGNoIGZvcjoge3ZhbHVlfVwiLFxuICAgIEFOWV9PRl9NSVNTSU5HOiBcIkRhdGEgZG9lcyBub3QgbWF0Y2ggYW55IHNjaGVtYXMgZnJvbSBcXFwiYW55T2ZcXFwiXCIsXG4gICAgT05FX09GX01JU1NJTkc6IFwiRGF0YSBkb2VzIG5vdCBtYXRjaCBhbnkgc2NoZW1hcyBmcm9tIFxcXCJvbmVPZlxcXCJcIixcbiAgICBPTkVfT0ZfTVVMVElQTEU6IFwiRGF0YSBpcyB2YWxpZCBhZ2FpbnN0IG1vcmUgdGhhbiBvbmUgc2NoZW1hIGZyb20gXFxcIm9uZU9mXFxcIjogaW5kaWNlcyB7aW5kZXgxfSBhbmQge2luZGV4Mn1cIixcbiAgICBOT1RfUEFTU0VEOiBcIkRhdGEgbWF0Y2hlcyBzY2hlbWEgZnJvbSBcXFwibm90XFxcIlwiLFxuICAgIC8vIE51bWVyaWMgZXJyb3JzXG4gICAgTlVNQkVSX01VTFRJUExFX09GOiBcIlZhbHVlIHt2YWx1ZX0gaXMgbm90IGEgbXVsdGlwbGUgb2Yge211bHRpcGxlT2Z9XCIsXG4gICAgTlVNQkVSX01JTklNVU06IFwiVmFsdWUge3ZhbHVlfSBpcyBsZXNzIHRoYW4gbWluaW11bSB7bWluaW11bX1cIixcbiAgICBOVU1CRVJfTUlOSU1VTV9FWENMVVNJVkU6IFwiVmFsdWUge3ZhbHVlfSBpcyBlcXVhbCB0byBleGNsdXNpdmUgbWluaW11bSB7bWluaW11bX1cIixcbiAgICBOVU1CRVJfTUFYSU1VTTogXCJWYWx1ZSB7dmFsdWV9IGlzIGdyZWF0ZXIgdGhhbiBtYXhpbXVtIHttYXhpbXVtfVwiLFxuICAgIE5VTUJFUl9NQVhJTVVNX0VYQ0xVU0lWRTogXCJWYWx1ZSB7dmFsdWV9IGlzIGVxdWFsIHRvIGV4Y2x1c2l2ZSBtYXhpbXVtIHttYXhpbXVtfVwiLFxuICAgIE5VTUJFUl9OT1RfQV9OVU1CRVI6IFwiVmFsdWUge3ZhbHVlfSBpcyBub3QgYSB2YWxpZCBudW1iZXJcIixcbiAgICAvLyBTdHJpbmcgZXJyb3JzXG4gICAgU1RSSU5HX0xFTkdUSF9TSE9SVDogXCJTdHJpbmcgaXMgdG9vIHNob3J0ICh7bGVuZ3RofSBjaGFycyksIG1pbmltdW0ge21pbmltdW19XCIsXG4gICAgU1RSSU5HX0xFTkdUSF9MT05HOiBcIlN0cmluZyBpcyB0b28gbG9uZyAoe2xlbmd0aH0gY2hhcnMpLCBtYXhpbXVtIHttYXhpbXVtfVwiLFxuICAgIFNUUklOR19QQVRURVJOOiBcIlN0cmluZyBkb2VzIG5vdCBtYXRjaCBwYXR0ZXJuOiB7cGF0dGVybn1cIixcbiAgICAvLyBPYmplY3QgZXJyb3JzXG4gICAgT0JKRUNUX1BST1BFUlRJRVNfTUlOSU1VTTogXCJUb28gZmV3IHByb3BlcnRpZXMgZGVmaW5lZCAoe3Byb3BlcnR5Q291bnR9KSwgbWluaW11bSB7bWluaW11bX1cIixcbiAgICBPQkpFQ1RfUFJPUEVSVElFU19NQVhJTVVNOiBcIlRvbyBtYW55IHByb3BlcnRpZXMgZGVmaW5lZCAoe3Byb3BlcnR5Q291bnR9KSwgbWF4aW11bSB7bWF4aW11bX1cIixcbiAgICBPQkpFQ1RfUkVRVUlSRUQ6IFwiTWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eToge2tleX1cIixcbiAgICBPQkpFQ1RfQURESVRJT05BTF9QUk9QRVJUSUVTOiBcIkFkZGl0aW9uYWwgcHJvcGVydGllcyBub3QgYWxsb3dlZFwiLFxuICAgIE9CSkVDVF9ERVBFTkRFTkNZX0tFWTogXCJEZXBlbmRlbmN5IGZhaWxlZCAtIGtleSBtdXN0IGV4aXN0OiB7bWlzc2luZ30gKGR1ZSB0byBrZXk6IHtrZXl9KVwiLFxuICAgIC8vIEFycmF5IGVycm9yc1xuICAgIEFSUkFZX0xFTkdUSF9TSE9SVDogXCJBcnJheSBpcyB0b28gc2hvcnQgKHtsZW5ndGh9KSwgbWluaW11bSB7bWluaW11bX1cIixcbiAgICBBUlJBWV9MRU5HVEhfTE9ORzogXCJBcnJheSBpcyB0b28gbG9uZyAoe2xlbmd0aH0pLCBtYXhpbXVtIHttYXhpbXVtfVwiLFxuICAgIEFSUkFZX1VOSVFVRTogXCJBcnJheSBpdGVtcyBhcmUgbm90IHVuaXF1ZSAoaW5kaWNlcyB7bWF0Y2gxfSBhbmQge21hdGNoMn0pXCIsXG4gICAgQVJSQVlfQURESVRJT05BTF9JVEVNUzogXCJBZGRpdGlvbmFsIGl0ZW1zIG5vdCBhbGxvd2VkXCIsXG4gICAgLy8gRm9ybWF0IGVycm9yc1xuICAgIEZPUk1BVF9DVVNUT006IFwiRm9ybWF0IHZhbGlkYXRpb24gZmFpbGVkICh7bWVzc2FnZX0pXCIsXG4gICAgS0VZV09SRF9DVVNUT006IFwiS2V5d29yZCBmYWlsZWQ6IHtrZXl9ICh7bWVzc2FnZX0pXCIsXG4gICAgLy8gU2NoZW1hIHN0cnVjdHVyZVxuICAgIENJUkNVTEFSX1JFRkVSRU5DRTogXCJDaXJjdWxhciAkcmVmczoge3VybHN9XCIsXG4gICAgLy8gTm9uLXN0YW5kYXJkIHZhbGlkYXRpb24gb3B0aW9uc1xuICAgIFVOS05PV05fUFJPUEVSVFk6IFwiVW5rbm93biBwcm9wZXJ0eSAobm90IGluIHNjaGVtYSlcIlxufTtcblxuZnVuY3Rpb24gVmFsaWRhdGlvbkVycm9yKGNvZGUsIHBhcmFtcywgZGF0YVBhdGgsIHNjaGVtYVBhdGgsIHN1YkVycm9ycykge1xuICAgIEVycm9yLmNhbGwodGhpcyk7XG4gICAgaWYgKGNvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBlcnJvciBjb2RlIHN1cHBsaWVkOiBcIiArIHNjaGVtYVBhdGgpO1xuICAgIH1cbiAgICB0aGlzLm1lc3NhZ2UgPSAnJztcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMuZGF0YVBhdGggPSBkYXRhUGF0aCB8fCBcIlwiO1xuICAgIHRoaXMuc2NoZW1hUGF0aCA9IHNjaGVtYVBhdGggfHwgXCJcIjtcbiAgICB0aGlzLnN1YkVycm9ycyA9IHN1YkVycm9ycyB8fCBudWxsO1xuXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcih0aGlzLm1lc3NhZ2UpO1xuICAgIHRoaXMuc3RhY2sgPSBlcnIuc3RhY2sgfHwgZXJyLnN0YWNrdHJhY2U7XG4gICAgaWYgKCF0aGlzLnN0YWNrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5zdGFjayA9IGVyci5zdGFjayB8fCBlcnIuc3RhY2t0cmFjZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblZhbGlkYXRpb25FcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBWYWxpZGF0aW9uRXJyb3I7XG5WYWxpZGF0aW9uRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnVmFsaWRhdGlvbkVycm9yJztcblxuVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZS5wcmVmaXhXaXRoID0gZnVuY3Rpb24gKGRhdGFQcmVmaXgsIHNjaGVtYVByZWZpeCkge1xuICAgIGlmIChkYXRhUHJlZml4ICE9PSBudWxsKSB7XG4gICAgICAgIGRhdGFQcmVmaXggPSBkYXRhUHJlZml4LnJlcGxhY2UoL34vZywgXCJ+MFwiKS5yZXBsYWNlKC9cXC8vZywgXCJ+MVwiKTtcbiAgICAgICAgdGhpcy5kYXRhUGF0aCA9IFwiL1wiICsgZGF0YVByZWZpeCArIHRoaXMuZGF0YVBhdGg7XG4gICAgfVxuICAgIGlmIChzY2hlbWFQcmVmaXggIT09IG51bGwpIHtcbiAgICAgICAgc2NoZW1hUHJlZml4ID0gc2NoZW1hUHJlZml4LnJlcGxhY2UoL34vZywgXCJ+MFwiKS5yZXBsYWNlKC9cXC8vZywgXCJ+MVwiKTtcbiAgICAgICAgdGhpcy5zY2hlbWFQYXRoID0gXCIvXCIgKyBzY2hlbWFQcmVmaXggKyB0aGlzLnNjaGVtYVBhdGg7XG4gICAgfVxuICAgIGlmICh0aGlzLnN1YkVycm9ycyAhPT0gbnVsbCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3ViRXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnN1YkVycm9yc1tpXS5wcmVmaXhXaXRoKGRhdGFQcmVmaXgsIHNjaGVtYVByZWZpeCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBpc1RydXN0ZWRVcmwoYmFzZVVybCwgdGVzdFVybCkge1xuICAgIGlmICh0ZXN0VXJsLnN1YnN0cmluZygwLCBiYXNlVXJsLmxlbmd0aCkgPT09IGJhc2VVcmwpIHtcbiAgICAgICAgdmFyIHJlbWFpbmRlciA9IHRlc3RVcmwuc3Vic3RyaW5nKGJhc2VVcmwubGVuZ3RoKTtcbiAgICAgICAgaWYgKCh0ZXN0VXJsLmxlbmd0aCA+IDAgJiYgdGVzdFVybC5jaGFyQXQoYmFzZVVybC5sZW5ndGggLSAxKSA9PT0gXCIvXCIpXG4gICAgICAgICAgICB8fCByZW1haW5kZXIuY2hhckF0KDApID09PSBcIiNcIlxuICAgICAgICAgICAgfHwgcmVtYWluZGVyLmNoYXJBdCgwKSA9PT0gXCI/XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGxhbmd1YWdlcyA9IHt9O1xuXG5mdW5jdGlvbiBjcmVhdGVBcGkobGFuZ3VhZ2UpIHtcbiAgICB2YXIgZ2xvYmFsQ29udGV4dCA9IG5ldyBWYWxpZGF0b3JDb250ZXh0KCk7XG4gICAgdmFyIGN1cnJlbnRMYW5ndWFnZTtcbiAgICB2YXIgY3VzdG9tRXJyb3JSZXBvcnRlcjtcbiAgICB2YXIgYXBpID0ge1xuICAgICAgICBzZXRFcnJvclJlcG9ydGVyOiBmdW5jdGlvbiAocmVwb3J0ZXIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVwb3J0ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFuZ3VhZ2UocmVwb3J0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VzdG9tRXJyb3JSZXBvcnRlciA9IHJlcG9ydGVyO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZEZvcm1hdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZ2xvYmFsQ29udGV4dC5hZGRGb3JtYXQuYXBwbHkoZ2xvYmFsQ29udGV4dCwgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgbGFuZ3VhZ2U6IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudExhbmd1YWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFsYW5ndWFnZXNbY29kZV0pIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gY29kZS5zcGxpdCgnLScpWzBdOyAvLyBmYWxsIGJhY2sgdG8gYmFzZSBsYW5ndWFnZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhbmd1YWdlc1tjb2RlXSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMYW5ndWFnZSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGU7IC8vIHNvIHlvdSBjYW4gdGVsbCBpZiBmYWxsLWJhY2sgaGFzIGhhcHBlbmVkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZExhbmd1YWdlOiBmdW5jdGlvbiAoY29kZSwgbWVzc2FnZU1hcCkge1xuICAgICAgICAgICAgdmFyIGtleTtcbiAgICAgICAgICAgIGZvciAoa2V5IGluIEVycm9yQ29kZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZU1hcFtrZXldICYmICFtZXNzYWdlTWFwW0Vycm9yQ29kZXNba2V5XV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZU1hcFtFcnJvckNvZGVzW2tleV1dID0gbWVzc2FnZU1hcFtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByb290Q29kZSA9IGNvZGUuc3BsaXQoJy0nKVswXTtcbiAgICAgICAgICAgIGlmICghbGFuZ3VhZ2VzW3Jvb3RDb2RlXSkgeyAvLyB1c2UgZm9yIGJhc2UgbGFuZ3VhZ2UgaWYgbm90IHlldCBkZWZpbmVkXG4gICAgICAgICAgICAgICAgbGFuZ3VhZ2VzW2NvZGVdID0gbWVzc2FnZU1hcDtcbiAgICAgICAgICAgICAgICBsYW5ndWFnZXNbcm9vdENvZGVdID0gbWVzc2FnZU1hcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFuZ3VhZ2VzW2NvZGVdID0gT2JqZWN0LmNyZWF0ZShsYW5ndWFnZXNbcm9vdENvZGVdKTtcbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBtZXNzYWdlTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGFuZ3VhZ2VzW3Jvb3RDb2RlXVtrZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2VzW3Jvb3RDb2RlXVtrZXldID0gbWVzc2FnZU1hcFtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlc1tjb2RlXVtrZXldID0gbWVzc2FnZU1hcFtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBmcmVzaEFwaTogZnVuY3Rpb24gKGxhbmd1YWdlKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlQXBpKCk7XG4gICAgICAgICAgICBpZiAobGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQubGFuZ3VhZ2UobGFuZ3VhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChkYXRhLCBzY2hlbWEsIGNoZWNrUmVjdXJzaXZlLCBiYW5Vbmtub3duUHJvcGVydGllcykge1xuICAgICAgICAgICAgdmFyIGRlZiA9IGRlZmF1bHRFcnJvclJlcG9ydGVyKGN1cnJlbnRMYW5ndWFnZSk7XG4gICAgICAgICAgICB2YXIgZXJyb3JSZXBvcnRlciA9IGN1c3RvbUVycm9yUmVwb3J0ZXIgPyBmdW5jdGlvbiAoZXJyb3IsIGRhdGEsIHNjaGVtYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXN0b21FcnJvclJlcG9ydGVyKGVycm9yLCBkYXRhLCBzY2hlbWEpIHx8IGRlZihlcnJvciwgZGF0YSwgc2NoZW1hKTtcbiAgICAgICAgICAgIH0gOiBkZWY7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IG5ldyBWYWxpZGF0b3JDb250ZXh0KGdsb2JhbENvbnRleHQsIGZhbHNlLCBlcnJvclJlcG9ydGVyLCBjaGVja1JlY3Vyc2l2ZSwgYmFuVW5rbm93blByb3BlcnRpZXMpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBzY2hlbWEgPSB7XCIkcmVmXCI6IHNjaGVtYX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0LmFkZFNjaGVtYShcIlwiLCBzY2hlbWEpO1xuICAgICAgICAgICAgdmFyIGVycm9yID0gY29udGV4dC52YWxpZGF0ZUFsbChkYXRhLCBzY2hlbWEsIG51bGwsIG51bGwsIFwiXCIpO1xuICAgICAgICAgICAgaWYgKCFlcnJvciAmJiBiYW5Vbmtub3duUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGVycm9yID0gY29udGV4dC5iYW5Vbmtub3duUHJvcGVydGllcyhkYXRhLCBzY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgdGhpcy5taXNzaW5nID0gY29udGV4dC5taXNzaW5nO1xuICAgICAgICAgICAgdGhpcy52YWxpZCA9IChlcnJvciA9PT0gbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWxpZDtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdGVSZXN1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGUuYXBwbHkocmVzdWx0LCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdGVNdWx0aXBsZTogZnVuY3Rpb24gKGRhdGEsIHNjaGVtYSwgY2hlY2tSZWN1cnNpdmUsIGJhblVua25vd25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB2YXIgZGVmID0gZGVmYXVsdEVycm9yUmVwb3J0ZXIoY3VycmVudExhbmd1YWdlKTtcbiAgICAgICAgICAgIHZhciBlcnJvclJlcG9ydGVyID0gY3VzdG9tRXJyb3JSZXBvcnRlciA/IGZ1bmN0aW9uIChlcnJvciwgZGF0YSwgc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1c3RvbUVycm9yUmVwb3J0ZXIoZXJyb3IsIGRhdGEsIHNjaGVtYSkgfHwgZGVmKGVycm9yLCBkYXRhLCBzY2hlbWEpO1xuICAgICAgICAgICAgfSA6IGRlZjtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gbmV3IFZhbGlkYXRvckNvbnRleHQoZ2xvYmFsQ29udGV4dCwgdHJ1ZSwgZXJyb3JSZXBvcnRlciwgY2hlY2tSZWN1cnNpdmUsIGJhblVua25vd25Qcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hID0ge1wiJHJlZlwiOiBzY2hlbWF9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5hZGRTY2hlbWEoXCJcIiwgc2NoZW1hKTtcbiAgICAgICAgICAgIGNvbnRleHQudmFsaWRhdGVBbGwoZGF0YSwgc2NoZW1hLCBudWxsLCBudWxsLCBcIlwiKTtcbiAgICAgICAgICAgIGlmIChiYW5Vbmtub3duUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuYmFuVW5rbm93blByb3BlcnRpZXMoZGF0YSwgc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMgPSBjb250ZXh0LmVycm9ycztcbiAgICAgICAgICAgIHJlc3VsdC5taXNzaW5nID0gY29udGV4dC5taXNzaW5nO1xuICAgICAgICAgICAgcmVzdWx0LnZhbGlkID0gKHJlc3VsdC5lcnJvcnMubGVuZ3RoID09PSAwKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZFNjaGVtYTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbENvbnRleHQuYWRkU2NoZW1hLmFwcGx5KGdsb2JhbENvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFNjaGVtYTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbENvbnRleHQuZ2V0U2NoZW1hLmFwcGx5KGdsb2JhbENvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFNjaGVtYU1hcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbENvbnRleHQuZ2V0U2NoZW1hTWFwLmFwcGx5KGdsb2JhbENvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFNjaGVtYVVyaXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxDb250ZXh0LmdldFNjaGVtYVVyaXMuYXBwbHkoZ2xvYmFsQ29udGV4dCwgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TWlzc2luZ1VyaXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxDb250ZXh0LmdldE1pc3NpbmdVcmlzLmFwcGx5KGdsb2JhbENvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIGRyb3BTY2hlbWFzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBnbG9iYWxDb250ZXh0LmRyb3BTY2hlbWFzLmFwcGx5KGdsb2JhbENvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlZmluZUtleXdvcmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGdsb2JhbENvbnRleHQuZGVmaW5lS2V5d29yZC5hcHBseShnbG9iYWxDb250ZXh0LCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuICAgICAgICBkZWZpbmVFcnJvcjogZnVuY3Rpb24gKGNvZGVOYW1lLCBjb2RlTnVtYmVyLCBkZWZhdWx0TWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb2RlTmFtZSAhPT0gJ3N0cmluZycgfHwgIS9eW0EtWl0rKF9bQS1aXSspKiQvLnRlc3QoY29kZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb2RlIG5hbWUgbXVzdCBiZSBhIHN0cmluZyBpbiBVUFBFUl9DQVNFX1dJVEhfVU5ERVJTQ09SRVMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29kZU51bWJlciAhPT0gJ251bWJlcicgfHwgY29kZU51bWJlciAlIDEgIT09IDAgfHwgY29kZU51bWJlciA8IDEwMDAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb2RlIG51bWJlciBtdXN0IGJlIGFuIGludGVnZXIgPiAxMDAwMCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBFcnJvckNvZGVzW2NvZGVOYW1lXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGFscmVhZHkgZGVmaW5lZDogJyArIGNvZGVOYW1lICsgJyBhcyAnICsgRXJyb3JDb2Rlc1tjb2RlTmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBFcnJvckNvZGVMb29rdXBbY29kZU51bWJlcl0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBjb2RlIGFscmVhZHkgdXNlZDogJyArIEVycm9yQ29kZUxvb2t1cFtjb2RlTnVtYmVyXSArICcgYXMgJyArIGNvZGVOdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgRXJyb3JDb2Rlc1tjb2RlTmFtZV0gPSBjb2RlTnVtYmVyO1xuICAgICAgICAgICAgRXJyb3JDb2RlTG9va3VwW2NvZGVOdW1iZXJdID0gY29kZU5hbWU7XG4gICAgICAgICAgICBFcnJvck1lc3NhZ2VzRGVmYXVsdFtjb2RlTmFtZV0gPSBFcnJvck1lc3NhZ2VzRGVmYXVsdFtjb2RlTnVtYmVyXSA9IGRlZmF1bHRNZXNzYWdlO1xuICAgICAgICAgICAgZm9yICh2YXIgbGFuZ0NvZGUgaW4gbGFuZ3VhZ2VzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhbmd1YWdlID0gbGFuZ3VhZ2VzW2xhbmdDb2RlXTtcbiAgICAgICAgICAgICAgICBpZiAobGFuZ3VhZ2VbY29kZU5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlW2NvZGVOdW1iZXJdID0gbGFuZ3VhZ2VbY29kZU51bWJlcl0gfHwgbGFuZ3VhZ2VbY29kZU5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGdsb2JhbENvbnRleHQucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5taXNzaW5nID0gW107XG4gICAgICAgICAgICB0aGlzLnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgbWlzc2luZzogW10sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICB2YWxpZDogdHJ1ZSxcbiAgICAgICAgbm9ybVNjaGVtYTogbm9ybVNjaGVtYSxcbiAgICAgICAgcmVzb2x2ZVVybDogcmVzb2x2ZVVybCxcbiAgICAgICAgZ2V0RG9jdW1lbnRVcmk6IGdldERvY3VtZW50VXJpLFxuICAgICAgICBlcnJvckNvZGVzOiBFcnJvckNvZGVzXG4gICAgfTtcbiAgICBhcGkubGFuZ3VhZ2UobGFuZ3VhZ2UgfHwgJ2VuJyk7XG4gICAgcmV0dXJuIGFwaTtcbn1cblxuLy9leHBvcnQgZnVuY3Rpb24gdmFsaWRhdG9yKCkge1xudmFyIHR2NCA9IGNyZWF0ZUFwaSgpO1xudHY0LmFkZExhbmd1YWdlKCdlbi1nYicsIEVycm9yTWVzc2FnZXNEZWZhdWx0KTtcblxuLy9sZWdhY3kgcHJvcGVydHlcbnR2NC50djQgPSB0djQ7XG4vL3JldHVybiB0djQ7XG5leHBvcnQgZGVmYXVsdCB0djQ7XG4vL30iLCIvKipcbiogQ29weXJpZ2h0IDIwMTYgUFQgSW5vdmHDp8OjbyBlIFNpc3RlbWFzIFNBXG4qIENvcHlyaWdodCAyMDE2IElORVNDLUlEXG4qIENvcHlyaWdodCAyMDE2IFFVT0JJUyBORVRXT1JLUyBTTFxuKiBDb3B5cmlnaHQgMjAxNiBGUkFVTkhPRkVSLUdFU0VMTFNDSEFGVCBaVVIgRk9FUkRFUlVORyBERVIgQU5HRVdBTkRURU4gRk9SU0NIVU5HIEUuVlxuKiBDb3B5cmlnaHQgMjAxNiBPUkFOR0UgU0FcbiogQ29weXJpZ2h0IDIwMTYgRGV1dHNjaGUgVGVsZWtvbSBBR1xuKiBDb3B5cmlnaHQgMjAxNiBBcGl6ZWVcbiogQ29weXJpZ2h0IDIwMTYgVEVDSE5JU0NIRSBVTklWRVJTSVRBVCBCRVJMSU5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKiovXG4vKipcbiAqIFN1cHBvcnQgbW9kdWxlIHdpdGggc29tZSBmdW5jdGlvbnMgd2lsbCBiZSB1c2VmdWxcbiAqIEBtb2R1bGUgdXRpbHNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIGRpdmlkZVVSTFxuICogQHR5cGUgT2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiBVUkxcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBvZiBVUkxcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZGVudGl0eSBUaGUgaWRlbnRpdHkgb2YgVVJMXG4gKi9cblxuLyoqXG4gKiBEaXZpZGUgYW4gdXJsIGluIHR5cGUsIGRvbWFpbiBhbmQgaWRlbnRpdHlcbiAqIEBwYXJhbSAge1VSTC5VUkx9IHVybCAtIHVybCBhZGRyZXNzXG4gKiBAcmV0dXJuIHtkaXZpZGVVUkx9IHRoZSByZXN1bHQgb2YgZGl2aWRlVVJMXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXZpZGVVUkwodXJsKSB7XG5cbiAgaWYgKCF1cmwpIHRocm93IEVycm9yKCdVUkwgaXMgbmVlZGVkIHRvIHNwbGl0Jyk7XG5cbiAgLy8gbGV0IHJlID0gLyhbYS16QS1aLV0qKT86XFwvXFwvKD86XFwuKT8oWy1hLXpBLVowLTlAOiUuX1xcK34jPV17MiwyNTZ9XFwuW2Etel17Miw2fVxcYikqKFxcL1tcXC9cXGRcXHdcXC4tXSopKig/OltcXD9dKSooLispKi9naTtcbiAgbGV0IHJlID0gLyhbYS16QS1aLV0qKTpcXC9cXC8oPzpcXC4pPyhbLWEtekEtWjAtOUA6JS5fXFwrfiM9XXsyLDI1Nn0pKFstYS16QS1aMC05QDolLl9cXCt+Iz1cXC9dKikvZ2k7XG4gIGxldCBzdWJzdCA9ICckMSwkMiwkMyc7XG4gIGxldCBwYXJ0cyA9IHVybC5yZXBsYWNlKHJlLCBzdWJzdCkuc3BsaXQoJywnKTtcblxuICAvLyBJZiB0aGUgdXJsIGhhcyBubyBwcm90b2NvbCwgdGhlIGRlZmF1bHQgcHJvdG9jb2wgc2V0IGlzIGh0dHBzXG4gIGlmIChwYXJ0c1swXSA9PT0gdXJsKSB7XG4gICAgcGFydHNbMF0gPSAnaHR0cHMnO1xuICAgIHBhcnRzWzFdID0gdXJsO1xuICB9XG5cbiAgbGV0IHJlc3VsdCA9IHtcbiAgICB0eXBlOiBwYXJ0c1swXSxcbiAgICBkb21haW46IHBhcnRzWzFdLFxuICAgIGlkZW50aXR5OiBwYXJ0c1syXVxuICB9O1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXZpZGVFbWFpbChlbWFpbCkge1xuICBsZXQgaW5kZXhPZkF0ID0gZW1haWwuaW5kZXhPZignQCcpO1xuXG4gIGxldCByZXN1bHQgPSB7XG4gICAgdXNlcm5hbWU6IGVtYWlsLnN1YnN0cmluZygwLCBpbmRleE9mQXQpLFxuICAgIGRvbWFpbjogZW1haWwuc3Vic3RyaW5nKGluZGV4T2ZBdCArIDEsIGVtYWlsLmxlbmd0aClcbiAgfTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIE9iamVjdCBpcyBlbXB0eVxuICogQHBhcmFtICB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGJlIGNoZWNrZWRcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgIHN0YXR1cyBvZiBPYmplY3QsIGVtcHR5IG9yIG5vdCAodHJ1ZXxmYWxzZSk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbXB0eU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCkubGVuZ3RoID4gMCA/IGZhbHNlIDogdHJ1ZTtcbn1cblxuLyoqXG4gKiBNYWtlIGEgQ09QWSBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICogQHBhcmFtICB7T2JqZWN0fSAgb2JqIC0gb2JqZWN0IHRvIGJlIGNsb25lZFxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVlcENsb25lKG9iaikge1xuICAvL1RPRE86IHNpbXBsZSBidXQgaW5lZmZpY2llbnQgSlNPTiBkZWVwIGNsb25lLi4uXG4gIGlmIChvYmopIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlUGF0aEZyb21VUkwodXJsKSB7XG4gIGxldCBzcGxpdFVSTCA9IHVybC5zcGxpdCgnLycpO1xuICByZXR1cm4gc3BsaXRVUkxbMF0gKyAnLy8nICsgc3BsaXRVUkxbMl0gKyAnLycgKyBzcGxpdFVSTFszXTtcbn1cblxuLyoqXG4gKiBPYnRhaW5zIHRoZSB1c2VyIFVSTCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEgZ2l2ZW4gZW1haWxcbiAqIEBwYXJhbSAge3N0cmluZ30gdXNlckVtYWlsIFRoZSB1c2VyIGVtYWlsXG4gKiBAcmV0dXJuIHtVUkwuVVJMfSB1c2VyVVJMIFRoZSB1c2VyIFVSTFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXNlclVSTEZyb21FbWFpbCh1c2VyRW1haWwpIHtcbiAgbGV0IGluZGV4T2ZBdCA9IHVzZXJFbWFpbC5pbmRleE9mKCdAJyk7XG4gIHJldHVybiAndXNlcjovLycgKyB1c2VyRW1haWwuc3Vic3RyaW5nKGluZGV4T2ZBdCArIDEsIHVzZXJFbWFpbC5sZW5ndGgpICsgJy8nICsgdXNlckVtYWlsLnN1YnN0cmluZygwLCBpbmRleE9mQXQpO1xufVxuXG4vKipcbiAqIE9idGFpbnMgdGhlIHVzZXIgZW1haWwgdGhhdCBjb3JyZXNwb25kcyB0byBhIGdpdmVuIFVSTFxuICogQHBhcmFtICB7VVJMLlVSTH0gdXNlclVSTCBUaGUgdXNlciBVUkxcbiAqIEByZXR1cm4ge3N0cmluZ30gdXNlckVtYWlsIFRoZSB1c2VyIGVtYWlsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVc2VyRW1haWxGcm9tVVJMKHVzZXJVUkwpIHtcbiAgbGV0IHVybCA9IGRpdmlkZVVSTCh1c2VyVVJMKTtcbiAgcmV0dXJuIHVybC5pZGVudGl0eS5yZXBsYWNlKCcvJywgJycpICsgJ0AnICsgdXJsLmRvbWFpbjsgLy8gaWRlbnRpdHkgZmllbGQgaGFzICcvZXhhbXBsZUlEJyBpbnN0ZWFkIG9mICdleGFtcGxlSUQnXG59XG5cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdXNlciBpZGVudGlmaWVyIGlzIGFscmVhZHkgaW4gdGhlIFVSTCBmb3JtYXQsIGlmIG5vdCwgY29udmVydCB0byBVUkwgZm9ybWF0XG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgaWRlbnRpZmllciAgdXNlciBpZGVudGlmaWVyXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgdXNlclVSTCAgICB0aGUgdXNlciBVUkxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb1VzZXJVUkwoaWRlbnRpZmllcikge1xuXG4gIC8vIGNoZWNrIGlmIHRoZSBpZGVudGlmaWVyIGlzIGFscmVhZHkgaW4gdGhlIHVybCBmb3JtYXRcbiAgaWYgKGlkZW50aWZpZXIuc3Vic3RyaW5nKDAsIDcpID09PSAndXNlcjovLycpIHtcbiAgICBsZXQgZGl2aWRlZFVSTCA9IGRpdmlkZVVSTChpZGVudGlmaWVyKTtcblxuICAgIC8vY2hlY2sgaWYgdGhlIHVybCBpcyB3ZWxsIGZvcm1hdGVkXG4gICAgaWYgKGRpdmlkZWRVUkwuZG9tYWluICYmIGRpdmlkZWRVUkwuaWRlbnRpdHkpIHtcbiAgICAgIHJldHVybiBpZGVudGlmaWVyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyAndXNlclVSTCB3aXRoIHdyb25nIGZvcm1hdCc7XG4gICAgfVxuXG4gIC8vaWYgbm90LCBjb252ZXJ0IHRoZSB1c2VyIGVtYWlsIHRvIFVSTCBmb3JtYXRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2V0VXNlclVSTEZyb21FbWFpbChpZGVudGlmaWVyKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEYXRhT2JqZWN0VVJMKHVybCkge1xuICBsZXQgc2NoZW1hc1RvSWdub3JlID0gWydkb21haW4taWRwJywgJ3J1bnRpbWUnLCAnZG9tYWluJywgJ2h5cGVydHknXTtcbiAgbGV0IHNwbGl0VVJMID0gKHVybCkuc3BsaXQoJzovLycpO1xuICBsZXQgdXJsU2NoZW1hID0gc3BsaXRVUkxbMF07XG5cbiAgcmV0dXJuIHNjaGVtYXNUb0lnbm9yZS5pbmRleE9mKHVybFNjaGVtYSkgPT09IC0xO1xufVxuXG4vKipcbiAqIGdldCBpbmZvcm1hdGlvbiByZWxhdGl2ZSBlYWNoIGNvbXBvbmVudCBjb25maWd1cmVkIG9uIHJ1bnRpbWUgY29uZmlndXJhdGlvbjtcbiAqIEBwYXJhbSAge29iamVjdH0gY29uZmlndXJhdGlvbiBvYmplY3Qgd2l0aCBhbGwgY29uZmlndXJhdGlvblxuICogQHBhcmFtICB7c3RyaW5nfSBjb21wb25lbnQgICAgIHN0cmluZyB3aXRoIHRoZSBjb21wb25lbnQgdG8gZ2V0IHRoZSBjb25maWd1cmF0aW9uLCBsaWtlLCBydW50aW1lVVJMUywgY2F0YWxvZ3VlVVJMcywgbXNnTm9kZVVSTCwgZG9tYWluUmVnaXN0cnlVUkw7XG4gKiBAcGFyYW0gIHtzdHJpbmd9IHJlc291cmNlICAgICAgdHlwZSBvZiByZXNvdXJjZSB0byBnZXQsIGxpa2UsIGNhdGFsb2d1ZSwgcnVudGltZVVBLCBwcm90b2NvbHN0dWIsIGlkcFByb3h5XG4gKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgICAgICAgcmV0dXJuIGFuIG9iamVjdCB3aXRoIGFsbCBjb25maWd1cmF0aW9ucztcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbmZpZ3VyYXRpb25SZXNvdXJjZXMoY29uZmlndXJhdGlvbiwgY29tcG9uZW50LCByZXNvdXJjZSkge1xuICBsZXQgb2JqZWN0UmVzb3VyY2UgPSBjb25maWd1cmF0aW9uW2NvbXBvbmVudF07XG4gIGxldCByZXNvdXJjZVR5cGUgPSBvYmplY3RSZXNvdXJjZVtyZXNvdXJjZV07XG5cbiAgcmV0dXJuIHJlc291cmNlVHlwZTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIGZ1bGwgdXJsIHdpdGggdGhlIHJ1bnRpbWUgY29uZmlndXJhdGlvbjtcbiAqIEBwYXJhbSAge29iamVjdH0gY29uZmlndXJhdGlvbiBvYmplY3Qgd2l0aCBhbGwgY29uZmlndXJhdGlvblxuICogQHBhcmFtICB7c3RyaW5nfSBjb21wb25lbnQgICAgIHN0cmluZyB3aXRoIHRoZSBjb21wb25lbnQgdG8gZ2V0IHRoZSBjb25maWd1cmF0aW9uLCBsaWtlLCBydW50aW1lVVJMUywgY2F0YWxvZ3VlVVJMcywgbXNnTm9kZVVSTCwgZG9tYWluUmVnaXN0cnlVUkw7XG4gKiBAcGFyYW0gIHtzdHJpbmd9IHJlc291cmNlICAgICAgdHlwZSBvZiByZXNvdXJjZSB0byBnZXQsIGxpa2UsIGNhdGFsb2d1ZSwgcnVudGltZVVBLCBwcm90b2NvbHN0dWIsIGlkcFByb3h5XG4gKiBAcGFyYW0gIHtzdHJpbmd9IHR5cGUgICAgICAgICAgcmVzb3VyY2UgdG8gZ2V0LCBsaWtlIGEgaHlwZXJ0eSBuYW1lIG9yIHByb3RvY29sc3R1YiBuYW1lO1xuICogQHBhcmFtICB7Ym9vbGVhbn0gdXNlRmFsbGJhY2sgIGlmIHRydWUgdGhlIGZ1bmN0aW9uIHdpbGwgY2hlY2sgaWYgaGF2ZSBhIGZhbGxiYWNrIHVybDtcbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgICAgICBwYXJ0aWFsIHVybCB0byBjb250YWN0IHRoZSByZXNvdXJjZTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkVVJMKGNvbmZpZ3VyYXRpb24sIGNvbXBvbmVudCwgcmVzb3VyY2UsIHR5cGUsIHVzZUZhbGxiYWNrID0gZmFsc2UpIHtcbiAgbGV0IG9iamVjdFJlc291cmNlID0gY29uZmlndXJhdGlvbltjb21wb25lbnRdO1xuICBsZXQgdXJsO1xuXG4gIGlmICghb2JqZWN0UmVzb3VyY2UuaGFzT3duUHJvcGVydHkocmVzb3VyY2UpKSB7XG4gICAgdGhyb3cgRXJyb3IoJ1RoZSBjb25maWd1cmF0aW9uICcgKyBKU09OLnN0cmluZ2lmeShvYmplY3RSZXNvdXJjZSwgJycsIDIpICsgJyBkb25cXCd0IGhhdmUgdGhlICcgKyByZXNvdXJjZSArICcgcmVzb3VyY2UgeW91IGFyZSBsb29raW5nIGZvcicpO1xuICB9XG5cbiAgbGV0IHJlc291cmNlVHlwZSA9IG9iamVjdFJlc291cmNlW3Jlc291cmNlXTtcblxuICBpZiAodHlwZSkge1xuICAgIHVybCA9IHJlc291cmNlVHlwZS5wcmVmaXggKyBjb25maWd1cmF0aW9uLmRvbWFpbiArIHJlc291cmNlVHlwZS5zdWZmaXggKyB0eXBlO1xuICAgIGlmIChyZXNvdXJjZVR5cGUuaGFzT3duUHJvcGVydHkoJ2ZhbGxiYWNrJykgJiYgdXNlRmFsbGJhY2spIHtcbiAgICAgIGlmIChyZXNvdXJjZVR5cGUuZmFsbGJhY2suaW5kZXhPZignJWRvbWFpbiUnKSkge1xuICAgICAgICB1cmwgPSByZXNvdXJjZVR5cGUuZmFsbGJhY2sucmVwbGFjZSgvKCVkb21haW4lKS9nLCBjb25maWd1cmF0aW9uLmRvbWFpbikgKyB0eXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsID0gcmVzb3VyY2VUeXBlLmZhbGxiYWNrICsgdHlwZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdXJsID0gcmVzb3VyY2VUeXBlLnByZWZpeCArIGNvbmZpZ3VyYXRpb24uZG9tYWluICsgcmVzb3VyY2VUeXBlLnN1ZmZpeDtcbiAgfVxuXG4gIC8vIGNvbnNvbGUubG9nKHVybCk7XG5cbiAgcmV0dXJuIHVybDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlR1VJRCgpIHtcblxuICBmdW5jdGlvbiBzNCgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcigoMSArIE1hdGgucmFuZG9tKCkpICogMHgxMDAwMClcbiAgICAgIC50b1N0cmluZygxNilcbiAgICAgIC5zdWJzdHJpbmcoMSk7XG4gIH1cblxuICByZXR1cm4gczQoKSArIHM0KCkgKyAnLScgKyBzNCgpICsgJy0nICsgczQoKSArICctJyArIHM0KCkgKyAnLScgKyBzNCgpICsgczQoKSArIHM0KCk7XG5cbn1cbiJdfQ==\n"],"file":"Runtime.js"}