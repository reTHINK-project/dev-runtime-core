// version: 0.16.0
// date: Fri Feb 22 2019 21:22:33 GMT+0000 (GMT)
// licence: 
/**
* Copyright 2016 PT Inovação e Sistemas SA
* Copyright 2016 INESC-ID
* Copyright 2016 QUOBIS NETWORKS SL
* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V
* Copyright 2016 ORANGE SA
* Copyright 2016 Deutsche Telekom AG
* Copyright 2016 Apizee
* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
**/


// version: 0.16.0
// date: Fri Feb 22 2019 21:22:33 GMT+0000 (GMT)
// licence: 
/**
* Copyright 2016 PT Inovação e Sistemas SA
* Copyright 2016 INESC-ID
* Copyright 2016 QUOBIS NETWORKS SL
* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V
* Copyright 2016 ORANGE SA
* Copyright 2016 Deutsche Telekom AG
* Copyright 2016 Apizee
* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
**/


!function(g,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define("StorageManager",[],e):"object"==typeof exports?exports.StorageManager=e():g.StorageManager=e()}(window,function(){return function(g){var e={};function n(I){if(e[I])return e[I].exports;var t=e[I]={i:I,l:!1,exports:{}};return g[I].call(t.exports,t,t.exports,n),t.l=!0,t.exports}return n.m=g,n.c=e,n.d=function(g,e,I){n.o(g,e)||Object.defineProperty(g,e,{enumerable:!0,get:I})},n.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},n.t=function(g,e){if(1&e&&(g=n(g)),8&e)return g;if(4&e&&"object"==typeof g&&g&&g.__esModule)return g;var I=Object.create(null);if(n.r(I),Object.defineProperty(I,"default",{enumerable:!0,value:g}),2&e&&"string"!=typeof g)for(var t in g)n.d(I,t,function(e){return g[e]}.bind(null,t));return I},n.n=function(g){var e=g&&g.__esModule?function(){return g.default}:function(){return g};return n.d(e,"a",e),e},n.o=function(g,e){return Object.prototype.hasOwnProperty.call(g,e)},n.p="",n(n.s=44)}({1:function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    "use strict";\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}(this, function () {\n    "use strict";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = "undefined";\n\n    var logMethods = [\n        "trace",\n        "debug",\n        "info",\n        "warn",\n        "error"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === \'function\') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === \'debug\') {\n            methodName = \'log\';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, \'log\');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn\'t present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      var storageKey = "loglevel";\n      if (name) {\n        storageKey += ":" + name;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || \'silent\').toUpperCase();\n\n          if (typeof window === undefinedType) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + "=" + levelName + ";";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + "=");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,\n          "ERROR": 4, "SILENT": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return "No console available for logging";\n              }\n          } else {\n              throw "log.setLevel() called with invalid level: " + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== "string" || name === "") {\n          throw new TypeError("You must supply a name when creating a logger.");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    return defaultLogger;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9sb2dsZXZlbC9saWIvbG9nbGV2ZWwuanM/NWM3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuKiBsb2dsZXZlbCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTMgVGltIFBlcnJ5XG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiovXG4oZnVuY3Rpb24gKHJvb3QsIGRlZmluaXRpb24pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShkZWZpbml0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QubG9nID0gZGVmaW5pdGlvbigpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gU2xpZ2h0bHkgZHViaW91cyB0cmlja3MgdG8gY3V0IGRvd24gbWluaW1pemVkIGZpbGUgc2l6ZVxuICAgIHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcbiAgICB2YXIgdW5kZWZpbmVkVHlwZSA9IFwidW5kZWZpbmVkXCI7XG5cbiAgICB2YXIgbG9nTWV0aG9kcyA9IFtcbiAgICAgICAgXCJ0cmFjZVwiLFxuICAgICAgICBcImRlYnVnXCIsXG4gICAgICAgIFwiaW5mb1wiLFxuICAgICAgICBcIndhcm5cIixcbiAgICAgICAgXCJlcnJvclwiXG4gICAgXTtcblxuICAgIC8vIENyb3NzLWJyb3dzZXIgYmluZCBlcXVpdmFsZW50IHRoYXQgd29ya3MgYXQgbGVhc3QgYmFjayB0byBJRTZcbiAgICBmdW5jdGlvbiBiaW5kTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgbWV0aG9kID0gb2JqW21ldGhvZE5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZC5iaW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmJpbmQob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwobWV0aG9kLCBvYmopO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIE1pc3NpbmcgYmluZCBzaGltIG9yIElFOCArIE1vZGVybml6ciwgZmFsbGJhY2sgdG8gd3JhcHBpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkobWV0aG9kLCBbb2JqLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgdGhlIGJlc3QgbG9nZ2luZyBtZXRob2QgcG9zc2libGUgZm9yIHRoaXMgZW52XG4gICAgLy8gV2hlcmV2ZXIgcG9zc2libGUgd2Ugd2FudCB0byBiaW5kLCBub3Qgd3JhcCwgdG8gcHJlc2VydmUgc3RhY2sgdHJhY2VzXG4gICAgZnVuY3Rpb24gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmIChtZXRob2ROYW1lID09PSAnZGVidWcnKSB7XG4gICAgICAgICAgICBtZXRob2ROYW1lID0gJ2xvZyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gbWV0aG9kIHBvc3NpYmxlLCBmb3Igbm93IC0gZml4ZWQgbGF0ZXIgYnkgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlc1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZS5sb2cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgJ2xvZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGVzZSBwcml2YXRlIGZ1bmN0aW9ucyBhbHdheXMgbmVlZCBgdGhpc2AgdG8gYmUgc2V0IHByb3Blcmx5XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGxvZ01ldGhvZHNbaV07XG4gICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdID0gKGkgPCBsZXZlbCkgP1xuICAgICAgICAgICAgICAgIG5vb3AgOlxuICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZpbmUgbG9nLmxvZyBhcyBhbiBhbGlhcyBmb3IgbG9nLmRlYnVnXG4gICAgICAgIHRoaXMubG9nID0gdGhpcy5kZWJ1ZztcbiAgICB9XG5cbiAgICAvLyBJbiBvbGQgSUUgdmVyc2lvbnMsIHRoZSBjb25zb2xlIGlzbid0IHByZXNlbnQgdW50aWwgeW91IGZpcnN0IG9wZW4gaXQuXG4gICAgLy8gV2UgYnVpbGQgcmVhbE1ldGhvZCgpIHJlcGxhY2VtZW50cyBoZXJlIHRoYXQgcmVnZW5lcmF0ZSBsb2dnaW5nIG1ldGhvZHNcbiAgICBmdW5jdGlvbiBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzKG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbCh0aGlzLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHVzZSBjbG9zZWx5IGJvdW5kIHJlYWwgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZSwgYW5kXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdhaXQgZm9yIGEgY29uc29sZSB0byBhcHBlYXIsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICByZXR1cm4gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB8fFxuICAgICAgICAgICAgICAgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvZ2dlcihuYW1lLCBkZWZhdWx0TGV2ZWwsIGZhY3RvcnkpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjdXJyZW50TGV2ZWw7XG4gICAgICB2YXIgc3RvcmFnZUtleSA9IFwibG9nbGV2ZWxcIjtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHN0b3JhZ2VLZXkgKz0gXCI6XCIgKyBuYW1lO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsTnVtKSB7XG4gICAgICAgICAgdmFyIGxldmVsTmFtZSA9IChsb2dNZXRob2RzW2xldmVsTnVtXSB8fCAnc2lsZW50JykudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlKSByZXR1cm47XG5cbiAgICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV0gPSBsZXZlbE5hbWU7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID1cbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIiArIGxldmVsTmFtZSArIFwiO1wiO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0UGVyc2lzdGVkTGV2ZWwoKSB7XG4gICAgICAgICAgdmFyIHN0b3JlZExldmVsO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUpIHJldHVybjtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XTtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBjb29raWVzIGlmIGxvY2FsIHN0b3JhZ2UgZ2l2ZXMgdXMgbm90aGluZ1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVkTGV2ZWwgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb29raWUgPSB3aW5kb3cuZG9jdW1lbnQuY29va2llO1xuICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY29va2llLmluZGV4T2YoXG4gICAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIpO1xuICAgICAgICAgICAgICAgICAgaWYgKGxvY2F0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZExldmVsID0gL14oW147XSspLy5leGVjKGNvb2tpZS5zbGljZShsb2NhdGlvbikpWzFdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhlIHN0b3JlZCBsZXZlbCBpcyBub3QgdmFsaWQsIHRyZWF0IGl0IGFzIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cbiAgICAgICAgICBpZiAoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN0b3JlZExldmVsO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgICpcbiAgICAgICAqIFB1YmxpYyBsb2dnZXIgQVBJIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbCBmb3IgZGV0YWlsc1xuICAgICAgICpcbiAgICAgICAqL1xuXG4gICAgICBzZWxmLm5hbWUgPSBuYW1lO1xuXG4gICAgICBzZWxmLmxldmVscyA9IHsgXCJUUkFDRVwiOiAwLCBcIkRFQlVHXCI6IDEsIFwiSU5GT1wiOiAyLCBcIldBUk5cIjogMyxcbiAgICAgICAgICBcIkVSUk9SXCI6IDQsIFwiU0lMRU5UXCI6IDV9O1xuXG4gICAgICBzZWxmLm1ldGhvZEZhY3RvcnkgPSBmYWN0b3J5IHx8IGRlZmF1bHRNZXRob2RGYWN0b3J5O1xuXG4gICAgICBzZWxmLmdldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50TGV2ZWw7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsLCBwZXJzaXN0KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIiAmJiBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGxldmVsID0gc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwibnVtYmVyXCIgJiYgbGV2ZWwgPj0gMCAmJiBsZXZlbCA8PSBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgY3VycmVudExldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICAgIGlmIChwZXJzaXN0ICE9PSBmYWxzZSkgeyAgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZiwgbGV2ZWwsIG5hbWUpO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUgJiYgbGV2ZWwgPCBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBcIk5vIGNvbnNvbGUgYXZhaWxhYmxlIGZvciBsb2dnaW5nXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBcImxvZy5zZXRMZXZlbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgbGV2ZWw6IFwiICsgbGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXREZWZhdWx0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICBpZiAoIWdldFBlcnNpc3RlZExldmVsKCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5zZXRMZXZlbChsZXZlbCwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZW5hYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuVFJBQ0UsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5kaXNhYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuU0lMRU5ULCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEluaXRpYWxpemUgd2l0aCB0aGUgcmlnaHQgbGV2ZWxcbiAgICAgIHZhciBpbml0aWFsTGV2ZWwgPSBnZXRQZXJzaXN0ZWRMZXZlbCgpO1xuICAgICAgaWYgKGluaXRpYWxMZXZlbCA9PSBudWxsKSB7XG4gICAgICAgICAgaW5pdGlhbExldmVsID0gZGVmYXVsdExldmVsID09IG51bGwgPyBcIldBUk5cIiA6IGRlZmF1bHRMZXZlbDtcbiAgICAgIH1cbiAgICAgIHNlbGYuc2V0TGV2ZWwoaW5pdGlhbExldmVsLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKlxuICAgICAqIFRvcC1sZXZlbCBBUElcbiAgICAgKlxuICAgICAqL1xuXG4gICAgdmFyIGRlZmF1bHRMb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG5cbiAgICB2YXIgX2xvZ2dlcnNCeU5hbWUgPSB7fTtcbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlciA9IGZ1bmN0aW9uIGdldExvZ2dlcihuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIiB8fCBuYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV07XG4gICAgICAgIGlmICghbG9nZ2VyKSB7XG4gICAgICAgICAgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV0gPSBuZXcgTG9nZ2VyKFxuICAgICAgICAgICAgbmFtZSwgZGVmYXVsdExvZ2dlci5nZXRMZXZlbCgpLCBkZWZhdWx0TG9nZ2VyLm1ldGhvZEZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgfTtcblxuICAgIC8vIEdyYWIgdGhlIGN1cnJlbnQgZ2xvYmFsIGxvZyB2YXJpYWJsZSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICAgIHZhciBfbG9nID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpID8gd2luZG93LmxvZyA6IHVuZGVmaW5lZDtcbiAgICBkZWZhdWx0TG9nZ2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUgJiZcbiAgICAgICAgICAgICAgIHdpbmRvdy5sb2cgPT09IGRlZmF1bHRMb2dnZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG4gICAgfTtcblxuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VycyA9IGZ1bmN0aW9uIGdldExvZ2dlcnMoKSB7XG4gICAgICAgIHJldHVybiBfbG9nZ2Vyc0J5TmFtZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG59KSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQSxhQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n')},24:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_0__);\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Log System\n\nvar log = loglevel__WEBPACK_IMPORTED_MODULE_0__[\"getLogger\"]('StorageManager');\n\nvar StorageManager =\n/*#__PURE__*/\nfunction () {\n  function StorageManager(db, storageName, schemas, runtimeUA) {\n    var version = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n    var remoteStorage = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n    _classCallCheck(this, StorageManager);\n\n    if (!db) throw Error('The Storage Manager needs the database instance');\n    if (!storageName) throw Error('The Storage Manager needs the storage name');\n    var stores = {};\n\n    if (schemas) {\n      stores = schemas;\n    } else {\n      stores[storageName] = 'key,version,value';\n    } //    db.version(version).stores(stores);\n\n\n    db.open().then(function (db) {\n      log.info('Found database name ' + db.name + ' with version no: ' + db.verno);\n    }).catch(log.error);\n    this.db = db;\n    this.storageName = storageName;\n    this._remoteStorage = remoteStorage;\n    this._runtimeUA = runtimeUA;\n  } // set remoteStorage backup server URL\n\n\n  _createClass(StorageManager, [{\n    key: \"connect\",\n    // start sync with remoteStorage server. Returns a promise that resolves if connection is performed otherwise it is rejected\n    value: function connect(options) {\n      return this.db.connect(this._remoteStorage, options);\n    } // stop sync with remoteStorage server. Returns promise \n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        _this.db.disconnect(_this._remoteStorage).then(function () {\n          resolve();\n        }, function (error) {\n          reject(error);\n        });\n      });\n    } // to retrieve the last revision stored in the backup server\n\n  }, {\n    key: \"getBackupRevision\",\n    value: function getBackupRevision(resource) {\n      var _this2 = this;\n\n      return new Promise(function (resolve) {\n        _this2.db._syncNodes.get({\n          type: 'remote'\n        }).then(function (status) {\n          console.log('[StorageManager.getBackupRevision] retrieved status: ', status);\n\n          if (status && status.hasOwnProperty('appliedRemoteRevision')) {\n            if (status.appliedRemoteRevision === null) status.appliedRemoteRevision = 0;\n            resolve(status.appliedRemoteRevision);\n          }\n        });\n      });\n    } // to retrieve the last revision stored in the backup server\n    // and broadcast it\n\n  }, {\n    key: \"_updateBackupRevision\",\n    value: function _updateBackupRevision(resource) {\n      var _this3 = this;\n\n      return new Promise(function (resolve) {\n        _this3.db._syncNodes.get({\n          type: 'remote'\n        }).then(function (status) {\n          console.log('[StorageManager._updateBackupRevision] retrieved status: ', status);\n\n          if (status && status.hasOwnProperty('appliedRemoteRevision')) {\n            if (status.appliedRemoteRevision === null) status.appliedRemoteRevision = 0;\n\n            _this3._runtimeUA._updateRuntimeStatus({\n              resource: resource,\n              value: {\n                backupRevision: status.appliedRemoteRevision\n              }\n            });\n\n            resolve(status.appliedRemoteRevision);\n          }\n        });\n      });\n    }\n  }, {\n    key: \"_checkKey\",\n    value: function _checkKey(key) {\n      if (typeof key !== 'string') return key.toString();\n      return key;\n    }\n  }, {\n    key: \"_getTable\",\n    value: function _getTable(key) {\n      var name;\n\n      try {\n        name = this.db.table(this.storageName).name;\n      } catch (error) {\n        //      try {\n        name = this.db.table(key).name;\n        /*      } catch (error) {\r\n                log.error('[StorageManager._getTable] error ', error);\r\n                name = false;\r\n              }*/\n      }\n\n      return name;\n    }\n  }, {\n    key: \"_getPrimaryKey\",\n    value: function _getPrimaryKey(table) {\n      return this.db.table(table).schema.primKey.name;\n    }\n  }, {\n    key: \"_isDefaultSchema\",\n    value: function _isDefaultSchema(table) {\n      var name = this._getTable(table);\n\n      var schema = this.db[name].schema.instanceTemplate;\n      return schema.hasOwnProperty('value') && schema.hasOwnProperty('version') && schema.hasOwnProperty('key');\n    }\n    /**\r\n     * Adds a new entry to the database for a given key, together with its version.\r\n     * If an entry for the given key is already stored in the database, it will be updated.\r\n     * @param {!string} key - key that can be used with {@link storageManager.get} to retrieve the value object\r\n     * @param {!string} version - version descriptor for the given value\r\n     * @param value - value stored in the database that is mapped to given key\r\n     * @param {!string} table - table which should be looking for\r\n     * @returns {Promise} result - Promise that will be fulfilled with the key if the entry was stored successfully,\r\n     * otherwise it is rejected with an error.\r\n     * @memberof StorageManager\r\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(key, version, value, table) {\n      var _this4 = this;\n\n      var updateRuntimeStatus = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n      return new Promise(function (resolve, reject) {\n        log.info('[StorageManager] - set ', key, value);\n        table = table ? table : key;\n\n        var name = _this4._getTable(table);\n\n        var primaryKey = _this4._getPrimaryKey(name); // Object.assign(value, {version: version});\n\n\n        var data = value;\n\n        if (_this4._isDefaultSchema(table)) {\n          data = {\n            key: key,\n            version: version,\n            value: value\n          };\n        } else {\n          var tmp = {};\n          tmp[primaryKey] = key;\n          Object.assign(data, tmp);\n        }\n\n        _this4.db[name].put(data).then(function () {\n          if (updateRuntimeStatus && data.backup && data.url) {\n            _this4._updateBackupRevision(data.url).then(function () {\n              resolve();\n            });\n          } else resolve();\n        }, function () {\n          resolve();\n        });\n      });\n    }\n    /**\r\n     * Get a entry value from the database for a given key.\r\n     * If no entry is found undefined is returned.\r\n     * @param {!string} key - key that was stored using {@link storageManager.set}\r\n     * @param {!any} value - value which should be found\r\n     * @param {!string} table - table which should be looking for\r\n     * @returns {Promise} result - Promise that will be fulfilled with the value.\r\n     * @memberof StorageManager\r\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(key, value, table) {\n      var _this5 = this;\n\n      console.info('[StorageManager] - get ', key, value);\n      table = table ? table : key;\n\n      var name = this._getTable(table);\n\n      if (!name) return undefined;\n\n      var primaryKey = this._getPrimaryKey(name);\n\n      return this.db.transaction('rw!', this.db[name], function () {\n        if (!key && !value) {\n          return _this5.db[name].toArray().then(function (objects) {\n            if (objects.length > 0) {\n              return objects.reduce(function (acc, key) {\n                acc[key[primaryKey]] = key;\n                return acc;\n              }, function () {\n                return {};\n              });\n            } else return {};\n          });\n        }\n\n        if (!value) {\n          return _this5.db[name].where(primaryKey).equals(key).first().then(function (object) {\n            if (object && object.hasOwnProperty('value')) {\n              return object.value;\n            } else {\n              return object;\n            }\n          });\n        } else {\n          var type = _typeof(value);\n\n          if (Array.isArray(value)) {\n            type = 'array';\n          }\n\n          switch (type) {\n            case 'string':\n              return _this5.db[name].where(key).equals(value).first().then(function (object) {\n                if (object && object.hasOwnProperty('value')) {\n                  return object.value;\n                } else {\n                  return object;\n                }\n              });\n\n            case 'object':\n              {\n                var strPath = 'value.' + Object.keys(value).toString();\n                var strValue = Object.values(value);\n                console.log(strPath, strValue);\n                return _this5.db[name].where(strPath).anyOf(strValue).first().then(function (object) {\n                  if (object && object.hasOwnProperty('value')) {\n                    return object.value;\n                  } else {\n                    return object;\n                  }\n                });\n              }\n\n            case 'array':\n              console.log('ARRAY:', value);\n              return _this5.db[name].where(value).then(function (object) {\n                if (object && object.hasOwnProperty('value')) {\n                  return object.value;\n                } else {\n                  return object;\n                }\n              });\n          }\n        }\n      });\n    }\n    /**\r\n     * Get a entry version from the database for a given key.\r\n     * If no entry is found undefined is returned.\r\n     * @param {!string} key - key that was stored using {@link storageManager.set}\r\n     * @param {any} value - the value which sould be used to find the storage resource\r\n     * @param {!string} table - table which should be looking for\r\n     * @returns {Promise} result - Promise that will be fulfilled with the version.\r\n     * @memberof StorageManager\r\n     */\n\n  }, {\n    key: \"getVersion\",\n    value: function getVersion(key, value, table) {\n      var _this6 = this;\n\n      log.info('[StorageManager] - getVersion for key ', key);\n      table = table ? table : key;\n\n      var name = this._getTable(table);\n\n      var primaryKey = this._getPrimaryKey(name);\n\n      var data = value;\n\n      if (!value) {\n        data = key;\n      }\n\n      return this.db.transaction('rw!', this.db[name], function () {\n        return _this6.db[name].where(primaryKey).equals(data).first().then(function (object) {\n          if (object && object.hasOwnProperty('version')) {\n            return object.version;\n          } else {\n            return object;\n          }\n        }).catch(function (error) {\n          log.info('error getting the version for ', key, ' with error: ', error);\n          return undefined;\n        });\n      });\n    }\n    /**\r\n     * Delete a entry from the database for a given key or the full DB in case the key is not provided.\r\n     * @param {!string} key - key that was stored using {@link storageManager.set}\r\n     * @param {!any} value - the value which sould be used to find the storage resource\r\n     * @param {!string} table - table which should be looking for\r\n     * @returns {Promise} result - Promise that will be fulfilled with the number of affected rows.\r\n     * @memberof StorageManager\r\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(key, value, table) {\n      if (key) {\n        table = table ? table : key;\n\n        var name = this._getTable(table);\n\n        var primaryKey = this._getPrimaryKey(name);\n\n        var data = value;\n\n        if (!value) {\n          data = key;\n        }\n\n        return this.db[name].where(primaryKey).equals(data).delete();\n      } else return this.db.delete();\n    }\n  }, {\n    key: \"remoteStorage\",\n    set: function set(remoteStorage) {\n      this._remoteStorage = remoteStorage;\n    }\n  }]);\n\n  return StorageManager;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (StorageManager);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvc3RvcmFnZS1tYW5hZ2VyL1N0b3JhZ2VNYW5hZ2VyLmpzPzhiMjEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gTG9nIFN5c3RlbVxyXG5pbXBvcnQgKiBhcyBsb2dnZXIgZnJvbSAnbG9nbGV2ZWwnO1xyXG5sZXQgbG9nID0gbG9nZ2VyLmdldExvZ2dlcignU3RvcmFnZU1hbmFnZXInKTtcclxuXHJcbmNsYXNzIFN0b3JhZ2VNYW5hZ2VyIHtcclxuXHJcbiAgY29uc3RydWN0b3IoZGIsIHN0b3JhZ2VOYW1lLCBzY2hlbWFzLCBydW50aW1lVUEsIHZlcnNpb24gPSAxLCByZW1vdGVTdG9yYWdlID0gZmFsc2UpIHtcclxuICAgIGlmICghZGIpIHRocm93IEVycm9yKCdUaGUgU3RvcmFnZSBNYW5hZ2VyIG5lZWRzIHRoZSBkYXRhYmFzZSBpbnN0YW5jZScpO1xyXG4gICAgaWYgKCFzdG9yYWdlTmFtZSkgdGhyb3cgRXJyb3IoJ1RoZSBTdG9yYWdlIE1hbmFnZXIgbmVlZHMgdGhlIHN0b3JhZ2UgbmFtZScpO1xyXG5cclxuICAgIGxldCBzdG9yZXMgPSAge307XHJcblxyXG4gICAgaWYgKHNjaGVtYXMpIHtcclxuICAgICAgc3RvcmVzID0gc2NoZW1hcztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0b3Jlc1tzdG9yYWdlTmFtZV0gPSAna2V5LHZlcnNpb24sdmFsdWUnO1xyXG4gICAgfVxyXG5cclxuLy8gICAgZGIudmVyc2lvbih2ZXJzaW9uKS5zdG9yZXMoc3RvcmVzKTtcclxuICAgIGRiLm9wZW4oKS50aGVuKChkYikgPT4ge1xyXG4gICAgICBsb2cuaW5mbygnRm91bmQgZGF0YWJhc2UgbmFtZSAnICsgZGIubmFtZSArICcgd2l0aCB2ZXJzaW9uIG5vOiAnICsgZGIudmVybm8pO1xyXG4gICAgfSkuY2F0Y2gobG9nLmVycm9yKTtcclxuXHJcbiAgICB0aGlzLmRiID0gZGI7XHJcbiAgICB0aGlzLnN0b3JhZ2VOYW1lID0gc3RvcmFnZU5hbWU7XHJcbiAgICB0aGlzLl9yZW1vdGVTdG9yYWdlID0gcmVtb3RlU3RvcmFnZTtcclxuICAgIHRoaXMuX3J1bnRpbWVVQSA9IHJ1bnRpbWVVQTtcclxuICB9XHJcblxyXG4gIC8vIHNldCByZW1vdGVTdG9yYWdlIGJhY2t1cCBzZXJ2ZXIgVVJMXHJcblxyXG4gIHNldCByZW1vdGVTdG9yYWdlKHJlbW90ZVN0b3JhZ2UpIHtcclxuICAgIHRoaXMuX3JlbW90ZVN0b3JhZ2UgPSByZW1vdGVTdG9yYWdlO1xyXG4gIH1cclxuXHJcbiAgLy8gc3RhcnQgc3luYyB3aXRoIHJlbW90ZVN0b3JhZ2Ugc2VydmVyLiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGlmIGNvbm5lY3Rpb24gaXMgcGVyZm9ybWVkIG90aGVyd2lzZSBpdCBpcyByZWplY3RlZFxyXG5cclxuICBjb25uZWN0KG9wdGlvbnMpIHtcclxuICAgIHJldHVybiB0aGlzLmRiLmNvbm5lY3QodGhpcy5fcmVtb3RlU3RvcmFnZSwgb3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICAvLyBzdG9wIHN5bmMgd2l0aCByZW1vdGVTdG9yYWdlIHNlcnZlci4gUmV0dXJucyBwcm9taXNlIFxyXG5cclxuICBkaXNjb25uZWN0KCkge1xyXG4gICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUscmVqZWN0KSA9PiB7XHJcbiAgICAgIHRoaXMuZGIuZGlzY29ubmVjdCh0aGlzLl9yZW1vdGVTdG9yYWdlKS50aGVuKCgpPT4ge1xyXG4gICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgfSwgKGVycm9yKSA9PiB7XHJcbiAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICB9KTtcclxuICB9KTtcclxufVxyXG4gIC8vIHRvIHJldHJpZXZlIHRoZSBsYXN0IHJldmlzaW9uIHN0b3JlZCBpbiB0aGUgYmFja3VwIHNlcnZlclxyXG5cclxuICBnZXRCYWNrdXBSZXZpc2lvbihyZXNvdXJjZSkge1xyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSk9PiB7XHJcbiAgICAgIHRoaXMuZGIuX3N5bmNOb2Rlcy5nZXQoe3R5cGU6ICdyZW1vdGUnfSkudGhlbigoc3RhdHVzKT0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZygnW1N0b3JhZ2VNYW5hZ2VyLmdldEJhY2t1cFJldmlzaW9uXSByZXRyaWV2ZWQgc3RhdHVzOiAnLCBzdGF0dXMpO1xyXG4gICAgICAgIGlmIChzdGF0dXMgJiYgc3RhdHVzLmhhc093blByb3BlcnR5KCdhcHBsaWVkUmVtb3RlUmV2aXNpb24nKSkge1xyXG4gICAgICAgICAgaWYgKHN0YXR1cy5hcHBsaWVkUmVtb3RlUmV2aXNpb24gPT09IG51bGwpIHN0YXR1cy5hcHBsaWVkUmVtb3RlUmV2aXNpb24gPSAwO1xyXG5cclxuICAgICAgICAgIHJlc29sdmUoc3RhdHVzLmFwcGxpZWRSZW1vdGVSZXZpc2lvbik7XHJcbiAgICAgICAgfSBcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59XHJcblxyXG4gIC8vIHRvIHJldHJpZXZlIHRoZSBsYXN0IHJldmlzaW9uIHN0b3JlZCBpbiB0aGUgYmFja3VwIHNlcnZlclxyXG4gIC8vIGFuZCBicm9hZGNhc3QgaXRcclxuXHJcbiAgX3VwZGF0ZUJhY2t1cFJldmlzaW9uKHJlc291cmNlKSB7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKT0+IHtcclxuICAgICAgdGhpcy5kYi5fc3luY05vZGVzLmdldCh7dHlwZTogJ3JlbW90ZSd9KS50aGVuKChzdGF0dXMpPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbU3RvcmFnZU1hbmFnZXIuX3VwZGF0ZUJhY2t1cFJldmlzaW9uXSByZXRyaWV2ZWQgc3RhdHVzOiAnLCBzdGF0dXMpO1xyXG4gICAgICAgIGlmIChzdGF0dXMgJiYgc3RhdHVzLmhhc093blByb3BlcnR5KCdhcHBsaWVkUmVtb3RlUmV2aXNpb24nKSkge1xyXG4gICAgICAgICAgaWYgKHN0YXR1cy5hcHBsaWVkUmVtb3RlUmV2aXNpb24gPT09IG51bGwpIHN0YXR1cy5hcHBsaWVkUmVtb3RlUmV2aXNpb24gPSAwO1xyXG5cclxuICAgICAgICAgIHRoaXMuX3J1bnRpbWVVQS5fdXBkYXRlUnVudGltZVN0YXR1cyhcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIHJlc291cmNlOiByZXNvdXJjZSxcclxuICAgICAgICAgICAgICB2YWx1ZTogeyBiYWNrdXBSZXZpc2lvbjogc3RhdHVzLmFwcGxpZWRSZW1vdGVSZXZpc2lvbiB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIClcclxuICAgICAgICAgIHJlc29sdmUoc3RhdHVzLmFwcGxpZWRSZW1vdGVSZXZpc2lvbik7XHJcbiAgICAgICAgfSBcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59XHJcblxyXG4gIF9jaGVja0tleShrZXkpIHtcclxuICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykgcmV0dXJuIGtleS50b1N0cmluZygpO1xyXG4gICAgcmV0dXJuIGtleTtcclxuICB9XHJcblxyXG4gIF9nZXRUYWJsZShrZXkpIHtcclxuICAgIGxldCBuYW1lO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIG5hbWUgPSB0aGlzLmRiLnRhYmxlKHRoaXMuc3RvcmFnZU5hbWUpLm5hbWU7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4vLyAgICAgIHRyeSB7XHJcbiAgICAgICAgbmFtZSA9IHRoaXMuZGIudGFibGUoa2V5KS5uYW1lO1xyXG4vKiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgbG9nLmVycm9yKCdbU3RvcmFnZU1hbmFnZXIuX2dldFRhYmxlXSBlcnJvciAnLCBlcnJvcik7XHJcbiAgICAgICAgbmFtZSA9IGZhbHNlO1xyXG4gICAgICB9Ki9cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmFtZTtcclxuICB9XHJcblxyXG4gIF9nZXRQcmltYXJ5S2V5KHRhYmxlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYi50YWJsZSh0YWJsZSkuc2NoZW1hLnByaW1LZXkubmFtZTtcclxuICB9XHJcblxyXG4gIF9pc0RlZmF1bHRTY2hlbWEodGFibGUpIHtcclxuICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9nZXRUYWJsZSh0YWJsZSk7XHJcbiAgICBjb25zdCBzY2hlbWEgPSB0aGlzLmRiW25hbWVdLnNjaGVtYS5pbnN0YW5jZVRlbXBsYXRlO1xyXG4gICAgcmV0dXJuIHNjaGVtYS5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSAmJiBzY2hlbWEuaGFzT3duUHJvcGVydHkoJ3ZlcnNpb24nKSAmJiBzY2hlbWEuaGFzT3duUHJvcGVydHkoJ2tleScpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhIG5ldyBlbnRyeSB0byB0aGUgZGF0YWJhc2UgZm9yIGEgZ2l2ZW4ga2V5LCB0b2dldGhlciB3aXRoIGl0cyB2ZXJzaW9uLlxyXG4gICAqIElmIGFuIGVudHJ5IGZvciB0aGUgZ2l2ZW4ga2V5IGlzIGFscmVhZHkgc3RvcmVkIGluIHRoZSBkYXRhYmFzZSwgaXQgd2lsbCBiZSB1cGRhdGVkLlxyXG4gICAqIEBwYXJhbSB7IXN0cmluZ30ga2V5IC0ga2V5IHRoYXQgY2FuIGJlIHVzZWQgd2l0aCB7QGxpbmsgc3RvcmFnZU1hbmFnZXIuZ2V0fSB0byByZXRyaWV2ZSB0aGUgdmFsdWUgb2JqZWN0XHJcbiAgICogQHBhcmFtIHshc3RyaW5nfSB2ZXJzaW9uIC0gdmVyc2lvbiBkZXNjcmlwdG9yIGZvciB0aGUgZ2l2ZW4gdmFsdWVcclxuICAgKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSBzdG9yZWQgaW4gdGhlIGRhdGFiYXNlIHRoYXQgaXMgbWFwcGVkIHRvIGdpdmVuIGtleVxyXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gdGFibGUgLSB0YWJsZSB3aGljaCBzaG91bGQgYmUgbG9va2luZyBmb3JcclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcmVzdWx0IC0gUHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdpdGggdGhlIGtleSBpZiB0aGUgZW50cnkgd2FzIHN0b3JlZCBzdWNjZXNzZnVsbHksXHJcbiAgICogb3RoZXJ3aXNlIGl0IGlzIHJlamVjdGVkIHdpdGggYW4gZXJyb3IuXHJcbiAgICogQG1lbWJlcm9mIFN0b3JhZ2VNYW5hZ2VyXHJcbiAgICovXHJcbiAgc2V0KGtleSwgdmVyc2lvbiwgdmFsdWUsIHRhYmxlLCB1cGRhdGVSdW50aW1lU3RhdHVzID0gdHJ1ZSkge1xyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSAoKHJlc29sdmUsIHJlamVjdCk9PiB7XHJcbiAgICAgIGxvZy5pbmZvKCdbU3RvcmFnZU1hbmFnZXJdIC0gc2V0ICcsIGtleSwgdmFsdWUpO1xyXG4gICAgICB0YWJsZSA9IHRhYmxlID8gdGFibGUgOiBrZXk7XHJcbiAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9nZXRUYWJsZSh0YWJsZSk7XHJcbiAgICAgIGNvbnN0IHByaW1hcnlLZXkgPSB0aGlzLl9nZXRQcmltYXJ5S2V5KG5hbWUpO1xyXG4gIFxyXG4gICAgICAvLyBPYmplY3QuYXNzaWduKHZhbHVlLCB7dmVyc2lvbjogdmVyc2lvbn0pO1xyXG4gIFxyXG4gICAgICBsZXQgZGF0YSA9IHZhbHVlO1xyXG4gIFxyXG4gICAgICBpZiAodGhpcy5faXNEZWZhdWx0U2NoZW1hKHRhYmxlKSkge1xyXG4gICAgICAgIGRhdGEgPSB7XHJcbiAgICAgICAgICBrZXk6IGtleSxcclxuICAgICAgICAgIHZlcnNpb246IHZlcnNpb24sXHJcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcclxuICAgICAgICB9O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHRtcCA9IHt9O1xyXG4gICAgICAgIHRtcFtwcmltYXJ5S2V5XSA9IGtleTtcclxuICAgICAgICBPYmplY3QuYXNzaWduKGRhdGEsIHRtcCk7XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgIHRoaXMuZGJbbmFtZV0ucHV0KGRhdGEpLnRoZW4oKCk9PntcclxuICAgICAgaWYgKHVwZGF0ZVJ1bnRpbWVTdGF0dXMgJiYgZGF0YS5iYWNrdXAgJiYgZGF0YS51cmwpIHtcclxuICAgICAgICB0aGlzLl91cGRhdGVCYWNrdXBSZXZpc2lvbihkYXRhLnVybCkudGhlbigoKT0+IHtcclxuICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHJlc29sdmUoKTtcclxuXHJcbiAgICAgICB9LCAoKT0+IHtcclxuICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgfSk7XHJcblxyXG4gICAgfSk7XHJcblxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGEgZW50cnkgdmFsdWUgZnJvbSB0aGUgZGF0YWJhc2UgZm9yIGEgZ2l2ZW4ga2V5LlxyXG4gICAqIElmIG5vIGVudHJ5IGlzIGZvdW5kIHVuZGVmaW5lZCBpcyByZXR1cm5lZC5cclxuICAgKiBAcGFyYW0geyFzdHJpbmd9IGtleSAtIGtleSB0aGF0IHdhcyBzdG9yZWQgdXNpbmcge0BsaW5rIHN0b3JhZ2VNYW5hZ2VyLnNldH1cclxuICAgKiBAcGFyYW0geyFhbnl9IHZhbHVlIC0gdmFsdWUgd2hpY2ggc2hvdWxkIGJlIGZvdW5kXHJcbiAgICogQHBhcmFtIHshc3RyaW5nfSB0YWJsZSAtIHRhYmxlIHdoaWNoIHNob3VsZCBiZSBsb29raW5nIGZvclxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSByZXN1bHQgLSBQcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgd2l0aCB0aGUgdmFsdWUuXHJcbiAgICogQG1lbWJlcm9mIFN0b3JhZ2VNYW5hZ2VyXHJcbiAgICovXHJcbiAgZ2V0KGtleSwgdmFsdWUsIHRhYmxlKSB7XHJcbiAgICBjb25zb2xlLmluZm8oJ1tTdG9yYWdlTWFuYWdlcl0gLSBnZXQgJywga2V5LCB2YWx1ZSk7XHJcbiAgICB0YWJsZSA9IHRhYmxlID8gdGFibGUgOiBrZXk7XHJcbiAgICBjb25zdCBuYW1lID0gdGhpcy5fZ2V0VGFibGUodGFibGUpO1xyXG4gICAgaWYgKCFuYW1lKSByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgY29uc3QgcHJpbWFyeUtleSA9IHRoaXMuX2dldFByaW1hcnlLZXkobmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZGIudHJhbnNhY3Rpb24oJ3J3IScsIHRoaXMuZGJbbmFtZV0sICgpID0+IHtcclxuXHJcbiAgICAgIGlmICgha2V5ICYmICF2YWx1ZSkgeyBcclxuICAgICAgICByZXR1cm4gdGhpcy5kYltuYW1lXS50b0FycmF5KCkudGhlbihvYmplY3RzID0+IHtcclxuICAgICAgICAgIGlmIChvYmplY3RzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdHMucmVkdWNlKChhY2MsIGtleSkgPT4ge1xyXG4gICAgICAgICAgICAgIGFjY1trZXlbcHJpbWFyeUtleV1dID0ga2V5O1xyXG4gICAgICAgICAgICAgIHJldHVybiBhY2M7XHJcbiAgICAgICAgICAgIH0sICgpID0+e3JldHVybiB7fSB9KTtcclxuICAgICAgICAgIH0gZWxzZSByZXR1cm4ge307XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghdmFsdWUpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGJbbmFtZV0ud2hlcmUocHJpbWFyeUtleSkuZXF1YWxzKGtleSkuZmlyc3QoKVxyXG4gICAgICAgICAgLnRoZW4ob2JqZWN0ID0+IHtcclxuICAgICAgICAgICAgaWYgKG9iamVjdCAmJiBvYmplY3QuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0LnZhbHVlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XHJcblxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgdHlwZSA9ICdhcnJheSc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYltuYW1lXS53aGVyZShrZXkpLmVxdWFscyh2YWx1ZSkuZmlyc3QoKVxyXG4gICAgICAgICAgICAgIC50aGVuKG9iamVjdCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0ICYmIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSkge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICBjYXNlICdvYmplY3QnOiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0clBhdGggPSAndmFsdWUuJyArIE9iamVjdC5rZXlzKHZhbHVlKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjb25zdCBzdHJWYWx1ZSA9IE9iamVjdC52YWx1ZXModmFsdWUpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhzdHJQYXRoLCBzdHJWYWx1ZSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYltuYW1lXS53aGVyZShzdHJQYXRoKS5hbnlPZihzdHJWYWx1ZSkuZmlyc3QoKVxyXG4gICAgICAgICAgICAgIC50aGVuKG9iamVjdCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0ICYmIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSkge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjYXNlICdhcnJheSc6XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBUlJBWTonLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRiW25hbWVdLndoZXJlKHZhbHVlKS50aGVuKG9iamVjdCA9PiB7XHJcbiAgICAgICAgICAgICAgaWYgKG9iamVjdCAmJiBvYmplY3QuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3QudmFsdWU7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGEgZW50cnkgdmVyc2lvbiBmcm9tIHRoZSBkYXRhYmFzZSBmb3IgYSBnaXZlbiBrZXkuXHJcbiAgICogSWYgbm8gZW50cnkgaXMgZm91bmQgdW5kZWZpbmVkIGlzIHJldHVybmVkLlxyXG4gICAqIEBwYXJhbSB7IXN0cmluZ30ga2V5IC0ga2V5IHRoYXQgd2FzIHN0b3JlZCB1c2luZyB7QGxpbmsgc3RvcmFnZU1hbmFnZXIuc2V0fVxyXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZSAtIHRoZSB2YWx1ZSB3aGljaCBzb3VsZCBiZSB1c2VkIHRvIGZpbmQgdGhlIHN0b3JhZ2UgcmVzb3VyY2VcclxuICAgKiBAcGFyYW0geyFzdHJpbmd9IHRhYmxlIC0gdGFibGUgd2hpY2ggc2hvdWxkIGJlIGxvb2tpbmcgZm9yXHJcbiAgICogQHJldHVybnMge1Byb21pc2V9IHJlc3VsdCAtIFByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aXRoIHRoZSB2ZXJzaW9uLlxyXG4gICAqIEBtZW1iZXJvZiBTdG9yYWdlTWFuYWdlclxyXG4gICAqL1xyXG4gIGdldFZlcnNpb24oa2V5LCB2YWx1ZSwgdGFibGUpIHtcclxuICAgIGxvZy5pbmZvKCdbU3RvcmFnZU1hbmFnZXJdIC0gZ2V0VmVyc2lvbiBmb3Iga2V5ICcsIGtleSk7XHJcbiAgICB0YWJsZSA9IHRhYmxlID8gdGFibGUgOiBrZXk7XHJcbiAgICBjb25zdCBuYW1lID0gdGhpcy5fZ2V0VGFibGUodGFibGUpO1xyXG4gICAgY29uc3QgcHJpbWFyeUtleSA9IHRoaXMuX2dldFByaW1hcnlLZXkobmFtZSk7XHJcblxyXG4gICAgbGV0IGRhdGEgPSB2YWx1ZTtcclxuXHJcbiAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgIGRhdGEgPSBrZXk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZGIudHJhbnNhY3Rpb24oJ3J3IScsIHRoaXMuZGJbbmFtZV0sICgpID0+IHtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLmRiW25hbWVdLndoZXJlKHByaW1hcnlLZXkpXHJcbiAgICAgICAgLmVxdWFscyhkYXRhKVxyXG4gICAgICAgIC5maXJzdCgpXHJcbiAgICAgICAgLnRoZW4oKG9iamVjdCkgPT4ge1xyXG4gICAgICAgICAgaWYgKG9iamVjdCAmJiBvYmplY3QuaGFzT3duUHJvcGVydHkoJ3ZlcnNpb24nKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0LnZlcnNpb247XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgIGxvZy5pbmZvKCdlcnJvciBnZXR0aW5nIHRoZSB2ZXJzaW9uIGZvciAnLCBrZXksICcgd2l0aCBlcnJvcjogJywgZXJyb3IpO1xyXG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVsZXRlIGEgZW50cnkgZnJvbSB0aGUgZGF0YWJhc2UgZm9yIGEgZ2l2ZW4ga2V5IG9yIHRoZSBmdWxsIERCIGluIGNhc2UgdGhlIGtleSBpcyBub3QgcHJvdmlkZWQuXHJcbiAgICogQHBhcmFtIHshc3RyaW5nfSBrZXkgLSBrZXkgdGhhdCB3YXMgc3RvcmVkIHVzaW5nIHtAbGluayBzdG9yYWdlTWFuYWdlci5zZXR9XHJcbiAgICogQHBhcmFtIHshYW55fSB2YWx1ZSAtIHRoZSB2YWx1ZSB3aGljaCBzb3VsZCBiZSB1c2VkIHRvIGZpbmQgdGhlIHN0b3JhZ2UgcmVzb3VyY2VcclxuICAgKiBAcGFyYW0geyFzdHJpbmd9IHRhYmxlIC0gdGFibGUgd2hpY2ggc2hvdWxkIGJlIGxvb2tpbmcgZm9yXHJcbiAgICogQHJldHVybnMge1Byb21pc2V9IHJlc3VsdCAtIFByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aXRoIHRoZSBudW1iZXIgb2YgYWZmZWN0ZWQgcm93cy5cclxuICAgKiBAbWVtYmVyb2YgU3RvcmFnZU1hbmFnZXJcclxuICAgKi9cclxuICBkZWxldGUoa2V5LCB2YWx1ZSwgdGFibGUpIHtcclxuXHJcbiAgICBpZiAoa2V5KSB7XHJcbiAgICAgIHRhYmxlID0gdGFibGUgPyB0YWJsZSA6IGtleTtcclxuICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX2dldFRhYmxlKHRhYmxlKTtcclxuICAgICAgY29uc3QgcHJpbWFyeUtleSA9IHRoaXMuX2dldFByaW1hcnlLZXkobmFtZSk7XHJcbiAgXHJcbiAgICAgIGxldCBkYXRhID0gdmFsdWU7XHJcbiAgXHJcbiAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICBkYXRhID0ga2V5O1xyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIHJldHVybiB0aGlzLmRiW25hbWVdXHJcbiAgICAgICAgLndoZXJlKHByaW1hcnlLZXkpXHJcbiAgICAgICAgLmVxdWFscyhkYXRhKVxyXG4gICAgICAgIC5kZWxldGUoKTtcclxuICAgIH0gZWxzZSByZXR1cm4gdGhpcy5kYi5kZWxldGUoKTtcclxuICBcclxuICB9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTdG9yYWdlTWFuYWdlcjtcclxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7O0FBV0E7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBOzs7Ozs7Ozs7Ozs7QUFTQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkNBO0FBcUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7QUFTQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7O0FBUUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFFQTs7O0FBMVNBO0FBQ0E7QUFDQTs7Ozs7O0FBNFNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///24\n")},25:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_0__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Log System\n\nvar log = loglevel__WEBPACK_IMPORTED_MODULE_0__[\"getLogger\"]('StorageManager');\n\nvar SyncStorageManager =\n/*#__PURE__*/\nfunction () {\n  function SyncStorageManager(db, storageName, remoteStorage) {\n    _classCallCheck(this, SyncStorageManager);\n\n    if (!db) throw Error('The Storage Manager needs the database instance');\n    if (!storageName) throw Error('The Storage Manager needs the storage name');\n    if (!remoteStorage) throw Error('The Storage Manager needs the remoteStorage constructor param');\n    this.db = db;\n    this.storageName = storageName;\n    this._remoteStorage = remoteStorage + '/' + storageName;\n  } // set remoteStorage backup server URL\n\n\n  _createClass(SyncStorageManager, [{\n    key: \"connect\",\n    // start backup with remoteStorage server. \n    value: function connect() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        live: true,\n        retry: true\n      };\n      // return this.db.connect(this._remoteStorage, options);\n      var live = options && options.hasOwnProperty('once') ? !options.once : true;\n      var opts = {\n        live: live,\n        retry: true\n      };\n      return this.replicationHandler = this.db.replicate.to(this._remoteStorage, opts, this._syncError());\n    } // There was some form or error syncing\n\n  }, {\n    key: \"_syncError\",\n    value: function _syncError() {} // do something\n    // stop backup with remoteStorage server.\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      return this.replicationHandler.cancel();\n    }\n    /**\r\n     * Adds a new entry to the database for a given key, together with its version.\r\n     * If an entry for the given key is already stored in the database, it will be updated.\r\n     * @param {!string} key - key that can be used with {@link storageManager.get} to retrieve the value object\r\n     * @param value - value stored in the database that is mapped to given key\r\n     * @returns {Promise} result - Promise that will be fulfilled with the stored doc if the entry was stored successfully,\r\n     * otherwise it is rejected with an error.\r\n     * @memberof StorageManager\r\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(key, value, version) {\n      var _this = this;\n\n      if (!key) throw Error('[SyncStorageManager.set] key is mandatory param');\n      if (!value) throw Error('[SyncStorageManager.set] value is mandatory param');\n      return new Promise(function (resolve, reject) {\n        console.log('[SyncStorageManager.set] key ', key, ' value ', value);\n        value._id = key;\n\n        _this.db.get(key).then(function (doc) {\n          var data = typeof value === 'string' ? {\n            value: value\n          } : value; // if no version is asked to set, it is assumed to update the same version of the document\n          // in order to avoid the increase of storage quota used\n\n          doc._rev = version ? version : doc._rev;\n          Object.assign(doc, data);\n\n          _this.db.put(doc).then(function () {\n            resolve(doc);\n          });\n        }, function (err) {\n          console.error('[SyncStorageManager.set] ', err);\n\n          if (err.name === 'not_found') {\n            var opts = {};\n\n            if (version) {\n              value._rev = version;\n              opts.new_edits = false;\n            }\n\n            _this.db.put(value, opts).then(function () {\n              resolve(value);\n            }, function (err) {\n              reject(err);\n            });\n          } else reject(err);\n        });\n      });\n    }\n    /**\r\n     * Get a entry value from the database for a given key.\r\n     * If no entry is found undefined is returned.\r\n     * @param {!string} key - key that was stored using {@link storageManager.set}\r\n     * @param {!any} value - value which should be found\r\n     * @returns {Promise} result - Promise that will be fulfilled with the value.\r\n     * @memberof StorageManager\r\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(key, value) {\n      var _this2 = this;\n\n      // TODO: add options for pagination for DOs with high number of child objects\n      //    if (!key) throw Error('[SyncStorageManager.get] key is mandatory param');\n      return new Promise(function (resolve, reject) {\n        log.info('[SyncStorageManager.get] key ', key, ' value ', value);\n\n        if (key) {\n          if (!value) {\n            _this2.db.get(key).then(function (doc) {\n              resolve(doc);\n            }, function (err) {\n              if (err.name === 'not_found') resolve(undefined);else reject(err);\n            });\n          } else _this2.db.get(key).then(function (doc) {\n            log.info('[SyncStorageManager.get] retrieved doc ', doc);\n            resolve(doc[value]);\n          }, function (err) {\n            if (err.name === 'not_found') resolve(undefined);else reject(err);\n          });\n        } else {\n          _this2.db.allDocs({\n            include_docs: true\n          }).then(function (docs) {\n            var result = [];\n            docs.forEach(function (doc) {\n              result.push(doc.doc);\n            });\n            resolve(result);\n          }, function (err) {\n            if (err.name === 'not_found') resolve(undefined);else reject(err);\n          });\n        }\n      });\n    }\n    /**\r\n     * Delete a entry from the database for a given key or the full DB in case the key is not provided.\r\n     * @param {!string} key - key that was stored using {@link storageManager.set}\r\n     * @param {!any} value - the value which sould be used to find the storage resource\r\n     * @returns {Promise} result - Promise that will be just fulfilled with no values if something was deleted otherwise it is fullfilled with undefined.\r\n     * @memberof StorageManager\r\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(key, value) {\n      var _this3 = this;\n\n      //todo: if no key delete the db\n      //    if (!key) throw Error('[SyncStorageManager.get] key is mandatory param');\n      return new Promise(function (resolve, reject) {\n        log.info('[SyncStorageManager.delete] key ', key, ' value ', value);\n\n        if (key) {\n          _this3.db.get(key).then(function (doc) {\n            if (!value) {\n              _this3.db.remove(doc).then(function () {\n                resolve();\n              }, resolve(undefined));\n            } else {\n              delete doc[value];\n              resolve(_this3.db.put(doc));\n            }\n          }, function (err) {\n            if (err.name === 'not_found') resolve(undefined);else reject(err);\n          });\n        } else {\n          db.destroy().then(function () {\n            return resolve();\n          }, function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n    /**\r\n     * Get the version from the database for a given key.\r\n     * If no entry is found undefined is returned.\r\n     * @param {!string} key - key that was stored using {@link storageManager.set}\r\n     * @param {any} value - the value which sould be used to find the storage resource\r\n     * @param {!string} table - table which should be looking for\r\n     * @returns {Promise} result - Promise that will be fulfilled with the version. If not found it is fullfilled with undefined\r\n     * @memberof StorageManager\r\n     */\n\n  }, {\n    key: \"getVersion\",\n    value: function getVersion(key) {\n      var _this4 = this;\n\n      if (!key) throw Error('[SyncStorageManager.get] key is mandatory param');\n      return new Promise(function (resolve, reject) {\n        log.info('[SyncStorageManager.getVersion] for key ', key);\n\n        _this4.db.get(key).then(function (doc) {\n          resolve(doc._rev);\n        }, function (err) {\n          if (err.name === 'not_found') resolve(undefined);else reject(err);\n        });\n      });\n    }\n  }, {\n    key: \"remoteStorage\",\n    set: function set(remoteStorage) {\n      this._remoteStorage = remoteStorage + '/' + storageName;\n    }\n  }]);\n\n  return SyncStorageManager;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (SyncStorageManager);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvc3RvcmFnZS1tYW5hZ2VyL1N5bmNTdG9yYWdlTWFuYWdlci5qcz9hY2Y1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIExvZyBTeXN0ZW1cclxuaW1wb3J0ICogYXMgbG9nZ2VyIGZyb20gJ2xvZ2xldmVsJztcclxubGV0IGxvZyA9IGxvZ2dlci5nZXRMb2dnZXIoJ1N0b3JhZ2VNYW5hZ2VyJyk7XHJcblxyXG5jbGFzcyBTeW5jU3RvcmFnZU1hbmFnZXIge1xyXG5cclxuICBjb25zdHJ1Y3RvcihkYiwgc3RvcmFnZU5hbWUsIHJlbW90ZVN0b3JhZ2UpIHtcclxuICAgIGlmICghZGIpIHRocm93IEVycm9yKCdUaGUgU3RvcmFnZSBNYW5hZ2VyIG5lZWRzIHRoZSBkYXRhYmFzZSBpbnN0YW5jZScpO1xyXG4gICAgaWYgKCFzdG9yYWdlTmFtZSkgdGhyb3cgRXJyb3IoJ1RoZSBTdG9yYWdlIE1hbmFnZXIgbmVlZHMgdGhlIHN0b3JhZ2UgbmFtZScpO1xyXG4gICAgaWYgKCFyZW1vdGVTdG9yYWdlKSB0aHJvdyBFcnJvcignVGhlIFN0b3JhZ2UgTWFuYWdlciBuZWVkcyB0aGUgcmVtb3RlU3RvcmFnZSBjb25zdHJ1Y3RvciBwYXJhbScpO1xyXG5cclxuICAgIHRoaXMuZGIgPSBkYjtcclxuICAgIHRoaXMuc3RvcmFnZU5hbWUgPSBzdG9yYWdlTmFtZTtcclxuICAgIHRoaXMuX3JlbW90ZVN0b3JhZ2UgPSByZW1vdGVTdG9yYWdlICsgJy8nICsgc3RvcmFnZU5hbWU7XHJcbiAgfVxyXG5cclxuICAvLyBzZXQgcmVtb3RlU3RvcmFnZSBiYWNrdXAgc2VydmVyIFVSTFxyXG5cclxuICBzZXQgcmVtb3RlU3RvcmFnZShyZW1vdGVTdG9yYWdlKSB7XHJcbiAgICB0aGlzLl9yZW1vdGVTdG9yYWdlID0gcmVtb3RlU3RvcmFnZSArICcvJyArIHN0b3JhZ2VOYW1lO1xyXG4gIH1cclxuXHJcbiAgLy8gc3RhcnQgYmFja3VwIHdpdGggcmVtb3RlU3RvcmFnZSBzZXJ2ZXIuIFxyXG5cclxuICBjb25uZWN0KG9wdGlvbnMgPSB7IGxpdmU6IHRydWUsIHJldHJ5OiB0cnVlIH0pIHtcclxuICAgIC8vIHJldHVybiB0aGlzLmRiLmNvbm5lY3QodGhpcy5fcmVtb3RlU3RvcmFnZSwgb3B0aW9ucyk7XHJcblxyXG4gICAgbGV0IGxpdmUgPSAob3B0aW9ucyAmJiBvcHRpb25zLmhhc093blByb3BlcnR5KCdvbmNlJykpID8gIW9wdGlvbnMub25jZSA6IHRydWU7XHJcblxyXG4gICAgbGV0IG9wdHMgPSB7IGxpdmU6IGxpdmUsIHJldHJ5OiB0cnVlIH07XHJcblxyXG4gICAgcmV0dXJuIHRoaXMucmVwbGljYXRpb25IYW5kbGVyID0gdGhpcy5kYi5yZXBsaWNhdGUudG8odGhpcy5fcmVtb3RlU3RvcmFnZSwgb3B0cywgdGhpcy5fc3luY0Vycm9yKCkpO1xyXG4gIH1cclxuXHJcbiAgLy8gVGhlcmUgd2FzIHNvbWUgZm9ybSBvciBlcnJvciBzeW5jaW5nXHJcbiAgX3N5bmNFcnJvcigpIHtcclxuICAgIC8vIGRvIHNvbWV0aGluZ1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIHN0b3AgYmFja3VwIHdpdGggcmVtb3RlU3RvcmFnZSBzZXJ2ZXIuXHJcblxyXG4gIGRpc2Nvbm5lY3QoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXBsaWNhdGlvbkhhbmRsZXIuY2FuY2VsKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGEgbmV3IGVudHJ5IHRvIHRoZSBkYXRhYmFzZSBmb3IgYSBnaXZlbiBrZXksIHRvZ2V0aGVyIHdpdGggaXRzIHZlcnNpb24uXHJcbiAgICogSWYgYW4gZW50cnkgZm9yIHRoZSBnaXZlbiBrZXkgaXMgYWxyZWFkeSBzdG9yZWQgaW4gdGhlIGRhdGFiYXNlLCBpdCB3aWxsIGJlIHVwZGF0ZWQuXHJcbiAgICogQHBhcmFtIHshc3RyaW5nfSBrZXkgLSBrZXkgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIHtAbGluayBzdG9yYWdlTWFuYWdlci5nZXR9IHRvIHJldHJpZXZlIHRoZSB2YWx1ZSBvYmplY3RcclxuICAgKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSBzdG9yZWQgaW4gdGhlIGRhdGFiYXNlIHRoYXQgaXMgbWFwcGVkIHRvIGdpdmVuIGtleVxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSByZXN1bHQgLSBQcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgd2l0aCB0aGUgc3RvcmVkIGRvYyBpZiB0aGUgZW50cnkgd2FzIHN0b3JlZCBzdWNjZXNzZnVsbHksXHJcbiAgICogb3RoZXJ3aXNlIGl0IGlzIHJlamVjdGVkIHdpdGggYW4gZXJyb3IuXHJcbiAgICogQG1lbWJlcm9mIFN0b3JhZ2VNYW5hZ2VyXHJcbiAgICovXHJcblxyXG4gIHNldChrZXksIHZhbHVlLCB2ZXJzaW9uKSB7XHJcbiAgICBpZiAoIWtleSkgdGhyb3cgRXJyb3IoJ1tTeW5jU3RvcmFnZU1hbmFnZXIuc2V0XSBrZXkgaXMgbWFuZGF0b3J5IHBhcmFtJyk7XHJcbiAgICBpZiAoIXZhbHVlKSB0aHJvdyBFcnJvcignW1N5bmNTdG9yYWdlTWFuYWdlci5zZXRdIHZhbHVlIGlzIG1hbmRhdG9yeSBwYXJhbScpO1xyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdbU3luY1N0b3JhZ2VNYW5hZ2VyLnNldF0ga2V5ICcsIGtleSwgJyB2YWx1ZSAnLCB2YWx1ZSk7XHJcblxyXG4gICAgICB2YWx1ZS5faWQgPSBrZXk7XHJcblxyXG4gICAgICB0aGlzLmRiLmdldChrZXkpLnRoZW4oKGRvYykgPT4ge1xyXG4gICAgICAgIGxldCBkYXRhID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHsgdmFsdWU6IHZhbHVlIH0gOiB2YWx1ZTtcclxuXHJcbiAgICAgICAgLy8gaWYgbm8gdmVyc2lvbiBpcyBhc2tlZCB0byBzZXQsIGl0IGlzIGFzc3VtZWQgdG8gdXBkYXRlIHRoZSBzYW1lIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50XHJcbiAgICAgICAgLy8gaW4gb3JkZXIgdG8gYXZvaWQgdGhlIGluY3JlYXNlIG9mIHN0b3JhZ2UgcXVvdGEgdXNlZFxyXG4gICAgICAgIGRvYy5fcmV2ID0gdmVyc2lvbiA/IHZlcnNpb24gOiBkb2MuX3JldjtcclxuXHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbihkb2MsIGRhdGEpO1xyXG4gICAgICAgIHRoaXMuZGIucHV0KGRvYykudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICByZXNvbHZlKGRvYyk7XHJcblxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgfSwgKGVycikgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTeW5jU3RvcmFnZU1hbmFnZXIuc2V0XSAnLCBlcnIpO1xyXG4gICAgICAgIGlmIChlcnIubmFtZSA9PT0gJ25vdF9mb3VuZCcpIHtcclxuICAgICAgICAgIGxldCBvcHRzID0ge307XHJcbiAgICAgICAgICBpZiAodmVyc2lvbikge1xyXG4gICAgICAgICAgICB2YWx1ZS5fcmV2ID0gdmVyc2lvbjtcclxuICAgICAgICAgICAgb3B0cy5uZXdfZWRpdHMgPSBmYWxzZTtcclxuICAgICAgICAgIH0gXHJcbiAgICAgICAgICB0aGlzLmRiLnB1dCh2YWx1ZSwgb3B0cykudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xyXG4gICAgICAgICAgfSwoZXJyKSA9PiB7cmVqZWN0KGVycik7IH0gKTtcclxuICAgICAgICB9IGVsc2UgcmVqZWN0KGVycik7XHJcblxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhIGVudHJ5IHZhbHVlIGZyb20gdGhlIGRhdGFiYXNlIGZvciBhIGdpdmVuIGtleS5cclxuICAgKiBJZiBubyBlbnRyeSBpcyBmb3VuZCB1bmRlZmluZWQgaXMgcmV0dXJuZWQuXHJcbiAgICogQHBhcmFtIHshc3RyaW5nfSBrZXkgLSBrZXkgdGhhdCB3YXMgc3RvcmVkIHVzaW5nIHtAbGluayBzdG9yYWdlTWFuYWdlci5zZXR9XHJcbiAgICogQHBhcmFtIHshYW55fSB2YWx1ZSAtIHZhbHVlIHdoaWNoIHNob3VsZCBiZSBmb3VuZFxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSByZXN1bHQgLSBQcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgd2l0aCB0aGUgdmFsdWUuXHJcbiAgICogQG1lbWJlcm9mIFN0b3JhZ2VNYW5hZ2VyXHJcbiAgICovXHJcbiAgZ2V0KGtleSwgdmFsdWUpIHtcclxuICAgIC8vIFRPRE86IGFkZCBvcHRpb25zIGZvciBwYWdpbmF0aW9uIGZvciBET3Mgd2l0aCBoaWdoIG51bWJlciBvZiBjaGlsZCBvYmplY3RzXHJcbi8vICAgIGlmICgha2V5KSB0aHJvdyBFcnJvcignW1N5bmNTdG9yYWdlTWFuYWdlci5nZXRdIGtleSBpcyBtYW5kYXRvcnkgcGFyYW0nKTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG5cclxuICAgICAgbG9nLmluZm8oJ1tTeW5jU3RvcmFnZU1hbmFnZXIuZ2V0XSBrZXkgJywga2V5LCAnIHZhbHVlICcsIHZhbHVlKTtcclxuXHJcbiAgICAgIGlmIChrZXkpIHtcclxuICAgICAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgICAgICB0aGlzLmRiLmdldChrZXkpLnRoZW4oKGRvYyk9PntcclxuICAgICAgICAgICAgcmVzb2x2ZShkb2MpO1xyXG4gICAgICAgICAgfSwgKGVycik9PntcclxuICAgICAgICAgICAgaWYgKGVyci5uYW1lID09PSAnbm90X2ZvdW5kJykgcmVzb2x2ZSh1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIGVsc2UgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9IFxyXG4gICAgICAgIGVsc2UgdGhpcy5kYi5nZXQoa2V5KS50aGVuKChkb2MpID0+IHtcclxuICAgICAgICAgIGxvZy5pbmZvKCdbU3luY1N0b3JhZ2VNYW5hZ2VyLmdldF0gcmV0cmlldmVkIGRvYyAnLCBkb2MpO1xyXG4gICAgICAgICAgcmVzb2x2ZShkb2NbdmFsdWVdKTtcclxuICAgICAgICB9LCAoZXJyKT0+e1xyXG4gICAgICAgICAgaWYgKGVyci5uYW1lID09PSAnbm90X2ZvdW5kJykgcmVzb2x2ZSh1bmRlZmluZWQpXHJcbiAgICAgICAgICBlbHNlIHJlamVjdChlcnIpO1xyXG4gICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmRiLmFsbERvY3Moe2luY2x1ZGVfZG9jczogdHJ1ZX0pLnRoZW4oKGRvY3MpPT57XHJcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gW107XHJcbiAgICAgICAgICBkb2NzLmZvckVhY2goKGRvYyk9PntcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZG9jLmRvYyk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICB9LCAoZXJyKT0+e1xyXG4gICAgICAgICAgaWYgKGVyci5uYW1lID09PSAnbm90X2ZvdW5kJykgcmVzb2x2ZSh1bmRlZmluZWQpXHJcbiAgICAgICAgICBlbHNlIHJlamVjdChlcnIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgfSk7XHJcblxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVsZXRlIGEgZW50cnkgZnJvbSB0aGUgZGF0YWJhc2UgZm9yIGEgZ2l2ZW4ga2V5IG9yIHRoZSBmdWxsIERCIGluIGNhc2UgdGhlIGtleSBpcyBub3QgcHJvdmlkZWQuXHJcbiAgICogQHBhcmFtIHshc3RyaW5nfSBrZXkgLSBrZXkgdGhhdCB3YXMgc3RvcmVkIHVzaW5nIHtAbGluayBzdG9yYWdlTWFuYWdlci5zZXR9XHJcbiAgICogQHBhcmFtIHshYW55fSB2YWx1ZSAtIHRoZSB2YWx1ZSB3aGljaCBzb3VsZCBiZSB1c2VkIHRvIGZpbmQgdGhlIHN0b3JhZ2UgcmVzb3VyY2VcclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcmVzdWx0IC0gUHJvbWlzZSB0aGF0IHdpbGwgYmUganVzdCBmdWxmaWxsZWQgd2l0aCBubyB2YWx1ZXMgaWYgc29tZXRoaW5nIHdhcyBkZWxldGVkIG90aGVyd2lzZSBpdCBpcyBmdWxsZmlsbGVkIHdpdGggdW5kZWZpbmVkLlxyXG4gICAqIEBtZW1iZXJvZiBTdG9yYWdlTWFuYWdlclxyXG4gICAqL1xyXG5cclxuICBkZWxldGUoa2V5LCB2YWx1ZSkge1xyXG4gICAgLy90b2RvOiBpZiBubyBrZXkgZGVsZXRlIHRoZSBkYlxyXG4vLyAgICBpZiAoIWtleSkgdGhyb3cgRXJyb3IoJ1tTeW5jU3RvcmFnZU1hbmFnZXIuZ2V0XSBrZXkgaXMgbWFuZGF0b3J5IHBhcmFtJyk7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG5cclxuICAgICAgbG9nLmluZm8oJ1tTeW5jU3RvcmFnZU1hbmFnZXIuZGVsZXRlXSBrZXkgJywga2V5LCAnIHZhbHVlICcsIHZhbHVlKTtcclxuXHJcbiAgICAgIGlmIChrZXkpIHtcclxuICAgICAgICB0aGlzLmRiLmdldChrZXkpLnRoZW4oKGRvYykgPT4ge1xyXG4gICAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRiLnJlbW92ZShkb2MpLnRoZW4oKCk9PntcclxuICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH0sIHJlc29sdmUodW5kZWZpbmVkKSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBkZWxldGUgZG9jW3ZhbHVlXTtcclxuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLmRiLnB1dChkb2MpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LCAoZXJyKT0+e1xyXG4gICAgICAgICAgaWYgKGVyci5uYW1lID09PSAnbm90X2ZvdW5kJykgcmVzb2x2ZSh1bmRlZmluZWQpXHJcbiAgICAgICAgICBlbHNlIHJlamVjdChlcnIpO1xyXG4gICAgICAgIH0pO1xyXG4gIFxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRiLmRlc3Ryb3koKS50aGVuKCgpPT4gcmVzb2x2ZSgpLCAoZXJyKSA9PiByZWplY3QoZXJyKSApXHJcbiAgICAgIH0gXHJcblxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIHZlcnNpb24gZnJvbSB0aGUgZGF0YWJhc2UgZm9yIGEgZ2l2ZW4ga2V5LlxyXG4gICAqIElmIG5vIGVudHJ5IGlzIGZvdW5kIHVuZGVmaW5lZCBpcyByZXR1cm5lZC5cclxuICAgKiBAcGFyYW0geyFzdHJpbmd9IGtleSAtIGtleSB0aGF0IHdhcyBzdG9yZWQgdXNpbmcge0BsaW5rIHN0b3JhZ2VNYW5hZ2VyLnNldH1cclxuICAgKiBAcGFyYW0ge2FueX0gdmFsdWUgLSB0aGUgdmFsdWUgd2hpY2ggc291bGQgYmUgdXNlZCB0byBmaW5kIHRoZSBzdG9yYWdlIHJlc291cmNlXHJcbiAgICogQHBhcmFtIHshc3RyaW5nfSB0YWJsZSAtIHRhYmxlIHdoaWNoIHNob3VsZCBiZSBsb29raW5nIGZvclxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSByZXN1bHQgLSBQcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgd2l0aCB0aGUgdmVyc2lvbi4gSWYgbm90IGZvdW5kIGl0IGlzIGZ1bGxmaWxsZWQgd2l0aCB1bmRlZmluZWRcclxuICAgKiBAbWVtYmVyb2YgU3RvcmFnZU1hbmFnZXJcclxuICAgKi9cclxuICBnZXRWZXJzaW9uKGtleSkge1xyXG4gICAgaWYgKCFrZXkpIHRocm93IEVycm9yKCdbU3luY1N0b3JhZ2VNYW5hZ2VyLmdldF0ga2V5IGlzIG1hbmRhdG9yeSBwYXJhbScpO1xyXG5cclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG5cclxuICAgICAgbG9nLmluZm8oJ1tTeW5jU3RvcmFnZU1hbmFnZXIuZ2V0VmVyc2lvbl0gZm9yIGtleSAnLCBrZXkpO1xyXG5cclxuICAgICAgICB0aGlzLmRiLmdldChrZXkpLnRoZW4oKGRvYyk9PntcclxuICAgICAgICAgIHJlc29sdmUoZG9jLl9yZXYpO1xyXG4gICAgICAgIH0sIChlcnIpPT57XHJcbiAgICAgICAgICBpZiAoZXJyLm5hbWUgPT09ICdub3RfZm91bmQnKSByZXNvbHZlKHVuZGVmaW5lZClcclxuICAgICAgICAgIGVsc2UgcmVqZWN0KGVycik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgfVxyXG5cclxuXHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTeW5jU3RvcmFnZU1hbmFnZXI7XHJcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQU1BO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFLQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7O0FBVUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBOzs7Ozs7Ozs7OztBQVFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUVBOzs7Ozs7Ozs7O0FBUUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7OztBQVNBO0FBQUE7QUFDQTtBQUFBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7OztBQTdMQTtBQUNBO0FBQ0E7Ozs7OztBQWlNQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///25\n")},44:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _storage_manager_StorageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StorageManager", function() { return _storage_manager_StorageManager__WEBPACK_IMPORTED_MODULE_0__["a"]; });\n\n/* harmony import */ var _storage_manager_SyncStorageManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SyncStorageManager", function() { return _storage_manager_SyncStorageManager__WEBPACK_IMPORTED_MODULE_1__["a"]; });\n\n/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the "License");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an "AS IS" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvc3RvcmFnZS1tYW5hZ2VyLXBhY2suanM/OTJkNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuKiBDb3B5cmlnaHQgMjAxNiBQVCBJbm92YcOnw6NvIGUgU2lzdGVtYXMgU0FcclxuKiBDb3B5cmlnaHQgMjAxNiBJTkVTQy1JRFxyXG4qIENvcHlyaWdodCAyMDE2IFFVT0JJUyBORVRXT1JLUyBTTFxyXG4qIENvcHlyaWdodCAyMDE2IEZSQVVOSE9GRVItR0VTRUxMU0NIQUZUIFpVUiBGT0VSREVSVU5HIERFUiBBTkdFV0FORFRFTiBGT1JTQ0hVTkcgRS5WXHJcbiogQ29weXJpZ2h0IDIwMTYgT1JBTkdFIFNBXHJcbiogQ29weXJpZ2h0IDIwMTYgRGV1dHNjaGUgVGVsZWtvbSBBR1xyXG4qIENvcHlyaWdodCAyMDE2IEFwaXplZVxyXG4qIENvcHlyaWdodCAyMDE2IFRFQ0hOSVNDSEUgVU5JVkVSU0lUQVQgQkVSTElOXHJcbipcclxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKiovXHJcbmltcG9ydCBTdG9yYWdlTWFuYWdlciBmcm9tICcuL3N0b3JhZ2UtbWFuYWdlci9TdG9yYWdlTWFuYWdlcic7XHJcbmltcG9ydCBTeW5jU3RvcmFnZU1hbmFnZXIgZnJvbSAnLi9zdG9yYWdlLW1hbmFnZXIvU3luY1N0b3JhZ2VNYW5hZ2VyJztcclxuXHJcbmV4cG9ydCB7U3RvcmFnZU1hbmFnZXIsIFN5bmNTdG9yYWdlTWFuYWdlcn07XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///44\n')}})});