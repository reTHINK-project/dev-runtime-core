// version: 0.16.0
// date: Sat Feb 23 2019 15:09:57 GMT+0000 (GMT)
// licence: 
/**
* Copyright 2016 PT Inovação e Sistemas SA
* Copyright 2016 INESC-ID
* Copyright 2016 QUOBIS NETWORKS SL
* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V
* Copyright 2016 ORANGE SA
* Copyright 2016 Deutsche Telekom AG
* Copyright 2016 Apizee
* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
**/


// version: 0.16.0
// date: Sat Feb 23 2019 15:09:57 GMT+0000 (GMT)
// licence: 
/**
* Copyright 2016 PT Inovação e Sistemas SA
* Copyright 2016 INESC-ID
* Copyright 2016 QUOBIS NETWORKS SL
* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V
* Copyright 2016 ORANGE SA
* Copyright 2016 Deutsche Telekom AG
* Copyright 2016 Apizee
* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
**/


!function(g,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define("StorageManager",[],e):"object"==typeof exports?exports.StorageManager=e():g.StorageManager=e()}(window,function(){return function(g){var e={};function I(n){if(e[n])return e[n].exports;var t=e[n]={i:n,l:!1,exports:{}};return g[n].call(t.exports,t,t.exports,I),t.l=!0,t.exports}return I.m=g,I.c=e,I.d=function(g,e,n){I.o(g,e)||Object.defineProperty(g,e,{enumerable:!0,get:n})},I.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},I.t=function(g,e){if(1&e&&(g=I(g)),8&e)return g;if(4&e&&"object"==typeof g&&g&&g.__esModule)return g;var n=Object.create(null);if(I.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:g}),2&e&&"string"!=typeof g)for(var t in g)I.d(n,t,function(e){return g[e]}.bind(null,t));return n},I.n=function(g){var e=g&&g.__esModule?function(){return g.default}:function(){return g};return I.d(e,"a",e),e},I.o=function(g,e){return Object.prototype.hasOwnProperty.call(g,e)},I.p="",I(I.s=44)}({1:function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    "use strict";\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}(this, function () {\n    "use strict";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = "undefined";\n\n    var logMethods = [\n        "trace",\n        "debug",\n        "info",\n        "warn",\n        "error"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === \'function\') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === \'debug\') {\n            methodName = \'log\';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, \'log\');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn\'t present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      var storageKey = "loglevel";\n      if (name) {\n        storageKey += ":" + name;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || \'silent\').toUpperCase();\n\n          if (typeof window === undefinedType) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + "=" + levelName + ";";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + "=");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,\n          "ERROR": 4, "SILENT": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return "No console available for logging";\n              }\n          } else {\n              throw "log.setLevel() called with invalid level: " + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== "string" || name === "") {\n          throw new TypeError("You must supply a name when creating a logger.");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    return defaultLogger;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9sb2dsZXZlbC9saWIvbG9nbGV2ZWwuanM/NWM3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuKiBsb2dsZXZlbCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTMgVGltIFBlcnJ5XG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiovXG4oZnVuY3Rpb24gKHJvb3QsIGRlZmluaXRpb24pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShkZWZpbml0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QubG9nID0gZGVmaW5pdGlvbigpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gU2xpZ2h0bHkgZHViaW91cyB0cmlja3MgdG8gY3V0IGRvd24gbWluaW1pemVkIGZpbGUgc2l6ZVxuICAgIHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcbiAgICB2YXIgdW5kZWZpbmVkVHlwZSA9IFwidW5kZWZpbmVkXCI7XG5cbiAgICB2YXIgbG9nTWV0aG9kcyA9IFtcbiAgICAgICAgXCJ0cmFjZVwiLFxuICAgICAgICBcImRlYnVnXCIsXG4gICAgICAgIFwiaW5mb1wiLFxuICAgICAgICBcIndhcm5cIixcbiAgICAgICAgXCJlcnJvclwiXG4gICAgXTtcblxuICAgIC8vIENyb3NzLWJyb3dzZXIgYmluZCBlcXVpdmFsZW50IHRoYXQgd29ya3MgYXQgbGVhc3QgYmFjayB0byBJRTZcbiAgICBmdW5jdGlvbiBiaW5kTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgbWV0aG9kID0gb2JqW21ldGhvZE5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZC5iaW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmJpbmQob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwobWV0aG9kLCBvYmopO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIE1pc3NpbmcgYmluZCBzaGltIG9yIElFOCArIE1vZGVybml6ciwgZmFsbGJhY2sgdG8gd3JhcHBpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkobWV0aG9kLCBbb2JqLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgdGhlIGJlc3QgbG9nZ2luZyBtZXRob2QgcG9zc2libGUgZm9yIHRoaXMgZW52XG4gICAgLy8gV2hlcmV2ZXIgcG9zc2libGUgd2Ugd2FudCB0byBiaW5kLCBub3Qgd3JhcCwgdG8gcHJlc2VydmUgc3RhY2sgdHJhY2VzXG4gICAgZnVuY3Rpb24gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmIChtZXRob2ROYW1lID09PSAnZGVidWcnKSB7XG4gICAgICAgICAgICBtZXRob2ROYW1lID0gJ2xvZyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gbWV0aG9kIHBvc3NpYmxlLCBmb3Igbm93IC0gZml4ZWQgbGF0ZXIgYnkgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlc1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZS5sb2cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgJ2xvZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGVzZSBwcml2YXRlIGZ1bmN0aW9ucyBhbHdheXMgbmVlZCBgdGhpc2AgdG8gYmUgc2V0IHByb3Blcmx5XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGxvZ01ldGhvZHNbaV07XG4gICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdID0gKGkgPCBsZXZlbCkgP1xuICAgICAgICAgICAgICAgIG5vb3AgOlxuICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZpbmUgbG9nLmxvZyBhcyBhbiBhbGlhcyBmb3IgbG9nLmRlYnVnXG4gICAgICAgIHRoaXMubG9nID0gdGhpcy5kZWJ1ZztcbiAgICB9XG5cbiAgICAvLyBJbiBvbGQgSUUgdmVyc2lvbnMsIHRoZSBjb25zb2xlIGlzbid0IHByZXNlbnQgdW50aWwgeW91IGZpcnN0IG9wZW4gaXQuXG4gICAgLy8gV2UgYnVpbGQgcmVhbE1ldGhvZCgpIHJlcGxhY2VtZW50cyBoZXJlIHRoYXQgcmVnZW5lcmF0ZSBsb2dnaW5nIG1ldGhvZHNcbiAgICBmdW5jdGlvbiBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzKG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbCh0aGlzLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHVzZSBjbG9zZWx5IGJvdW5kIHJlYWwgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZSwgYW5kXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdhaXQgZm9yIGEgY29uc29sZSB0byBhcHBlYXIsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICByZXR1cm4gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB8fFxuICAgICAgICAgICAgICAgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvZ2dlcihuYW1lLCBkZWZhdWx0TGV2ZWwsIGZhY3RvcnkpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjdXJyZW50TGV2ZWw7XG4gICAgICB2YXIgc3RvcmFnZUtleSA9IFwibG9nbGV2ZWxcIjtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHN0b3JhZ2VLZXkgKz0gXCI6XCIgKyBuYW1lO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsTnVtKSB7XG4gICAgICAgICAgdmFyIGxldmVsTmFtZSA9IChsb2dNZXRob2RzW2xldmVsTnVtXSB8fCAnc2lsZW50JykudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlKSByZXR1cm47XG5cbiAgICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV0gPSBsZXZlbE5hbWU7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID1cbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIiArIGxldmVsTmFtZSArIFwiO1wiO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0UGVyc2lzdGVkTGV2ZWwoKSB7XG4gICAgICAgICAgdmFyIHN0b3JlZExldmVsO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUpIHJldHVybjtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XTtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBjb29raWVzIGlmIGxvY2FsIHN0b3JhZ2UgZ2l2ZXMgdXMgbm90aGluZ1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVkTGV2ZWwgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb29raWUgPSB3aW5kb3cuZG9jdW1lbnQuY29va2llO1xuICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY29va2llLmluZGV4T2YoXG4gICAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIpO1xuICAgICAgICAgICAgICAgICAgaWYgKGxvY2F0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZExldmVsID0gL14oW147XSspLy5leGVjKGNvb2tpZS5zbGljZShsb2NhdGlvbikpWzFdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhlIHN0b3JlZCBsZXZlbCBpcyBub3QgdmFsaWQsIHRyZWF0IGl0IGFzIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cbiAgICAgICAgICBpZiAoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN0b3JlZExldmVsO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgICpcbiAgICAgICAqIFB1YmxpYyBsb2dnZXIgQVBJIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbCBmb3IgZGV0YWlsc1xuICAgICAgICpcbiAgICAgICAqL1xuXG4gICAgICBzZWxmLm5hbWUgPSBuYW1lO1xuXG4gICAgICBzZWxmLmxldmVscyA9IHsgXCJUUkFDRVwiOiAwLCBcIkRFQlVHXCI6IDEsIFwiSU5GT1wiOiAyLCBcIldBUk5cIjogMyxcbiAgICAgICAgICBcIkVSUk9SXCI6IDQsIFwiU0lMRU5UXCI6IDV9O1xuXG4gICAgICBzZWxmLm1ldGhvZEZhY3RvcnkgPSBmYWN0b3J5IHx8IGRlZmF1bHRNZXRob2RGYWN0b3J5O1xuXG4gICAgICBzZWxmLmdldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50TGV2ZWw7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsLCBwZXJzaXN0KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIiAmJiBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGxldmVsID0gc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwibnVtYmVyXCIgJiYgbGV2ZWwgPj0gMCAmJiBsZXZlbCA8PSBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgY3VycmVudExldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICAgIGlmIChwZXJzaXN0ICE9PSBmYWxzZSkgeyAgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZiwgbGV2ZWwsIG5hbWUpO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUgJiYgbGV2ZWwgPCBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBcIk5vIGNvbnNvbGUgYXZhaWxhYmxlIGZvciBsb2dnaW5nXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBcImxvZy5zZXRMZXZlbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgbGV2ZWw6IFwiICsgbGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXREZWZhdWx0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICBpZiAoIWdldFBlcnNpc3RlZExldmVsKCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5zZXRMZXZlbChsZXZlbCwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZW5hYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuVFJBQ0UsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5kaXNhYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuU0lMRU5ULCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEluaXRpYWxpemUgd2l0aCB0aGUgcmlnaHQgbGV2ZWxcbiAgICAgIHZhciBpbml0aWFsTGV2ZWwgPSBnZXRQZXJzaXN0ZWRMZXZlbCgpO1xuICAgICAgaWYgKGluaXRpYWxMZXZlbCA9PSBudWxsKSB7XG4gICAgICAgICAgaW5pdGlhbExldmVsID0gZGVmYXVsdExldmVsID09IG51bGwgPyBcIldBUk5cIiA6IGRlZmF1bHRMZXZlbDtcbiAgICAgIH1cbiAgICAgIHNlbGYuc2V0TGV2ZWwoaW5pdGlhbExldmVsLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKlxuICAgICAqIFRvcC1sZXZlbCBBUElcbiAgICAgKlxuICAgICAqL1xuXG4gICAgdmFyIGRlZmF1bHRMb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG5cbiAgICB2YXIgX2xvZ2dlcnNCeU5hbWUgPSB7fTtcbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlciA9IGZ1bmN0aW9uIGdldExvZ2dlcihuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIiB8fCBuYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV07XG4gICAgICAgIGlmICghbG9nZ2VyKSB7XG4gICAgICAgICAgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV0gPSBuZXcgTG9nZ2VyKFxuICAgICAgICAgICAgbmFtZSwgZGVmYXVsdExvZ2dlci5nZXRMZXZlbCgpLCBkZWZhdWx0TG9nZ2VyLm1ldGhvZEZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgfTtcblxuICAgIC8vIEdyYWIgdGhlIGN1cnJlbnQgZ2xvYmFsIGxvZyB2YXJpYWJsZSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICAgIHZhciBfbG9nID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpID8gd2luZG93LmxvZyA6IHVuZGVmaW5lZDtcbiAgICBkZWZhdWx0TG9nZ2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUgJiZcbiAgICAgICAgICAgICAgIHdpbmRvdy5sb2cgPT09IGRlZmF1bHRMb2dnZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG4gICAgfTtcblxuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VycyA9IGZ1bmN0aW9uIGdldExvZ2dlcnMoKSB7XG4gICAgICAgIHJldHVybiBfbG9nZ2Vyc0J5TmFtZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG59KSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQSxhQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n')},24:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_0__);\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Log System\n\nvar log = loglevel__WEBPACK_IMPORTED_MODULE_0__[\"getLogger\"]('StorageManager');\n\nvar StorageManager =\n/*#__PURE__*/\nfunction () {\n  function StorageManager(db, storageName, schemas, runtimeUA) {\n    var version = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n    var remoteStorage = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n    _classCallCheck(this, StorageManager);\n\n    if (!db) throw Error('The Storage Manager needs the database instance');\n    if (!storageName) throw Error('The Storage Manager needs the storage name');\n    var stores = {};\n\n    if (schemas) {\n      stores = schemas;\n    } else {\n      stores[storageName] = 'key,version,value';\n    } //    db.version(version).stores(stores);\n\n\n    db.open().then(function (db) {\n      log.info('Found database name ' + db.name + ' with version no: ' + db.verno);\n    }).catch(log.error);\n    this.db = db;\n    this.storageName = storageName;\n    this._remoteStorage = remoteStorage;\n    this._runtimeUA = runtimeUA;\n  } // set remoteStorage backup server URL\n\n\n  _createClass(StorageManager, [{\n    key: \"_checkKey\",\n    // start sync with remoteStorage server. Returns a promise that resolves if connection is performed otherwise it is rejected\n\n    /*  connect(options) {\r\n        return this.db.connect(this._remoteStorage, options);\r\n      }*/\n    // stop sync with remoteStorage server. Returns promise \n\n    /*  disconnect() {\r\n       return new Promise((resolve,reject) => {\r\n          this.db.disconnect(this._remoteStorage).then(()=> {\r\n            resolve();\r\n          }, (error) => {\r\n          reject(error);\r\n        });\r\n      });\r\n      }*/\n    // to retrieve the last revision stored in the backup server\n\n    /*  getBackupRevision(resource) {\r\n    \r\n        return new Promise((resolve)=> {\r\n          this.db._syncNodes.get({type: 'remote'}).then((status)=> {\r\n            console.log('[StorageManager.getBackupRevision] retrieved status: ', status);\r\n            if (status && status.hasOwnProperty('appliedRemoteRevision')) {\r\n              if (status.appliedRemoteRevision === null) status.appliedRemoteRevision = 0;\r\n    \r\n              resolve(status.appliedRemoteRevision);\r\n            } \r\n        });\r\n      });\r\n      }*/\n    // to retrieve the last revision stored in the backup server\n    // and broadcast it\n\n    /* _updateBackupRevision(resource) {\r\n    \n       return new Promise((resolve)=> {\r\n         this.db._syncNodes.get({type: 'remote'}).then((status)=> {\r\n           console.log('[StorageManager._updateBackupRevision] retrieved status: ', status);\r\n           if (status && status.hasOwnProperty('appliedRemoteRevision')) {\r\n             if (status.appliedRemoteRevision === null) status.appliedRemoteRevision = 0;\r\n    \n             this._runtimeUA._updateRuntimeStatus(\r\n               {\r\n                 resource: resource,\r\n                 value: { backupRevision: status.appliedRemoteRevision }\r\n               }\r\n             )\r\n             resolve(status.appliedRemoteRevision);\r\n           } \r\n       });\r\n     });\r\n     }*/\n    value: function _checkKey(key) {\n      if (typeof key !== 'string') return key.toString();\n      return key;\n    }\n  }, {\n    key: \"_getTable\",\n    value: function _getTable(key) {\n      var name;\n\n      try {\n        name = this.db.table(this.storageName).name;\n      } catch (error) {\n        //      try {\n        name = this.db.table(key).name;\n        /*      } catch (error) {\r\n                log.error('[StorageManager._getTable] error ', error);\r\n                name = false;\r\n              }*/\n      }\n\n      return name;\n    }\n  }, {\n    key: \"_getPrimaryKey\",\n    value: function _getPrimaryKey(table) {\n      return this.db.table(table).schema.primKey.name;\n    }\n  }, {\n    key: \"_isDefaultSchema\",\n    value: function _isDefaultSchema(table) {\n      var name = this._getTable(table);\n\n      var schema = this.db[name].schema.instanceTemplate;\n      return schema.hasOwnProperty('value') && schema.hasOwnProperty('version') && schema.hasOwnProperty('key');\n    }\n    /**\r\n     * Adds a new entry to the database for a given key, together with its version.\r\n     * If an entry for the given key is already stored in the database, it will be updated.\r\n     * @param {!string} key - key that can be used with {@link storageManager.get} to retrieve the value object\r\n     * @param {!string} version - version descriptor for the given value\r\n     * @param value - value stored in the database that is mapped to given key\r\n     * @param {!string} table - table which should be looking for\r\n     * @returns {Promise} result - Promise that will be fulfilled with the key if the entry was stored successfully,\r\n     * otherwise it is rejected with an error.\r\n     * @memberof StorageManager\r\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(key, version, value, table) {\n      var _this = this;\n\n      var updateRuntimeStatus = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n      return new Promise(function (resolve, reject) {\n        log.info('[StorageManager] - set ', key, value);\n        table = table ? table : key;\n\n        var name = _this._getTable(table);\n\n        var primaryKey = _this._getPrimaryKey(name); // Object.assign(value, {version: version});\n\n\n        var data = value;\n\n        if (_this._isDefaultSchema(table)) {\n          data = {\n            key: key,\n            version: version,\n            value: value\n          };\n        } else {\n          var tmp = {};\n          tmp[primaryKey] = key;\n          Object.assign(data, tmp);\n        }\n\n        log.info('[StorageManager.set] data to put ', data);\n\n        _this.db[name].put(data).then(function () {\n          /*      if (updateRuntimeStatus && data.backup && data.url) {\r\n                  this._updateBackupRevision(data.url).then(()=> {\r\n                    resolve();\r\n                  });\r\n                } else */\n          resolve();\n        }, function () {\n          resolve();\n        });\n      });\n    }\n    /**\r\n     * Get a entry value from the database for a given key.\r\n     * If no entry is found undefined is returned.\r\n     * @param {!string} key - key that was stored using {@link storageManager.set}\r\n     * @param {!any} value - value which should be found\r\n     * @param {!string} table - table which should be looking for\r\n     * @returns {Promise} result - Promise that will be fulfilled with the value.\r\n     * @memberof StorageManager\r\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(key, value, table) {\n      var _this2 = this;\n\n      console.info('[StorageManager] - get ', key, value);\n      return new Promise(function (resolve, reject) {\n        table = table ? table : key;\n\n        var name = _this2._getTable(table);\n\n        if (!name) resolve(undefined);\n\n        var primaryKey = _this2._getPrimaryKey(name);\n\n        var result = _this2.db.transaction('rw!', _this2.db[name], function () {\n          if (!key && !value) {\n            return _this2.db[name].toArray().then(function (objects) {\n              if (objects.length > 0) {\n                return objects.reduce(function (acc, key) {\n                  acc[key[primaryKey]] = key;\n                  return acc;\n                }, function () {\n                  return {};\n                });\n              } else return {};\n            });\n          }\n\n          if (!value) {\n            return _this2.db[name].where(primaryKey).equals(key).first().then(function (object) {\n              if (object && object.hasOwnProperty('value')) {\n                return object.value;\n              } else {\n                return object;\n              }\n            });\n          } else {\n            var type = _typeof(value);\n\n            if (Array.isArray(value)) {\n              type = 'array';\n            }\n\n            switch (type) {\n              case 'string':\n                return _this2.db[name].where(key).equals(value).first().then(function (object) {\n                  if (object && object.hasOwnProperty('value')) {\n                    return object.value;\n                  } else {\n                    return object;\n                  }\n                });\n\n              case 'object':\n                {\n                  var strPath = 'value.' + Object.keys(value).toString();\n                  var strValue = Object.values(value);\n                  console.log(strPath, strValue);\n                  return _this2.db[name].where(strPath).anyOf(strValue).first().then(function (object) {\n                    if (object && object.hasOwnProperty('value')) {\n                      return object.value;\n                    } else {\n                      return object;\n                    }\n                  });\n                }\n\n              case 'array':\n                console.log('ARRAY:', value);\n                return _this2.db[name].where(value).then(function (object) {\n                  if (object && object.hasOwnProperty('value')) {\n                    return object.value;\n                  } else {\n                    return object;\n                  }\n                });\n            }\n          }\n        });\n\n        resolve(result);\n      });\n    }\n    /**\r\n     * Get a entry version from the database for a given key.\r\n     * If no entry is found undefined is returned.\r\n     * @param {!string} key - key that was stored using {@link storageManager.set}\r\n     * @param {any} value - the value which sould be used to find the storage resource\r\n     * @param {!string} table - table which should be looking for\r\n     * @returns {Promise} result - Promise that will be fulfilled with the version.\r\n     * @memberof StorageManager\r\n     */\n\n  }, {\n    key: \"getVersion\",\n    value: function getVersion(key, value, table) {\n      var _this3 = this;\n\n      log.info('[StorageManager] - getVersion for key ', key);\n      table = table ? table : key;\n\n      var name = this._getTable(table);\n\n      var primaryKey = this._getPrimaryKey(name);\n\n      var data = value;\n\n      if (!value) {\n        data = key;\n      }\n\n      return this.db.transaction('rw!', this.db[name], function () {\n        return _this3.db[name].where(primaryKey).equals(data).first().then(function (object) {\n          if (object && object.hasOwnProperty('version')) {\n            return object.version;\n          } else {\n            return object;\n          }\n        }).catch(function (error) {\n          log.info('error getting the version for ', key, ' with error: ', error);\n          return undefined;\n        });\n      });\n    }\n    /**\r\n     * Delete a entry from the database for a given key or the full DB in case the key is not provided.\r\n     * @param {!string} key - key that was stored using {@link storageManager.set}\r\n     * @param {!any} value - the value which sould be used to find the storage resource\r\n     * @param {!string} table - table which should be looking for\r\n     * @returns {Promise} result - Promise that will be fulfilled with the number of affected rows.\r\n     * @memberof StorageManager\r\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(key, value, table) {\n      if (key) {\n        table = table ? table : key;\n\n        var name = this._getTable(table);\n\n        var primaryKey = this._getPrimaryKey(name);\n\n        var data = value;\n\n        if (!value) {\n          data = key;\n        }\n\n        return this.db[name].where(primaryKey).equals(data).delete();\n      } else return this.db.delete();\n    }\n  }, {\n    key: \"remoteStorage\",\n    set: function set(remoteStorage) {\n      this._remoteStorage = remoteStorage;\n    }\n  }]);\n\n  return StorageManager;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (StorageManager);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvc3RvcmFnZS1tYW5hZ2VyL1N0b3JhZ2VNYW5hZ2VyLmpzPzhiMjEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gTG9nIFN5c3RlbVxyXG5pbXBvcnQgKiBhcyBsb2dnZXIgZnJvbSAnbG9nbGV2ZWwnO1xyXG5sZXQgbG9nID0gbG9nZ2VyLmdldExvZ2dlcignU3RvcmFnZU1hbmFnZXInKTtcclxuXHJcbmNsYXNzIFN0b3JhZ2VNYW5hZ2VyIHtcclxuXHJcbiAgY29uc3RydWN0b3IoZGIsIHN0b3JhZ2VOYW1lLCBzY2hlbWFzLCBydW50aW1lVUEsIHZlcnNpb24gPSAxLCByZW1vdGVTdG9yYWdlID0gZmFsc2UpIHtcclxuICAgIGlmICghZGIpIHRocm93IEVycm9yKCdUaGUgU3RvcmFnZSBNYW5hZ2VyIG5lZWRzIHRoZSBkYXRhYmFzZSBpbnN0YW5jZScpO1xyXG4gICAgaWYgKCFzdG9yYWdlTmFtZSkgdGhyb3cgRXJyb3IoJ1RoZSBTdG9yYWdlIE1hbmFnZXIgbmVlZHMgdGhlIHN0b3JhZ2UgbmFtZScpO1xyXG5cclxuICAgIGxldCBzdG9yZXMgPSAge307XHJcblxyXG4gICAgaWYgKHNjaGVtYXMpIHtcclxuICAgICAgc3RvcmVzID0gc2NoZW1hcztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0b3Jlc1tzdG9yYWdlTmFtZV0gPSAna2V5LHZlcnNpb24sdmFsdWUnO1xyXG4gICAgfVxyXG5cclxuLy8gICAgZGIudmVyc2lvbih2ZXJzaW9uKS5zdG9yZXMoc3RvcmVzKTtcclxuICAgIGRiLm9wZW4oKS50aGVuKChkYikgPT4ge1xyXG4gICAgICBsb2cuaW5mbygnRm91bmQgZGF0YWJhc2UgbmFtZSAnICsgZGIubmFtZSArICcgd2l0aCB2ZXJzaW9uIG5vOiAnICsgZGIudmVybm8pO1xyXG4gICAgfSkuY2F0Y2gobG9nLmVycm9yKTtcclxuXHJcbiAgICB0aGlzLmRiID0gZGI7XHJcbiAgICB0aGlzLnN0b3JhZ2VOYW1lID0gc3RvcmFnZU5hbWU7XHJcbiAgICB0aGlzLl9yZW1vdGVTdG9yYWdlID0gcmVtb3RlU3RvcmFnZTtcclxuICAgIHRoaXMuX3J1bnRpbWVVQSA9IHJ1bnRpbWVVQTtcclxuICB9XHJcblxyXG4gIC8vIHNldCByZW1vdGVTdG9yYWdlIGJhY2t1cCBzZXJ2ZXIgVVJMXHJcblxyXG4gIHNldCByZW1vdGVTdG9yYWdlKHJlbW90ZVN0b3JhZ2UpIHtcclxuICAgIHRoaXMuX3JlbW90ZVN0b3JhZ2UgPSByZW1vdGVTdG9yYWdlO1xyXG4gIH1cclxuXHJcbiAgLy8gc3RhcnQgc3luYyB3aXRoIHJlbW90ZVN0b3JhZ2Ugc2VydmVyLiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGlmIGNvbm5lY3Rpb24gaXMgcGVyZm9ybWVkIG90aGVyd2lzZSBpdCBpcyByZWplY3RlZFxyXG5cclxuLyogIGNvbm5lY3Qob3B0aW9ucykge1xyXG4gICAgcmV0dXJuIHRoaXMuZGIuY29ubmVjdCh0aGlzLl9yZW1vdGVTdG9yYWdlLCBvcHRpb25zKTtcclxuICB9Ki9cclxuXHJcbiAgLy8gc3RvcCBzeW5jIHdpdGggcmVtb3RlU3RvcmFnZSBzZXJ2ZXIuIFJldHVybnMgcHJvbWlzZSBcclxuXHJcbi8qICBkaXNjb25uZWN0KCkge1xyXG4gICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUscmVqZWN0KSA9PiB7XHJcbiAgICAgIHRoaXMuZGIuZGlzY29ubmVjdCh0aGlzLl9yZW1vdGVTdG9yYWdlKS50aGVuKCgpPT4ge1xyXG4gICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgfSwgKGVycm9yKSA9PiB7XHJcbiAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICB9KTtcclxuICB9KTtcclxuICB9Ki9cclxuICAvLyB0byByZXRyaWV2ZSB0aGUgbGFzdCByZXZpc2lvbiBzdG9yZWQgaW4gdGhlIGJhY2t1cCBzZXJ2ZXJcclxuXHJcbi8qICBnZXRCYWNrdXBSZXZpc2lvbihyZXNvdXJjZSkge1xyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSk9PiB7XHJcbiAgICAgIHRoaXMuZGIuX3N5bmNOb2Rlcy5nZXQoe3R5cGU6ICdyZW1vdGUnfSkudGhlbigoc3RhdHVzKT0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZygnW1N0b3JhZ2VNYW5hZ2VyLmdldEJhY2t1cFJldmlzaW9uXSByZXRyaWV2ZWQgc3RhdHVzOiAnLCBzdGF0dXMpO1xyXG4gICAgICAgIGlmIChzdGF0dXMgJiYgc3RhdHVzLmhhc093blByb3BlcnR5KCdhcHBsaWVkUmVtb3RlUmV2aXNpb24nKSkge1xyXG4gICAgICAgICAgaWYgKHN0YXR1cy5hcHBsaWVkUmVtb3RlUmV2aXNpb24gPT09IG51bGwpIHN0YXR1cy5hcHBsaWVkUmVtb3RlUmV2aXNpb24gPSAwO1xyXG5cclxuICAgICAgICAgIHJlc29sdmUoc3RhdHVzLmFwcGxpZWRSZW1vdGVSZXZpc2lvbik7XHJcbiAgICAgICAgfSBcclxuICAgIH0pO1xyXG4gIH0pO1xyXG4gIH0qL1xyXG5cclxuICAvLyB0byByZXRyaWV2ZSB0aGUgbGFzdCByZXZpc2lvbiBzdG9yZWQgaW4gdGhlIGJhY2t1cCBzZXJ2ZXJcclxuICAvLyBhbmQgYnJvYWRjYXN0IGl0XHJcblxyXG4gLyogX3VwZGF0ZUJhY2t1cFJldmlzaW9uKHJlc291cmNlKSB7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKT0+IHtcclxuICAgICAgdGhpcy5kYi5fc3luY05vZGVzLmdldCh7dHlwZTogJ3JlbW90ZSd9KS50aGVuKChzdGF0dXMpPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbU3RvcmFnZU1hbmFnZXIuX3VwZGF0ZUJhY2t1cFJldmlzaW9uXSByZXRyaWV2ZWQgc3RhdHVzOiAnLCBzdGF0dXMpO1xyXG4gICAgICAgIGlmIChzdGF0dXMgJiYgc3RhdHVzLmhhc093blByb3BlcnR5KCdhcHBsaWVkUmVtb3RlUmV2aXNpb24nKSkge1xyXG4gICAgICAgICAgaWYgKHN0YXR1cy5hcHBsaWVkUmVtb3RlUmV2aXNpb24gPT09IG51bGwpIHN0YXR1cy5hcHBsaWVkUmVtb3RlUmV2aXNpb24gPSAwO1xyXG5cclxuICAgICAgICAgIHRoaXMuX3J1bnRpbWVVQS5fdXBkYXRlUnVudGltZVN0YXR1cyhcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIHJlc291cmNlOiByZXNvdXJjZSxcclxuICAgICAgICAgICAgICB2YWx1ZTogeyBiYWNrdXBSZXZpc2lvbjogc3RhdHVzLmFwcGxpZWRSZW1vdGVSZXZpc2lvbiB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIClcclxuICAgICAgICAgIHJlc29sdmUoc3RhdHVzLmFwcGxpZWRSZW1vdGVSZXZpc2lvbik7XHJcbiAgICAgICAgfSBcclxuICAgIH0pO1xyXG4gIH0pO1xyXG4gIH0qL1xyXG5cclxuICBfY2hlY2tLZXkoa2V5KSB7XHJcbiAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHJldHVybiBrZXkudG9TdHJpbmcoKTtcclxuICAgIHJldHVybiBrZXk7XHJcbiAgfVxyXG5cclxuICBfZ2V0VGFibGUoa2V5KSB7XHJcbiAgICBsZXQgbmFtZTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBuYW1lID0gdGhpcy5kYi50YWJsZSh0aGlzLnN0b3JhZ2VOYW1lKS5uYW1lO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuLy8gICAgICB0cnkge1xyXG4gICAgICAgIG5hbWUgPSB0aGlzLmRiLnRhYmxlKGtleSkubmFtZTtcclxuLyogICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGxvZy5lcnJvcignW1N0b3JhZ2VNYW5hZ2VyLl9nZXRUYWJsZV0gZXJyb3IgJywgZXJyb3IpO1xyXG4gICAgICAgIG5hbWUgPSBmYWxzZTtcclxuICAgICAgfSovXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5hbWU7XHJcbiAgfVxyXG5cclxuICBfZ2V0UHJpbWFyeUtleSh0YWJsZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGIudGFibGUodGFibGUpLnNjaGVtYS5wcmltS2V5Lm5hbWU7XHJcbiAgfVxyXG5cclxuICBfaXNEZWZhdWx0U2NoZW1hKHRhYmxlKSB7XHJcbiAgICBjb25zdCBuYW1lID0gdGhpcy5fZ2V0VGFibGUodGFibGUpO1xyXG4gICAgY29uc3Qgc2NoZW1hID0gdGhpcy5kYltuYW1lXS5zY2hlbWEuaW5zdGFuY2VUZW1wbGF0ZTtcclxuICAgIHJldHVybiBzY2hlbWEuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykgJiYgc2NoZW1hLmhhc093blByb3BlcnR5KCd2ZXJzaW9uJykgJiYgc2NoZW1hLmhhc093blByb3BlcnR5KCdrZXknKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgYSBuZXcgZW50cnkgdG8gdGhlIGRhdGFiYXNlIGZvciBhIGdpdmVuIGtleSwgdG9nZXRoZXIgd2l0aCBpdHMgdmVyc2lvbi5cclxuICAgKiBJZiBhbiBlbnRyeSBmb3IgdGhlIGdpdmVuIGtleSBpcyBhbHJlYWR5IHN0b3JlZCBpbiB0aGUgZGF0YWJhc2UsIGl0IHdpbGwgYmUgdXBkYXRlZC5cclxuICAgKiBAcGFyYW0geyFzdHJpbmd9IGtleSAtIGtleSB0aGF0IGNhbiBiZSB1c2VkIHdpdGgge0BsaW5rIHN0b3JhZ2VNYW5hZ2VyLmdldH0gdG8gcmV0cmlldmUgdGhlIHZhbHVlIG9iamVjdFxyXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gdmVyc2lvbiAtIHZlcnNpb24gZGVzY3JpcHRvciBmb3IgdGhlIGdpdmVuIHZhbHVlXHJcbiAgICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgc3RvcmVkIGluIHRoZSBkYXRhYmFzZSB0aGF0IGlzIG1hcHBlZCB0byBnaXZlbiBrZXlcclxuICAgKiBAcGFyYW0geyFzdHJpbmd9IHRhYmxlIC0gdGFibGUgd2hpY2ggc2hvdWxkIGJlIGxvb2tpbmcgZm9yXHJcbiAgICogQHJldHVybnMge1Byb21pc2V9IHJlc3VsdCAtIFByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aXRoIHRoZSBrZXkgaWYgdGhlIGVudHJ5IHdhcyBzdG9yZWQgc3VjY2Vzc2Z1bGx5LFxyXG4gICAqIG90aGVyd2lzZSBpdCBpcyByZWplY3RlZCB3aXRoIGFuIGVycm9yLlxyXG4gICAqIEBtZW1iZXJvZiBTdG9yYWdlTWFuYWdlclxyXG4gICAqL1xyXG4gIHNldChrZXksIHZlcnNpb24sIHZhbHVlLCB0YWJsZSwgdXBkYXRlUnVudGltZVN0YXR1cyA9IHRydWUpIHtcclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UgKChyZXNvbHZlLCByZWplY3QpPT4ge1xyXG4gICAgICBsb2cuaW5mbygnW1N0b3JhZ2VNYW5hZ2VyXSAtIHNldCAnLCBrZXksIHZhbHVlKTtcclxuICAgICAgdGFibGUgPSB0YWJsZSA/IHRhYmxlIDoga2V5O1xyXG4gICAgICBjb25zdCBuYW1lID0gdGhpcy5fZ2V0VGFibGUodGFibGUpO1xyXG4gICAgICBjb25zdCBwcmltYXJ5S2V5ID0gdGhpcy5fZ2V0UHJpbWFyeUtleShuYW1lKTtcclxuICBcclxuICAgICAgLy8gT2JqZWN0LmFzc2lnbih2YWx1ZSwge3ZlcnNpb246IHZlcnNpb259KTtcclxuICBcclxuICAgICAgbGV0IGRhdGEgPSB2YWx1ZTtcclxuICBcclxuICAgICAgaWYgKHRoaXMuX2lzRGVmYXVsdFNjaGVtYSh0YWJsZSkpIHtcclxuICAgICAgICBkYXRhID0ge1xyXG4gICAgICAgICAga2V5OiBrZXksXHJcbiAgICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uLFxyXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXHJcbiAgICAgICAgfTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCB0bXAgPSB7fTtcclxuICAgICAgICB0bXBbcHJpbWFyeUtleV0gPSBrZXk7XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbihkYXRhLCB0bXApO1xyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIGxvZy5pbmZvKCdbU3RvcmFnZU1hbmFnZXIuc2V0XSBkYXRhIHRvIHB1dCAnLCBkYXRhKTtcclxuICAgICAgIHRoaXMuZGJbbmFtZV0ucHV0KGRhdGEpLnRoZW4oKCk9PntcclxuLyogICAgICBpZiAodXBkYXRlUnVudGltZVN0YXR1cyAmJiBkYXRhLmJhY2t1cCAmJiBkYXRhLnVybCkge1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUJhY2t1cFJldmlzaW9uKGRhdGEudXJsKS50aGVuKCgpPT4ge1xyXG4gICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2UgKi9yZXNvbHZlKCk7XHJcblxyXG4gICAgICAgfSwgKCk9PiB7XHJcbiAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgIH0pO1xyXG5cclxuICAgIH0pO1xyXG5cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhIGVudHJ5IHZhbHVlIGZyb20gdGhlIGRhdGFiYXNlIGZvciBhIGdpdmVuIGtleS5cclxuICAgKiBJZiBubyBlbnRyeSBpcyBmb3VuZCB1bmRlZmluZWQgaXMgcmV0dXJuZWQuXHJcbiAgICogQHBhcmFtIHshc3RyaW5nfSBrZXkgLSBrZXkgdGhhdCB3YXMgc3RvcmVkIHVzaW5nIHtAbGluayBzdG9yYWdlTWFuYWdlci5zZXR9XHJcbiAgICogQHBhcmFtIHshYW55fSB2YWx1ZSAtIHZhbHVlIHdoaWNoIHNob3VsZCBiZSBmb3VuZFxyXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gdGFibGUgLSB0YWJsZSB3aGljaCBzaG91bGQgYmUgbG9va2luZyBmb3JcclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcmVzdWx0IC0gUHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdpdGggdGhlIHZhbHVlLlxyXG4gICAqIEBtZW1iZXJvZiBTdG9yYWdlTWFuYWdlclxyXG4gICAqL1xyXG4gIGdldChrZXksIHZhbHVlLCB0YWJsZSkge1xyXG4gICAgY29uc29sZS5pbmZvKCdbU3RvcmFnZU1hbmFnZXJdIC0gZ2V0ICcsIGtleSwgdmFsdWUpO1xyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSAoKHJlc29sdmUsIHJlamVjdCk9PiB7XHJcbiAgICAgIHRhYmxlID0gdGFibGUgPyB0YWJsZSA6IGtleTtcclxuICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX2dldFRhYmxlKHRhYmxlKTtcclxuICAgICAgaWYgKCFuYW1lKSByZXNvbHZlKHVuZGVmaW5lZCk7IFxyXG4gICAgICBjb25zdCBwcmltYXJ5S2V5ID0gdGhpcy5fZ2V0UHJpbWFyeUtleShuYW1lKTtcclxuICBcclxuICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuZGIudHJhbnNhY3Rpb24oJ3J3IScsIHRoaXMuZGJbbmFtZV0sICgpID0+IHtcclxuICBcclxuICAgICAgICBpZiAoIWtleSAmJiAhdmFsdWUpIHsgXHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5kYltuYW1lXS50b0FycmF5KCkudGhlbihvYmplY3RzID0+IHtcclxuICAgICAgICAgICAgaWYgKG9iamVjdHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBvYmplY3RzLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcclxuICAgICAgICAgICAgICAgIGFjY1trZXlbcHJpbWFyeUtleV1dID0ga2V5O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcclxuICAgICAgICAgICAgICB9LCAoKSA9PntyZXR1cm4ge30gfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSByZXR1cm4ge307XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgXHJcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gIFxyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGJbbmFtZV0ud2hlcmUocHJpbWFyeUtleSkuZXF1YWxzKGtleSkuZmlyc3QoKVxyXG4gICAgICAgICAgICAudGhlbihvYmplY3QgPT4ge1xyXG4gICAgICAgICAgICAgIGlmIChvYmplY3QgJiYgb2JqZWN0Lmhhc093blByb3BlcnR5KCd2YWx1ZScpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0LnZhbHVlO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICBcclxuICAgICAgICAgIGxldCB0eXBlID0gdHlwZW9mIHZhbHVlO1xyXG4gIFxyXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSAnYXJyYXknO1xyXG4gICAgICAgICAgfVxyXG4gIFxyXG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgXHJcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGJbbmFtZV0ud2hlcmUoa2V5KS5lcXVhbHModmFsdWUpLmZpcnN0KClcclxuICAgICAgICAgICAgICAgIC50aGVuKG9iamVjdCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChvYmplY3QgJiYgb2JqZWN0Lmhhc093blByb3BlcnR5KCd2YWx1ZScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICBcclxuICAgICAgICAgICAgY2FzZSAnb2JqZWN0Jzoge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHN0clBhdGggPSAndmFsdWUuJyArIE9iamVjdC5rZXlzKHZhbHVlKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgIGNvbnN0IHN0clZhbHVlID0gT2JqZWN0LnZhbHVlcyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coc3RyUGF0aCwgc3RyVmFsdWUpO1xyXG4gIFxyXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmRiW25hbWVdLndoZXJlKHN0clBhdGgpLmFueU9mKHN0clZhbHVlKS5maXJzdCgpXHJcbiAgICAgICAgICAgICAgICAudGhlbihvYmplY3QgPT4ge1xyXG4gICAgICAgICAgICAgICAgICBpZiAob2JqZWN0ICYmIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3QudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICBcclxuICAgICAgICAgICAgY2FzZSAnYXJyYXknOlxyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBUlJBWTonLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGJbbmFtZV0ud2hlcmUodmFsdWUpLnRoZW4ob2JqZWN0ID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChvYmplY3QgJiYgb2JqZWN0Lmhhc093blByb3BlcnR5KCd2YWx1ZScpKSB7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3QudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuXHJcbiAgICB9KTtcclxuXHJcblxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGEgZW50cnkgdmVyc2lvbiBmcm9tIHRoZSBkYXRhYmFzZSBmb3IgYSBnaXZlbiBrZXkuXHJcbiAgICogSWYgbm8gZW50cnkgaXMgZm91bmQgdW5kZWZpbmVkIGlzIHJldHVybmVkLlxyXG4gICAqIEBwYXJhbSB7IXN0cmluZ30ga2V5IC0ga2V5IHRoYXQgd2FzIHN0b3JlZCB1c2luZyB7QGxpbmsgc3RvcmFnZU1hbmFnZXIuc2V0fVxyXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZSAtIHRoZSB2YWx1ZSB3aGljaCBzb3VsZCBiZSB1c2VkIHRvIGZpbmQgdGhlIHN0b3JhZ2UgcmVzb3VyY2VcclxuICAgKiBAcGFyYW0geyFzdHJpbmd9IHRhYmxlIC0gdGFibGUgd2hpY2ggc2hvdWxkIGJlIGxvb2tpbmcgZm9yXHJcbiAgICogQHJldHVybnMge1Byb21pc2V9IHJlc3VsdCAtIFByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aXRoIHRoZSB2ZXJzaW9uLlxyXG4gICAqIEBtZW1iZXJvZiBTdG9yYWdlTWFuYWdlclxyXG4gICAqL1xyXG4gIGdldFZlcnNpb24oa2V5LCB2YWx1ZSwgdGFibGUpIHtcclxuICAgIGxvZy5pbmZvKCdbU3RvcmFnZU1hbmFnZXJdIC0gZ2V0VmVyc2lvbiBmb3Iga2V5ICcsIGtleSk7XHJcbiAgICB0YWJsZSA9IHRhYmxlID8gdGFibGUgOiBrZXk7XHJcbiAgICBjb25zdCBuYW1lID0gdGhpcy5fZ2V0VGFibGUodGFibGUpO1xyXG4gICAgY29uc3QgcHJpbWFyeUtleSA9IHRoaXMuX2dldFByaW1hcnlLZXkobmFtZSk7XHJcblxyXG4gICAgbGV0IGRhdGEgPSB2YWx1ZTtcclxuXHJcbiAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgIGRhdGEgPSBrZXk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZGIudHJhbnNhY3Rpb24oJ3J3IScsIHRoaXMuZGJbbmFtZV0sICgpID0+IHtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLmRiW25hbWVdLndoZXJlKHByaW1hcnlLZXkpXHJcbiAgICAgICAgLmVxdWFscyhkYXRhKVxyXG4gICAgICAgIC5maXJzdCgpXHJcbiAgICAgICAgLnRoZW4oKG9iamVjdCkgPT4ge1xyXG4gICAgICAgICAgaWYgKG9iamVjdCAmJiBvYmplY3QuaGFzT3duUHJvcGVydHkoJ3ZlcnNpb24nKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0LnZlcnNpb247XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgIGxvZy5pbmZvKCdlcnJvciBnZXR0aW5nIHRoZSB2ZXJzaW9uIGZvciAnLCBrZXksICcgd2l0aCBlcnJvcjogJywgZXJyb3IpO1xyXG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVsZXRlIGEgZW50cnkgZnJvbSB0aGUgZGF0YWJhc2UgZm9yIGEgZ2l2ZW4ga2V5IG9yIHRoZSBmdWxsIERCIGluIGNhc2UgdGhlIGtleSBpcyBub3QgcHJvdmlkZWQuXHJcbiAgICogQHBhcmFtIHshc3RyaW5nfSBrZXkgLSBrZXkgdGhhdCB3YXMgc3RvcmVkIHVzaW5nIHtAbGluayBzdG9yYWdlTWFuYWdlci5zZXR9XHJcbiAgICogQHBhcmFtIHshYW55fSB2YWx1ZSAtIHRoZSB2YWx1ZSB3aGljaCBzb3VsZCBiZSB1c2VkIHRvIGZpbmQgdGhlIHN0b3JhZ2UgcmVzb3VyY2VcclxuICAgKiBAcGFyYW0geyFzdHJpbmd9IHRhYmxlIC0gdGFibGUgd2hpY2ggc2hvdWxkIGJlIGxvb2tpbmcgZm9yXHJcbiAgICogQHJldHVybnMge1Byb21pc2V9IHJlc3VsdCAtIFByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aXRoIHRoZSBudW1iZXIgb2YgYWZmZWN0ZWQgcm93cy5cclxuICAgKiBAbWVtYmVyb2YgU3RvcmFnZU1hbmFnZXJcclxuICAgKi9cclxuICBkZWxldGUoa2V5LCB2YWx1ZSwgdGFibGUpIHtcclxuXHJcbiAgICBpZiAoa2V5KSB7XHJcbiAgICAgIHRhYmxlID0gdGFibGUgPyB0YWJsZSA6IGtleTtcclxuICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX2dldFRhYmxlKHRhYmxlKTtcclxuICAgICAgY29uc3QgcHJpbWFyeUtleSA9IHRoaXMuX2dldFByaW1hcnlLZXkobmFtZSk7XHJcbiAgXHJcbiAgICAgIGxldCBkYXRhID0gdmFsdWU7XHJcbiAgXHJcbiAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICBkYXRhID0ga2V5O1xyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIHJldHVybiB0aGlzLmRiW25hbWVdXHJcbiAgICAgICAgLndoZXJlKHByaW1hcnlLZXkpXHJcbiAgICAgICAgLmVxdWFscyhkYXRhKVxyXG4gICAgICAgIC5kZWxldGUoKTtcclxuICAgIH0gZWxzZSByZXR1cm4gdGhpcy5kYi5kZWxldGUoKTtcclxuICBcclxuICB9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTdG9yYWdlTWFuYWdlcjtcclxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFNQTtBQUNBO0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7O0FBV0E7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7O0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7Ozs7Ozs7Ozs7OztBQVNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5DQTtBQXFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBR0E7QUFFQTs7Ozs7Ozs7Ozs7O0FBU0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7OztBQVFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7OztBQWxUQTtBQUNBO0FBQ0E7Ozs7OztBQW9UQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///24\n")},25:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_0__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Log System\n\nvar log = loglevel__WEBPACK_IMPORTED_MODULE_0__[\"getLogger\"]('StorageManager');\n\nvar SyncStorageManager =\n/*#__PURE__*/\nfunction () {\n  function SyncStorageManager(db, storageName, remoteStorage) {\n    _classCallCheck(this, SyncStorageManager);\n\n    if (!db) throw Error('The Storage Manager needs the database instance');\n    if (!storageName) throw Error('The Storage Manager needs the storage name');\n    if (!remoteStorage) throw Error('The Storage Manager needs the remoteStorage constructor param');\n    this.db = db;\n    this.storageName = storageName;\n    this._remoteStorage = remoteStorage + '/' + storageName;\n  } // set remoteStorage backup server URL\n\n\n  _createClass(SyncStorageManager, [{\n    key: \"connect\",\n    // start backup with remoteStorage server. \n    value: function connect(options) {\n      // return this.db.connect(this._remoteStorage, options);\n      var live = options && options.hasOwnProperty('once') ? !options.once : false;\n      var opts = {\n        retry: true,\n        live: live\n      };\n      return this.replicationHandler = this.db.replicate.to(this._remoteStorage, opts, this._syncError());\n    } // backup at remote backup server of doc identified by id\n\n  }, {\n    key: \"backup\",\n    value: function backup(id) {\n      // return this.db.connect(this._remoteStorage, options);\n      var opts = {\n        retry: true\n      };\n      if (id) opts.doc_ids = [id];\n      return this.replicationHandler = this.db.replicate.to(this._remoteStorage, opts, this._syncError());\n    } // There was some form or error syncing\n\n  }, {\n    key: \"_syncError\",\n    value: function _syncError() {} // do something\n    // stop backup with remoteStorage server.\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      return this.replicationHandler.cancel();\n    }\n    /**\r\n     * Adds a new entry to the database for a given key, together with its version.\r\n     * If an entry for the given key is already stored in the database, it will be updated.\r\n     * @param {!string} key - key that can be used with {@link storageManager.get} to retrieve the value object\r\n     * @param value - value stored in the database that is mapped to given key\r\n     * @returns {Promise} result - Promise that will be fulfilled with the stored doc if the entry was stored successfully,\r\n     * otherwise it is rejected with an error.\r\n     * @memberof StorageManager\r\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(key, value, version) {\n      var _this = this;\n\n      if (!key) throw Error('[SyncStorageManager.set] key is mandatory param');\n      if (!value) throw Error('[SyncStorageManager.set] value is mandatory param');\n      return new Promise(function (resolve, reject) {\n        console.log('[SyncStorageManager.set] key ', key, ' value ', value);\n        value._id = key;\n\n        _this.db.get(key).then(function (doc) {\n          var data = typeof value === 'string' ? {\n            value: value\n          } : value; // if no version is asked to set, it is assumed to update the same version of the document\n          // in order to avoid the increase of storage quota used\n\n          doc._rev = version ? version : doc._rev;\n          Object.assign(doc, data);\n\n          _this.db.put(doc).then(function () {\n            resolve(doc);\n          });\n        }, function (err) {\n          console.error('[SyncStorageManager.set] ', err);\n\n          if (err.name === 'not_found') {\n            var opts = {};\n\n            if (version) {\n              value._rev = version;\n              opts.new_edits = false;\n            }\n\n            _this.db.put(value, opts).then(function () {\n              resolve(value);\n            }, function (err) {\n              reject(err);\n            });\n          } else reject(err);\n        });\n      });\n    }\n    /**\r\n     * Get a entry value from the database for a given key.\r\n     * If no entry is found undefined is returned.\r\n     * @param {!string} key - key that was stored using {@link storageManager.set}\r\n     * @param {!any} value - value which should be found\r\n     * @returns {Promise} result - Promise that will be fulfilled with the value.\r\n     * @memberof StorageManager\r\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(key, value) {\n      var _this2 = this;\n\n      // TODO: add options for pagination for DOs with high number of child objects\n      //    if (!key) throw Error('[SyncStorageManager.get] key is mandatory param');\n      return new Promise(function (resolve, reject) {\n        log.info('[SyncStorageManager.get] key ', key, ' value ', value);\n\n        if (key) {\n          if (!value) {\n            _this2.db.get(key).then(function (doc) {\n              resolve(doc);\n            }, function (err) {\n              if (err.name === 'not_found') resolve(undefined);else reject(err);\n            });\n          } else _this2.db.get(key).then(function (doc) {\n            log.info('[SyncStorageManager.get] retrieved doc ', doc);\n            resolve(doc[value]);\n          }, function (err) {\n            if (err.name === 'not_found') resolve(undefined);else reject(err);\n          });\n        } else {\n          _this2.db.allDocs({\n            include_docs: true\n          }).then(function (docs) {\n            var result = [];\n            docs.rows.forEach(function (doc) {\n              result.push(doc.doc);\n            });\n            resolve(result);\n          }, function (err) {\n            if (err.name === 'not_found') resolve(undefined);else reject(err);\n          });\n        }\n      });\n    }\n    /**\r\n     * Delete a entry from the database for a given key or the full DB in case the key is not provided.\r\n     * @param {!string} key - key that was stored using {@link storageManager.set}\r\n     * @param {!any} value - the value which sould be used to find the storage resource\r\n     * @returns {Promise} result - Promise that will be just fulfilled with no values if something was deleted otherwise it is fullfilled with undefined.\r\n     * @memberof StorageManager\r\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(key, value) {\n      var _this3 = this;\n\n      //todo: if no key delete the db\n      //    if (!key) throw Error('[SyncStorageManager.get] key is mandatory param');\n      return new Promise(function (resolve, reject) {\n        log.info('[SyncStorageManager.delete] key ', key, ' value ', value);\n\n        if (key) {\n          _this3.db.get(key).then(function (doc) {\n            if (!value) {\n              _this3.db.remove(doc).then(function () {\n                resolve();\n              }, resolve(undefined));\n            } else {\n              delete doc[value];\n              resolve(_this3.db.put(doc));\n            }\n          }, function (err) {\n            if (err.name === 'not_found') resolve(undefined);else reject(err);\n          });\n        } else {\n          _this3.db.destroy().then(function () {\n            return resolve();\n          }, function (err) {\n            return reject(err);\n          });\n        }\n      });\n    }\n    /**\r\n     * Get the version from the database for a given key.\r\n     * If no entry is found undefined is returned.\r\n     * @param {!string} key - key that was stored using {@link storageManager.set}\r\n     * @param {any} value - the value which sould be used to find the storage resource\r\n     * @param {!string} table - table which should be looking for\r\n     * @returns {Promise} result - Promise that will be fulfilled with the version. If not found it is fullfilled with undefined\r\n     * @memberof StorageManager\r\n     */\n\n  }, {\n    key: \"getVersion\",\n    value: function getVersion(key) {\n      var _this4 = this;\n\n      if (!key) throw Error('[SyncStorageManager.get] key is mandatory param');\n      return new Promise(function (resolve, reject) {\n        log.info('[SyncStorageManager.getVersion] for key ', key);\n\n        _this4.db.get(key).then(function (doc) {\n          resolve(doc._rev);\n        }, function (err) {\n          if (err.name === 'not_found') resolve(undefined);else reject(err);\n        });\n      });\n    }\n  }, {\n    key: \"remoteStorage\",\n    set: function set(remoteStorage) {\n      this._remoteStorage = remoteStorage + '/' + storageName;\n    }\n  }]);\n\n  return SyncStorageManager;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (SyncStorageManager);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvc3RvcmFnZS1tYW5hZ2VyL1N5bmNTdG9yYWdlTWFuYWdlci5qcz9hY2Y1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIExvZyBTeXN0ZW1cclxuaW1wb3J0ICogYXMgbG9nZ2VyIGZyb20gJ2xvZ2xldmVsJztcclxubGV0IGxvZyA9IGxvZ2dlci5nZXRMb2dnZXIoJ1N0b3JhZ2VNYW5hZ2VyJyk7XHJcblxyXG5jbGFzcyBTeW5jU3RvcmFnZU1hbmFnZXIge1xyXG5cclxuICBjb25zdHJ1Y3RvcihkYiwgc3RvcmFnZU5hbWUsIHJlbW90ZVN0b3JhZ2UpIHtcclxuICAgIGlmICghZGIpIHRocm93IEVycm9yKCdUaGUgU3RvcmFnZSBNYW5hZ2VyIG5lZWRzIHRoZSBkYXRhYmFzZSBpbnN0YW5jZScpO1xyXG4gICAgaWYgKCFzdG9yYWdlTmFtZSkgdGhyb3cgRXJyb3IoJ1RoZSBTdG9yYWdlIE1hbmFnZXIgbmVlZHMgdGhlIHN0b3JhZ2UgbmFtZScpO1xyXG4gICAgaWYgKCFyZW1vdGVTdG9yYWdlKSB0aHJvdyBFcnJvcignVGhlIFN0b3JhZ2UgTWFuYWdlciBuZWVkcyB0aGUgcmVtb3RlU3RvcmFnZSBjb25zdHJ1Y3RvciBwYXJhbScpO1xyXG5cclxuICAgIHRoaXMuZGIgPSBkYjtcclxuICAgIHRoaXMuc3RvcmFnZU5hbWUgPSBzdG9yYWdlTmFtZTtcclxuICAgIHRoaXMuX3JlbW90ZVN0b3JhZ2UgPSByZW1vdGVTdG9yYWdlICsgJy8nICsgc3RvcmFnZU5hbWU7XHJcbiAgfVxyXG5cclxuICAvLyBzZXQgcmVtb3RlU3RvcmFnZSBiYWNrdXAgc2VydmVyIFVSTFxyXG5cclxuICBzZXQgcmVtb3RlU3RvcmFnZShyZW1vdGVTdG9yYWdlKSB7XHJcbiAgICB0aGlzLl9yZW1vdGVTdG9yYWdlID0gcmVtb3RlU3RvcmFnZSArICcvJyArIHN0b3JhZ2VOYW1lO1xyXG4gIH1cclxuXHJcbiAgLy8gc3RhcnQgYmFja3VwIHdpdGggcmVtb3RlU3RvcmFnZSBzZXJ2ZXIuIFxyXG5cclxuICBjb25uZWN0KG9wdGlvbnMpIHtcclxuICAgIC8vIHJldHVybiB0aGlzLmRiLmNvbm5lY3QodGhpcy5fcmVtb3RlU3RvcmFnZSwgb3B0aW9ucyk7XHJcblxyXG4gICAgbGV0IGxpdmUgPSAob3B0aW9ucyAmJiBvcHRpb25zLmhhc093blByb3BlcnR5KCdvbmNlJykpID8gIW9wdGlvbnMub25jZSA6IGZhbHNlO1xyXG5cclxuICAgIGxldCBvcHRzID0geyByZXRyeTogdHJ1ZSwgbGl2ZTogbGl2ZSB9O1xyXG5cclxuICAgIHJldHVybiB0aGlzLnJlcGxpY2F0aW9uSGFuZGxlciA9IHRoaXMuZGIucmVwbGljYXRlLnRvKHRoaXMuX3JlbW90ZVN0b3JhZ2UsIG9wdHMsIHRoaXMuX3N5bmNFcnJvcigpKTtcclxuICB9XHJcblxyXG4gIC8vIGJhY2t1cCBhdCByZW1vdGUgYmFja3VwIHNlcnZlciBvZiBkb2MgaWRlbnRpZmllZCBieSBpZFxyXG5cclxuICBiYWNrdXAoaWQpIHtcclxuICAgIC8vIHJldHVybiB0aGlzLmRiLmNvbm5lY3QodGhpcy5fcmVtb3RlU3RvcmFnZSwgb3B0aW9ucyk7XHJcblxyXG4gICAgbGV0IG9wdHMgPSB7IHJldHJ5OiB0cnVlIH07XHJcblxyXG4gICAgaWYgKGlkKSBvcHRzLmRvY19pZHMgPVtpZF07XHJcblxyXG4gICAgcmV0dXJuIHRoaXMucmVwbGljYXRpb25IYW5kbGVyID0gdGhpcy5kYi5yZXBsaWNhdGUudG8odGhpcy5fcmVtb3RlU3RvcmFnZSwgb3B0cywgdGhpcy5fc3luY0Vycm9yKCkpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIFRoZXJlIHdhcyBzb21lIGZvcm0gb3IgZXJyb3Igc3luY2luZ1xyXG4gIF9zeW5jRXJyb3IoKSB7XHJcbiAgICAvLyBkbyBzb21ldGhpbmdcclxuICB9XHJcblxyXG5cclxuICAvLyBzdG9wIGJhY2t1cCB3aXRoIHJlbW90ZVN0b3JhZ2Ugc2VydmVyLlxyXG5cclxuICBkaXNjb25uZWN0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMucmVwbGljYXRpb25IYW5kbGVyLmNhbmNlbCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhIG5ldyBlbnRyeSB0byB0aGUgZGF0YWJhc2UgZm9yIGEgZ2l2ZW4ga2V5LCB0b2dldGhlciB3aXRoIGl0cyB2ZXJzaW9uLlxyXG4gICAqIElmIGFuIGVudHJ5IGZvciB0aGUgZ2l2ZW4ga2V5IGlzIGFscmVhZHkgc3RvcmVkIGluIHRoZSBkYXRhYmFzZSwgaXQgd2lsbCBiZSB1cGRhdGVkLlxyXG4gICAqIEBwYXJhbSB7IXN0cmluZ30ga2V5IC0ga2V5IHRoYXQgY2FuIGJlIHVzZWQgd2l0aCB7QGxpbmsgc3RvcmFnZU1hbmFnZXIuZ2V0fSB0byByZXRyaWV2ZSB0aGUgdmFsdWUgb2JqZWN0XHJcbiAgICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgc3RvcmVkIGluIHRoZSBkYXRhYmFzZSB0aGF0IGlzIG1hcHBlZCB0byBnaXZlbiBrZXlcclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcmVzdWx0IC0gUHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdpdGggdGhlIHN0b3JlZCBkb2MgaWYgdGhlIGVudHJ5IHdhcyBzdG9yZWQgc3VjY2Vzc2Z1bGx5LFxyXG4gICAqIG90aGVyd2lzZSBpdCBpcyByZWplY3RlZCB3aXRoIGFuIGVycm9yLlxyXG4gICAqIEBtZW1iZXJvZiBTdG9yYWdlTWFuYWdlclxyXG4gICAqL1xyXG5cclxuICBzZXQoa2V5LCB2YWx1ZSwgdmVyc2lvbikge1xyXG4gICAgaWYgKCFrZXkpIHRocm93IEVycm9yKCdbU3luY1N0b3JhZ2VNYW5hZ2VyLnNldF0ga2V5IGlzIG1hbmRhdG9yeSBwYXJhbScpO1xyXG4gICAgaWYgKCF2YWx1ZSkgdGhyb3cgRXJyb3IoJ1tTeW5jU3RvcmFnZU1hbmFnZXIuc2V0XSB2YWx1ZSBpcyBtYW5kYXRvcnkgcGFyYW0nKTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBjb25zb2xlLmxvZygnW1N5bmNTdG9yYWdlTWFuYWdlci5zZXRdIGtleSAnLCBrZXksICcgdmFsdWUgJywgdmFsdWUpO1xyXG5cclxuICAgICAgdmFsdWUuX2lkID0ga2V5O1xyXG5cclxuICAgICAgdGhpcy5kYi5nZXQoa2V5KS50aGVuKChkb2MpID0+IHtcclxuICAgICAgICBsZXQgZGF0YSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB7IHZhbHVlOiB2YWx1ZSB9IDogdmFsdWU7XHJcblxyXG4gICAgICAgIC8vIGlmIG5vIHZlcnNpb24gaXMgYXNrZWQgdG8gc2V0LCBpdCBpcyBhc3N1bWVkIHRvIHVwZGF0ZSB0aGUgc2FtZSB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudFxyXG4gICAgICAgIC8vIGluIG9yZGVyIHRvIGF2b2lkIHRoZSBpbmNyZWFzZSBvZiBzdG9yYWdlIHF1b3RhIHVzZWRcclxuICAgICAgICBkb2MuX3JldiA9IHZlcnNpb24gPyB2ZXJzaW9uIDogZG9jLl9yZXY7XHJcblxyXG4gICAgICAgIE9iamVjdC5hc3NpZ24oZG9jLCBkYXRhKTtcclxuICAgICAgICB0aGlzLmRiLnB1dChkb2MpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgcmVzb2x2ZShkb2MpO1xyXG5cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgIH0sIChlcnIpID0+IHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdbU3luY1N0b3JhZ2VNYW5hZ2VyLnNldF0gJywgZXJyKTtcclxuICAgICAgICBpZiAoZXJyLm5hbWUgPT09ICdub3RfZm91bmQnKSB7XHJcbiAgICAgICAgICBsZXQgb3B0cyA9IHt9O1xyXG4gICAgICAgICAgaWYgKHZlcnNpb24pIHtcclxuICAgICAgICAgICAgdmFsdWUuX3JldiA9IHZlcnNpb247XHJcbiAgICAgICAgICAgIG9wdHMubmV3X2VkaXRzID0gZmFsc2U7XHJcbiAgICAgICAgICB9IFxyXG4gICAgICAgICAgdGhpcy5kYi5wdXQodmFsdWUsIG9wdHMpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcclxuICAgICAgICAgIH0sKGVycikgPT4ge3JlamVjdChlcnIpOyB9ICk7XHJcbiAgICAgICAgfSBlbHNlIHJlamVjdChlcnIpO1xyXG5cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgYSBlbnRyeSB2YWx1ZSBmcm9tIHRoZSBkYXRhYmFzZSBmb3IgYSBnaXZlbiBrZXkuXHJcbiAgICogSWYgbm8gZW50cnkgaXMgZm91bmQgdW5kZWZpbmVkIGlzIHJldHVybmVkLlxyXG4gICAqIEBwYXJhbSB7IXN0cmluZ30ga2V5IC0ga2V5IHRoYXQgd2FzIHN0b3JlZCB1c2luZyB7QGxpbmsgc3RvcmFnZU1hbmFnZXIuc2V0fVxyXG4gICAqIEBwYXJhbSB7IWFueX0gdmFsdWUgLSB2YWx1ZSB3aGljaCBzaG91bGQgYmUgZm91bmRcclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcmVzdWx0IC0gUHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdpdGggdGhlIHZhbHVlLlxyXG4gICAqIEBtZW1iZXJvZiBTdG9yYWdlTWFuYWdlclxyXG4gICAqL1xyXG4gIGdldChrZXksIHZhbHVlKSB7XHJcbiAgICAvLyBUT0RPOiBhZGQgb3B0aW9ucyBmb3IgcGFnaW5hdGlvbiBmb3IgRE9zIHdpdGggaGlnaCBudW1iZXIgb2YgY2hpbGQgb2JqZWN0c1xyXG4vLyAgICBpZiAoIWtleSkgdGhyb3cgRXJyb3IoJ1tTeW5jU3RvcmFnZU1hbmFnZXIuZ2V0XSBrZXkgaXMgbWFuZGF0b3J5IHBhcmFtJyk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuXHJcbiAgICAgIGxvZy5pbmZvKCdbU3luY1N0b3JhZ2VNYW5hZ2VyLmdldF0ga2V5ICcsIGtleSwgJyB2YWx1ZSAnLCB2YWx1ZSk7XHJcblxyXG4gICAgICBpZiAoa2V5KSB7XHJcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgdGhpcy5kYi5nZXQoa2V5KS50aGVuKChkb2MpPT57XHJcbiAgICAgICAgICAgIHJlc29sdmUoZG9jKTtcclxuICAgICAgICAgIH0sIChlcnIpPT57XHJcbiAgICAgICAgICAgIGlmIChlcnIubmFtZSA9PT0gJ25vdF9mb3VuZCcpIHJlc29sdmUodW5kZWZpbmVkKVxyXG4gICAgICAgICAgICBlbHNlIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBcclxuICAgICAgICBlbHNlIHRoaXMuZGIuZ2V0KGtleSkudGhlbigoZG9jKSA9PiB7XHJcbiAgICAgICAgICBsb2cuaW5mbygnW1N5bmNTdG9yYWdlTWFuYWdlci5nZXRdIHJldHJpZXZlZCBkb2MgJywgZG9jKTtcclxuICAgICAgICAgIHJlc29sdmUoZG9jW3ZhbHVlXSk7XHJcbiAgICAgICAgfSwgKGVycik9PntcclxuICAgICAgICAgIGlmIChlcnIubmFtZSA9PT0gJ25vdF9mb3VuZCcpIHJlc29sdmUodW5kZWZpbmVkKVxyXG4gICAgICAgICAgZWxzZSByZWplY3QoZXJyKTtcclxuICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5kYi5hbGxEb2NzKHtpbmNsdWRlX2RvY3M6IHRydWV9KS50aGVuKChkb2NzKT0+e1xyXG4gICAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgZG9jcy5yb3dzLmZvckVhY2goKGRvYyk9PntcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZG9jLmRvYyk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICB9LCAoZXJyKT0+e1xyXG4gICAgICAgICAgaWYgKGVyci5uYW1lID09PSAnbm90X2ZvdW5kJykgcmVzb2x2ZSh1bmRlZmluZWQpXHJcbiAgICAgICAgICBlbHNlIHJlamVjdChlcnIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgfSk7XHJcblxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVsZXRlIGEgZW50cnkgZnJvbSB0aGUgZGF0YWJhc2UgZm9yIGEgZ2l2ZW4ga2V5IG9yIHRoZSBmdWxsIERCIGluIGNhc2UgdGhlIGtleSBpcyBub3QgcHJvdmlkZWQuXHJcbiAgICogQHBhcmFtIHshc3RyaW5nfSBrZXkgLSBrZXkgdGhhdCB3YXMgc3RvcmVkIHVzaW5nIHtAbGluayBzdG9yYWdlTWFuYWdlci5zZXR9XHJcbiAgICogQHBhcmFtIHshYW55fSB2YWx1ZSAtIHRoZSB2YWx1ZSB3aGljaCBzb3VsZCBiZSB1c2VkIHRvIGZpbmQgdGhlIHN0b3JhZ2UgcmVzb3VyY2VcclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcmVzdWx0IC0gUHJvbWlzZSB0aGF0IHdpbGwgYmUganVzdCBmdWxmaWxsZWQgd2l0aCBubyB2YWx1ZXMgaWYgc29tZXRoaW5nIHdhcyBkZWxldGVkIG90aGVyd2lzZSBpdCBpcyBmdWxsZmlsbGVkIHdpdGggdW5kZWZpbmVkLlxyXG4gICAqIEBtZW1iZXJvZiBTdG9yYWdlTWFuYWdlclxyXG4gICAqL1xyXG5cclxuICBkZWxldGUoa2V5LCB2YWx1ZSkge1xyXG4gICAgLy90b2RvOiBpZiBubyBrZXkgZGVsZXRlIHRoZSBkYlxyXG4vLyAgICBpZiAoIWtleSkgdGhyb3cgRXJyb3IoJ1tTeW5jU3RvcmFnZU1hbmFnZXIuZ2V0XSBrZXkgaXMgbWFuZGF0b3J5IHBhcmFtJyk7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG5cclxuICAgICAgbG9nLmluZm8oJ1tTeW5jU3RvcmFnZU1hbmFnZXIuZGVsZXRlXSBrZXkgJywga2V5LCAnIHZhbHVlICcsIHZhbHVlKTtcclxuXHJcbiAgICAgIGlmIChrZXkpIHtcclxuICAgICAgICB0aGlzLmRiLmdldChrZXkpLnRoZW4oKGRvYykgPT4ge1xyXG4gICAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRiLnJlbW92ZShkb2MpLnRoZW4oKCk9PntcclxuICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH0sIHJlc29sdmUodW5kZWZpbmVkKSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBkZWxldGUgZG9jW3ZhbHVlXTtcclxuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLmRiLnB1dChkb2MpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LCAoZXJyKT0+e1xyXG4gICAgICAgICAgaWYgKGVyci5uYW1lID09PSAnbm90X2ZvdW5kJykgcmVzb2x2ZSh1bmRlZmluZWQpXHJcbiAgICAgICAgICBlbHNlIHJlamVjdChlcnIpO1xyXG4gICAgICAgIH0pO1xyXG4gIFxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuZGIuZGVzdHJveSgpLnRoZW4oKCk9PiByZXNvbHZlKCksIChlcnIpID0+IHJlamVjdChlcnIpIClcclxuICAgICAgfSBcclxuXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgdmVyc2lvbiBmcm9tIHRoZSBkYXRhYmFzZSBmb3IgYSBnaXZlbiBrZXkuXHJcbiAgICogSWYgbm8gZW50cnkgaXMgZm91bmQgdW5kZWZpbmVkIGlzIHJldHVybmVkLlxyXG4gICAqIEBwYXJhbSB7IXN0cmluZ30ga2V5IC0ga2V5IHRoYXQgd2FzIHN0b3JlZCB1c2luZyB7QGxpbmsgc3RvcmFnZU1hbmFnZXIuc2V0fVxyXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZSAtIHRoZSB2YWx1ZSB3aGljaCBzb3VsZCBiZSB1c2VkIHRvIGZpbmQgdGhlIHN0b3JhZ2UgcmVzb3VyY2VcclxuICAgKiBAcGFyYW0geyFzdHJpbmd9IHRhYmxlIC0gdGFibGUgd2hpY2ggc2hvdWxkIGJlIGxvb2tpbmcgZm9yXHJcbiAgICogQHJldHVybnMge1Byb21pc2V9IHJlc3VsdCAtIFByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aXRoIHRoZSB2ZXJzaW9uLiBJZiBub3QgZm91bmQgaXQgaXMgZnVsbGZpbGxlZCB3aXRoIHVuZGVmaW5lZFxyXG4gICAqIEBtZW1iZXJvZiBTdG9yYWdlTWFuYWdlclxyXG4gICAqL1xyXG4gIGdldFZlcnNpb24oa2V5KSB7XHJcbiAgICBpZiAoIWtleSkgdGhyb3cgRXJyb3IoJ1tTeW5jU3RvcmFnZU1hbmFnZXIuZ2V0XSBrZXkgaXMgbWFuZGF0b3J5IHBhcmFtJyk7XHJcblxyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcblxyXG4gICAgICBsb2cuaW5mbygnW1N5bmNTdG9yYWdlTWFuYWdlci5nZXRWZXJzaW9uXSBmb3Iga2V5ICcsIGtleSk7XHJcblxyXG4gICAgICAgIHRoaXMuZGIuZ2V0KGtleSkudGhlbigoZG9jKT0+e1xyXG4gICAgICAgICAgcmVzb2x2ZShkb2MuX3Jldik7XHJcbiAgICAgICAgfSwgKGVycik9PntcclxuICAgICAgICAgIGlmIChlcnIubmFtZSA9PT0gJ25vdF9mb3VuZCcpIHJlc29sdmUodW5kZWZpbmVkKVxyXG4gICAgICAgICAgZWxzZSByZWplY3QoZXJyKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICB9XHJcblxyXG5cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFN5bmNTdG9yYWdlTWFuYWdlcjtcclxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBTUE7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUtBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7QUFVQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7Ozs7Ozs7Ozs7O0FBUUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7Ozs7Ozs7Ozs7QUFRQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7O0FBU0E7QUFBQTtBQUNBO0FBQUE7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7O0FBMU1BO0FBQ0E7QUFDQTs7Ozs7O0FBOE1BIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///25\n")},44:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _storage_manager_StorageManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StorageManager", function() { return _storage_manager_StorageManager__WEBPACK_IMPORTED_MODULE_0__["a"]; });\n\n/* harmony import */ var _storage_manager_SyncStorageManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SyncStorageManager", function() { return _storage_manager_SyncStorageManager__WEBPACK_IMPORTED_MODULE_1__["a"]; });\n\n/**\r\n* Copyright 2016 PT Inovação e Sistemas SA\r\n* Copyright 2016 INESC-ID\r\n* Copyright 2016 QUOBIS NETWORKS SL\r\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\r\n* Copyright 2016 ORANGE SA\r\n* Copyright 2016 Deutsche Telekom AG\r\n* Copyright 2016 Apizee\r\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\r\n*\r\n* Licensed under the Apache License, Version 2.0 (the "License");\r\n* you may not use this file except in compliance with the License.\r\n* You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing, software\r\n* distributed under the License is distributed on an "AS IS" BASIS,\r\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n* See the License for the specific language governing permissions and\r\n* limitations under the License.\r\n**/\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvc3RvcmFnZS1tYW5hZ2VyLXBhY2suanM/OTJkNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuKiBDb3B5cmlnaHQgMjAxNiBQVCBJbm92YcOnw6NvIGUgU2lzdGVtYXMgU0FcclxuKiBDb3B5cmlnaHQgMjAxNiBJTkVTQy1JRFxyXG4qIENvcHlyaWdodCAyMDE2IFFVT0JJUyBORVRXT1JLUyBTTFxyXG4qIENvcHlyaWdodCAyMDE2IEZSQVVOSE9GRVItR0VTRUxMU0NIQUZUIFpVUiBGT0VSREVSVU5HIERFUiBBTkdFV0FORFRFTiBGT1JTQ0hVTkcgRS5WXHJcbiogQ29weXJpZ2h0IDIwMTYgT1JBTkdFIFNBXHJcbiogQ29weXJpZ2h0IDIwMTYgRGV1dHNjaGUgVGVsZWtvbSBBR1xyXG4qIENvcHlyaWdodCAyMDE2IEFwaXplZVxyXG4qIENvcHlyaWdodCAyMDE2IFRFQ0hOSVNDSEUgVU5JVkVSU0lUQVQgQkVSTElOXHJcbipcclxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKiovXHJcbmltcG9ydCBTdG9yYWdlTWFuYWdlciBmcm9tICcuL3N0b3JhZ2UtbWFuYWdlci9TdG9yYWdlTWFuYWdlcic7XHJcbmltcG9ydCBTeW5jU3RvcmFnZU1hbmFnZXIgZnJvbSAnLi9zdG9yYWdlLW1hbmFnZXIvU3luY1N0b3JhZ2VNYW5hZ2VyJztcclxuXHJcbmV4cG9ydCB7U3RvcmFnZU1hbmFnZXIsIFN5bmNTdG9yYWdlTWFuYWdlcn07XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///44\n')}})});