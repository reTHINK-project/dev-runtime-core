// version: 0.15.0
// date: Wed Dec 19 2018 14:18:56 GMT+0000 (Western European Standard Time)
// licence: 
/**
* Copyright 2016 PT Inovação e Sistemas SA
* Copyright 2016 INESC-ID
* Copyright 2016 QUOBIS NETWORKS SL
* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V
* Copyright 2016 ORANGE SA
* Copyright 2016 Deutsche Telekom AG
* Copyright 2016 Apizee
* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
**/


!function(g,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define("StorageManager",[],e):"object"==typeof exports?exports.StorageManager=e():g.StorageManager=e()}(window,function(){return function(g){var e={};function I(n){if(e[n])return e[n].exports;var t=e[n]={i:n,l:!1,exports:{}};return g[n].call(t.exports,t,t.exports,I),t.l=!0,t.exports}return I.m=g,I.c=e,I.d=function(g,e,n){I.o(g,e)||Object.defineProperty(g,e,{enumerable:!0,get:n})},I.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},I.t=function(g,e){if(1&e&&(g=I(g)),8&e)return g;if(4&e&&"object"==typeof g&&g&&g.__esModule)return g;var n=Object.create(null);if(I.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:g}),2&e&&"string"!=typeof g)for(var t in g)I.d(n,t,function(e){return g[e]}.bind(null,t));return n},I.n=function(g){var e=g&&g.__esModule?function(){return g.default}:function(){return g};return I.d(e,"a",e),e},I.o=function(g,e){return Object.prototype.hasOwnProperty.call(g,e)},I.p="",I(I.s=21)}({1:function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    "use strict";\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}(this, function () {\n    "use strict";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = "undefined";\n\n    var logMethods = [\n        "trace",\n        "debug",\n        "info",\n        "warn",\n        "error"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === \'function\') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === \'debug\') {\n            methodName = \'log\';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, \'log\');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn\'t present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      var storageKey = "loglevel";\n      if (name) {\n        storageKey += ":" + name;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || \'silent\').toUpperCase();\n\n          if (typeof window === undefinedType) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + "=" + levelName + ";";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + "=");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,\n          "ERROR": 4, "SILENT": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return "No console available for logging";\n              }\n          } else {\n              throw "log.setLevel() called with invalid level: " + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== "string" || name === "") {\n          throw new TypeError("You must supply a name when creating a logger.");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    return defaultLogger;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9sb2dsZXZlbC9saWIvbG9nbGV2ZWwuanM/NWM3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuKiBsb2dsZXZlbCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTMgVGltIFBlcnJ5XG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiovXG4oZnVuY3Rpb24gKHJvb3QsIGRlZmluaXRpb24pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShkZWZpbml0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QubG9nID0gZGVmaW5pdGlvbigpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gU2xpZ2h0bHkgZHViaW91cyB0cmlja3MgdG8gY3V0IGRvd24gbWluaW1pemVkIGZpbGUgc2l6ZVxuICAgIHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcbiAgICB2YXIgdW5kZWZpbmVkVHlwZSA9IFwidW5kZWZpbmVkXCI7XG5cbiAgICB2YXIgbG9nTWV0aG9kcyA9IFtcbiAgICAgICAgXCJ0cmFjZVwiLFxuICAgICAgICBcImRlYnVnXCIsXG4gICAgICAgIFwiaW5mb1wiLFxuICAgICAgICBcIndhcm5cIixcbiAgICAgICAgXCJlcnJvclwiXG4gICAgXTtcblxuICAgIC8vIENyb3NzLWJyb3dzZXIgYmluZCBlcXVpdmFsZW50IHRoYXQgd29ya3MgYXQgbGVhc3QgYmFjayB0byBJRTZcbiAgICBmdW5jdGlvbiBiaW5kTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgbWV0aG9kID0gb2JqW21ldGhvZE5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZC5iaW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmJpbmQob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwobWV0aG9kLCBvYmopO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIE1pc3NpbmcgYmluZCBzaGltIG9yIElFOCArIE1vZGVybml6ciwgZmFsbGJhY2sgdG8gd3JhcHBpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkobWV0aG9kLCBbb2JqLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgdGhlIGJlc3QgbG9nZ2luZyBtZXRob2QgcG9zc2libGUgZm9yIHRoaXMgZW52XG4gICAgLy8gV2hlcmV2ZXIgcG9zc2libGUgd2Ugd2FudCB0byBiaW5kLCBub3Qgd3JhcCwgdG8gcHJlc2VydmUgc3RhY2sgdHJhY2VzXG4gICAgZnVuY3Rpb24gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmIChtZXRob2ROYW1lID09PSAnZGVidWcnKSB7XG4gICAgICAgICAgICBtZXRob2ROYW1lID0gJ2xvZyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gbWV0aG9kIHBvc3NpYmxlLCBmb3Igbm93IC0gZml4ZWQgbGF0ZXIgYnkgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlc1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZS5sb2cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgJ2xvZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGVzZSBwcml2YXRlIGZ1bmN0aW9ucyBhbHdheXMgbmVlZCBgdGhpc2AgdG8gYmUgc2V0IHByb3Blcmx5XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGxvZ01ldGhvZHNbaV07XG4gICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdID0gKGkgPCBsZXZlbCkgP1xuICAgICAgICAgICAgICAgIG5vb3AgOlxuICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZpbmUgbG9nLmxvZyBhcyBhbiBhbGlhcyBmb3IgbG9nLmRlYnVnXG4gICAgICAgIHRoaXMubG9nID0gdGhpcy5kZWJ1ZztcbiAgICB9XG5cbiAgICAvLyBJbiBvbGQgSUUgdmVyc2lvbnMsIHRoZSBjb25zb2xlIGlzbid0IHByZXNlbnQgdW50aWwgeW91IGZpcnN0IG9wZW4gaXQuXG4gICAgLy8gV2UgYnVpbGQgcmVhbE1ldGhvZCgpIHJlcGxhY2VtZW50cyBoZXJlIHRoYXQgcmVnZW5lcmF0ZSBsb2dnaW5nIG1ldGhvZHNcbiAgICBmdW5jdGlvbiBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzKG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbCh0aGlzLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHVzZSBjbG9zZWx5IGJvdW5kIHJlYWwgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZSwgYW5kXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdhaXQgZm9yIGEgY29uc29sZSB0byBhcHBlYXIsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICByZXR1cm4gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB8fFxuICAgICAgICAgICAgICAgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvZ2dlcihuYW1lLCBkZWZhdWx0TGV2ZWwsIGZhY3RvcnkpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjdXJyZW50TGV2ZWw7XG4gICAgICB2YXIgc3RvcmFnZUtleSA9IFwibG9nbGV2ZWxcIjtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHN0b3JhZ2VLZXkgKz0gXCI6XCIgKyBuYW1lO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsTnVtKSB7XG4gICAgICAgICAgdmFyIGxldmVsTmFtZSA9IChsb2dNZXRob2RzW2xldmVsTnVtXSB8fCAnc2lsZW50JykudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlKSByZXR1cm47XG5cbiAgICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV0gPSBsZXZlbE5hbWU7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID1cbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIiArIGxldmVsTmFtZSArIFwiO1wiO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0UGVyc2lzdGVkTGV2ZWwoKSB7XG4gICAgICAgICAgdmFyIHN0b3JlZExldmVsO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUpIHJldHVybjtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XTtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBjb29raWVzIGlmIGxvY2FsIHN0b3JhZ2UgZ2l2ZXMgdXMgbm90aGluZ1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVkTGV2ZWwgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb29raWUgPSB3aW5kb3cuZG9jdW1lbnQuY29va2llO1xuICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY29va2llLmluZGV4T2YoXG4gICAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIpO1xuICAgICAgICAgICAgICAgICAgaWYgKGxvY2F0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZExldmVsID0gL14oW147XSspLy5leGVjKGNvb2tpZS5zbGljZShsb2NhdGlvbikpWzFdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhlIHN0b3JlZCBsZXZlbCBpcyBub3QgdmFsaWQsIHRyZWF0IGl0IGFzIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cbiAgICAgICAgICBpZiAoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN0b3JlZExldmVsO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgICpcbiAgICAgICAqIFB1YmxpYyBsb2dnZXIgQVBJIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbCBmb3IgZGV0YWlsc1xuICAgICAgICpcbiAgICAgICAqL1xuXG4gICAgICBzZWxmLm5hbWUgPSBuYW1lO1xuXG4gICAgICBzZWxmLmxldmVscyA9IHsgXCJUUkFDRVwiOiAwLCBcIkRFQlVHXCI6IDEsIFwiSU5GT1wiOiAyLCBcIldBUk5cIjogMyxcbiAgICAgICAgICBcIkVSUk9SXCI6IDQsIFwiU0lMRU5UXCI6IDV9O1xuXG4gICAgICBzZWxmLm1ldGhvZEZhY3RvcnkgPSBmYWN0b3J5IHx8IGRlZmF1bHRNZXRob2RGYWN0b3J5O1xuXG4gICAgICBzZWxmLmdldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50TGV2ZWw7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsLCBwZXJzaXN0KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIiAmJiBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGxldmVsID0gc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwibnVtYmVyXCIgJiYgbGV2ZWwgPj0gMCAmJiBsZXZlbCA8PSBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgY3VycmVudExldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICAgIGlmIChwZXJzaXN0ICE9PSBmYWxzZSkgeyAgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZiwgbGV2ZWwsIG5hbWUpO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUgJiYgbGV2ZWwgPCBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBcIk5vIGNvbnNvbGUgYXZhaWxhYmxlIGZvciBsb2dnaW5nXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBcImxvZy5zZXRMZXZlbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgbGV2ZWw6IFwiICsgbGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXREZWZhdWx0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICBpZiAoIWdldFBlcnNpc3RlZExldmVsKCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5zZXRMZXZlbChsZXZlbCwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZW5hYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuVFJBQ0UsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5kaXNhYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuU0lMRU5ULCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEluaXRpYWxpemUgd2l0aCB0aGUgcmlnaHQgbGV2ZWxcbiAgICAgIHZhciBpbml0aWFsTGV2ZWwgPSBnZXRQZXJzaXN0ZWRMZXZlbCgpO1xuICAgICAgaWYgKGluaXRpYWxMZXZlbCA9PSBudWxsKSB7XG4gICAgICAgICAgaW5pdGlhbExldmVsID0gZGVmYXVsdExldmVsID09IG51bGwgPyBcIldBUk5cIiA6IGRlZmF1bHRMZXZlbDtcbiAgICAgIH1cbiAgICAgIHNlbGYuc2V0TGV2ZWwoaW5pdGlhbExldmVsLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKlxuICAgICAqIFRvcC1sZXZlbCBBUElcbiAgICAgKlxuICAgICAqL1xuXG4gICAgdmFyIGRlZmF1bHRMb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG5cbiAgICB2YXIgX2xvZ2dlcnNCeU5hbWUgPSB7fTtcbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlciA9IGZ1bmN0aW9uIGdldExvZ2dlcihuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIiB8fCBuYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV07XG4gICAgICAgIGlmICghbG9nZ2VyKSB7XG4gICAgICAgICAgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV0gPSBuZXcgTG9nZ2VyKFxuICAgICAgICAgICAgbmFtZSwgZGVmYXVsdExvZ2dlci5nZXRMZXZlbCgpLCBkZWZhdWx0TG9nZ2VyLm1ldGhvZEZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgfTtcblxuICAgIC8vIEdyYWIgdGhlIGN1cnJlbnQgZ2xvYmFsIGxvZyB2YXJpYWJsZSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICAgIHZhciBfbG9nID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpID8gd2luZG93LmxvZyA6IHVuZGVmaW5lZDtcbiAgICBkZWZhdWx0TG9nZ2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUgJiZcbiAgICAgICAgICAgICAgIHdpbmRvdy5sb2cgPT09IGRlZmF1bHRMb2dnZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG4gICAgfTtcblxuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VycyA9IGZ1bmN0aW9uIGdldExvZ2dlcnMoKSB7XG4gICAgICAgIHJldHVybiBfbG9nZ2Vyc0J5TmFtZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG59KSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQSxhQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n')},21:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_0__);\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Log System\n\nvar log = loglevel__WEBPACK_IMPORTED_MODULE_0__[\"getLogger\"]('StorageManager');\n\nvar StorageManager =\n/*#__PURE__*/\nfunction () {\n  function StorageManager(db, storageName, schemas, runtimeUA) {\n    var version = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n    var remoteStorage = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n    _classCallCheck(this, StorageManager);\n\n    if (!db) throw Error('The Storage Manager needs the database instance');\n    if (!storageName) throw Error('The Storage Manager needs the storage name');\n    var stores = {};\n\n    if (schemas) {\n      stores = schemas;\n    } else {\n      stores[storageName] = 'key,version,value';\n    } //    db.version(version).stores(stores);\n\n\n    db.open().then(function (db) {\n      log.info('Found database name ' + db.name + ' with version no: ' + db.verno);\n    }).catch(log.error);\n    this.db = db;\n    this.storageName = storageName;\n    this._remoteStorage = remoteStorage;\n    this._runtimeUA = runtimeUA;\n  } // set remoteStorage backup server URL\n\n\n  _createClass(StorageManager, [{\n    key: \"connect\",\n    // start sync with remoteStorage server. Returns a promise that resolves if connection is performed otherwise it is rejected\n    value: function connect(options) {\n      return this.db.connect(this._remoteStorage, options);\n    } // stop sync with remoteStorage server. Returns promise \n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        _this.db.disconnect(_this._remoteStorage).then(function () {\n          resolve();\n        }, function (error) {\n          reject(error);\n        });\n      });\n    } // to retrieve the last revision stored in the backup server\n\n  }, {\n    key: \"getBackupRevision\",\n    value: function getBackupRevision(resource) {\n      var _this2 = this;\n\n      return new Promise(function (resolve) {\n        _this2.db._syncNodes.get({\n          type: 'remote'\n        }).then(function (status) {\n          console.log('[StorageManager.getBackupRevision] retrieved status: ', status);\n\n          if (status && status.hasOwnProperty('appliedRemoteRevision')) {\n            if (status.appliedRemoteRevision === null) status.appliedRemoteRevision = 0;\n            resolve(status.appliedRemoteRevision);\n          }\n        });\n      });\n    } // to retrieve the last revision stored in the backup server\n    // and broadcast it\n\n  }, {\n    key: \"_updateBackupRevision\",\n    value: function _updateBackupRevision(resource) {\n      var _this3 = this;\n\n      return new Promise(function (resolve) {\n        _this3.db._syncNodes.get({\n          type: 'remote'\n        }).then(function (status) {\n          console.log('[StorageManager._updateBackupRevision] retrieved status: ', status);\n\n          if (status && status.hasOwnProperty('appliedRemoteRevision')) {\n            if (status.appliedRemoteRevision === null) status.appliedRemoteRevision = 0;\n\n            _this3._runtimeUA._updateRuntimeStatus({\n              resource: resource,\n              value: {\n                backupRevision: status.appliedRemoteRevision\n              }\n            });\n\n            resolve(status.appliedRemoteRevision);\n          }\n        });\n      });\n    }\n  }, {\n    key: \"_checkKey\",\n    value: function _checkKey(key) {\n      if (typeof key !== 'string') return key.toString();\n      return key;\n    }\n  }, {\n    key: \"_getTable\",\n    value: function _getTable(key) {\n      var name;\n\n      try {\n        name = this.db.table(this.storageName).name;\n      } catch (error) {\n        //      try {\n        name = this.db.table(key).name;\n        /*      } catch (error) {\n                log.error('[StorageManager._getTable] error ', error);\n                name = false;\n              }*/\n      }\n\n      return name;\n    }\n  }, {\n    key: \"_getPrimaryKey\",\n    value: function _getPrimaryKey(table) {\n      return this.db.table(table).schema.primKey.name;\n    }\n  }, {\n    key: \"_isDefaultSchema\",\n    value: function _isDefaultSchema(table) {\n      var name = this._getTable(table);\n\n      var schema = this.db[name].schema.instanceTemplate;\n      return schema.hasOwnProperty('value') && schema.hasOwnProperty('version') && schema.hasOwnProperty('key');\n    }\n    /**\n     * Adds a new entry to the database for a given key, together with its version.\n     * If an entry for the given key is already stored in the database, it will be updated.\n     * @param {!string} key - key that can be used with {@link storageManager.get} to retrieve the value object\n     * @param {!string} version - version descriptor for the given value\n     * @param value - value stored in the database that is mapped to given key\n     * @param {!string} table - table which should be looking for\n     * @returns {Promise} result - Promise that will be fulfilled with the key if the entry was stored successfully,\n     * otherwise it is rejected with an error.\n     * @memberof StorageManager\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(key, version, value, table) {\n      var _this4 = this;\n\n      var updateRuntimeStatus = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n      return new Promise(function (resolve, reject) {\n        log.info('[StorageManager] - set ', key, value);\n        table = table ? table : key;\n\n        var name = _this4._getTable(table);\n\n        var primaryKey = _this4._getPrimaryKey(name); // Object.assign(value, {version: version});\n\n\n        var data = value;\n\n        if (_this4._isDefaultSchema(table)) {\n          data = {\n            key: key,\n            version: version,\n            value: value\n          };\n        } else {\n          var tmp = {};\n          tmp[primaryKey] = key;\n          Object.assign(data, tmp);\n        }\n\n        _this4.db[name].put(data).then(function () {\n          if (updateRuntimeStatus && data.backup && data.url) {\n            _this4._updateBackupRevision(data.url).then(function () {\n              resolve();\n            });\n          } else resolve();\n        }, function () {\n          resolve();\n        });\n      });\n    }\n    /**\n     * Get a entry value from the database for a given key.\n     * If no entry is found undefined is returned.\n     * @param {!string} key - key that was stored using {@link storageManager.set}\n     * @param {!any} value - value which should be found\n     * @param {!string} table - table which should be looking for\n     * @returns {Promise} result - Promise that will be fulfilled with the value.\n     * @memberof StorageManager\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(key, value, table) {\n      var _this5 = this;\n\n      console.info('[StorageManager] - get ', key, value);\n      table = table ? table : key;\n\n      var name = this._getTable(table);\n\n      if (!name) return undefined;\n\n      var primaryKey = this._getPrimaryKey(name);\n\n      return this.db.transaction('rw!', this.db[name], function () {\n        if (!key && !value) {\n          return _this5.db[name].toArray().then(function (objects) {\n            if (objects.length > 0) {\n              return objects.reduce(function (acc, key) {\n                acc[key[primaryKey]] = key;\n                return acc;\n              }, function () {\n                return {};\n              });\n            } else return {};\n          });\n        }\n\n        if (!value) {\n          return _this5.db[name].where(primaryKey).equals(key).first().then(function (object) {\n            if (object && object.hasOwnProperty('value')) {\n              return object.value;\n            } else {\n              return object;\n            }\n          });\n        } else {\n          var type = _typeof(value);\n\n          if (Array.isArray(value)) {\n            type = 'array';\n          }\n\n          switch (type) {\n            case 'string':\n              return _this5.db[name].where(key).equals(value).first().then(function (object) {\n                if (object && object.hasOwnProperty('value')) {\n                  return object.value;\n                } else {\n                  return object;\n                }\n              });\n\n            case 'object':\n              {\n                var strPath = 'value.' + Object.keys(value).toString();\n                var strValue = Object.values(value);\n                console.log(strPath, strValue);\n                return _this5.db[name].where(strPath).anyOf(strValue).first().then(function (object) {\n                  if (object && object.hasOwnProperty('value')) {\n                    return object.value;\n                  } else {\n                    return object;\n                  }\n                });\n              }\n\n            case 'array':\n              console.log('ARRAY:', value);\n              return _this5.db[name].where(value).then(function (object) {\n                if (object && object.hasOwnProperty('value')) {\n                  return object.value;\n                } else {\n                  return object;\n                }\n              });\n          }\n        }\n      });\n    }\n    /**\n     * Get a entry version from the database for a given key.\n     * If no entry is found undefined is returned.\n     * @param {!string} key - key that was stored using {@link storageManager.set}\n     * @param {any} value - the value which sould be used to find the storage resource\n     * @param {!string} table - table which should be looking for\n     * @returns {Promise} result - Promise that will be fulfilled with the version.\n     * @memberof StorageManager\n     */\n\n  }, {\n    key: \"getVersion\",\n    value: function getVersion(key, value, table) {\n      var _this6 = this;\n\n      log.info('[StorageManager] - getVersion for key ', key);\n      table = table ? table : key;\n\n      var name = this._getTable(table);\n\n      var primaryKey = this._getPrimaryKey(name);\n\n      var data = value;\n\n      if (!value) {\n        data = key;\n      }\n\n      return this.db.transaction('rw!', this.db[name], function () {\n        return _this6.db[name].where(primaryKey).equals(data).first().then(function (object) {\n          if (object && object.hasOwnProperty('version')) {\n            return object.version;\n          } else {\n            return object;\n          }\n        }).catch(function (error) {\n          log.info('error getting the version for ', key, ' with error: ', error);\n          return undefined;\n        });\n      });\n    }\n    /**\n     * Delete a entry from the database for a given key or the full DB in case the key is not provided.\n     * @param {!string} key - key that was stored using {@link storageManager.set}\n     * @param {!any} value - the value which sould be used to find the storage resource\n     * @param {!string} table - table which should be looking for\n     * @returns {Promise} result - Promise that will be fulfilled with the number of affected rows.\n     * @memberof StorageManager\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(key, value, table) {\n      if (key) {\n        table = table ? table : key;\n\n        var name = this._getTable(table);\n\n        var primaryKey = this._getPrimaryKey(name);\n\n        var data = value;\n\n        if (!value) {\n          data = key;\n        }\n\n        return this.db[name].where(primaryKey).equals(data).delete();\n      } else return this.db.delete();\n    }\n  }, {\n    key: \"remoteStorage\",\n    set: function set(remoteStorage) {\n      this._remoteStorage = remoteStorage;\n    }\n  }]);\n\n  return StorageManager;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (StorageManager);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvc3RvcmFnZS1tYW5hZ2VyL1N0b3JhZ2VNYW5hZ2VyLmpzPzhiMjEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gTG9nIFN5c3RlbVxuaW1wb3J0ICogYXMgbG9nZ2VyIGZyb20gJ2xvZ2xldmVsJztcbmxldCBsb2cgPSBsb2dnZXIuZ2V0TG9nZ2VyKCdTdG9yYWdlTWFuYWdlcicpO1xuXG5jbGFzcyBTdG9yYWdlTWFuYWdlciB7XG5cbiAgY29uc3RydWN0b3IoZGIsIHN0b3JhZ2VOYW1lLCBzY2hlbWFzLCBydW50aW1lVUEsIHZlcnNpb24gPSAxLCByZW1vdGVTdG9yYWdlID0gZmFsc2UpIHtcbiAgICBpZiAoIWRiKSB0aHJvdyBFcnJvcignVGhlIFN0b3JhZ2UgTWFuYWdlciBuZWVkcyB0aGUgZGF0YWJhc2UgaW5zdGFuY2UnKTtcbiAgICBpZiAoIXN0b3JhZ2VOYW1lKSB0aHJvdyBFcnJvcignVGhlIFN0b3JhZ2UgTWFuYWdlciBuZWVkcyB0aGUgc3RvcmFnZSBuYW1lJyk7XG5cbiAgICBsZXQgc3RvcmVzID0gIHt9O1xuXG4gICAgaWYgKHNjaGVtYXMpIHtcbiAgICAgIHN0b3JlcyA9IHNjaGVtYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0b3Jlc1tzdG9yYWdlTmFtZV0gPSAna2V5LHZlcnNpb24sdmFsdWUnO1xuICAgIH1cblxuLy8gICAgZGIudmVyc2lvbih2ZXJzaW9uKS5zdG9yZXMoc3RvcmVzKTtcbiAgICBkYi5vcGVuKCkudGhlbigoZGIpID0+IHtcbiAgICAgIGxvZy5pbmZvKCdGb3VuZCBkYXRhYmFzZSBuYW1lICcgKyBkYi5uYW1lICsgJyB3aXRoIHZlcnNpb24gbm86ICcgKyBkYi52ZXJubyk7XG4gICAgfSkuY2F0Y2gobG9nLmVycm9yKTtcblxuICAgIHRoaXMuZGIgPSBkYjtcbiAgICB0aGlzLnN0b3JhZ2VOYW1lID0gc3RvcmFnZU5hbWU7XG4gICAgdGhpcy5fcmVtb3RlU3RvcmFnZSA9IHJlbW90ZVN0b3JhZ2U7XG4gICAgdGhpcy5fcnVudGltZVVBID0gcnVudGltZVVBO1xuICB9XG5cbiAgLy8gc2V0IHJlbW90ZVN0b3JhZ2UgYmFja3VwIHNlcnZlciBVUkxcblxuICBzZXQgcmVtb3RlU3RvcmFnZShyZW1vdGVTdG9yYWdlKSB7XG4gICAgdGhpcy5fcmVtb3RlU3RvcmFnZSA9IHJlbW90ZVN0b3JhZ2U7XG4gIH1cblxuICAvLyBzdGFydCBzeW5jIHdpdGggcmVtb3RlU3RvcmFnZSBzZXJ2ZXIuIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgaWYgY29ubmVjdGlvbiBpcyBwZXJmb3JtZWQgb3RoZXJ3aXNlIGl0IGlzIHJlamVjdGVkXG5cbiAgY29ubmVjdChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuZGIuY29ubmVjdCh0aGlzLl9yZW1vdGVTdG9yYWdlLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIHN0b3Agc3luYyB3aXRoIHJlbW90ZVN0b3JhZ2Ugc2VydmVyLiBSZXR1cm5zIHByb21pc2UgXG5cbiAgZGlzY29ubmVjdCgpIHtcbiAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSxyZWplY3QpID0+IHtcbiAgICAgIHRoaXMuZGIuZGlzY29ubmVjdCh0aGlzLl9yZW1vdGVTdG9yYWdlKS50aGVuKCgpPT4ge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgIHJlamVjdChlcnJvcik7XG4gICAgfSk7XG4gIH0pO1xufVxuICAvLyB0byByZXRyaWV2ZSB0aGUgbGFzdCByZXZpc2lvbiBzdG9yZWQgaW4gdGhlIGJhY2t1cCBzZXJ2ZXJcblxuICBnZXRCYWNrdXBSZXZpc2lvbihyZXNvdXJjZSkge1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKT0+IHtcbiAgICAgIHRoaXMuZGIuX3N5bmNOb2Rlcy5nZXQoe3R5cGU6ICdyZW1vdGUnfSkudGhlbigoc3RhdHVzKT0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tTdG9yYWdlTWFuYWdlci5nZXRCYWNrdXBSZXZpc2lvbl0gcmV0cmlldmVkIHN0YXR1czogJywgc3RhdHVzKTtcbiAgICAgICAgaWYgKHN0YXR1cyAmJiBzdGF0dXMuaGFzT3duUHJvcGVydHkoJ2FwcGxpZWRSZW1vdGVSZXZpc2lvbicpKSB7XG4gICAgICAgICAgaWYgKHN0YXR1cy5hcHBsaWVkUmVtb3RlUmV2aXNpb24gPT09IG51bGwpIHN0YXR1cy5hcHBsaWVkUmVtb3RlUmV2aXNpb24gPSAwO1xuXG4gICAgICAgICAgcmVzb2x2ZShzdGF0dXMuYXBwbGllZFJlbW90ZVJldmlzaW9uKTtcbiAgICAgICAgfSBcbiAgICB9KTtcbiAgfSk7XG59XG5cbiAgLy8gdG8gcmV0cmlldmUgdGhlIGxhc3QgcmV2aXNpb24gc3RvcmVkIGluIHRoZSBiYWNrdXAgc2VydmVyXG4gIC8vIGFuZCBicm9hZGNhc3QgaXRcblxuICBfdXBkYXRlQmFja3VwUmV2aXNpb24ocmVzb3VyY2UpIHtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSk9PiB7XG4gICAgICB0aGlzLmRiLl9zeW5jTm9kZXMuZ2V0KHt0eXBlOiAncmVtb3RlJ30pLnRoZW4oKHN0YXR1cyk9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbU3RvcmFnZU1hbmFnZXIuX3VwZGF0ZUJhY2t1cFJldmlzaW9uXSByZXRyaWV2ZWQgc3RhdHVzOiAnLCBzdGF0dXMpO1xuICAgICAgICBpZiAoc3RhdHVzICYmIHN0YXR1cy5oYXNPd25Qcm9wZXJ0eSgnYXBwbGllZFJlbW90ZVJldmlzaW9uJykpIHtcbiAgICAgICAgICBpZiAoc3RhdHVzLmFwcGxpZWRSZW1vdGVSZXZpc2lvbiA9PT0gbnVsbCkgc3RhdHVzLmFwcGxpZWRSZW1vdGVSZXZpc2lvbiA9IDA7XG5cbiAgICAgICAgICB0aGlzLl9ydW50aW1lVUEuX3VwZGF0ZVJ1bnRpbWVTdGF0dXMoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJlc291cmNlOiByZXNvdXJjZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHsgYmFja3VwUmV2aXNpb246IHN0YXR1cy5hcHBsaWVkUmVtb3RlUmV2aXNpb24gfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgICByZXNvbHZlKHN0YXR1cy5hcHBsaWVkUmVtb3RlUmV2aXNpb24pO1xuICAgICAgICB9IFxuICAgIH0pO1xuICB9KTtcbn1cblxuICBfY2hlY2tLZXkoa2V5KSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSByZXR1cm4ga2V5LnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIGtleTtcbiAgfVxuXG4gIF9nZXRUYWJsZShrZXkpIHtcbiAgICBsZXQgbmFtZTtcblxuICAgIHRyeSB7XG4gICAgICBuYW1lID0gdGhpcy5kYi50YWJsZSh0aGlzLnN0b3JhZ2VOYW1lKS5uYW1lO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4vLyAgICAgIHRyeSB7XG4gICAgICAgIG5hbWUgPSB0aGlzLmRiLnRhYmxlKGtleSkubmFtZTtcbi8qICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nLmVycm9yKCdbU3RvcmFnZU1hbmFnZXIuX2dldFRhYmxlXSBlcnJvciAnLCBlcnJvcik7XG4gICAgICAgIG5hbWUgPSBmYWxzZTtcbiAgICAgIH0qL1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lO1xuICB9XG5cbiAgX2dldFByaW1hcnlLZXkodGFibGUpIHtcbiAgICByZXR1cm4gdGhpcy5kYi50YWJsZSh0YWJsZSkuc2NoZW1hLnByaW1LZXkubmFtZTtcbiAgfVxuXG4gIF9pc0RlZmF1bHRTY2hlbWEodGFibGUpIHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5fZ2V0VGFibGUodGFibGUpO1xuICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuZGJbbmFtZV0uc2NoZW1hLmluc3RhbmNlVGVtcGxhdGU7XG4gICAgcmV0dXJuIHNjaGVtYS5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSAmJiBzY2hlbWEuaGFzT3duUHJvcGVydHkoJ3ZlcnNpb24nKSAmJiBzY2hlbWEuaGFzT3duUHJvcGVydHkoJ2tleScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBuZXcgZW50cnkgdG8gdGhlIGRhdGFiYXNlIGZvciBhIGdpdmVuIGtleSwgdG9nZXRoZXIgd2l0aCBpdHMgdmVyc2lvbi5cbiAgICogSWYgYW4gZW50cnkgZm9yIHRoZSBnaXZlbiBrZXkgaXMgYWxyZWFkeSBzdG9yZWQgaW4gdGhlIGRhdGFiYXNlLCBpdCB3aWxsIGJlIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7IXN0cmluZ30ga2V5IC0ga2V5IHRoYXQgY2FuIGJlIHVzZWQgd2l0aCB7QGxpbmsgc3RvcmFnZU1hbmFnZXIuZ2V0fSB0byByZXRyaWV2ZSB0aGUgdmFsdWUgb2JqZWN0XG4gICAqIEBwYXJhbSB7IXN0cmluZ30gdmVyc2lvbiAtIHZlcnNpb24gZGVzY3JpcHRvciBmb3IgdGhlIGdpdmVuIHZhbHVlXG4gICAqIEBwYXJhbSB2YWx1ZSAtIHZhbHVlIHN0b3JlZCBpbiB0aGUgZGF0YWJhc2UgdGhhdCBpcyBtYXBwZWQgdG8gZ2l2ZW4ga2V5XG4gICAqIEBwYXJhbSB7IXN0cmluZ30gdGFibGUgLSB0YWJsZSB3aGljaCBzaG91bGQgYmUgbG9va2luZyBmb3JcbiAgICogQHJldHVybnMge1Byb21pc2V9IHJlc3VsdCAtIFByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aXRoIHRoZSBrZXkgaWYgdGhlIGVudHJ5IHdhcyBzdG9yZWQgc3VjY2Vzc2Z1bGx5LFxuICAgKiBvdGhlcndpc2UgaXQgaXMgcmVqZWN0ZWQgd2l0aCBhbiBlcnJvci5cbiAgICogQG1lbWJlcm9mIFN0b3JhZ2VNYW5hZ2VyXG4gICAqL1xuICBzZXQoa2V5LCB2ZXJzaW9uLCB2YWx1ZSwgdGFibGUsIHVwZGF0ZVJ1bnRpbWVTdGF0dXMgPSB0cnVlKSB7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UgKChyZXNvbHZlLCByZWplY3QpPT4ge1xuICAgICAgbG9nLmluZm8oJ1tTdG9yYWdlTWFuYWdlcl0gLSBzZXQgJywga2V5LCB2YWx1ZSk7XG4gICAgICB0YWJsZSA9IHRhYmxlID8gdGFibGUgOiBrZXk7XG4gICAgICBjb25zdCBuYW1lID0gdGhpcy5fZ2V0VGFibGUodGFibGUpO1xuICAgICAgY29uc3QgcHJpbWFyeUtleSA9IHRoaXMuX2dldFByaW1hcnlLZXkobmFtZSk7XG4gIFxuICAgICAgLy8gT2JqZWN0LmFzc2lnbih2YWx1ZSwge3ZlcnNpb246IHZlcnNpb259KTtcbiAgXG4gICAgICBsZXQgZGF0YSA9IHZhbHVlO1xuICBcbiAgICAgIGlmICh0aGlzLl9pc0RlZmF1bHRTY2hlbWEodGFibGUpKSB7XG4gICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgdmVyc2lvbjogdmVyc2lvbixcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRtcCA9IHt9O1xuICAgICAgICB0bXBbcHJpbWFyeUtleV0gPSBrZXk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oZGF0YSwgdG1wKTtcbiAgICAgIH1cbiAgXG4gICAgICAgdGhpcy5kYltuYW1lXS5wdXQoZGF0YSkudGhlbigoKT0+e1xuICAgICAgaWYgKHVwZGF0ZVJ1bnRpbWVTdGF0dXMgJiYgZGF0YS5iYWNrdXAgJiYgZGF0YS51cmwpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlQmFja3VwUmV2aXNpb24oZGF0YS51cmwpLnRoZW4oKCk9PiB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSByZXNvbHZlKCk7XG5cbiAgICAgICB9LCAoKT0+IHtcbiAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICB9KTtcblxuICAgIH0pO1xuXG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgZW50cnkgdmFsdWUgZnJvbSB0aGUgZGF0YWJhc2UgZm9yIGEgZ2l2ZW4ga2V5LlxuICAgKiBJZiBubyBlbnRyeSBpcyBmb3VuZCB1bmRlZmluZWQgaXMgcmV0dXJuZWQuXG4gICAqIEBwYXJhbSB7IXN0cmluZ30ga2V5IC0ga2V5IHRoYXQgd2FzIHN0b3JlZCB1c2luZyB7QGxpbmsgc3RvcmFnZU1hbmFnZXIuc2V0fVxuICAgKiBAcGFyYW0geyFhbnl9IHZhbHVlIC0gdmFsdWUgd2hpY2ggc2hvdWxkIGJlIGZvdW5kXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gdGFibGUgLSB0YWJsZSB3aGljaCBzaG91bGQgYmUgbG9va2luZyBmb3JcbiAgICogQHJldHVybnMge1Byb21pc2V9IHJlc3VsdCAtIFByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aXRoIHRoZSB2YWx1ZS5cbiAgICogQG1lbWJlcm9mIFN0b3JhZ2VNYW5hZ2VyXG4gICAqL1xuICBnZXQoa2V5LCB2YWx1ZSwgdGFibGUpIHtcbiAgICBjb25zb2xlLmluZm8oJ1tTdG9yYWdlTWFuYWdlcl0gLSBnZXQgJywga2V5LCB2YWx1ZSk7XG4gICAgdGFibGUgPSB0YWJsZSA/IHRhYmxlIDoga2V5O1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9nZXRUYWJsZSh0YWJsZSk7XG4gICAgaWYgKCFuYW1lKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHByaW1hcnlLZXkgPSB0aGlzLl9nZXRQcmltYXJ5S2V5KG5hbWUpO1xuXG4gICAgcmV0dXJuIHRoaXMuZGIudHJhbnNhY3Rpb24oJ3J3IScsIHRoaXMuZGJbbmFtZV0sICgpID0+IHtcblxuICAgICAgaWYgKCFrZXkgJiYgIXZhbHVlKSB7IFxuICAgICAgICByZXR1cm4gdGhpcy5kYltuYW1lXS50b0FycmF5KCkudGhlbihvYmplY3RzID0+IHtcbiAgICAgICAgICBpZiAob2JqZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0cy5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICAgICAgICAgIGFjY1trZXlbcHJpbWFyeUtleV1dID0ga2V5O1xuICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwgKCkgPT57cmV0dXJuIHt9IH0pO1xuICAgICAgICAgIH0gZWxzZSByZXR1cm4ge307XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXZhbHVlKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGJbbmFtZV0ud2hlcmUocHJpbWFyeUtleSkuZXF1YWxzKGtleSkuZmlyc3QoKVxuICAgICAgICAgIC50aGVuKG9iamVjdCA9PiB7XG4gICAgICAgICAgICBpZiAob2JqZWN0ICYmIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSkge1xuICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0LnZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBsZXQgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICB0eXBlID0gJ2FycmF5JztcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRiW25hbWVdLndoZXJlKGtleSkuZXF1YWxzKHZhbHVlKS5maXJzdCgpXG4gICAgICAgICAgICAgIC50aGVuKG9iamVjdCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdCAmJiBvYmplY3QuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3QudmFsdWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgJ29iamVjdCc6IHtcbiAgICAgICAgICAgIGNvbnN0IHN0clBhdGggPSAndmFsdWUuJyArIE9iamVjdC5rZXlzKHZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3Qgc3RyVmFsdWUgPSBPYmplY3QudmFsdWVzKHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHN0clBhdGgsIHN0clZhbHVlKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGJbbmFtZV0ud2hlcmUoc3RyUGF0aCkuYW55T2Yoc3RyVmFsdWUpLmZpcnN0KClcbiAgICAgICAgICAgICAgLnRoZW4ob2JqZWN0ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0ICYmIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBUlJBWTonLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYltuYW1lXS53aGVyZSh2YWx1ZSkudGhlbihvYmplY3QgPT4ge1xuICAgICAgICAgICAgICBpZiAob2JqZWN0ICYmIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3QudmFsdWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBlbnRyeSB2ZXJzaW9uIGZyb20gdGhlIGRhdGFiYXNlIGZvciBhIGdpdmVuIGtleS5cbiAgICogSWYgbm8gZW50cnkgaXMgZm91bmQgdW5kZWZpbmVkIGlzIHJldHVybmVkLlxuICAgKiBAcGFyYW0geyFzdHJpbmd9IGtleSAtIGtleSB0aGF0IHdhcyBzdG9yZWQgdXNpbmcge0BsaW5rIHN0b3JhZ2VNYW5hZ2VyLnNldH1cbiAgICogQHBhcmFtIHthbnl9IHZhbHVlIC0gdGhlIHZhbHVlIHdoaWNoIHNvdWxkIGJlIHVzZWQgdG8gZmluZCB0aGUgc3RvcmFnZSByZXNvdXJjZVxuICAgKiBAcGFyYW0geyFzdHJpbmd9IHRhYmxlIC0gdGFibGUgd2hpY2ggc2hvdWxkIGJlIGxvb2tpbmcgZm9yXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSByZXN1bHQgLSBQcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgd2l0aCB0aGUgdmVyc2lvbi5cbiAgICogQG1lbWJlcm9mIFN0b3JhZ2VNYW5hZ2VyXG4gICAqL1xuICBnZXRWZXJzaW9uKGtleSwgdmFsdWUsIHRhYmxlKSB7XG4gICAgbG9nLmluZm8oJ1tTdG9yYWdlTWFuYWdlcl0gLSBnZXRWZXJzaW9uIGZvciBrZXkgJywga2V5KTtcbiAgICB0YWJsZSA9IHRhYmxlID8gdGFibGUgOiBrZXk7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMuX2dldFRhYmxlKHRhYmxlKTtcbiAgICBjb25zdCBwcmltYXJ5S2V5ID0gdGhpcy5fZ2V0UHJpbWFyeUtleShuYW1lKTtcblxuICAgIGxldCBkYXRhID0gdmFsdWU7XG5cbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICBkYXRhID0ga2V5O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmRiLnRyYW5zYWN0aW9uKCdydyEnLCB0aGlzLmRiW25hbWVdLCAoKSA9PiB7XG5cbiAgICAgIHJldHVybiB0aGlzLmRiW25hbWVdLndoZXJlKHByaW1hcnlLZXkpXG4gICAgICAgIC5lcXVhbHMoZGF0YSlcbiAgICAgICAgLmZpcnN0KClcbiAgICAgICAgLnRoZW4oKG9iamVjdCkgPT4ge1xuICAgICAgICAgIGlmIChvYmplY3QgJiYgb2JqZWN0Lmhhc093blByb3BlcnR5KCd2ZXJzaW9uJykpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QudmVyc2lvbjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgbG9nLmluZm8oJ2Vycm9yIGdldHRpbmcgdGhlIHZlcnNpb24gZm9yICcsIGtleSwgJyB3aXRoIGVycm9yOiAnLCBlcnJvcik7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGEgZW50cnkgZnJvbSB0aGUgZGF0YWJhc2UgZm9yIGEgZ2l2ZW4ga2V5IG9yIHRoZSBmdWxsIERCIGluIGNhc2UgdGhlIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gICAqIEBwYXJhbSB7IXN0cmluZ30ga2V5IC0ga2V5IHRoYXQgd2FzIHN0b3JlZCB1c2luZyB7QGxpbmsgc3RvcmFnZU1hbmFnZXIuc2V0fVxuICAgKiBAcGFyYW0geyFhbnl9IHZhbHVlIC0gdGhlIHZhbHVlIHdoaWNoIHNvdWxkIGJlIHVzZWQgdG8gZmluZCB0aGUgc3RvcmFnZSByZXNvdXJjZVxuICAgKiBAcGFyYW0geyFzdHJpbmd9IHRhYmxlIC0gdGFibGUgd2hpY2ggc2hvdWxkIGJlIGxvb2tpbmcgZm9yXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSByZXN1bHQgLSBQcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgd2l0aCB0aGUgbnVtYmVyIG9mIGFmZmVjdGVkIHJvd3MuXG4gICAqIEBtZW1iZXJvZiBTdG9yYWdlTWFuYWdlclxuICAgKi9cbiAgZGVsZXRlKGtleSwgdmFsdWUsIHRhYmxlKSB7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICB0YWJsZSA9IHRhYmxlID8gdGFibGUgOiBrZXk7XG4gICAgICBjb25zdCBuYW1lID0gdGhpcy5fZ2V0VGFibGUodGFibGUpO1xuICAgICAgY29uc3QgcHJpbWFyeUtleSA9IHRoaXMuX2dldFByaW1hcnlLZXkobmFtZSk7XG4gIFxuICAgICAgbGV0IGRhdGEgPSB2YWx1ZTtcbiAgXG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIGRhdGEgPSBrZXk7XG4gICAgICB9XG4gIFxuICAgICAgcmV0dXJuIHRoaXMuZGJbbmFtZV1cbiAgICAgICAgLndoZXJlKHByaW1hcnlLZXkpXG4gICAgICAgIC5lcXVhbHMoZGF0YSlcbiAgICAgICAgLmRlbGV0ZSgpO1xuICAgIH0gZWxzZSByZXR1cm4gdGhpcy5kYi5kZWxldGUoKTtcbiAgXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBTdG9yYWdlTWFuYWdlcjtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQU1BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBOzs7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7QUFXQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7Ozs7Ozs7Ozs7OztBQVNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuQ0E7QUFxQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7OztBQVNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7QUFRQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUVBOzs7QUExU0E7QUFDQTtBQUNBOzs7Ozs7QUE0U0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///21\n")}})});