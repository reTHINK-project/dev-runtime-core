// version: 0.17.0
<<<<<<< HEAD
// date: Mon Jun 17 2019 10:00:41 GMT+0100 (GMT+01:00)
// licence: 
/**
* Copyright 2016 PT Inovação e Sistemas SA
* Copyright 2016 INESC-ID
* Copyright 2016 QUOBIS NETWORKS SL
* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V
* Copyright 2016 ORANGE SA
* Copyright 2016 Deutsche Telekom AG
* Copyright 2016 Apizee
* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
**/


// version: 0.17.0
// date: Mon Jun 17 2019 10:00:41 GMT+0100 (GMT+01:00)
=======
// date: Mon Jun 17 2019 09:28:57 GMT+0100 (Western European Summer Time)
>>>>>>> 4956552670eb42a03a2183bfef5ced66a828df66
// licence: 
/**
* Copyright 2016 PT Inovação e Sistemas SA
* Copyright 2016 INESC-ID
* Copyright 2016 QUOBIS NETWORKS SL
* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V
* Copyright 2016 ORANGE SA
* Copyright 2016 Deutsche Telekom AG
* Copyright 2016 Apizee
* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
**/


!function(n,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define("PEP",[],e):"object"==typeof exports?exports.PEP=e():n.PEP=e()}(window,function(){return function(n){var e={};function t(i){if(e[i])return e[i].exports;var c=e[i]={i:i,l:!1,exports:{}};return n[i].call(c.exports,c,c.exports,t),c.l=!0,c.exports}return t.m=n,t.c=e,t.d=function(n,e,i){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:i})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var i=Object.create(null);if(t.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var c in n)t.d(i,c,function(e){return n[e]}.bind(null,c));return i},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="",t(t.s=35)}({0:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"k\", function() { return divideURL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"l\", function() { return emptyObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"C\", function() { return secondsSinceEpoch; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return deepClone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"B\", function() { return removePathFromURL; });\n/* unused harmony export getUserURLFromEmail */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"p\", function() { return getUserEmailFromURL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return convertToUserURL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"s\", function() { return isDataObjectURL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"u\", function() { return isLegacy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"v\", function() { return isURL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"w\", function() { return isUserURL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"t\", function() { return isHypertyURL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"o\", function() { return getConfigurationResources; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return buildURL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"n\", function() { return generateGUID; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"q\", function() { return getUserIdentityDomain; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"r\", function() { return isBackendServiceURL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"j\", function() { return divideEmail; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return assign; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"D\", function() { return splitObjectURL; });\n/* unused harmony export checkAttribute */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"y\", function() { return parseAttributes; });\n/* unused harmony export isEmpty */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return chatkeysToStringCloner; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return chatkeysToArrayCloner; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"z\", function() { return parseMessageURL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return availableSpace; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"m\", function() { return encode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return decode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return decodeToUint8Array; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"E\", function() { return stringify; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"x\", function() { return parse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"A\", function() { return parseToUint8Array; });\n/**\n* Copyright 2016 PT Inovação e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n\n/**\n * Support module with some functions will be useful\n * @module utils\n */\n\n/**\n * @typedef divideURL\n * @type Object\n * @property {string} type The type of URL\n * @property {string} domain The domain of URL\n * @property {string} identity The identity of URL\n */\n\n/**\n * Divide an url in type, domain and identity\n * @param  {URL.URL} url - url address\n * @return {divideURL} the result of divideURL\n */\nfunction divideURL(url) {\n  function recurse(value) {\n    var regex = /([a-zA-Z-]*)(:\\/\\/(?:\\.)?|:)([-a-zA-Z0-9@:%._+~#=]{2,256})([-a-zA-Z0-9@:%._+~#=/]*)/gi;\n    var subst = '$1,$3,$4';\n    var parts = value.replace(regex, subst).split(',');\n    return parts;\n  }\n\n  var parts = recurse(url); // If the url has no scheme\n\n  if (parts[0] === url && !parts[0].includes('@')) {\n    var _result = {\n      type: '',\n      domain: url,\n      identity: ''\n    };\n    console.warn('[DivideURL] DivideURL don\\'t support url without scheme. Please review your url address', url);\n    return _result;\n  } // check if the url has the scheme and includes an @\n\n\n  if (parts[0] === url && parts[0].includes('@')) {\n    var scheme = parts[0] === url ? 'smtp' : parts[0];\n    parts = recurse(scheme + '://' + parts[0]);\n  } // if the domain includes an @, divide it to domain and identity respectively\n\n\n  if (parts[1].includes('@')) {\n    parts[2] = parts[0] + '://' + parts[1];\n    parts[1] = parts[1].substr(parts[1].indexOf('@') + 1);\n  }\n  /*else if (parts[2].includes('/')) {\n  parts[2] = parts[2].substr(parts[2].lastIndexOf('/')+1);\n  }*/\n\n\n  var result = {\n    type: parts[0],\n    domain: parts[1],\n    identity: parts[2]\n  };\n  return result;\n}\n/**\n * Check if an Object is empty\n * @param  {Object} object Object to be checked\n * @return {Boolean}       status of Object, empty or not (true|false);\n */\n\nfunction emptyObject(object) {\n  return Object.keys(object).length > 0 ? false : true;\n}\nfunction secondsSinceEpoch() {\n  return Math.floor(Date.now() / 1000);\n}\n/**\n * Make a COPY of the original data\n * @param  {Object}  obj - object to be cloned\n * @return {Object}\n */\n\nfunction deepClone(obj) {\n  //TODO: simple but inefficient JSON deep clone...\n  if (obj) return JSON.parse(JSON.stringify(obj));\n}\nfunction removePathFromURL(url) {\n  var splitURL = url.split('/');\n  return splitURL[0] + '//' + splitURL[2] + '/' + splitURL[3];\n}\n/**\n * Obtains the user URL that corresponds to a given email\n * @param  {string} userEmail The user email\n * @return {URL.URL} userURL The user URL\n */\n\nfunction getUserURLFromEmail(userEmail) {\n  var indexOfAt = userEmail.indexOf('@');\n  return 'user://' + userEmail.substring(indexOfAt + 1, userEmail.length) + '/' + userEmail.substring(0, indexOfAt);\n}\n/**\n * Obtains the user email that corresponds to a given URL\n * @param  {URL.URL} userURL The user URL\n * @return {string} userEmail The user email\n */\n\nfunction getUserEmailFromURL(userURL) {\n  var url = divideURL(userURL);\n  return url.identity.replace('/', '') + '@' + url.domain; // identity field has '/exampleID' instead of 'exampleID'\n}\n/**\n * Check if the user identifier is already in the URL format, if not, convert to URL format\n * @param  {string}   identifier  user identifier\n * @return {string}   userURL    the user URL\n */\n\nfunction convertToUserURL(identifier) {\n  // check if the identifier is already in the url format\n  if (identifier.substring(0, 7) === 'user://') {\n    var dividedURL = divideURL(identifier); //check if the url is well formated\n\n    if (dividedURL.domain && dividedURL.identity) {\n      return identifier;\n    } else {\n      throw 'userURL with wrong format';\n    } //if not, convert the user email to URL format\n\n  } else {\n    return getUserURLFromEmail(identifier);\n  }\n}\nfunction isDataObjectURL(url) {\n  var schemasToIgnore = ['domain-idp', 'runtime', 'domain', 'hyperty'];\n  var splitURL = url.split('://');\n  var urlSchema = splitURL[0];\n  return schemasToIgnore.indexOf(urlSchema) === -1;\n}\nfunction isLegacy(url) {\n  if (url.split('@').length > 1) {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction isURL(url) {\n  return url.split('/').length >= 3;\n}\nfunction isUserURL(url) {\n  return divideURL(url).type === 'user';\n}\nfunction isHypertyURL(url) {\n  return divideURL(url).type === 'hyperty';\n}\n/**\n * get information relative each component configured on runtime configuration;\n * @param  {object} configuration object with all configuration\n * @param  {string} component     string with the component to get the configuration, like, runtimeURLS, catalogueURLs, msgNodeURL, domainRegistryURL;\n * @param  {string} resource      type of resource to get, like, catalogue, runtimeUA, protocolstub, idpProxy\n * @return {object}               return an object with all configurations;\n */\n\nfunction getConfigurationResources(configuration, component, resource) {\n  var objectResource = configuration[component];\n  var resourceType = objectResource[resource];\n  return resourceType;\n}\n/**\n * Build a full url with the runtime configuration;\n * @param  {object} configuration object with all configuration\n * @param  {string} component     string with the component to get the configuration, like, runtimeURLS, catalogueURLs, msgNodeURL, domainRegistryURL;\n * @param  {string} resource      type of resource to get, like, catalogue, runtimeUA, protocolstub, idpProxy\n * @param  {string} type          resource to get, like a hyperty name or protocolstub name;\n * @param  {boolean} useFallback  if true the function will check if have a fallback url;\n * @return {string}               partial url to contact the resource;\n */\n\nfunction buildURL(configuration, component, type, resource) {\n  var useFallback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var objectResource = configuration[component];\n  var url;\n\n  if (!objectResource.hasOwnProperty(type)) {\n    throw Error('The configuration ' + JSON.stringify(objectResource, '', 2) + ' don\\'t have the ' + type + ' resource you are looking for');\n  }\n\n  var resourceType = objectResource[type];\n\n  if (type) {\n    var ext = type === 'idp-proxy' ? '.idp.js' : '.ps.js';\n    url = resourceType.prefix + configuration.domain + resourceType.suffix + resource;\n\n    if (resourceType.hasOwnProperty('fallback') && useFallback) {\n      if (resourceType.fallback.indexOf('%domain%')) {\n        url = resourceType.fallback.replace(/(%domain%)/g, configuration.domain) + resource + ext;\n      } else {\n        url = resourceType.fallback + resource;\n      }\n    }\n  } else {\n    url = resourceType.prefix + configuration.domain + resourceType.suffix;\n  } // console.log(url);\n\n\n  return url;\n}\n/**\n * Generate a Global Unique ID\n *\n * @returns String;\n */\n\nfunction generateGUID() {\n  function s4() {\n    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n  }\n\n  return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n}\nfunction getUserIdentityDomain(url) {\n  var dividedURL = divideURL(url);\n  var splitedDomain = dividedURL.domain.split('.');\n  var splitedLength = splitedDomain.length;\n\n  if (splitedLength == 1) {\n    return splitedDomain[splitedLength - 1];\n  }\n\n  var domain = splitedDomain[splitedLength - 2] + '.' + splitedDomain[splitedLength - 1];\n  return domain;\n}\n/**\n * Check if URL is from a backend service\n * @param  {string} url     URL to be processed\n * @return {boolean}\n */\n\nfunction isBackendServiceURL(url) {\n  var dividedURL = divideURL(url);\n  var splitedDomain = dividedURL.domain.split('.');\n  var backendSchemes = ['domain', 'global', 'domain-idp']; // should be defined in the runtime configuration\n\n  var backendSubDomains = ['registry', 'msg-node']; // should be defined in the runtime configuration\n\n  var subDomain;\n\n  if (splitedDomain.length > 1) {\n    subDomain = splitedDomain.filter(function (item) {\n      return backendSubDomains.indexOf(item) !== -1;\n    })[0];\n  }\n\n  if (subDomain && backendSubDomains.indexOf(subDomain) !== -1) {\n    return true;\n  }\n\n  if (dividedURL.type) {\n    return backendSchemes.indexOf(dividedURL.type) !== -1;\n  }\n\n  return false;\n}\nfunction divideEmail(email) {\n  var indexOfAt = email.indexOf('@');\n  var result = {\n    username: email.substring(0, indexOfAt),\n    domain: email.substring(indexOfAt + 1, email.length)\n  };\n  return result;\n}\nfunction assign(obj, keyPath, value) {\n  if (!obj) obj = {};\n  if (typeof keyPath === 'string') keyPath = parseAttributes(keyPath);\n  var lastKeyIndex = keyPath.length - 1;\n\n  for (var i = 0; i < lastKeyIndex; ++i) {\n    var key = keyPath[i];\n\n    if (!(key in obj)) {\n      obj[key] = {};\n    }\n\n    obj = obj[key];\n  }\n\n  obj[keyPath[lastKeyIndex]] = value;\n}\nfunction splitObjectURL(dataObjectURL) {\n  console.info('[utils - splitObjectURL]: ', dataObjectURL);\n  var splitedURL = dataObjectURL.split('/');\n  var url = splitedURL[0] + '//' + splitedURL[2] + '/' + splitedURL[3];\n  var resource = splitedURL[5];\n  var result = {\n    url: url,\n    resource: resource\n  };\n  console.info('[utils - splitObjectURL]: ', result);\n  return result;\n}\nfunction checkAttribute(path) {\n  var regex = /((([a-zA-Z]+):\\/\\/([0-9a-zA-Z][-\\w]*[0-9a-zA-Z]\\.)+[a-zA-Z]{2,9})\\/[a-zA-Z0-9.]+@[a-zA-Z0-9]+(-)?[a-zA-Z0-9]+(\\.)?[a-zA-Z0-9]{2,10}?\\.[a-zA-Z]{2,10})(.+(?=.identity))?/gm;\n  var list = [];\n  var _final = [];\n  var test = path.match(regex);\n\n  if (test == null) {\n    _final = path.split('.');\n  } else {\n    var m;\n\n    while ((m = regex.exec(path)) !== null) {\n      // This is necessary to avoid infinite loops with zero-width matches\n      if (m.index === regex.lastIndex) {\n        regex.lastIndex++;\n      } // The result can be accessed through the `m`-variable.\n\n\n      m.forEach(function (match, groupIndex) {\n        if (groupIndex === 0) {\n          list.push(match);\n        }\n      });\n    }\n\n    var result;\n    list.forEach(function (url) {\n      result = path.replace(url, '*-*');\n      _final = result.split('.').map(function (item) {\n        if (item === '*-*') {\n          return url;\n        }\n\n        return item;\n      });\n    });\n  }\n\n  console.log('[RuntimeCore.Utils.checkAttribute]', _final);\n  return _final;\n}\nfunction parseAttributes(path) {\n  var regex = /([0-9a-zA-Z][-\\w]*):\\/\\//g;\n  var string3 = 'identity';\n\n  if (!path.includes('://')) {\n    return path.split('.');\n  } else {\n    var string1 = path.split(regex)[0];\n    var array1 = string1.split('.');\n    var string2 = path.replace(string1, '');\n\n    if (path.includes(string3)) {\n      var array2 = string2.split(string3 + '.');\n      console.log('array2 ' + array2);\n      string2 = array2[0].slice('.', -1);\n      array2 = array2[1].split('.');\n      array1.push(string2, string3);\n      array1 = array1.concat(array2);\n    } else {\n      array1.push(string2);\n    }\n\n    return array1.filter(Boolean);\n  }\n}\nfunction isEmpty(obj) {\n  for (var prop in obj) {\n    if (obj.hasOwnProperty(prop)) {\n      return false;\n    }\n  }\n\n  return JSON.stringify(obj) === JSON.stringify({});\n}\nfunction chatkeysToStringCloner(sessionKeys) {\n  var dataObjectSessionKeysClone = {};\n  var fields = Object.keys(sessionKeys);\n\n  if (fields) {\n    try {\n      for (var i = 0; i < fields.length; i++) {\n        var field = fields[i];\n        dataObjectSessionKeysClone[field] = {};\n        dataObjectSessionKeysClone[field].sessionKey = sessionKeys[field].sessionKey.toString();\n        dataObjectSessionKeysClone[field].isToEncrypt = sessionKeys[field].isToEncrypt;\n      }\n    } catch (err) {\n      console.error('_chatkeysToStringCloner:err', err);\n    }\n  }\n\n  return dataObjectSessionKeysClone;\n}\nfunction chatkeysToArrayCloner(sessionKeys) {\n  var dataObjectSessionKeysClone = {};\n  var fields = Object.keys(sessionKeys);\n\n  if (fields) {\n    try {\n      for (var i = 0; i < fields.length; i++) {\n        var field = fields[i];\n        dataObjectSessionKeysClone[field] = {};\n        var arrayValues = JSON.parse('[' + sessionKeys[field].sessionKey + ']');\n        dataObjectSessionKeysClone[field].sessionKey = new Uint8Array(arrayValues);\n        dataObjectSessionKeysClone[field].isToEncrypt = sessionKeys[field].isToEncrypt;\n      }\n    } catch (err) {\n      console.error('_chatkeysToArrayCloner:err', err);\n    }\n  }\n\n  return dataObjectSessionKeysClone;\n}\nfunction parseMessageURL(URL) {\n  var splitedToURL = URL.split('/');\n\n  if (splitedToURL.length <= 6) {\n    return splitedToURL[0] + '//' + splitedToURL[2] + '/' + splitedToURL[3];\n  } else {\n    return splitedToURL[0] + '//' + splitedToURL[2] + '/' + splitedToURL[3] + '/' + splitedToURL[4];\n  }\n}\nfunction availableSpace(usage, quota) {\n  var available = (usage / quota).toFixed(2);\n  return {\n    quota: quota,\n    usage: usage,\n    percent: Number(available)\n  };\n}\n/**\n* Encodes a JS object to base 64 encode\n* @param   {Object}    value    byteArray value\n* @return  {string}   encoded value\n*/\n\nfunction encode(value) {\n  try {\n    var stringValue = stringify(value);\n    return btoa(stringValue);\n  } catch (err) {\n    console.error('[Utils.encode:err] ' + err);\n    throw err;\n  }\n}\n/**\n  * Decode a base64 string to object\n  * @param   {string_b64}    value    value encoded in base 64\n  * @return  {Object} decodedValue\n  */\n\nfunction decode(value) {\n  try {\n    return JSON.parse(atob(value));\n  } catch (err) {\n    console.log('[Utils.decode:err] ' + err);\n    throw err;\n  }\n}\n/**\n* Decode a base64 string to Uint8Array\n* @param   {string_b64}    value    byteArray value\n* @return  {Uint8Array}   encoded value\n*/\n\nfunction decodeToUint8Array(value) {\n  try {\n    return new Uint8Array(decode(value));\n  } catch (err) {\n    console.error('[Utils.decodeToUint8Array:err] ' + err);\n    throw err;\n  }\n}\n/**\n* Converts a JS object to string\n* NOTE: Special conversion for Uint8Arrays\n* @param   {Object}    value    byteArray value\n* @return  {Uint8Array}   encoded value\n*/\n\nfunction stringify(value) {\n  try {\n    var stringValue;\n\n    if (value.constructor === Uint8Array) {\n      stringValue = '[' + value.toString() + ']'; // the [] is for JSON.parse compatibility\n    } else {\n      stringValue = JSON.stringify(value);\n    }\n\n    return stringValue;\n  } catch (err) {\n    console.error('[Utils.stringify:err] ' + err);\n    throw err;\n  }\n}\n/**\n* Converts a stringified object to object\n* @param   {String}    value    byteArray value\n* @return  {Object}   encoded value\n*/\n\nfunction parse(value) {\n  try {\n    return JSON.parse(value);\n  } catch (err) {\n    console.error('[Utils.parse:err]' + err);\n    console.trace();\n    console.error('That that cause the error:', value);\n    throw err;\n  }\n}\n/**\n* Converts a stringified object to object\n* @param   {String}    value    byteArray value\n* @return  {Uint8Array}   encoded value\n*/\n\nfunction parseToUint8Array(value) {\n  try {\n    return new Uint8Array(parse(value));\n  } catch (err) {\n    console.error('[Utils.parseToUint8Array:err]' + err);\n    throw err;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL1tuYW1lXS8uL3NyYy91dGlscy91dGlscy5qcz9mYTdkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuKiBDb3B5cmlnaHQgMjAxNiBQVCBJbm92YcOnw6NvIGUgU2lzdGVtYXMgU0FcbiogQ29weXJpZ2h0IDIwMTYgSU5FU0MtSURcbiogQ29weXJpZ2h0IDIwMTYgUVVPQklTIE5FVFdPUktTIFNMXG4qIENvcHlyaWdodCAyMDE2IEZSQVVOSE9GRVItR0VTRUxMU0NIQUZUIFpVUiBGT0VSREVSVU5HIERFUiBBTkdFV0FORFRFTiBGT1JTQ0hVTkcgRS5WXG4qIENvcHlyaWdodCAyMDE2IE9SQU5HRSBTQVxuKiBDb3B5cmlnaHQgMjAxNiBEZXV0c2NoZSBUZWxla29tIEFHXG4qIENvcHlyaWdodCAyMDE2IEFwaXplZVxuKiBDb3B5cmlnaHQgMjAxNiBURUNITklTQ0hFIFVOSVZFUlNJVEFUIEJFUkxJTlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qKi9cbi8qKlxuICogU3VwcG9ydCBtb2R1bGUgd2l0aCBzb21lIGZ1bmN0aW9ucyB3aWxsIGJlIHVzZWZ1bFxuICogQG1vZHVsZSB1dGlsc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYgZGl2aWRlVVJMXG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIFVSTFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG9mIFVSTFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkZW50aXR5IFRoZSBpZGVudGl0eSBvZiBVUkxcbiAqL1xuXG4vKipcbiAqIERpdmlkZSBhbiB1cmwgaW4gdHlwZSwgZG9tYWluIGFuZCBpZGVudGl0eVxuICogQHBhcmFtICB7VVJMLlVSTH0gdXJsIC0gdXJsIGFkZHJlc3NcbiAqIEByZXR1cm4ge2RpdmlkZVVSTH0gdGhlIHJlc3VsdCBvZiBkaXZpZGVVUkxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpdmlkZVVSTCh1cmwpIHtcblxuICBmdW5jdGlvbiByZWN1cnNlKHZhbHVlKSB7XG4gICAgY29uc3QgcmVnZXggPSAvKFthLXpBLVotXSopKDpcXC9cXC8oPzpcXC4pP3w6KShbLWEtekEtWjAtOUA6JS5fK34jPV17MiwyNTZ9KShbLWEtekEtWjAtOUA6JS5fK34jPS9dKikvZ2k7XG4gICAgY29uc3Qgc3Vic3QgPSAnJDEsJDMsJDQnO1xuICAgIGxldCBwYXJ0cyA9IHZhbHVlLnJlcGxhY2UocmVnZXgsIHN1YnN0KS5zcGxpdCgnLCcpO1xuICAgIHJldHVybiBwYXJ0cztcbiAgfVxuXG4gIGxldCBwYXJ0cyA9IHJlY3Vyc2UodXJsKTtcblxuICAvLyBJZiB0aGUgdXJsIGhhcyBubyBzY2hlbWVcbiAgaWYgKHBhcnRzWzBdID09PSB1cmwgJiYgIXBhcnRzWzBdLmluY2x1ZGVzKCdAJykpIHtcblxuICAgIGxldCByZXN1bHQgPSB7XG4gICAgICB0eXBlOiAnJyxcbiAgICAgIGRvbWFpbjogdXJsLFxuICAgICAgaWRlbnRpdHk6ICcnXG4gICAgfTtcblxuICAgIGNvbnNvbGUud2FybignW0RpdmlkZVVSTF0gRGl2aWRlVVJMIGRvblxcJ3Qgc3VwcG9ydCB1cmwgd2l0aG91dCBzY2hlbWUuIFBsZWFzZSByZXZpZXcgeW91ciB1cmwgYWRkcmVzcycsIHVybCk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gY2hlY2sgaWYgdGhlIHVybCBoYXMgdGhlIHNjaGVtZSBhbmQgaW5jbHVkZXMgYW4gQFxuICBpZiAocGFydHNbMF0gPT09IHVybCAmJiBwYXJ0c1swXS5pbmNsdWRlcygnQCcpKSB7XG4gICAgbGV0IHNjaGVtZSA9IHBhcnRzWzBdID09PSB1cmwgPyAnc210cCcgOiBwYXJ0c1swXTtcbiAgICBwYXJ0cyA9IHJlY3Vyc2Uoc2NoZW1lICsgJzovLycgKyBwYXJ0c1swXSk7XG4gIH1cblxuICAvLyBpZiB0aGUgZG9tYWluIGluY2x1ZGVzIGFuIEAsIGRpdmlkZSBpdCB0byBkb21haW4gYW5kIGlkZW50aXR5IHJlc3BlY3RpdmVseVxuICBpZiAocGFydHNbMV0uaW5jbHVkZXMoJ0AnKSkge1xuICAgIHBhcnRzWzJdID0gcGFydHNbMF0gKyAnOi8vJyArIHBhcnRzWzFdO1xuICAgIHBhcnRzWzFdID0gcGFydHNbMV0uc3Vic3RyKHBhcnRzWzFdLmluZGV4T2YoJ0AnKSArIDEpO1xuICB9IFx0LyplbHNlIGlmIChwYXJ0c1syXS5pbmNsdWRlcygnLycpKSB7XG4gICAgcGFydHNbMl0gPSBwYXJ0c1syXS5zdWJzdHIocGFydHNbMl0ubGFzdEluZGV4T2YoJy8nKSsxKTtcbiAgfSovXG5cbiAgbGV0IHJlc3VsdCA9IHtcbiAgICB0eXBlOiBwYXJ0c1swXSxcbiAgICBkb21haW46IHBhcnRzWzFdLFxuICAgIGlkZW50aXR5OiBwYXJ0c1syXVxuICB9O1xuXG4gIHJldHVybiByZXN1bHQ7XG5cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBPYmplY3QgaXMgZW1wdHlcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBiZSBjaGVja2VkXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICBzdGF0dXMgb2YgT2JqZWN0LCBlbXB0eSBvciBub3QgKHRydWV8ZmFsc2UpO1xuICovXG5leHBvcnQgZnVuY3Rpb24gZW1wdHlPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpLmxlbmd0aCA+IDAgPyBmYWxzZSA6IHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZWNvbmRzU2luY2VFcG9jaCgpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xufVxuXG5cbi8qKlxuICogTWFrZSBhIENPUFkgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbiAqIEBwYXJhbSAge09iamVjdH0gIG9iaiAtIG9iamVjdCB0byBiZSBjbG9uZWRcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBDbG9uZShvYmopIHtcbiAgLy9UT0RPOiBzaW1wbGUgYnV0IGluZWZmaWNpZW50IEpTT04gZGVlcCBjbG9uZS4uLlxuICBpZiAob2JqKSByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVBhdGhGcm9tVVJMKHVybCkge1xuICBsZXQgc3BsaXRVUkwgPSB1cmwuc3BsaXQoJy8nKTtcbiAgcmV0dXJuIHNwbGl0VVJMWzBdICsgJy8vJyArIHNwbGl0VVJMWzJdICsgJy8nICsgc3BsaXRVUkxbM107XG59XG5cbi8qKlxuICogT2J0YWlucyB0aGUgdXNlciBVUkwgdGhhdCBjb3JyZXNwb25kcyB0byBhIGdpdmVuIGVtYWlsXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHVzZXJFbWFpbCBUaGUgdXNlciBlbWFpbFxuICogQHJldHVybiB7VVJMLlVSTH0gdXNlclVSTCBUaGUgdXNlciBVUkxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVzZXJVUkxGcm9tRW1haWwodXNlckVtYWlsKSB7XG4gIGxldCBpbmRleE9mQXQgPSB1c2VyRW1haWwuaW5kZXhPZignQCcpO1xuICByZXR1cm4gJ3VzZXI6Ly8nICsgdXNlckVtYWlsLnN1YnN0cmluZyhpbmRleE9mQXQgKyAxLCB1c2VyRW1haWwubGVuZ3RoKSArICcvJyArIHVzZXJFbWFpbC5zdWJzdHJpbmcoMCwgaW5kZXhPZkF0KTtcbn1cblxuLyoqXG4gKiBPYnRhaW5zIHRoZSB1c2VyIGVtYWlsIHRoYXQgY29ycmVzcG9uZHMgdG8gYSBnaXZlbiBVUkxcbiAqIEBwYXJhbSAge1VSTC5VUkx9IHVzZXJVUkwgVGhlIHVzZXIgVVJMXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHVzZXJFbWFpbCBUaGUgdXNlciBlbWFpbFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXNlckVtYWlsRnJvbVVSTCh1c2VyVVJMKSB7XG4gIGxldCB1cmwgPSBkaXZpZGVVUkwodXNlclVSTCk7XG4gIHJldHVybiB1cmwuaWRlbnRpdHkucmVwbGFjZSgnLycsICcnKSArICdAJyArIHVybC5kb21haW47IC8vIGlkZW50aXR5IGZpZWxkIGhhcyAnL2V4YW1wbGVJRCcgaW5zdGVhZCBvZiAnZXhhbXBsZUlEJ1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSB1c2VyIGlkZW50aWZpZXIgaXMgYWxyZWFkeSBpbiB0aGUgVVJMIGZvcm1hdCwgaWYgbm90LCBjb252ZXJ0IHRvIFVSTCBmb3JtYXRcbiAqIEBwYXJhbSAge3N0cmluZ30gICBpZGVudGlmaWVyICB1c2VyIGlkZW50aWZpZXJcbiAqIEByZXR1cm4ge3N0cmluZ30gICB1c2VyVVJMICAgIHRoZSB1c2VyIFVSTFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRvVXNlclVSTChpZGVudGlmaWVyKSB7XG5cbiAgLy8gY2hlY2sgaWYgdGhlIGlkZW50aWZpZXIgaXMgYWxyZWFkeSBpbiB0aGUgdXJsIGZvcm1hdFxuICBpZiAoaWRlbnRpZmllci5zdWJzdHJpbmcoMCwgNykgPT09ICd1c2VyOi8vJykge1xuICAgIGxldCBkaXZpZGVkVVJMID0gZGl2aWRlVVJMKGlkZW50aWZpZXIpO1xuXG4gICAgLy9jaGVjayBpZiB0aGUgdXJsIGlzIHdlbGwgZm9ybWF0ZWRcbiAgICBpZiAoZGl2aWRlZFVSTC5kb21haW4gJiYgZGl2aWRlZFVSTC5pZGVudGl0eSkge1xuICAgICAgcmV0dXJuIGlkZW50aWZpZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93ICd1c2VyVVJMIHdpdGggd3JvbmcgZm9ybWF0JztcbiAgICB9XG5cbiAgLy9pZiBub3QsIGNvbnZlcnQgdGhlIHVzZXIgZW1haWwgdG8gVVJMIGZvcm1hdFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZXRVc2VyVVJMRnJvbUVtYWlsKGlkZW50aWZpZXIpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGFPYmplY3RVUkwodXJsKSB7XG4gIGxldCBzY2hlbWFzVG9JZ25vcmUgPSBbJ2RvbWFpbi1pZHAnLCAncnVudGltZScsICdkb21haW4nLCAnaHlwZXJ0eSddO1xuICBsZXQgc3BsaXRVUkwgPSAodXJsKS5zcGxpdCgnOi8vJyk7XG4gIGxldCB1cmxTY2hlbWEgPSBzcGxpdFVSTFswXTtcblxuICByZXR1cm4gc2NoZW1hc1RvSWdub3JlLmluZGV4T2YodXJsU2NoZW1hKSA9PT0gLTE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0xlZ2FjeSh1cmwpIHtcbiAgaWYgKHVybC5zcGxpdCgnQCcpLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVVJMKHVybCkge1xuICByZXR1cm4gKHVybCkuc3BsaXQoJy8nKS5sZW5ndGggPj0gMztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVXNlclVSTCh1cmwpIHtcbiAgcmV0dXJuIGRpdmlkZVVSTCh1cmwpLnR5cGUgPT09ICd1c2VyJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSHlwZXJ0eVVSTCh1cmwpIHtcbiAgcmV0dXJuIGRpdmlkZVVSTCh1cmwpLnR5cGUgPT09ICdoeXBlcnR5Jztcbn1cblxuLyoqXG4gKiBnZXQgaW5mb3JtYXRpb24gcmVsYXRpdmUgZWFjaCBjb21wb25lbnQgY29uZmlndXJlZCBvbiBydW50aW1lIGNvbmZpZ3VyYXRpb247XG4gKiBAcGFyYW0gIHtvYmplY3R9IGNvbmZpZ3VyYXRpb24gb2JqZWN0IHdpdGggYWxsIGNvbmZpZ3VyYXRpb25cbiAqIEBwYXJhbSAge3N0cmluZ30gY29tcG9uZW50ICAgICBzdHJpbmcgd2l0aCB0aGUgY29tcG9uZW50IHRvIGdldCB0aGUgY29uZmlndXJhdGlvbiwgbGlrZSwgcnVudGltZVVSTFMsIGNhdGFsb2d1ZVVSTHMsIG1zZ05vZGVVUkwsIGRvbWFpblJlZ2lzdHJ5VVJMO1xuICogQHBhcmFtICB7c3RyaW5nfSByZXNvdXJjZSAgICAgIHR5cGUgb2YgcmVzb3VyY2UgdG8gZ2V0LCBsaWtlLCBjYXRhbG9ndWUsIHJ1bnRpbWVVQSwgcHJvdG9jb2xzdHViLCBpZHBQcm94eVxuICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgICAgIHJldHVybiBhbiBvYmplY3Qgd2l0aCBhbGwgY29uZmlndXJhdGlvbnM7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb25maWd1cmF0aW9uUmVzb3VyY2VzKGNvbmZpZ3VyYXRpb24sIGNvbXBvbmVudCwgcmVzb3VyY2UpIHtcbiAgbGV0IG9iamVjdFJlc291cmNlID0gY29uZmlndXJhdGlvbltjb21wb25lbnRdO1xuICBsZXQgcmVzb3VyY2VUeXBlID0gb2JqZWN0UmVzb3VyY2VbcmVzb3VyY2VdO1xuXG4gIHJldHVybiByZXNvdXJjZVR5cGU7XG59XG5cbi8qKlxuICogQnVpbGQgYSBmdWxsIHVybCB3aXRoIHRoZSBydW50aW1lIGNvbmZpZ3VyYXRpb247XG4gKiBAcGFyYW0gIHtvYmplY3R9IGNvbmZpZ3VyYXRpb24gb2JqZWN0IHdpdGggYWxsIGNvbmZpZ3VyYXRpb25cbiAqIEBwYXJhbSAge3N0cmluZ30gY29tcG9uZW50ICAgICBzdHJpbmcgd2l0aCB0aGUgY29tcG9uZW50IHRvIGdldCB0aGUgY29uZmlndXJhdGlvbiwgbGlrZSwgcnVudGltZVVSTFMsIGNhdGFsb2d1ZVVSTHMsIG1zZ05vZGVVUkwsIGRvbWFpblJlZ2lzdHJ5VVJMO1xuICogQHBhcmFtICB7c3RyaW5nfSByZXNvdXJjZSAgICAgIHR5cGUgb2YgcmVzb3VyY2UgdG8gZ2V0LCBsaWtlLCBjYXRhbG9ndWUsIHJ1bnRpbWVVQSwgcHJvdG9jb2xzdHViLCBpZHBQcm94eVxuICogQHBhcmFtICB7c3RyaW5nfSB0eXBlICAgICAgICAgIHJlc291cmNlIHRvIGdldCwgbGlrZSBhIGh5cGVydHkgbmFtZSBvciBwcm90b2NvbHN0dWIgbmFtZTtcbiAqIEBwYXJhbSAge2Jvb2xlYW59IHVzZUZhbGxiYWNrICBpZiB0cnVlIHRoZSBmdW5jdGlvbiB3aWxsIGNoZWNrIGlmIGhhdmUgYSBmYWxsYmFjayB1cmw7XG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgICAgICAgICAgcGFydGlhbCB1cmwgdG8gY29udGFjdCB0aGUgcmVzb3VyY2U7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFVSTChjb25maWd1cmF0aW9uLCBjb21wb25lbnQsIHR5cGUsIHJlc291cmNlLCB1c2VGYWxsYmFjayA9IGZhbHNlKSB7XG4gIGxldCBvYmplY3RSZXNvdXJjZSA9IGNvbmZpZ3VyYXRpb25bY29tcG9uZW50XTtcbiAgbGV0IHVybDtcblxuICBpZiAoIW9iamVjdFJlc291cmNlLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG4gICAgdGhyb3cgRXJyb3IoJ1RoZSBjb25maWd1cmF0aW9uICcgKyBKU09OLnN0cmluZ2lmeShvYmplY3RSZXNvdXJjZSwgJycsIDIpICsgJyBkb25cXCd0IGhhdmUgdGhlICcgKyB0eXBlICsgJyByZXNvdXJjZSB5b3UgYXJlIGxvb2tpbmcgZm9yJyk7XG4gIH1cblxuICBsZXQgcmVzb3VyY2VUeXBlID0gb2JqZWN0UmVzb3VyY2VbdHlwZV07XG5cblxuICBpZiAodHlwZSkge1xuICAgIGxldCBleHQgPSB0eXBlID09PSAnaWRwLXByb3h5JyA/ICcuaWRwLmpzJyA6ICcucHMuanMnO1xuICAgIHVybCA9IHJlc291cmNlVHlwZS5wcmVmaXggKyBjb25maWd1cmF0aW9uLmRvbWFpbiArIHJlc291cmNlVHlwZS5zdWZmaXggKyByZXNvdXJjZTtcbiAgICBpZiAocmVzb3VyY2VUeXBlLmhhc093blByb3BlcnR5KCdmYWxsYmFjaycpICYmIHVzZUZhbGxiYWNrKSB7XG4gICAgICBpZiAocmVzb3VyY2VUeXBlLmZhbGxiYWNrLmluZGV4T2YoJyVkb21haW4lJykpIHtcbiAgICAgICAgdXJsID0gcmVzb3VyY2VUeXBlLmZhbGxiYWNrLnJlcGxhY2UoLyglZG9tYWluJSkvZywgY29uZmlndXJhdGlvbi5kb21haW4pICsgcmVzb3VyY2UrZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsID0gcmVzb3VyY2VUeXBlLmZhbGxiYWNrICsgcmVzb3VyY2U7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHVybCA9IHJlc291cmNlVHlwZS5wcmVmaXggKyBjb25maWd1cmF0aW9uLmRvbWFpbiArIHJlc291cmNlVHlwZS5zdWZmaXg7XG4gIH1cblxuICAvLyBjb25zb2xlLmxvZyh1cmwpO1xuXG4gIHJldHVybiB1cmw7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBHbG9iYWwgVW5pcXVlIElEXG4gKlxuICogQHJldHVybnMgU3RyaW5nO1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVHVUlEKCkge1xuXG4gIGZ1bmN0aW9uIHM0KCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKCgxICsgTWF0aC5yYW5kb20oKSkgKiAweDEwMDAwKVxuICAgICAgLnRvU3RyaW5nKDE2KVxuICAgICAgLnN1YnN0cmluZygxKTtcbiAgfVxuXG4gIHJldHVybiBzNCgpICsgczQoKSArICctJyArIHM0KCkgKyAnLScgKyBzNCgpICsgJy0nICsgczQoKSArICctJyArIHM0KCkgKyBzNCgpICsgczQoKTtcblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXNlcklkZW50aXR5RG9tYWluKHVybCkge1xuICBsZXQgZGl2aWRlZFVSTCA9IGRpdmlkZVVSTCh1cmwpO1xuICBsZXQgc3BsaXRlZERvbWFpbiA9IGRpdmlkZWRVUkwuZG9tYWluLnNwbGl0KCcuJyk7XG4gIGxldCBzcGxpdGVkTGVuZ3RoID0gc3BsaXRlZERvbWFpbi5sZW5ndGg7XG4gIGlmIChzcGxpdGVkTGVuZ3RoID09IDEpIHtcbiAgICByZXR1cm4gc3BsaXRlZERvbWFpbltzcGxpdGVkTGVuZ3RoIC0gMV07XG4gIH1cbiAgbGV0IGRvbWFpbiA9IHNwbGl0ZWREb21haW5bc3BsaXRlZExlbmd0aCAtIDJdICsgJy4nICsgc3BsaXRlZERvbWFpbltzcGxpdGVkTGVuZ3RoIC0gMV07XG4gIHJldHVybiBkb21haW47XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgVVJMIGlzIGZyb20gYSBiYWNrZW5kIHNlcnZpY2VcbiAqIEBwYXJhbSAge3N0cmluZ30gdXJsICAgICBVUkwgdG8gYmUgcHJvY2Vzc2VkXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0JhY2tlbmRTZXJ2aWNlVVJMKHVybCkge1xuICBsZXQgZGl2aWRlZFVSTCA9IGRpdmlkZVVSTCh1cmwpO1xuICBsZXQgc3BsaXRlZERvbWFpbiA9IGRpdmlkZWRVUkwuZG9tYWluLnNwbGl0KCcuJyk7XG4gIGxldCBiYWNrZW5kU2NoZW1lcyA9IFsnZG9tYWluJywgJ2dsb2JhbCcsICdkb21haW4taWRwJ107IC8vIHNob3VsZCBiZSBkZWZpbmVkIGluIHRoZSBydW50aW1lIGNvbmZpZ3VyYXRpb25cbiAgbGV0IGJhY2tlbmRTdWJEb21haW5zID0gWydyZWdpc3RyeScsICdtc2ctbm9kZSddOyAvLyBzaG91bGQgYmUgZGVmaW5lZCBpbiB0aGUgcnVudGltZSBjb25maWd1cmF0aW9uXG4gIGxldCBzdWJEb21haW47XG5cbiAgaWYgKHNwbGl0ZWREb21haW4ubGVuZ3RoID4gMSkge1xuICAgIHN1YkRvbWFpbiA9IHNwbGl0ZWREb21haW4uZmlsdGVyKGl0ZW0gPT4gYmFja2VuZFN1YkRvbWFpbnMuaW5kZXhPZihpdGVtKSAhPT0gLTEpWzBdO1xuICB9XG5cbiAgaWYgKHN1YkRvbWFpbiAmJiBiYWNrZW5kU3ViRG9tYWlucy5pbmRleE9mKHN1YkRvbWFpbikgIT09IC0xKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoZGl2aWRlZFVSTC50eXBlKSB7XG4gICAgcmV0dXJuIChiYWNrZW5kU2NoZW1lcy5pbmRleE9mKGRpdmlkZWRVUkwudHlwZSkgIT09IC0xKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpdmlkZUVtYWlsKGVtYWlsKSB7XG4gIGxldCBpbmRleE9mQXQgPSBlbWFpbC5pbmRleE9mKCdAJyk7XG5cbiAgbGV0IHJlc3VsdCA9IHtcbiAgICB1c2VybmFtZTogZW1haWwuc3Vic3RyaW5nKDAsIGluZGV4T2ZBdCksXG4gICAgZG9tYWluOiBlbWFpbC5zdWJzdHJpbmcoaW5kZXhPZkF0ICsgMSwgZW1haWwubGVuZ3RoKVxuICB9O1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbihvYmosIGtleVBhdGgsIHZhbHVlKSB7XG5cbiAgaWYgKCFvYmopIG9iaiA9IHt9O1xuICBpZiAodHlwZW9mKGtleVBhdGgpID09PSAnc3RyaW5nJykga2V5UGF0aCA9IHBhcnNlQXR0cmlidXRlcyhrZXlQYXRoKTtcblxuICBsZXQgbGFzdEtleUluZGV4ID0ga2V5UGF0aC5sZW5ndGggLSAxO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdEtleUluZGV4OyArK2kpIHtcbiAgICBsZXQga2V5ID0ga2V5UGF0aFtpXTtcbiAgICBpZiAoIShrZXkgaW4gb2JqKSkge1xuICAgICAgb2JqW2tleV0gPSB7fTtcbiAgICB9XG5cbiAgICBvYmogPSBvYmpba2V5XTtcblxuICB9XG5cbiAgb2JqW2tleVBhdGhbbGFzdEtleUluZGV4XV0gPSB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0T2JqZWN0VVJMKGRhdGFPYmplY3RVUkwpIHtcbiAgY29uc29sZS5pbmZvKCdbdXRpbHMgLSBzcGxpdE9iamVjdFVSTF06ICcsIGRhdGFPYmplY3RVUkwpO1xuXG4gIGxldCBzcGxpdGVkVVJMID0gZGF0YU9iamVjdFVSTC5zcGxpdCgnLycpO1xuICBsZXQgdXJsID0gc3BsaXRlZFVSTFswXSArICcvLycgKyBzcGxpdGVkVVJMWzJdICsgJy8nICsgc3BsaXRlZFVSTFszXTtcbiAgbGV0IHJlc291cmNlID0gc3BsaXRlZFVSTFs1XTtcblxuICBsZXQgcmVzdWx0ID0ge1xuICAgIHVybDogdXJsLFxuICAgIHJlc291cmNlOiByZXNvdXJjZVxuICB9O1xuXG4gIGNvbnNvbGUuaW5mbygnW3V0aWxzIC0gc3BsaXRPYmplY3RVUkxdOiAnLCByZXN1bHQpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0F0dHJpYnV0ZShwYXRoKSB7XG5cbiAgbGV0IHJlZ2V4ID0gLygoKFthLXpBLVpdKyk6XFwvXFwvKFswLTlhLXpBLVpdWy1cXHddKlswLTlhLXpBLVpdXFwuKStbYS16QS1aXXsyLDl9KVxcL1thLXpBLVowLTkuXStAW2EtekEtWjAtOV0rKC0pP1thLXpBLVowLTldKyhcXC4pP1thLXpBLVowLTldezIsMTB9P1xcLlthLXpBLVpdezIsMTB9KSguKyg/PS5pZGVudGl0eSkpPy9nbTtcblxuICBsZXQgbGlzdCA9IFtdO1xuICBsZXQgZmluYWwgPSBbXTtcbiAgbGV0IHRlc3QgPSBwYXRoLm1hdGNoKHJlZ2V4KTtcblxuICBpZiAodGVzdCA9PSBudWxsKSB7XG4gICAgZmluYWwgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IG07XG4gICAgd2hpbGUgKChtID0gcmVnZXguZXhlYyhwYXRoKSkgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIGF2b2lkIGluZmluaXRlIGxvb3BzIHdpdGggemVyby13aWR0aCBtYXRjaGVzXG4gICAgICBpZiAobS5pbmRleCA9PT0gcmVnZXgubGFzdEluZGV4KSB7XG4gICAgICAgIHJlZ2V4Lmxhc3RJbmRleCsrO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgcmVzdWx0IGNhbiBiZSBhY2Nlc3NlZCB0aHJvdWdoIHRoZSBgbWAtdmFyaWFibGUuXG4gICAgICBtLmZvckVhY2goKG1hdGNoLCBncm91cEluZGV4KSA9PiB7XG4gICAgICAgIGlmIChncm91cEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgbGlzdC5wdXNoKG1hdGNoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCByZXN1bHQ7XG4gICAgbGlzdC5mb3JFYWNoKCh1cmwpID0+IHtcblxuICAgICAgcmVzdWx0ID0gcGF0aC5yZXBsYWNlKHVybCwgJyotKicpO1xuICAgICAgZmluYWwgPSByZXN1bHQuc3BsaXQoJy4nKS5tYXAoKGl0ZW0pID0+IHtcblxuICAgICAgICBpZiAoaXRlbSA9PT0gJyotKicpIHsgcmV0dXJuIHVybDsgfVxuXG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBjb25zb2xlLmxvZygnW1J1bnRpbWVDb3JlLlV0aWxzLmNoZWNrQXR0cmlidXRlXScsIGZpbmFsKTtcbiAgcmV0dXJuIGZpbmFsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGVzKHBhdGgpIHtcbiAgbGV0IHJlZ2V4ID0gLyhbMC05YS16QS1aXVstXFx3XSopOlxcL1xcLy9nO1xuXG4gIGxldCBzdHJpbmczID0gJ2lkZW50aXR5JztcblxuICBpZiAoIXBhdGguaW5jbHVkZXMoJzovLycpKSB7XG4gICAgcmV0dXJuIChwYXRoLnNwbGl0KCcuJykpO1xuICB9IGVsc2Uge1xuICAgIGxldCBzdHJpbmcxID0gcGF0aC5zcGxpdChyZWdleClbMF07XG5cbiAgICBsZXQgYXJyYXkxID0gc3RyaW5nMS5zcGxpdCgnLicpO1xuXG4gICAgbGV0IHN0cmluZzIgPSBwYXRoLnJlcGxhY2Uoc3RyaW5nMSwgJycpO1xuXG4gICAgaWYgKHBhdGguaW5jbHVkZXMoc3RyaW5nMykpIHtcblxuICAgICAgbGV0IGFycmF5MiA9IHN0cmluZzIuc3BsaXQoc3RyaW5nMyArICcuJyk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCdhcnJheTIgJyArIGFycmF5Mik7XG5cbiAgICAgIHN0cmluZzIgPSBhcnJheTJbMF0uc2xpY2UoJy4nLCAtMSk7XG5cbiAgICAgIGFycmF5MiA9IGFycmF5MlsxXS5zcGxpdCgnLicpO1xuXG4gICAgICBhcnJheTEucHVzaChzdHJpbmcyLCBzdHJpbmczKTtcblxuICAgICAgYXJyYXkxID0gYXJyYXkxLmNvbmNhdChhcnJheTIpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGFycmF5MS5wdXNoKHN0cmluZzIpO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIChhcnJheTEuZmlsdGVyKEJvb2xlYW4pKTtcblxuICB9XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XG4gIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG5cbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqKSA9PT0gSlNPTi5zdHJpbmdpZnkoe30pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hhdGtleXNUb1N0cmluZ0Nsb25lcihzZXNzaW9uS2V5cykge1xuICBsZXQgZGF0YU9iamVjdFNlc3Npb25LZXlzQ2xvbmUgPSB7fTtcbiAgbGV0IGZpZWxkcyA9IE9iamVjdC5rZXlzKHNlc3Npb25LZXlzKTtcbiAgaWYgKGZpZWxkcykge1xuICAgIHRyeSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8ICBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgICBkYXRhT2JqZWN0U2Vzc2lvbktleXNDbG9uZVtmaWVsZF0gPSB7fTtcbiAgICAgICAgZGF0YU9iamVjdFNlc3Npb25LZXlzQ2xvbmVbZmllbGRdLnNlc3Npb25LZXkgPSBzZXNzaW9uS2V5c1tmaWVsZF0uc2Vzc2lvbktleS50b1N0cmluZygpO1xuICAgICAgICBkYXRhT2JqZWN0U2Vzc2lvbktleXNDbG9uZVtmaWVsZF0uaXNUb0VuY3J5cHQgPSBzZXNzaW9uS2V5c1tmaWVsZF0uaXNUb0VuY3J5cHQ7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdfY2hhdGtleXNUb1N0cmluZ0Nsb25lcjplcnInLCBlcnIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YU9iamVjdFNlc3Npb25LZXlzQ2xvbmU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGF0a2V5c1RvQXJyYXlDbG9uZXIoc2Vzc2lvbktleXMpIHtcbiAgbGV0IGRhdGFPYmplY3RTZXNzaW9uS2V5c0Nsb25lID0ge307XG4gIGxldCBmaWVsZHMgPSBPYmplY3Qua2V5cyhzZXNzaW9uS2V5cyk7XG4gIGlmIChmaWVsZHMpIHtcbiAgICB0cnkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBmaWVsZCA9IGZpZWxkc1tpXTtcbiAgICAgICAgZGF0YU9iamVjdFNlc3Npb25LZXlzQ2xvbmVbZmllbGRdID0ge307XG4gICAgICAgIGxldCBhcnJheVZhbHVlcyA9IEpTT04ucGFyc2UoJ1snICsgc2Vzc2lvbktleXNbZmllbGRdLnNlc3Npb25LZXkgKyAnXScpO1xuICAgICAgICBkYXRhT2JqZWN0U2Vzc2lvbktleXNDbG9uZVtmaWVsZF0uc2Vzc2lvbktleSA9IG5ldyBVaW50OEFycmF5KGFycmF5VmFsdWVzKTtcbiAgICAgICAgZGF0YU9iamVjdFNlc3Npb25LZXlzQ2xvbmVbZmllbGRdLmlzVG9FbmNyeXB0ID0gc2Vzc2lvbktleXNbZmllbGRdLmlzVG9FbmNyeXB0O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignX2NoYXRrZXlzVG9BcnJheUNsb25lcjplcnInLCBlcnIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YU9iamVjdFNlc3Npb25LZXlzQ2xvbmU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU1lc3NhZ2VVUkwoVVJMKSB7XG4gIGxldCBzcGxpdGVkVG9VUkwgPSBVUkwuc3BsaXQoJy8nKTtcbiAgaWYgKHNwbGl0ZWRUb1VSTC5sZW5ndGggPD0gNikge1xuICAgIHJldHVybiBzcGxpdGVkVG9VUkxbMF0gKyAnLy8nICsgc3BsaXRlZFRvVVJMWzJdICsgJy8nICsgc3BsaXRlZFRvVVJMWzNdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzcGxpdGVkVG9VUkxbMF0gKyAnLy8nICsgc3BsaXRlZFRvVVJMWzJdICsgJy8nICsgc3BsaXRlZFRvVVJMWzNdICsgJy8nICsgc3BsaXRlZFRvVVJMWzRdO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhdmFpbGFibGVTcGFjZSh1c2FnZSwgcXVvdGEpIHtcbiAgY29uc3QgYXZhaWxhYmxlID0gKHVzYWdlIC8gcXVvdGEpLnRvRml4ZWQoMik7XG4gIHJldHVybiB7XG4gICAgcXVvdGE6IHF1b3RhLFxuICAgIHVzYWdlOiB1c2FnZSxcbiAgICBwZXJjZW50OiBOdW1iZXIoYXZhaWxhYmxlKVxuICB9O1xufVxuXG4vKipcbiogRW5jb2RlcyBhIEpTIG9iamVjdCB0byBiYXNlIDY0IGVuY29kZVxuKiBAcGFyYW0gICB7T2JqZWN0fSAgICB2YWx1ZSAgICBieXRlQXJyYXkgdmFsdWVcbiogQHJldHVybiAge3N0cmluZ30gICBlbmNvZGVkIHZhbHVlXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZSh2YWx1ZSkge1xuICB0cnkge1xuICAgIGxldCBzdHJpbmdWYWx1ZSA9IHN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgcmV0dXJuIGJ0b2Eoc3RyaW5nVmFsdWUpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbVXRpbHMuZW5jb2RlOmVycl0gJyArIGVycik7XG4gICAgdGhyb3cgZXJyO1xuICB9XG59XG5cbi8qKlxuICAqIERlY29kZSBhIGJhc2U2NCBzdHJpbmcgdG8gb2JqZWN0XG4gICogQHBhcmFtICAge3N0cmluZ19iNjR9ICAgIHZhbHVlICAgIHZhbHVlIGVuY29kZWQgaW4gYmFzZSA2NFxuICAqIEByZXR1cm4gIHtPYmplY3R9IGRlY29kZWRWYWx1ZVxuICAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZSh2YWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKGF0b2IodmFsdWUpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5sb2coJ1tVdGlscy5kZWNvZGU6ZXJyXSAnICsgZXJyKTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbn1cblxuLyoqXG4qIERlY29kZSBhIGJhc2U2NCBzdHJpbmcgdG8gVWludDhBcnJheVxuKiBAcGFyYW0gICB7c3RyaW5nX2I2NH0gICAgdmFsdWUgICAgYnl0ZUFycmF5IHZhbHVlXG4qIEByZXR1cm4gIHtVaW50OEFycmF5fSAgIGVuY29kZWQgdmFsdWVcbiovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlVG9VaW50OEFycmF5KHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRlY29kZSh2YWx1ZSkpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbVXRpbHMuZGVjb2RlVG9VaW50OEFycmF5OmVycl0gJyArIGVycik7XG4gICAgdGhyb3cgZXJyO1xuICB9XG59XG5cbi8qKlxuKiBDb252ZXJ0cyBhIEpTIG9iamVjdCB0byBzdHJpbmdcbiogTk9URTogU3BlY2lhbCBjb252ZXJzaW9uIGZvciBVaW50OEFycmF5c1xuKiBAcGFyYW0gICB7T2JqZWN0fSAgICB2YWx1ZSAgICBieXRlQXJyYXkgdmFsdWVcbiogQHJldHVybiAge1VpbnQ4QXJyYXl9ICAgZW5jb2RlZCB2YWx1ZVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBsZXQgc3RyaW5nVmFsdWU7XG4gICAgaWYgKHZhbHVlLmNvbnN0cnVjdG9yID09PSBVaW50OEFycmF5KSB7XG4gICAgICBzdHJpbmdWYWx1ZSA9ICdbJyArIHZhbHVlLnRvU3RyaW5nKCkgKyAnXSc7IC8vIHRoZSBbXSBpcyBmb3IgSlNPTi5wYXJzZSBjb21wYXRpYmlsaXR5XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmluZ1ZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nVmFsdWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tVdGlscy5zdHJpbmdpZnk6ZXJyXSAnICsgZXJyKTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbn1cblxuLyoqXG4qIENvbnZlcnRzIGEgc3RyaW5naWZpZWQgb2JqZWN0IHRvIG9iamVjdFxuKiBAcGFyYW0gICB7U3RyaW5nfSAgICB2YWx1ZSAgICBieXRlQXJyYXkgdmFsdWVcbiogQHJldHVybiAge09iamVjdH0gICBlbmNvZGVkIHZhbHVlXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbVXRpbHMucGFyc2U6ZXJyXScgKyBlcnIpO1xuICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICBjb25zb2xlLmVycm9yKCdUaGF0IHRoYXQgY2F1c2UgdGhlIGVycm9yOicsIHZhbHVlKTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbn1cblxuLyoqXG4qIENvbnZlcnRzIGEgc3RyaW5naWZpZWQgb2JqZWN0IHRvIG9iamVjdFxuKiBAcGFyYW0gICB7U3RyaW5nfSAgICB2YWx1ZSAgICBieXRlQXJyYXkgdmFsdWVcbiogQHJldHVybiAge1VpbnQ4QXJyYXl9ICAgZW5jb2RlZCB2YWx1ZVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVRvVWludDhBcnJheSh2YWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShwYXJzZSh2YWx1ZSkpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbVXRpbHMucGFyc2VUb1VpbnQ4QXJyYXk6ZXJyXScgKyBlcnIpO1xuICAgIHRocm93IGVycjtcbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCQTs7Ozs7QUFLQTs7Ozs7Ozs7QUFRQTs7Ozs7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOzs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUVBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7Ozs7Ozs7O0FBU0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7Ozs7QUFLQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUVBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n")},1:function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    "use strict";\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}(this, function () {\n    "use strict";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = "undefined";\n\n    var logMethods = [\n        "trace",\n        "debug",\n        "info",\n        "warn",\n        "error"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === \'function\') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === \'debug\') {\n            methodName = \'log\';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, \'log\');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn\'t present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      var storageKey = "loglevel";\n      if (name) {\n        storageKey += ":" + name;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || \'silent\').toUpperCase();\n\n          if (typeof window === undefinedType) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + "=" + levelName + ";";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + "=");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,\n          "ERROR": 4, "SILENT": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return "No console available for logging";\n              }\n          } else {\n              throw "log.setLevel() called with invalid level: " + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== "string" || name === "") {\n          throw new TypeError("You must supply a name when creating a logger.");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    return defaultLogger;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL1tuYW1lXS8uL25vZGVfbW9kdWxlcy9sb2dsZXZlbC9saWIvbG9nbGV2ZWwuanM/NWM3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuKiBsb2dsZXZlbCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTMgVGltIFBlcnJ5XG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiovXG4oZnVuY3Rpb24gKHJvb3QsIGRlZmluaXRpb24pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShkZWZpbml0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QubG9nID0gZGVmaW5pdGlvbigpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gU2xpZ2h0bHkgZHViaW91cyB0cmlja3MgdG8gY3V0IGRvd24gbWluaW1pemVkIGZpbGUgc2l6ZVxuICAgIHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcbiAgICB2YXIgdW5kZWZpbmVkVHlwZSA9IFwidW5kZWZpbmVkXCI7XG5cbiAgICB2YXIgbG9nTWV0aG9kcyA9IFtcbiAgICAgICAgXCJ0cmFjZVwiLFxuICAgICAgICBcImRlYnVnXCIsXG4gICAgICAgIFwiaW5mb1wiLFxuICAgICAgICBcIndhcm5cIixcbiAgICAgICAgXCJlcnJvclwiXG4gICAgXTtcblxuICAgIC8vIENyb3NzLWJyb3dzZXIgYmluZCBlcXVpdmFsZW50IHRoYXQgd29ya3MgYXQgbGVhc3QgYmFjayB0byBJRTZcbiAgICBmdW5jdGlvbiBiaW5kTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgbWV0aG9kID0gb2JqW21ldGhvZE5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZC5iaW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmJpbmQob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwobWV0aG9kLCBvYmopO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIE1pc3NpbmcgYmluZCBzaGltIG9yIElFOCArIE1vZGVybml6ciwgZmFsbGJhY2sgdG8gd3JhcHBpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkobWV0aG9kLCBbb2JqLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgdGhlIGJlc3QgbG9nZ2luZyBtZXRob2QgcG9zc2libGUgZm9yIHRoaXMgZW52XG4gICAgLy8gV2hlcmV2ZXIgcG9zc2libGUgd2Ugd2FudCB0byBiaW5kLCBub3Qgd3JhcCwgdG8gcHJlc2VydmUgc3RhY2sgdHJhY2VzXG4gICAgZnVuY3Rpb24gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmIChtZXRob2ROYW1lID09PSAnZGVidWcnKSB7XG4gICAgICAgICAgICBtZXRob2ROYW1lID0gJ2xvZyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gbWV0aG9kIHBvc3NpYmxlLCBmb3Igbm93IC0gZml4ZWQgbGF0ZXIgYnkgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlc1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZS5sb2cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgJ2xvZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGVzZSBwcml2YXRlIGZ1bmN0aW9ucyBhbHdheXMgbmVlZCBgdGhpc2AgdG8gYmUgc2V0IHByb3Blcmx5XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGxvZ01ldGhvZHNbaV07XG4gICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdID0gKGkgPCBsZXZlbCkgP1xuICAgICAgICAgICAgICAgIG5vb3AgOlxuICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZpbmUgbG9nLmxvZyBhcyBhbiBhbGlhcyBmb3IgbG9nLmRlYnVnXG4gICAgICAgIHRoaXMubG9nID0gdGhpcy5kZWJ1ZztcbiAgICB9XG5cbiAgICAvLyBJbiBvbGQgSUUgdmVyc2lvbnMsIHRoZSBjb25zb2xlIGlzbid0IHByZXNlbnQgdW50aWwgeW91IGZpcnN0IG9wZW4gaXQuXG4gICAgLy8gV2UgYnVpbGQgcmVhbE1ldGhvZCgpIHJlcGxhY2VtZW50cyBoZXJlIHRoYXQgcmVnZW5lcmF0ZSBsb2dnaW5nIG1ldGhvZHNcbiAgICBmdW5jdGlvbiBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzKG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbCh0aGlzLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHVzZSBjbG9zZWx5IGJvdW5kIHJlYWwgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZSwgYW5kXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdhaXQgZm9yIGEgY29uc29sZSB0byBhcHBlYXIsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICByZXR1cm4gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB8fFxuICAgICAgICAgICAgICAgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvZ2dlcihuYW1lLCBkZWZhdWx0TGV2ZWwsIGZhY3RvcnkpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjdXJyZW50TGV2ZWw7XG4gICAgICB2YXIgc3RvcmFnZUtleSA9IFwibG9nbGV2ZWxcIjtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHN0b3JhZ2VLZXkgKz0gXCI6XCIgKyBuYW1lO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsTnVtKSB7XG4gICAgICAgICAgdmFyIGxldmVsTmFtZSA9IChsb2dNZXRob2RzW2xldmVsTnVtXSB8fCAnc2lsZW50JykudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlKSByZXR1cm47XG5cbiAgICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV0gPSBsZXZlbE5hbWU7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID1cbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIiArIGxldmVsTmFtZSArIFwiO1wiO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0UGVyc2lzdGVkTGV2ZWwoKSB7XG4gICAgICAgICAgdmFyIHN0b3JlZExldmVsO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUpIHJldHVybjtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XTtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBjb29raWVzIGlmIGxvY2FsIHN0b3JhZ2UgZ2l2ZXMgdXMgbm90aGluZ1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVkTGV2ZWwgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb29raWUgPSB3aW5kb3cuZG9jdW1lbnQuY29va2llO1xuICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY29va2llLmluZGV4T2YoXG4gICAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIpO1xuICAgICAgICAgICAgICAgICAgaWYgKGxvY2F0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZExldmVsID0gL14oW147XSspLy5leGVjKGNvb2tpZS5zbGljZShsb2NhdGlvbikpWzFdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhlIHN0b3JlZCBsZXZlbCBpcyBub3QgdmFsaWQsIHRyZWF0IGl0IGFzIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cbiAgICAgICAgICBpZiAoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN0b3JlZExldmVsO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgICpcbiAgICAgICAqIFB1YmxpYyBsb2dnZXIgQVBJIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbCBmb3IgZGV0YWlsc1xuICAgICAgICpcbiAgICAgICAqL1xuXG4gICAgICBzZWxmLm5hbWUgPSBuYW1lO1xuXG4gICAgICBzZWxmLmxldmVscyA9IHsgXCJUUkFDRVwiOiAwLCBcIkRFQlVHXCI6IDEsIFwiSU5GT1wiOiAyLCBcIldBUk5cIjogMyxcbiAgICAgICAgICBcIkVSUk9SXCI6IDQsIFwiU0lMRU5UXCI6IDV9O1xuXG4gICAgICBzZWxmLm1ldGhvZEZhY3RvcnkgPSBmYWN0b3J5IHx8IGRlZmF1bHRNZXRob2RGYWN0b3J5O1xuXG4gICAgICBzZWxmLmdldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50TGV2ZWw7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsLCBwZXJzaXN0KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIiAmJiBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGxldmVsID0gc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwibnVtYmVyXCIgJiYgbGV2ZWwgPj0gMCAmJiBsZXZlbCA8PSBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgY3VycmVudExldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICAgIGlmIChwZXJzaXN0ICE9PSBmYWxzZSkgeyAgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZiwgbGV2ZWwsIG5hbWUpO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUgJiYgbGV2ZWwgPCBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBcIk5vIGNvbnNvbGUgYXZhaWxhYmxlIGZvciBsb2dnaW5nXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBcImxvZy5zZXRMZXZlbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgbGV2ZWw6IFwiICsgbGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXREZWZhdWx0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICBpZiAoIWdldFBlcnNpc3RlZExldmVsKCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5zZXRMZXZlbChsZXZlbCwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZW5hYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuVFJBQ0UsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5kaXNhYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuU0lMRU5ULCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEluaXRpYWxpemUgd2l0aCB0aGUgcmlnaHQgbGV2ZWxcbiAgICAgIHZhciBpbml0aWFsTGV2ZWwgPSBnZXRQZXJzaXN0ZWRMZXZlbCgpO1xuICAgICAgaWYgKGluaXRpYWxMZXZlbCA9PSBudWxsKSB7XG4gICAgICAgICAgaW5pdGlhbExldmVsID0gZGVmYXVsdExldmVsID09IG51bGwgPyBcIldBUk5cIiA6IGRlZmF1bHRMZXZlbDtcbiAgICAgIH1cbiAgICAgIHNlbGYuc2V0TGV2ZWwoaW5pdGlhbExldmVsLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKlxuICAgICAqIFRvcC1sZXZlbCBBUElcbiAgICAgKlxuICAgICAqL1xuXG4gICAgdmFyIGRlZmF1bHRMb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG5cbiAgICB2YXIgX2xvZ2dlcnNCeU5hbWUgPSB7fTtcbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlciA9IGZ1bmN0aW9uIGdldExvZ2dlcihuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIiB8fCBuYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV07XG4gICAgICAgIGlmICghbG9nZ2VyKSB7XG4gICAgICAgICAgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV0gPSBuZXcgTG9nZ2VyKFxuICAgICAgICAgICAgbmFtZSwgZGVmYXVsdExvZ2dlci5nZXRMZXZlbCgpLCBkZWZhdWx0TG9nZ2VyLm1ldGhvZEZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgfTtcblxuICAgIC8vIEdyYWIgdGhlIGN1cnJlbnQgZ2xvYmFsIGxvZyB2YXJpYWJsZSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICAgIHZhciBfbG9nID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpID8gd2luZG93LmxvZyA6IHVuZGVmaW5lZDtcbiAgICBkZWZhdWx0TG9nZ2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUgJiZcbiAgICAgICAgICAgICAgIHdpbmRvdy5sb2cgPT09IGRlZmF1bHRMb2dnZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG4gICAgfTtcblxuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VycyA9IGZ1bmN0aW9uIGdldExvZ2dlcnMoKSB7XG4gICAgICAgIHJldHVybiBfbG9nZ2Vyc0J5TmFtZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG59KSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQSxhQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n')},20:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n* Copyright 2016 PT Inovação e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the "License");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an "AS IS" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n\n/**\n* @author Ana Caldeira <ana.caldeira@tecnico.ulisboa.pt>\n* @classdesc Class to combine the authorization decisions that result from rules evaluation.\n*/\nvar AllowOverrides =\n/*#__PURE__*/\nfunction () {\n  function AllowOverrides() {\n    _classCallCheck(this, AllowOverrides);\n  }\n\n  _createClass(AllowOverrides, [{\n    key: "combine",\n\n    /**\n    * Given an array of individual authorization decisions, prioritizes a positive one.\n    * @param    {boolean[]}   decisions\n    * @returns  {boolean}\n    */\n    value: function combine(decisions) {\n      if (decisions.indexOf(true) !== -1) {\n        return true;\n      } else {\n        if (decisions.indexOf(false) !== -1) {\n          return false;\n        } else {\n          return \'Not Applicable\';\n        }\n      }\n    }\n  }]);\n\n  return AllowOverrides;\n}();\n\n/* harmony default export */ __webpack_exports__["a"] = (AllowOverrides);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvcG9saWN5L2NvbWJpbmluZ0FsZ29yaXRobXMvQWxsb3dPdmVycmlkZXMuanM/MGQxNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiogQ29weXJpZ2h0IDIwMTYgUFQgSW5vdmHDp8OjbyBlIFNpc3RlbWFzIFNBXG4qIENvcHlyaWdodCAyMDE2IElORVNDLUlEXG4qIENvcHlyaWdodCAyMDE2IFFVT0JJUyBORVRXT1JLUyBTTFxuKiBDb3B5cmlnaHQgMjAxNiBGUkFVTkhPRkVSLUdFU0VMTFNDSEFGVCBaVVIgRk9FUkRFUlVORyBERVIgQU5HRVdBTkRURU4gRk9SU0NIVU5HIEUuVlxuKiBDb3B5cmlnaHQgMjAxNiBPUkFOR0UgU0FcbiogQ29weXJpZ2h0IDIwMTYgRGV1dHNjaGUgVGVsZWtvbSBBR1xuKiBDb3B5cmlnaHQgMjAxNiBBcGl6ZWVcbiogQ29weXJpZ2h0IDIwMTYgVEVDSE5JU0NIRSBVTklWRVJTSVRBVCBCRVJMSU5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKiovXG5cbi8qKlxuKiBAYXV0aG9yIEFuYSBDYWxkZWlyYSA8YW5hLmNhbGRlaXJhQHRlY25pY28udWxpc2JvYS5wdD5cbiogQGNsYXNzZGVzYyBDbGFzcyB0byBjb21iaW5lIHRoZSBhdXRob3JpemF0aW9uIGRlY2lzaW9ucyB0aGF0IHJlc3VsdCBmcm9tIHJ1bGVzIGV2YWx1YXRpb24uXG4qL1xuY2xhc3MgQWxsb3dPdmVycmlkZXMge1xuXG4gIC8qKlxuICAqIEdpdmVuIGFuIGFycmF5IG9mIGluZGl2aWR1YWwgYXV0aG9yaXphdGlvbiBkZWNpc2lvbnMsIHByaW9yaXRpemVzIGEgcG9zaXRpdmUgb25lLlxuICAqIEBwYXJhbSAgICB7Ym9vbGVhbltdfSAgIGRlY2lzaW9uc1xuICAqIEByZXR1cm5zICB7Ym9vbGVhbn1cbiAgKi9cbiAgY29tYmluZShkZWNpc2lvbnMpIHtcbiAgICBpZiAoZGVjaXNpb25zLmluZGV4T2YodHJ1ZSkgIT09IC0xKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRlY2lzaW9ucy5pbmRleE9mKGZhbHNlKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdOb3QgQXBwbGljYWJsZSc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQWxsb3dPdmVycmlkZXM7XG4iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQTs7OztBQUlBOzs7Ozs7Ozs7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBSUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///20\n')},21:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n* Copyright 2016 PT Inovação e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the "License");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an "AS IS" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n\n/**\n* @author Ana Caldeira <ana.caldeira@tecnico.ulisboa.pt>\n* @classdesc Class to combine the authorization decisions that result from rules evaluation.\n*/\nvar BlockOverrides =\n/*#__PURE__*/\nfunction () {\n  function BlockOverrides() {\n    _classCallCheck(this, BlockOverrides);\n  }\n\n  _createClass(BlockOverrides, [{\n    key: "combine",\n\n    /**\n    * Given an array of individual authorisation decisions, prioritises a negative one.\n    * @param    {boolean[]}   decisions\n    * @returns  {boolean}\n    */\n    value: function combine(decisions) {\n      if (decisions.indexOf(false) !== -1) {\n        return false;\n      } else {\n        if (decisions.indexOf(true) !== -1) {\n          return true;\n        } else {\n          return \'Not Applicable\';\n        }\n      }\n    }\n  }]);\n\n  return BlockOverrides;\n}();\n\n/* harmony default export */ __webpack_exports__["a"] = (BlockOverrides);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvcG9saWN5L2NvbWJpbmluZ0FsZ29yaXRobXMvQmxvY2tPdmVycmlkZXMuanM/N2Q2NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiogQ29weXJpZ2h0IDIwMTYgUFQgSW5vdmHDp8OjbyBlIFNpc3RlbWFzIFNBXG4qIENvcHlyaWdodCAyMDE2IElORVNDLUlEXG4qIENvcHlyaWdodCAyMDE2IFFVT0JJUyBORVRXT1JLUyBTTFxuKiBDb3B5cmlnaHQgMjAxNiBGUkFVTkhPRkVSLUdFU0VMTFNDSEFGVCBaVVIgRk9FUkRFUlVORyBERVIgQU5HRVdBTkRURU4gRk9SU0NIVU5HIEUuVlxuKiBDb3B5cmlnaHQgMjAxNiBPUkFOR0UgU0FcbiogQ29weXJpZ2h0IDIwMTYgRGV1dHNjaGUgVGVsZWtvbSBBR1xuKiBDb3B5cmlnaHQgMjAxNiBBcGl6ZWVcbiogQ29weXJpZ2h0IDIwMTYgVEVDSE5JU0NIRSBVTklWRVJTSVRBVCBCRVJMSU5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKiovXG5cbi8qKlxuKiBAYXV0aG9yIEFuYSBDYWxkZWlyYSA8YW5hLmNhbGRlaXJhQHRlY25pY28udWxpc2JvYS5wdD5cbiogQGNsYXNzZGVzYyBDbGFzcyB0byBjb21iaW5lIHRoZSBhdXRob3JpemF0aW9uIGRlY2lzaW9ucyB0aGF0IHJlc3VsdCBmcm9tIHJ1bGVzIGV2YWx1YXRpb24uXG4qL1xuY2xhc3MgQmxvY2tPdmVycmlkZXMge1xuXG4gIC8qKlxuICAqIEdpdmVuIGFuIGFycmF5IG9mIGluZGl2aWR1YWwgYXV0aG9yaXNhdGlvbiBkZWNpc2lvbnMsIHByaW9yaXRpc2VzIGEgbmVnYXRpdmUgb25lLlxuICAqIEBwYXJhbSAgICB7Ym9vbGVhbltdfSAgIGRlY2lzaW9uc1xuICAqIEByZXR1cm5zICB7Ym9vbGVhbn1cbiAgKi9cbiAgY29tYmluZShkZWNpc2lvbnMpIHtcbiAgICBpZiAoZGVjaXNpb25zLmluZGV4T2YoZmFsc2UpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZGVjaXNpb25zLmluZGV4T2YodHJ1ZSkgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdOb3QgQXBwbGljYWJsZSc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmxvY2tPdmVycmlkZXM7XG4iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQTs7OztBQUlBOzs7Ozs7Ozs7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBSUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///21\n')},22:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n* Copyright 2016 PT Inovação e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the "License");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an "AS IS" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n\n/**\n* @author Ana Caldeira <ana.caldeira@tecnico.ulisboa.pt>\n* @classdesc Class to combine the authorization decisions that result from rules evaluation.\n*/\nvar FirstApplicable =\n/*#__PURE__*/\nfunction () {\n  function FirstApplicable() {\n    _classCallCheck(this, FirstApplicable);\n  }\n\n  _createClass(FirstApplicable, [{\n    key: "combine",\n\n    /**\n    * Given an array of individual authorisation decisions, returns the first one different from \'Not Applicable\', either positive or negative.\n    * @param    {boolean[]}     decisions\n    * @returns  {boolean}\n    */\n    value: function combine(decisions) {\n      for (var i in decisions) {\n        if (decisions[i] !== \'Not Applicable\') {\n          return decisions[i];\n        }\n      }\n\n      return \'Not Applicable\';\n    }\n  }]);\n\n  return FirstApplicable;\n}();\n\n/* harmony default export */ __webpack_exports__["a"] = (FirstApplicable);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvcG9saWN5L2NvbWJpbmluZ0FsZ29yaXRobXMvRmlyc3RBcHBsaWNhYmxlLmpzP2ExMzIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4qIENvcHlyaWdodCAyMDE2IFBUIElub3Zhw6fDo28gZSBTaXN0ZW1hcyBTQVxuKiBDb3B5cmlnaHQgMjAxNiBJTkVTQy1JRFxuKiBDb3B5cmlnaHQgMjAxNiBRVU9CSVMgTkVUV09SS1MgU0xcbiogQ29weXJpZ2h0IDIwMTYgRlJBVU5IT0ZFUi1HRVNFTExTQ0hBRlQgWlVSIEZPRVJERVJVTkcgREVSIEFOR0VXQU5EVEVOIEZPUlNDSFVORyBFLlZcbiogQ29weXJpZ2h0IDIwMTYgT1JBTkdFIFNBXG4qIENvcHlyaWdodCAyMDE2IERldXRzY2hlIFRlbGVrb20gQUdcbiogQ29weXJpZ2h0IDIwMTYgQXBpemVlXG4qIENvcHlyaWdodCAyMDE2IFRFQ0hOSVNDSEUgVU5JVkVSU0lUQVQgQkVSTElOXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbioqL1xuXG4vKipcbiogQGF1dGhvciBBbmEgQ2FsZGVpcmEgPGFuYS5jYWxkZWlyYUB0ZWNuaWNvLnVsaXNib2EucHQ+XG4qIEBjbGFzc2Rlc2MgQ2xhc3MgdG8gY29tYmluZSB0aGUgYXV0aG9yaXphdGlvbiBkZWNpc2lvbnMgdGhhdCByZXN1bHQgZnJvbSBydWxlcyBldmFsdWF0aW9uLlxuKi9cbmNsYXNzIEZpcnN0QXBwbGljYWJsZSB7XG5cbiAgLyoqXG4gICogR2l2ZW4gYW4gYXJyYXkgb2YgaW5kaXZpZHVhbCBhdXRob3Jpc2F0aW9uIGRlY2lzaW9ucywgcmV0dXJucyB0aGUgZmlyc3Qgb25lIGRpZmZlcmVudCBmcm9tICdOb3QgQXBwbGljYWJsZScsIGVpdGhlciBwb3NpdGl2ZSBvciBuZWdhdGl2ZS5cbiAgKiBAcGFyYW0gICAge2Jvb2xlYW5bXX0gICAgIGRlY2lzaW9uc1xuICAqIEByZXR1cm5zICB7Ym9vbGVhbn1cbiAgKi9cbiAgY29tYmluZShkZWNpc2lvbnMpIHtcbiAgICBmb3IgKGxldCBpIGluIGRlY2lzaW9ucykge1xuICAgICAgaWYgKGRlY2lzaW9uc1tpXSAhPT0gJ05vdCBBcHBsaWNhYmxlJykge1xuICAgICAgICByZXR1cm4gZGVjaXNpb25zW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJ05vdCBBcHBsaWNhYmxlJztcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEZpcnN0QXBwbGljYWJsZTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBOzs7O0FBSUE7Ozs7Ozs7Ozs7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7OztBQUlBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///22\n')},35:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/loglevel/lib/loglevel.js\nvar loglevel = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./src/policy/ActionsService.js\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar ActionsService =\n/*#__PURE__*/\nfunction () {\n  function ActionsService(context) {\n    _classCallCheck(this, ActionsService);\n\n    this.context = context;\n  }\n\n  _createClass(ActionsService, [{\n    key: \"enforcePolicies\",\n    value: function enforcePolicies(message, isIncomingMessage) {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        var policies = _this.context.getPolicies(message, isIncomingMessage);\n\n        if (policies !== undefined) {\n          if (policies.serviceProviderPolicy !== undefined) {\n            policies.serviceProviderPolicy.enforceActions(_this.context, message).then(function (messages) {\n              resolve(messages);\n            }, function (error) {\n              reject(error);\n            });\n          } else {\n            if (policies.userPolicy !== undefined) {\n              policies.userPolicy.enforceActions(_this.context, message).then(function (messages) {\n                resolve(messages);\n              }, function (error) {\n                reject(error);\n              });\n            } else {\n              resolve([message]);\n            }\n          }\n        } else {\n          resolve([message]);\n        }\n      });\n    }\n  }, {\n    key: \"forwardToID\",\n    value: function forwardToID(message, email) {\n      var _this = this;\n\n      if (!_this.context.runtimeRegistry) throw new Error('forward message to given ID is unsupported in this environment');\n      return new Promise(function (resolve, reject) {\n        if (_this.context.runtimeRegistry.hypertiesList[0].hypertyURL === message.to) {\n          var splitTo = message.to.split('://');\n\n          if (splitTo[0] !== 'runtime') {\n            _this.context.runtimeRegistry.discoverHypertyPerUser(email).then(function (result) {\n              message.to = result.hypertyURL;\n              message.body.via = undefined;\n              resolve(message);\n\n              _this.context.runtimeRegistry._messageBus.postMessage(message);\n            }, function (error) {\n              reject(error);\n            });\n          } else {\n            resolve(message);\n          }\n        } else {\n          resolve(message);\n        }\n      });\n    }\n  }, {\n    key: \"forwardToHyperty\",\n    value: function forwardToHyperty(message, hypertyURL) {\n      var _this = this;\n\n      if (!_this.context.runtimeRegistry) throw new Error('forward message to given ID is unsupported in this environment');\n      return new Promise(function (resolve) {\n        if (_this.context.runtimeRegistry.hypertiesList[0].hypertyURL === message.to) {\n          var splitTo = message.to.split('://');\n\n          if (splitTo[0] !== 'runtime') {\n            message.to = hypertyURL;\n            message.body.via = undefined;\n            resolve(message);\n\n            _this.context.runtimeRegistry._messageBus.postMessage(message);\n          } else {\n            resolve(message);\n          }\n        } else {\n          resolve(message);\n        }\n      });\n    }\n  }, {\n    key: \"sendAutomaticMessage\",\n    value: function sendAutomaticMessage(message, text) {\n      var _this = this;\n\n      return new Promise(function (resolve) {\n        var automaticMessage = {\n          from: message.to,\n          to: message.from,\n          body: {\n            value: text\n          },\n          type: message.type\n        };\n        resolve(message);\n\n        _this.context.runtimeRegistry._messageBus.postMessage(automaticMessage);\n      });\n    }\n  }]);\n\n  return ActionsService;\n}();\n\n/* harmony default export */ var policy_ActionsService = (ActionsService);\n// CONCATENATED MODULE: ./src/policy/Operators.js\nfunction Operators_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction Operators_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Operators_createClass(Constructor, protoProps, staticProps) { if (protoProps) Operators_defineProperties(Constructor.prototype, protoProps); if (staticProps) Operators_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Operators =\n/*#__PURE__*/\nfunction () {\n  function Operators() {\n    Operators_classCallCheck(this, Operators);\n  }\n\n  Operators_createClass(Operators, [{\n    key: \"and\",\n    value: function and(params) {\n      return params[0] && params[1];\n    }\n  }, {\n    key: \"between\",\n    value: function between(params) {\n      var start = parseInt(params[0][0]);\n      var end = parseInt(params[0][1]);\n      var now = params[1];\n\n      if (end < start) {\n        now = now < start ? now += 2400 : now;\n        end += 2400;\n      }\n\n      return now > start && now < end;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(params) {\n      return String(params[0]) === '*' || String(params[0]) === String(params[1]);\n    }\n  }, {\n    key: \"greaterThan\",\n    value: function greaterThan(params) {\n      return params[1] > params[0];\n    }\n  }, {\n    key: \"in\",\n    value: function _in(params) {\n      return params[0].indexOf(params[1]) > -1;\n    }\n  }, {\n    key: \"lessThan\",\n    value: function lessThan(params) {\n      return params[1] < params[0];\n    }\n  }, {\n    key: \"not\",\n    value: function not(params) {\n      return !params[0];\n    }\n  }, {\n    key: \"or\",\n    value: function or(params) {\n      return params[0] || params[1];\n    }\n  }]);\n\n  return Operators;\n}();\n\n/* harmony default export */ var policy_Operators = (Operators);\n// CONCATENATED MODULE: ./src/policy/PDP.js\nfunction PDP_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction PDP_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction PDP_createClass(Constructor, protoProps, staticProps) { if (protoProps) PDP_defineProperties(Constructor.prototype, protoProps); if (staticProps) PDP_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n/**\n* The Policy Decision Point (PDP) decides if a message is to be authorised by checking a set of\n* policies. The resource to be verified is specified in the first word of the 'condition' field of\n* a Policy object. The implementation that verifies if the message is compliant with a policy is\n* specified in a hashtable to allow dynamic definition of the implementation, providing\n* extensibility to the Policy Engine functionalities.\n*/\n\nvar PDP_PDP =\n/*#__PURE__*/\nfunction () {\n  function PDP(context) {\n    PDP_classCallCheck(this, PDP);\n\n    this.context = context;\n    this.operators = new policy_Operators();\n  }\n\n  PDP_createClass(PDP, [{\n    key: \"evaluatePolicies\",\n    value: function evaluatePolicies(message, isIncomingMessage) {\n      var policies = this.context.getPolicies(message, isIncomingMessage);\n      var result = 'Not Applicable';\n\n      if (policies !== undefined) {\n        result = this.evaluatePolicy(message, policies.serviceProviderPolicy, isIncomingMessage);\n\n        if (result || result === 'Not Applicable') {\n          var userResult = this.evaluatePolicy(message, policies.userPolicy, isIncomingMessage);\n\n          if (userResult !== 'Not Applicable') {\n            result = userResult;\n          }\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"evaluatePolicy\",\n    value: function evaluatePolicy(message, policy, isIncoming) {\n      var result = 'Not Applicable';\n\n      if (policy) {\n        result = policy.evaluateRules(this.context, message, isIncoming);\n      }\n\n      return result;\n    }\n  }]);\n\n  return PDP;\n}();\n\n/* harmony default export */ var policy_PDP = (PDP_PDP);\n// EXTERNAL MODULE: ./src/policy/combiningAlgorithms/AllowOverrides.js\nvar AllowOverrides = __webpack_require__(20);\n\n// EXTERNAL MODULE: ./src/policy/combiningAlgorithms/BlockOverrides.js\nvar BlockOverrides = __webpack_require__(21);\n\n// EXTERNAL MODULE: ./src/policy/combiningAlgorithms/FirstApplicable.js\nvar FirstApplicable = __webpack_require__(22);\n\n// CONCATENATED MODULE: ./src/policy/conditions/Condition.js\nfunction Condition_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction Condition_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Condition_createClass(Constructor, protoProps, staticProps) { if (protoProps) Condition_defineProperties(Constructor.prototype, protoProps); if (staticProps) Condition_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n* Copyright 2016 PT Inovação e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n\n/**\n* @author Ana Caldeira <ana.caldeira@tecnico.ulisboa.pt>\n* @classdesc Class to represent a condition and evaluate its applicability.\n*/\n\nvar Condition_Condition =\n/*#__PURE__*/\nfunction () {\n  /**\n  * Creates a new Condition.\n  * @class\n  * @param  {string}  attribute\n  * @param  {string}  operator\n  * @param  {*}       params\n  */\n  function Condition(attribute, operator, params) {\n    Condition_classCallCheck(this, Condition);\n\n    this.attribute = attribute;\n    this.operator = operator;\n    this.params = params;\n    this.operators = new policy_Operators();\n  }\n  /**\n  * Verifies if the condition is applicable to the message. First, the system value that corresponds to the attribute is retrieved; then, that value is compared with the parameter specified in the condition by executing the operator implementation. If the operator is 'in' and the name of a group is given, then the array holding the members of the group is retrieved before the comparison.\n  * @param  {Object}    context   environment where the Policy Engine is being used\n  * @param  {Object}    message\n  */\n\n\n  Condition_createClass(Condition, [{\n    key: \"isApplicable\",\n    value: function isApplicable(context, message) {\n      context[this.attribute] = {\n        message: message\n      };\n      var value = context[this.attribute];\n      var tempParam;\n\n      if (this.operator === 'in') {\n        if (!Array.isArray(this.params)) {\n          tempParam = context.getGroup(this.params, message.to);\n          return this.operators[this.operator]([tempParam, value]);\n        }\n      }\n\n      return this.operators[this.operator]([this.params, value]);\n    }\n  }]);\n\n  return Condition;\n}();\n\n/* harmony default export */ var conditions_Condition = (Condition_Condition);\n// CONCATENATED MODULE: ./src/policy/conditions/SubscriptionCondition.js\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction SubscriptionCondition_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction SubscriptionCondition_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction SubscriptionCondition_createClass(Constructor, protoProps, staticProps) { if (protoProps) SubscriptionCondition_defineProperties(Constructor.prototype, protoProps); if (staticProps) SubscriptionCondition_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n* Copyright 2016 PT Inovação e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n\n/**\n* @author Ana Caldeira <ana.caldeira@tecnico.ulisboa.pt>\n* @classdesc Class to represent a subscription condition and evaluate its applicability.\n*/\n\nvar SubscriptionCondition =\n/*#__PURE__*/\nfunction (_Condition) {\n  _inherits(SubscriptionCondition, _Condition);\n\n  /**\n  * Creates a new SubscriptionCondition.\n  * @class\n  * @param  {string}  attribute\n  * @param  {string}  operator\n  * @param  {*}       params\n  */\n  function SubscriptionCondition(attribute, operator, params) {\n    SubscriptionCondition_classCallCheck(this, SubscriptionCondition);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(SubscriptionCondition).call(this, attribute, operator, params));\n  }\n  /**\n  * Verifies if the subscription condition is applicable to the message. First, verifies if the message is of the subscription type; second, verifies if the message is from a remote runtime to guarantee that the subscription is being validated in the destination runtime; third, verifies if the subscription preference is met.\n  * @param  {Object}    context   environment where the Policy Engine is being used\n  * @param  {Object}    message\n  */\n\n\n  SubscriptionCondition_createClass(SubscriptionCondition, [{\n    key: \"isApplicable\",\n    value: function isApplicable(context, message) {\n      var isSubscription = message.type === 'subscribe';\n      var isFromRemoteSM = context.isFromRemoteSM(message.from);\n\n      if (isSubscription & isFromRemoteSM) {\n        return _get(_getPrototypeOf(SubscriptionCondition.prototype), \"isApplicable\", this).call(this, context, message);\n      } else {\n        return false;\n      }\n    }\n  }]);\n\n  return SubscriptionCondition;\n}(conditions_Condition);\n\n/* harmony default export */ var conditions_SubscriptionCondition = (SubscriptionCondition);\n// CONCATENATED MODULE: ./src/policy/conditions/AdvancedCondition.js\nfunction AdvancedCondition_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction AdvancedCondition_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AdvancedCondition_createClass(Constructor, protoProps, staticProps) { if (protoProps) AdvancedCondition_defineProperties(Constructor.prototype, protoProps); if (staticProps) AdvancedCondition_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\nvar AdvancedCondition_AdvancedCondition =\n/*#__PURE__*/\nfunction () {\n  function AdvancedCondition(condition) {\n    AdvancedCondition_classCallCheck(this, AdvancedCondition);\n\n    this.operators = new policy_Operators();\n\n    if (condition.operators !== undefined) {\n      condition = condition.condition;\n    }\n\n    condition = this.buildCondition(condition);\n    this.condition = condition;\n  }\n\n  AdvancedCondition_createClass(AdvancedCondition, [{\n    key: \"buildCondition\",\n    value: function buildCondition(condition) {\n      if (Array.isArray(condition[1])) {\n        condition[1] = this.buildCondition(condition[1]);\n      } else {\n        if (condition[1].attribute === 'subscription') {\n          condition[1] = new conditions_SubscriptionCondition(condition[1].attribute, condition[1].operator, condition[1].params);\n        } else {\n          condition[1] = new conditions_Condition(condition[1].attribute, condition[1].operator, condition[1].params);\n        }\n      }\n\n      if (condition[2] !== undefined) {\n        if (Array.isArray(condition[2])) {\n          condition[2] = this.buildCondition(condition[2]);\n        } else {\n          if (condition[2].attribute === 'subscription') {\n            condition[2] = new conditions_SubscriptionCondition(condition[2].attribute, condition[2].operator, condition[2].params);\n          } else {\n            condition[2] = new conditions_Condition(condition[2].attribute, condition[2].operator, condition[2].params);\n          }\n        }\n      }\n\n      return condition;\n    }\n  }, {\n    key: \"isApplicable\",\n    value: function isApplicable(context, message, scope, target, operator, left, right) {\n      if (!operator) {\n        operator = this.condition[0];\n        left = this.condition[1];\n        right = this.condition[2];\n      }\n\n      while (!(left instanceof conditions_Condition) & !(left instanceof conditions_SubscriptionCondition) & typeof left !== 'boolean') {\n        left = this.isApplicable(context, message, scope, target, left[0], left[1], left[2]);\n      }\n\n      if (right !== undefined) {\n        while (!(right instanceof conditions_Condition) & !(right instanceof conditions_SubscriptionCondition) & typeof right !== 'boolean') {\n          right = this.isApplicable(context, message, scope, target, right[0], right[1], right[2]);\n        }\n      }\n\n      var resultLeft = typeof left === 'boolean' ? left : left.isApplicable(context, message, scope, target);\n      var resultRight;\n\n      if (right !== undefined) {\n        resultRight = typeof right === 'boolean' ? right : right.isApplicable(context, message, scope, target);\n      }\n\n      return this.operators[operator]([resultLeft, resultRight]);\n    }\n  }]);\n\n  return AdvancedCondition;\n}();\n\n/* harmony default export */ var conditions_AdvancedCondition = (AdvancedCondition_AdvancedCondition);\n// EXTERNAL MODULE: ./src/utils/utils.js\nvar utils = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./src/policy/Rule.js\nfunction Rule_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction Rule_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Rule_createClass(Constructor, protoProps, staticProps) { if (protoProps) Rule_defineProperties(Constructor.prototype, protoProps); if (staticProps) Rule_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\nvar Rule_Rule =\n/*#__PURE__*/\nfunction () {\n  function Rule(decision, condition, scope, target, priority) {\n    Rule_classCallCheck(this, Rule);\n\n    this.decision = decision;\n    this.setCondition(condition);\n    this.priority = priority;\n    this.scope = scope;\n    this.target = target;\n  }\n\n  Rule_createClass(Rule, [{\n    key: \"setCondition\",\n    value: function setCondition(condition) {\n      if (!(condition instanceof conditions_Condition || condition instanceof conditions_AdvancedCondition || condition instanceof conditions_AdvancedCondition)) {\n        var attribute = condition.attribute;\n\n        switch (attribute) {\n          case 'subscription':\n            this.condition = new conditions_AdvancedCondition(condition.attribute, condition.operator, condition.params);\n            break;\n\n          case undefined:\n            this.condition = new conditions_AdvancedCondition(condition);\n            break;\n\n          default:\n            this.condition = new conditions_Condition(condition.attribute, condition.operator, condition.params);\n        }\n      } else {\n        this.condition = condition;\n      }\n    }\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(context, message, isIncoming) {\n      var field = isIncoming ? message.to : message.from;\n      var hypertyName;\n\n      switch (this.scope) {\n        case 'global':\n          break;\n\n        case 'hyperty':\n          if (Object(utils[\"s\" /* isDataObjectURL */])(field)) {\n            var reporter = context.runtimeRegistry.getReporterURLSynchonous(Object(utils[\"B\" /* removePathFromURL */])(field));\n\n            if (reporter !== undefined) {\n              hypertyName = context.runtimeRegistry.getHypertyName(reporter);\n            }\n          } else {\n            if (field.split('://')[0] === 'hyperty') {\n              hypertyName = context.runtimeRegistry.getHypertyName(Object(utils[\"B\" /* removePathFromURL */])(field));\n            }\n          }\n\n          if (hypertyName === this.target) {\n            break;\n          }\n\n          return 'Not Applicable';\n\n        case 'identity':\n          var owner;\n\n          if (Object(utils[\"s\" /* isDataObjectURL */])(field)) {\n            var _reporter = context.runtimeRegistry.getReporterURLSynchonous(Object(utils[\"B\" /* removePathFromURL */])(field));\n\n            owner = context.runtimeRegistry.getHypertyOwner(_reporter);\n          } else {\n            if (field.split('://')[0] === 'hyperty') {\n              owner = context.runtimeRegistry.getHypertyOwner(Object(utils[\"B\" /* removePathFromURL */])(field));\n            }\n          }\n\n          if (owner !== undefined) {\n            owner = Object(utils[\"p\" /* getUserEmailFromURL */])(owner);\n          }\n\n          if (owner === this.target) {\n            break;\n          }\n\n          return 'Not Applicable';\n      }\n\n      if (this.condition.isApplicable(context, message, this.scope, this.target)) {\n        return this.decision;\n      } else {\n        return 'Not Applicable';\n      }\n    }\n  }]);\n\n  return Rule;\n}();\n\n/* harmony default export */ var policy_Rule = (Rule_Rule);\n// CONCATENATED MODULE: ./src/policy/Policy.js\nfunction Policy_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction Policy_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Policy_createClass(Constructor, protoProps, staticProps) { if (protoProps) Policy_defineProperties(Constructor.prototype, protoProps); if (staticProps) Policy_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\nvar Policy_Policy =\n/*#__PURE__*/\nfunction () {\n  function Policy(key, rules, actions, combiningAlgorithm) {\n    Policy_classCallCheck(this, Policy);\n\n    if (!key) throw new Error('key is not defined');\n    if (!actions) throw new Error('actions are not defined');\n    this.actions = actions;\n    this.key = key;\n\n    this._setRules(rules);\n\n    this._setCombiningAlgorithm(combiningAlgorithm);\n  }\n\n  Policy_createClass(Policy, [{\n    key: \"addAction\",\n    value: function addAction(method, param) {\n      this.actions.push({\n        method: method,\n        param: param\n      });\n    }\n  }, {\n    key: \"createRule\",\n    value: function createRule(decision, condition, scope, target, priority) {\n      if (priority === undefined) {\n        priority = this.getLastPriority() + 1;\n      }\n\n      var rule = new policy_Rule(decision, condition, scope, target, priority);\n      this.rules.push(rule);\n    }\n  }, {\n    key: \"deleteRule\",\n    value: function deleteRule(rule) {\n      var indexToRemove = this.rules.indexOf(rule);\n      this.rules.splice(indexToRemove, 1);\n    }\n  }, {\n    key: \"enforceActions\",\n    value: function enforceActions(context, message) {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        var results = [];\n\n        if (_this.actions.length !== 0) {\n          for (var i in _this.actions) {\n            var result = context.pep.actionsService[_this.actions[i].method](message, _this.actions[i].param);\n\n            results.push(result);\n          }\n\n          Promise.all(results).then(function (messages) {\n            resolve(messages);\n          }, function (error) {\n            reject(error);\n          });\n        } else {\n          resolve([message]);\n        }\n      });\n    }\n  }, {\n    key: \"evaluateRules\",\n    value: function evaluateRules(context, message, isIncoming) {\n      var results = [];\n\n      for (var i in this.rules) {\n        results.push(this.rules[i].evaluate(context, message, isIncoming));\n      }\n\n      return this.combiningAlgorithm.combine(results);\n    }\n  }, {\n    key: \"getLastPriority\",\n    value: function getLastPriority() {\n      var priorities = [];\n\n      if (this.rules.length !== 0) {\n        for (var i in this.rules) {\n          priorities.push(this.rules[i].priority);\n        }\n\n        return Math.max.apply(Math, priorities);\n      } else {\n        return -1;\n      }\n    }\n  }, {\n    key: \"getRuleByPriority\",\n    value: function getRuleByPriority(priority) {\n      for (var i in this.rules) {\n        if (String(this.rules[i].priority) === String(priority)) {\n          return this.rules[i];\n        }\n      }\n\n      throw Error('Rule with priority ' + priority + ' does not exist!');\n    }\n  }, {\n    key: \"_setCombiningAlgorithm\",\n    value: function _setCombiningAlgorithm(combiningAlgorithm) {\n      if (!combiningAlgorithm) {\n        combiningAlgorithm = 'blockOverrides';\n      }\n\n      switch (combiningAlgorithm) {\n        case 'blockOverrides':\n          this.combiningAlgorithm = new BlockOverrides[\"a\" /* default */]();\n          break;\n\n        case 'allowOverrides':\n          this.combiningAlgorithm = new AllowOverrides[\"a\" /* default */]();\n          break;\n\n        case 'firstApplicable':\n          this.combiningAlgorithm = new FirstApplicable[\"a\" /* default */]();\n          break;\n\n        default:\n          throw Error('Unknown algorithm: ' + combiningAlgorithm);\n      }\n    }\n  }, {\n    key: \"_setRules\",\n    value: function _setRules(rules) {\n      this.rules = [];\n\n      for (var i in rules) {\n        var rule = rules[i];\n\n        if (rule.priority === undefined) {\n          rule.priority = this.getLastPriority() + 1;\n        }\n\n        if (!(rule instanceof policy_Rule)) {\n          rule = new policy_Rule(rule.decision, rule.condition, rule.scope, rule.target, rule.priority);\n        }\n\n        this.rules.push(rule);\n      }\n    }\n  }, {\n    key: \"sortRules\",\n    value: function sortRules() {\n      return this.rules.sort(function (a, b) {\n        var x = a.priority;\n        var y = b.priority;\n        return x < y ? -1 : x > y ? 1 : 0;\n      });\n    }\n  }]);\n\n  return Policy;\n}();\n\n/* harmony default export */ var policy_Policy = (Policy_Policy);\n// CONCATENATED MODULE: ./src/policy/PEP.js\nfunction PEP_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction PEP_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction PEP_createClass(Constructor, protoProps, staticProps) { if (protoProps) PEP_defineProperties(Constructor.prototype, protoProps); if (staticProps) PEP_defineProperties(Constructor, staticProps); return Constructor; }\n\n// Log System\n\nvar log = loglevel[\"getLogger\"]('PEP');\n\n\n\n\n\nvar PEP_PEP =\n/*#__PURE__*/\nfunction () {\n  /**\n  * Creates a Policy Enforcement Point (PEP) instance\n  * @param    {Object}    context\n  */\n  function PEP(context) {\n    PEP_classCallCheck(this, PEP);\n\n    var _this = this;\n\n    _this.pdp = new policy_PDP(context);\n    _this.actionsService = new policy_ActionsService(context);\n    _this.context = context;\n    context.pep = _this; //TODO should be added a trigger to verify when the loadConfigurations is successfully completed\n\n    context.loadConfigurations();\n  }\n  /**\n  * return the messageBus in this Registry\n  * @param {MessageBus}           messageBus\n  */\n\n\n  PEP_createClass(PEP, [{\n    key: \"addGUIListeners\",\n    value: function addGUIListeners() {\n      var _this = this;\n\n      _this.context.messageBus.addListener(_this.context.pepURL, function (msg) {\n        var funcName = msg.body.method;\n        var returnedValue;\n\n        if (funcName === 'addToGroup') {\n          var groupName = msg.body.params.groupName;\n          var userEmail = msg.body.params.userEmail;\n          returnedValue = _this.context.addToGroup(groupName, userEmail);\n        } else if (funcName === 'createGroup') {\n          var _groupName = msg.body.params.groupName;\n          returnedValue = _this.context.createGroup(_groupName);\n        } else if (funcName === 'addPolicy') {\n          var source = msg.body.params.source;\n          var key = msg.body.params.key;\n          var policy = msg.body.params.policy;\n          var combiningAlgorithm = msg.body.params.combiningAlgorithm;\n          returnedValue = _this.addPolicy(source, key, policy, combiningAlgorithm);\n        } else if (funcName === 'deleteGroup') {\n          var _groupName2 = msg.body.params.groupName;\n          returnedValue = _this.context.deleteGroup(_groupName2);\n        } else if (funcName === 'removePolicy') {\n          var _source = msg.body.params.source;\n          var _key = msg.body.params.key;\n          returnedValue = _this.removePolicy(_source, _key);\n        } else if (funcName === 'savePolicies') {\n          var _source2 = msg.body.params.source;\n          returnedValue = _this.context.savePolicies(_source2);\n        } else if (funcName === 'userPolicies') {\n          returnedValue = _this.context.userPolicies;\n        } else if (funcName === 'activeUserPolicy') {\n          var userPolicy = msg.body.params.userPolicy;\n\n          if (userPolicy) {\n            _this.context.activeUserPolicy = userPolicy;\n          }\n\n          returnedValue = _this.context.activeUserPolicy;\n        } else if (funcName === 'userPolicy') {\n          var _key2 = msg.body.params.key;\n          returnedValue = _this.context.userPolicies[_key2];\n        } else if (funcName === 'saveActivePolicy') {\n          returnedValue = _this.context.saveActivePolicy();\n        } else if (funcName === 'getMyEmails') {\n          returnedValue = _this.context.getMyEmails();\n        } else if (funcName === 'getMyHyperties') {\n          returnedValue = _this.context.getMyHyperties();\n        } else if (funcName === 'groups') {\n          returnedValue = _this.context.groups;\n        } else if (funcName === 'getGroupsNames') {\n          returnedValue = _this.context.getGroupsNames();\n        }\n\n        if (funcName === 'removeFromGroup') {\n          var _groupName3 = msg.body.params.groupName;\n          var _userEmail = msg.body.params.userEmail;\n          returnedValue = _this.context.removeFromGroup(_groupName3, _userEmail);\n        }\n\n        var value = {\n          type: 'execute',\n          value: returnedValue,\n          code: 200\n        };\n        var replyMsg = {\n          id: msg.id,\n          type: 'response',\n          to: msg.from,\n          from: msg.to,\n          body: value\n        };\n\n        _this.context.messageBus.postMessage(replyMsg);\n      });\n    }\n    /**\n    * Adds a policy to the Policy Enforcement Point (PEP). The policy can be created by the service\n    * provider or by the user.\n    * @param    {String}    source\n    * @param    {String}    key\n    * @param    {Object}    policy\n    */\n\n  }, {\n    key: \"addPolicy\",\n    value: function addPolicy(source, key, policy, combiningAlgorithm) {\n      if (!source) throw new Error('source is not defined');\n      if (!key) throw new Error('key is not defined');\n\n      if (policy === undefined) {\n        policy = new policy_Policy(key, [], [], combiningAlgorithm);\n      } else {\n        if (!(policy instanceof policy_Policy)) {\n          policy = new policy_Policy(policy.key, policy.rules, policy.actions, policy.combiningAlgorithm);\n        }\n      }\n\n      switch (source) {\n        case 'SERVICE_PROVIDER':\n          this.context.savePolicies(source, policy, key);\n          break;\n\n        case 'USER':\n          this.context.userPolicies[key] = policy;\n          this.context.savePolicies(source);\n          break;\n\n        default:\n          throw Error('Unknown policy source: ' + source);\n      }\n    }\n  }, {\n    key: \"authorise\",\n    value: function authorise(message, isIncoming) {\n      var _this2 = this;\n\n      // log.log('[Policy.PEP Authorise] ', message);\n      // log.log(message);\n      if (!message) throw new Error('message is not defined');\n      if (!message.from) throw new Error('message.from is not defined');\n      if (!message.to) throw new Error('message.to is not defined');\n      if (!message.type) throw new Error('message.type is not defined');\n      message.body = message.body || {};\n      return new Promise(function (resolve, reject) {\n        message.body = message.body || {};\n        var _this = _this2;\n\n        var result = _this.pdp.evaluatePolicies(message, isIncoming);\n\n        if (result === 'Not Applicable') {\n          result = _this.context.defaultBehaviour;\n          message.body.auth = false;\n        }\n\n        _this.actionsService.enforcePolicies(message, isIncoming).then(function (messages) {\n          for (var i in messages) {\n            message = messages[i];\n\n            if (result) {\n              message.body.auth = message.body.auth === undefined ? true : message.body.auth;\n              resolve(message);\n            } else {\n              var errorMessage = {\n                body: {\n                  code: 403,\n                  description: 'Blocked by policy'\n                },\n                from: message.to,\n                to: message.from,\n                type: 'response'\n              };\n              reject(errorMessage);\n            }\n          }\n        }, function (error) {\n          reject(error);\n        });\n      });\n    }\n  }, {\n    key: \"authoriseSync\",\n    value: function authoriseSync(message) {\n      var result;\n      message.body = message.body || {};\n      result = this.pdp.evaluatePolicies(message, true);\n\n      if (result === 'Not Applicable') {\n        result = this.context.defaultBehaviour;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"removePolicy\",\n    value: function removePolicy(source, key) {\n      if (!source) throw new Error('source is not defined');\n      if (source !== '*' && !key) throw new Error('key is not defined');\n\n      switch (source) {\n        case '*':\n          this.context.serviceProviderPolicy = {};\n          this.context.userPolicies = {};\n          this.context.activeUserPolicy = undefined;\n          this.context.savePolicies('USER');\n          this.context.savePolicies('SERVICE_PROVIDER');\n          this.context.saveActivePolicy();\n          break;\n\n        case 'SERVICE_PROVIDER':\n          delete this.context.serviceProviderPolicy[key];\n          this.context.savePolicies();\n          break;\n\n        case 'USER':\n          delete this.context.userPolicies[key];\n\n          if (key === this.context.activeUserPolicy) {\n            this.context.activeUserPolicy = undefined;\n            this.context.saveActivePolicy();\n          }\n\n          this.context.savePolicies('USER');\n          break;\n\n        default:\n          throw Error('Unknown policy source: ' + source);\n      }\n    }\n  }, {\n    key: \"messageBus\",\n    get: function get() {\n      var _this = this;\n\n      return _this.context.messageBus;\n    }\n    /**\n    * Set the messageBus in this Registry\n    * @param {MessageBus}           messageBus\n    */\n    ,\n    set: function set(messageBus) {\n      var _this = this;\n\n      _this.context.messageBus = messageBus;\n\n      _this.addGUIListeners();\n    }\n  }]);\n\n  return PEP;\n}();\n\n/* harmony default export */ var policy_PEP = __webpack_exports__[\"default\"] = (PEP_PEP);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvcG9saWN5L0FjdGlvbnNTZXJ2aWNlLmpzPzllNzIiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vc3JjL3BvbGljeS9PcGVyYXRvcnMuanM/M2IyZiIsIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvcG9saWN5L1BEUC5qcz8yMmVkIiwid2VicGFjazovL1tuYW1lXS8uL3NyYy9wb2xpY3kvY29uZGl0aW9ucy9Db25kaXRpb24uanM/MzMxNSIsIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvcG9saWN5L2NvbmRpdGlvbnMvU3Vic2NyaXB0aW9uQ29uZGl0aW9uLmpzPzdlMWIiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vc3JjL3BvbGljeS9jb25kaXRpb25zL0FkdmFuY2VkQ29uZGl0aW9uLmpzPzljMzIiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vc3JjL3BvbGljeS9SdWxlLmpzPzVkZDgiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vc3JjL3BvbGljeS9Qb2xpY3kuanM/ZDFhZCIsIndlYnBhY2s6Ly9bbmFtZV0vLi9zcmMvcG9saWN5L1BFUC5qcz85YTFmIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEFjdGlvbnNTZXJ2aWNlIHtcblxuICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgfVxuXG4gIGVuZm9yY2VQb2xpY2llcyhtZXNzYWdlLCBpc0luY29taW5nTWVzc2FnZSkge1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgbGV0IHBvbGljaWVzID0gX3RoaXMuY29udGV4dC5nZXRQb2xpY2llcyhtZXNzYWdlLCBpc0luY29taW5nTWVzc2FnZSk7XG5cbiAgICAgIGlmIChwb2xpY2llcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChwb2xpY2llcy5zZXJ2aWNlUHJvdmlkZXJQb2xpY3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBvbGljaWVzLnNlcnZpY2VQcm92aWRlclBvbGljeS5lbmZvcmNlQWN0aW9ucyhfdGhpcy5jb250ZXh0LCBtZXNzYWdlKS50aGVuKG1lc3NhZ2VzID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUobWVzc2FnZXMpO1xuICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocG9saWNpZXMudXNlclBvbGljeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwb2xpY2llcy51c2VyUG9saWN5LmVuZm9yY2VBY3Rpb25zKF90aGlzLmNvbnRleHQsIG1lc3NhZ2UpLnRoZW4obWVzc2FnZXMgPT4ge1xuICAgICAgICAgICAgICByZXNvbHZlKG1lc3NhZ2VzKTtcbiAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoW21lc3NhZ2VdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoW21lc3NhZ2VdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZvcndhcmRUb0lEKG1lc3NhZ2UsIGVtYWlsKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcbiAgICBpZiAoIV90aGlzLmNvbnRleHQucnVudGltZVJlZ2lzdHJ5KSB0aHJvdyBuZXcgRXJyb3IoJ2ZvcndhcmQgbWVzc2FnZSB0byBnaXZlbiBJRCBpcyB1bnN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKF90aGlzLmNvbnRleHQucnVudGltZVJlZ2lzdHJ5Lmh5cGVydGllc0xpc3RbMF0uaHlwZXJ0eVVSTCA9PT0gbWVzc2FnZS50bykge1xuICAgICAgICBsZXQgc3BsaXRUbyA9IChtZXNzYWdlLnRvKS5zcGxpdCgnOi8vJyk7XG4gICAgICAgIGlmIChzcGxpdFRvWzBdICE9PSAncnVudGltZScpIHtcbiAgICAgICAgICBfdGhpcy5jb250ZXh0LnJ1bnRpbWVSZWdpc3RyeS5kaXNjb3Zlckh5cGVydHlQZXJVc2VyKGVtYWlsKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICBtZXNzYWdlLnRvID0gcmVzdWx0Lmh5cGVydHlVUkw7XG4gICAgICAgICAgICBtZXNzYWdlLmJvZHkudmlhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmVzb2x2ZShtZXNzYWdlKTtcbiAgICAgICAgICAgIF90aGlzLmNvbnRleHQucnVudGltZVJlZ2lzdHJ5Ll9tZXNzYWdlQnVzLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZm9yd2FyZFRvSHlwZXJ0eShtZXNzYWdlLCBoeXBlcnR5VVJMKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcbiAgICBpZiAoIV90aGlzLmNvbnRleHQucnVudGltZVJlZ2lzdHJ5KSB0aHJvdyBuZXcgRXJyb3IoJ2ZvcndhcmQgbWVzc2FnZSB0byBnaXZlbiBJRCBpcyB1bnN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGlmIChfdGhpcy5jb250ZXh0LnJ1bnRpbWVSZWdpc3RyeS5oeXBlcnRpZXNMaXN0WzBdLmh5cGVydHlVUkwgPT09IG1lc3NhZ2UudG8pIHtcbiAgICAgICAgbGV0IHNwbGl0VG8gPSAobWVzc2FnZS50bykuc3BsaXQoJzovLycpO1xuICAgICAgICBpZiAoc3BsaXRUb1swXSAhPT0gJ3J1bnRpbWUnKSB7XG4gICAgICAgICAgbWVzc2FnZS50byA9IGh5cGVydHlVUkw7XG4gICAgICAgICAgbWVzc2FnZS5ib2R5LnZpYSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXNvbHZlKG1lc3NhZ2UpO1xuICAgICAgICAgIF90aGlzLmNvbnRleHQucnVudGltZVJlZ2lzdHJ5Ll9tZXNzYWdlQnVzLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUobWVzc2FnZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzZW5kQXV0b21hdGljTWVzc2FnZShtZXNzYWdlLCB0ZXh0KSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGxldCBhdXRvbWF0aWNNZXNzYWdlID0ge1xuICAgICAgICBmcm9tOiBtZXNzYWdlLnRvLFxuICAgICAgICB0bzogbWVzc2FnZS5mcm9tLFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgdmFsdWU6IHRleHRcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZTogbWVzc2FnZS50eXBlXG4gICAgICB9O1xuICAgICAgcmVzb2x2ZShtZXNzYWdlKTtcbiAgICAgIF90aGlzLmNvbnRleHQucnVudGltZVJlZ2lzdHJ5Ll9tZXNzYWdlQnVzLnBvc3RNZXNzYWdlKGF1dG9tYXRpY01lc3NhZ2UpO1xuICAgIH0pO1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQWN0aW9uc1NlcnZpY2U7XG4iLCJjbGFzcyBPcGVyYXRvcnMge1xuXG4gIGFuZChwYXJhbXMpIHtcbiAgICByZXR1cm4gcGFyYW1zWzBdICYmIHBhcmFtc1sxXTtcbiAgfVxuXG4gIGJldHdlZW4ocGFyYW1zKSB7XG4gICAgbGV0IHN0YXJ0ID0gcGFyc2VJbnQocGFyYW1zWzBdWzBdKTtcbiAgICBsZXQgZW5kID0gcGFyc2VJbnQocGFyYW1zWzBdWzFdKTtcbiAgICBsZXQgbm93ID0gcGFyYW1zWzFdO1xuXG4gICAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgICBub3cgPSAobm93IDwgc3RhcnQpID8gbm93ICs9IDI0MDAgOiBub3c7XG4gICAgICBlbmQgKz0gMjQwMDtcbiAgICB9XG5cbiAgICByZXR1cm4gKG5vdyA+IHN0YXJ0ICYmIG5vdyA8IGVuZCk7XG4gIH1cblxuICBlcXVhbHMocGFyYW1zKSB7XG4gICAgcmV0dXJuIFN0cmluZyhwYXJhbXNbMF0pID09PSAnKicgfHwgU3RyaW5nKHBhcmFtc1swXSkgPT09IFN0cmluZyhwYXJhbXNbMV0pO1xuICB9XG5cbiAgZ3JlYXRlclRoYW4ocGFyYW1zKSB7XG4gICAgcmV0dXJuIHBhcmFtc1sxXSA+IHBhcmFtc1swXTtcbiAgfVxuXG4gIGluKHBhcmFtcykge1xuICAgIHJldHVybiBwYXJhbXNbMF0uaW5kZXhPZihwYXJhbXNbMV0pID4gLTE7XG4gIH1cblxuICBsZXNzVGhhbihwYXJhbXMpIHtcbiAgICByZXR1cm4gcGFyYW1zWzFdIDwgcGFyYW1zWzBdO1xuICB9XG5cbiAgbm90KHBhcmFtcykge1xuICAgIHJldHVybiAhcGFyYW1zWzBdO1xuICB9XG5cbiAgb3IocGFyYW1zKSB7XG4gICAgcmV0dXJuIHBhcmFtc1swXSB8fCBwYXJhbXNbMV07XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBPcGVyYXRvcnM7XG4iLCJpbXBvcnQgT3BlcmF0b3JzIGZyb20gJy4vT3BlcmF0b3JzJztcblxuLyoqXG4qIFRoZSBQb2xpY3kgRGVjaXNpb24gUG9pbnQgKFBEUCkgZGVjaWRlcyBpZiBhIG1lc3NhZ2UgaXMgdG8gYmUgYXV0aG9yaXNlZCBieSBjaGVja2luZyBhIHNldCBvZlxuKiBwb2xpY2llcy4gVGhlIHJlc291cmNlIHRvIGJlIHZlcmlmaWVkIGlzIHNwZWNpZmllZCBpbiB0aGUgZmlyc3Qgd29yZCBvZiB0aGUgJ2NvbmRpdGlvbicgZmllbGQgb2ZcbiogYSBQb2xpY3kgb2JqZWN0LiBUaGUgaW1wbGVtZW50YXRpb24gdGhhdCB2ZXJpZmllcyBpZiB0aGUgbWVzc2FnZSBpcyBjb21wbGlhbnQgd2l0aCBhIHBvbGljeSBpc1xuKiBzcGVjaWZpZWQgaW4gYSBoYXNodGFibGUgdG8gYWxsb3cgZHluYW1pYyBkZWZpbml0aW9uIG9mIHRoZSBpbXBsZW1lbnRhdGlvbiwgcHJvdmlkaW5nXG4qIGV4dGVuc2liaWxpdHkgdG8gdGhlIFBvbGljeSBFbmdpbmUgZnVuY3Rpb25hbGl0aWVzLlxuKi9cbmNsYXNzIFBEUCB7XG5cbiAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5vcGVyYXRvcnMgPSBuZXcgT3BlcmF0b3JzKCk7XG4gIH1cblxuICBldmFsdWF0ZVBvbGljaWVzKG1lc3NhZ2UsIGlzSW5jb21pbmdNZXNzYWdlKSB7XG4gICAgbGV0IHBvbGljaWVzID0gdGhpcy5jb250ZXh0LmdldFBvbGljaWVzKG1lc3NhZ2UsIGlzSW5jb21pbmdNZXNzYWdlKTtcbiAgICBsZXQgcmVzdWx0ID0gJ05vdCBBcHBsaWNhYmxlJztcbiAgICBpZiAocG9saWNpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5ldmFsdWF0ZVBvbGljeShtZXNzYWdlLCBwb2xpY2llcy5zZXJ2aWNlUHJvdmlkZXJQb2xpY3ksIGlzSW5jb21pbmdNZXNzYWdlKTtcbiAgICAgIGlmIChyZXN1bHQgfHwgcmVzdWx0ID09PSAnTm90IEFwcGxpY2FibGUnKSB7XG4gICAgICAgIGxldCB1c2VyUmVzdWx0ID0gdGhpcy5ldmFsdWF0ZVBvbGljeShtZXNzYWdlLCBwb2xpY2llcy51c2VyUG9saWN5LCBpc0luY29taW5nTWVzc2FnZSk7XG4gICAgICAgIGlmICh1c2VyUmVzdWx0ICE9PSAnTm90IEFwcGxpY2FibGUnKSB7XG4gICAgICAgICAgcmVzdWx0ID0gdXNlclJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBldmFsdWF0ZVBvbGljeShtZXNzYWdlLCBwb2xpY3ksIGlzSW5jb21pbmcpIHtcbiAgICBsZXQgcmVzdWx0ID0gJ05vdCBBcHBsaWNhYmxlJztcbiAgICBpZiAocG9saWN5KSB7XG4gICAgICByZXN1bHQgPSBwb2xpY3kuZXZhbHVhdGVSdWxlcyh0aGlzLmNvbnRleHQsIG1lc3NhZ2UsIGlzSW5jb21pbmcpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBQRFA7XG4iLCIvKipcbiogQ29weXJpZ2h0IDIwMTYgUFQgSW5vdmHDp8OjbyBlIFNpc3RlbWFzIFNBXG4qIENvcHlyaWdodCAyMDE2IElORVNDLUlEXG4qIENvcHlyaWdodCAyMDE2IFFVT0JJUyBORVRXT1JLUyBTTFxuKiBDb3B5cmlnaHQgMjAxNiBGUkFVTkhPRkVSLUdFU0VMTFNDSEFGVCBaVVIgRk9FUkRFUlVORyBERVIgQU5HRVdBTkRURU4gRk9SU0NIVU5HIEUuVlxuKiBDb3B5cmlnaHQgMjAxNiBPUkFOR0UgU0FcbiogQ29weXJpZ2h0IDIwMTYgRGV1dHNjaGUgVGVsZWtvbSBBR1xuKiBDb3B5cmlnaHQgMjAxNiBBcGl6ZWVcbiogQ29weXJpZ2h0IDIwMTYgVEVDSE5JU0NIRSBVTklWRVJTSVRBVCBCRVJMSU5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKiovXG5cbmltcG9ydCBPcGVyYXRvcnMgZnJvbSAnLi4vT3BlcmF0b3JzJztcblxuLyoqXG4qIEBhdXRob3IgQW5hIENhbGRlaXJhIDxhbmEuY2FsZGVpcmFAdGVjbmljby51bGlzYm9hLnB0PlxuKiBAY2xhc3NkZXNjIENsYXNzIHRvIHJlcHJlc2VudCBhIGNvbmRpdGlvbiBhbmQgZXZhbHVhdGUgaXRzIGFwcGxpY2FiaWxpdHkuXG4qL1xuY2xhc3MgQ29uZGl0aW9uIHtcblxuICAvKipcbiAgKiBDcmVhdGVzIGEgbmV3IENvbmRpdGlvbi5cbiAgKiBAY2xhc3NcbiAgKiBAcGFyYW0gIHtzdHJpbmd9ICBhdHRyaWJ1dGVcbiAgKiBAcGFyYW0gIHtzdHJpbmd9ICBvcGVyYXRvclxuICAqIEBwYXJhbSAgeyp9ICAgICAgIHBhcmFtc1xuICAqL1xuICBjb25zdHJ1Y3RvcihhdHRyaWJ1dGUsIG9wZXJhdG9yLCBwYXJhbXMpIHtcbiAgICB0aGlzLmF0dHJpYnV0ZSA9IGF0dHJpYnV0ZTtcbiAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgdGhpcy5vcGVyYXRvcnMgPSBuZXcgT3BlcmF0b3JzKCk7XG4gIH1cblxuICAvKipcbiAgKiBWZXJpZmllcyBpZiB0aGUgY29uZGl0aW9uIGlzIGFwcGxpY2FibGUgdG8gdGhlIG1lc3NhZ2UuIEZpcnN0LCB0aGUgc3lzdGVtIHZhbHVlIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGF0dHJpYnV0ZSBpcyByZXRyaWV2ZWQ7IHRoZW4sIHRoYXQgdmFsdWUgaXMgY29tcGFyZWQgd2l0aCB0aGUgcGFyYW1ldGVyIHNwZWNpZmllZCBpbiB0aGUgY29uZGl0aW9uIGJ5IGV4ZWN1dGluZyB0aGUgb3BlcmF0b3IgaW1wbGVtZW50YXRpb24uIElmIHRoZSBvcGVyYXRvciBpcyAnaW4nIGFuZCB0aGUgbmFtZSBvZiBhIGdyb3VwIGlzIGdpdmVuLCB0aGVuIHRoZSBhcnJheSBob2xkaW5nIHRoZSBtZW1iZXJzIG9mIHRoZSBncm91cCBpcyByZXRyaWV2ZWQgYmVmb3JlIHRoZSBjb21wYXJpc29uLlxuICAqIEBwYXJhbSAge09iamVjdH0gICAgY29udGV4dCAgIGVudmlyb25tZW50IHdoZXJlIHRoZSBQb2xpY3kgRW5naW5lIGlzIGJlaW5nIHVzZWRcbiAgKiBAcGFyYW0gIHtPYmplY3R9ICAgIG1lc3NhZ2VcbiAgKi9cbiAgaXNBcHBsaWNhYmxlKGNvbnRleHQsIG1lc3NhZ2UpIHtcbiAgICBjb250ZXh0W3RoaXMuYXR0cmlidXRlXSA9IHsgbWVzc2FnZTogbWVzc2FnZSB9O1xuICAgIGxldCB2YWx1ZSA9IGNvbnRleHRbdGhpcy5hdHRyaWJ1dGVdO1xuICAgIGxldCB0ZW1wUGFyYW07XG5cbiAgICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJ2luJykge1xuICAgICAgaWYgKCEoQXJyYXkuaXNBcnJheSh0aGlzLnBhcmFtcykpKSB7XG4gICAgICAgIHRlbXBQYXJhbSA9IGNvbnRleHQuZ2V0R3JvdXAodGhpcy5wYXJhbXMsIG1lc3NhZ2UudG8pO1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRvcnNbdGhpcy5vcGVyYXRvcl0oW3RlbXBQYXJhbSwgdmFsdWVdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5vcGVyYXRvcnNbdGhpcy5vcGVyYXRvcl0oW3RoaXMucGFyYW1zLCB2YWx1ZV0pO1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29uZGl0aW9uO1xuIiwiLyoqXG4qIENvcHlyaWdodCAyMDE2IFBUIElub3Zhw6fDo28gZSBTaXN0ZW1hcyBTQVxuKiBDb3B5cmlnaHQgMjAxNiBJTkVTQy1JRFxuKiBDb3B5cmlnaHQgMjAxNiBRVU9CSVMgTkVUV09SS1MgU0xcbiogQ29weXJpZ2h0IDIwMTYgRlJBVU5IT0ZFUi1HRVNFTExTQ0hBRlQgWlVSIEZPRVJERVJVTkcgREVSIEFOR0VXQU5EVEVOIEZPUlNDSFVORyBFLlZcbiogQ29weXJpZ2h0IDIwMTYgT1JBTkdFIFNBXG4qIENvcHlyaWdodCAyMDE2IERldXRzY2hlIFRlbGVrb20gQUdcbiogQ29weXJpZ2h0IDIwMTYgQXBpemVlXG4qIENvcHlyaWdodCAyMDE2IFRFQ0hOSVNDSEUgVU5JVkVSU0lUQVQgQkVSTElOXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbioqL1xuXG5pbXBvcnQgQ29uZGl0aW9uIGZyb20gJy4vQ29uZGl0aW9uJztcblxuLyoqXG4qIEBhdXRob3IgQW5hIENhbGRlaXJhIDxhbmEuY2FsZGVpcmFAdGVjbmljby51bGlzYm9hLnB0PlxuKiBAY2xhc3NkZXNjIENsYXNzIHRvIHJlcHJlc2VudCBhIHN1YnNjcmlwdGlvbiBjb25kaXRpb24gYW5kIGV2YWx1YXRlIGl0cyBhcHBsaWNhYmlsaXR5LlxuKi9cbmNsYXNzIFN1YnNjcmlwdGlvbkNvbmRpdGlvbiBleHRlbmRzIENvbmRpdGlvbiB7XG5cbiAgLyoqXG4gICogQ3JlYXRlcyBhIG5ldyBTdWJzY3JpcHRpb25Db25kaXRpb24uXG4gICogQGNsYXNzXG4gICogQHBhcmFtICB7c3RyaW5nfSAgYXR0cmlidXRlXG4gICogQHBhcmFtICB7c3RyaW5nfSAgb3BlcmF0b3JcbiAgKiBAcGFyYW0gIHsqfSAgICAgICBwYXJhbXNcbiAgKi9cbiAgY29uc3RydWN0b3IoYXR0cmlidXRlLCBvcGVyYXRvciwgcGFyYW1zKSB7XG4gICAgc3VwZXIoYXR0cmlidXRlLCBvcGVyYXRvciwgcGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAqIFZlcmlmaWVzIGlmIHRoZSBzdWJzY3JpcHRpb24gY29uZGl0aW9uIGlzIGFwcGxpY2FibGUgdG8gdGhlIG1lc3NhZ2UuIEZpcnN0LCB2ZXJpZmllcyBpZiB0aGUgbWVzc2FnZSBpcyBvZiB0aGUgc3Vic2NyaXB0aW9uIHR5cGU7IHNlY29uZCwgdmVyaWZpZXMgaWYgdGhlIG1lc3NhZ2UgaXMgZnJvbSBhIHJlbW90ZSBydW50aW1lIHRvIGd1YXJhbnRlZSB0aGF0IHRoZSBzdWJzY3JpcHRpb24gaXMgYmVpbmcgdmFsaWRhdGVkIGluIHRoZSBkZXN0aW5hdGlvbiBydW50aW1lOyB0aGlyZCwgdmVyaWZpZXMgaWYgdGhlIHN1YnNjcmlwdGlvbiBwcmVmZXJlbmNlIGlzIG1ldC5cbiAgKiBAcGFyYW0gIHtPYmplY3R9ICAgIGNvbnRleHQgICBlbnZpcm9ubWVudCB3aGVyZSB0aGUgUG9saWN5IEVuZ2luZSBpcyBiZWluZyB1c2VkXG4gICogQHBhcmFtICB7T2JqZWN0fSAgICBtZXNzYWdlXG4gICovXG4gIGlzQXBwbGljYWJsZShjb250ZXh0LCBtZXNzYWdlKSB7XG4gICAgbGV0IGlzU3Vic2NyaXB0aW9uID0gbWVzc2FnZS50eXBlID09PSAnc3Vic2NyaWJlJztcbiAgICBsZXQgaXNGcm9tUmVtb3RlU00gPSBjb250ZXh0LmlzRnJvbVJlbW90ZVNNKG1lc3NhZ2UuZnJvbSk7XG4gICAgaWYgKGlzU3Vic2NyaXB0aW9uICYgaXNGcm9tUmVtb3RlU00pIHtcbiAgICAgIHJldHVybiBzdXBlci5pc0FwcGxpY2FibGUoY29udGV4dCwgbWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBTdWJzY3JpcHRpb25Db25kaXRpb247XG4iLCJpbXBvcnQgQ29uZGl0aW9uIGZyb20gJy4vQ29uZGl0aW9uJztcbmltcG9ydCBPcGVyYXRvcnMgZnJvbSAnLi4vT3BlcmF0b3JzJztcbmltcG9ydCBTdWJzY3JpcHRpb25Db25kaXRpb24gZnJvbSAnLi9TdWJzY3JpcHRpb25Db25kaXRpb24nO1xuXG5jbGFzcyBBZHZhbmNlZENvbmRpdGlvbiB7XG5cbiAgY29uc3RydWN0b3IoY29uZGl0aW9uKSB7XG4gICAgdGhpcy5vcGVyYXRvcnMgPSBuZXcgT3BlcmF0b3JzKCk7XG4gICAgaWYgKGNvbmRpdGlvbi5vcGVyYXRvcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uZGl0aW9uID0gY29uZGl0aW9uLmNvbmRpdGlvbjtcbiAgICB9XG4gICAgY29uZGl0aW9uID0gdGhpcy5idWlsZENvbmRpdGlvbihjb25kaXRpb24pO1xuICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICB9XG5cbiAgYnVpbGRDb25kaXRpb24oY29uZGl0aW9uKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZGl0aW9uWzFdKSkge1xuICAgICAgY29uZGl0aW9uWzFdID0gdGhpcy5idWlsZENvbmRpdGlvbihjb25kaXRpb25bMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29uZGl0aW9uWzFdLmF0dHJpYnV0ZSA9PT0gJ3N1YnNjcmlwdGlvbicpIHtcbiAgICAgICAgY29uZGl0aW9uWzFdID0gbmV3IFN1YnNjcmlwdGlvbkNvbmRpdGlvbihjb25kaXRpb25bMV0uYXR0cmlidXRlLCBjb25kaXRpb25bMV0ub3BlcmF0b3IsIGNvbmRpdGlvblsxXS5wYXJhbXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uZGl0aW9uWzFdID0gbmV3IENvbmRpdGlvbihjb25kaXRpb25bMV0uYXR0cmlidXRlLCBjb25kaXRpb25bMV0ub3BlcmF0b3IsIGNvbmRpdGlvblsxXS5wYXJhbXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb25kaXRpb25bMl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZGl0aW9uWzJdKSkge1xuICAgICAgICBjb25kaXRpb25bMl0gPSB0aGlzLmJ1aWxkQ29uZGl0aW9uKGNvbmRpdGlvblsyXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY29uZGl0aW9uWzJdLmF0dHJpYnV0ZSA9PT0gJ3N1YnNjcmlwdGlvbicpIHtcbiAgICAgICAgICBjb25kaXRpb25bMl0gPSBuZXcgU3Vic2NyaXB0aW9uQ29uZGl0aW9uKGNvbmRpdGlvblsyXS5hdHRyaWJ1dGUsIGNvbmRpdGlvblsyXS5vcGVyYXRvciwgY29uZGl0aW9uWzJdLnBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uZGl0aW9uWzJdID0gbmV3IENvbmRpdGlvbihjb25kaXRpb25bMl0uYXR0cmlidXRlLCBjb25kaXRpb25bMl0ub3BlcmF0b3IsIGNvbmRpdGlvblsyXS5wYXJhbXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb25kaXRpb247XG4gIH1cblxuICBpc0FwcGxpY2FibGUoY29udGV4dCwgbWVzc2FnZSwgc2NvcGUsIHRhcmdldCwgb3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKCFvcGVyYXRvcikge1xuICAgICAgb3BlcmF0b3IgPSB0aGlzLmNvbmRpdGlvblswXTtcbiAgICAgIGxlZnQgPSB0aGlzLmNvbmRpdGlvblsxXTtcbiAgICAgIHJpZ2h0ID0gdGhpcy5jb25kaXRpb25bMl07XG4gICAgfVxuXG4gICAgd2hpbGUgKCEobGVmdCBpbnN0YW5jZW9mIENvbmRpdGlvbikgJiAhKGxlZnQgaW5zdGFuY2VvZiBTdWJzY3JpcHRpb25Db25kaXRpb24pICYgKHR5cGVvZiBsZWZ0ICE9PSAnYm9vbGVhbicpKSB7XG4gICAgICBsZWZ0ID0gdGhpcy5pc0FwcGxpY2FibGUoY29udGV4dCwgbWVzc2FnZSwgc2NvcGUsIHRhcmdldCwgbGVmdFswXSwgbGVmdFsxXSwgbGVmdFsyXSk7XG4gICAgfVxuICAgIGlmIChyaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB3aGlsZSAoIShyaWdodCBpbnN0YW5jZW9mIENvbmRpdGlvbikgJiAhKHJpZ2h0IGluc3RhbmNlb2YgU3Vic2NyaXB0aW9uQ29uZGl0aW9uKSAmICh0eXBlb2YgcmlnaHQgIT09ICdib29sZWFuJykpIHtcbiAgICAgICAgcmlnaHQgPSB0aGlzLmlzQXBwbGljYWJsZShjb250ZXh0LCBtZXNzYWdlLCBzY29wZSwgdGFyZ2V0LCByaWdodFswXSwgcmlnaHRbMV0sIHJpZ2h0WzJdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0TGVmdCA9ICh0eXBlb2YgbGVmdCA9PT0gJ2Jvb2xlYW4nKSA/IGxlZnQgOiBsZWZ0LmlzQXBwbGljYWJsZShjb250ZXh0LCBtZXNzYWdlLCBzY29wZSwgdGFyZ2V0KTtcbiAgICBsZXQgcmVzdWx0UmlnaHQ7XG4gICAgaWYgKHJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc3VsdFJpZ2h0ID0gKHR5cGVvZiByaWdodCA9PT0gJ2Jvb2xlYW4nKSA/IHJpZ2h0IDogcmlnaHQuaXNBcHBsaWNhYmxlKGNvbnRleHQsIG1lc3NhZ2UsIHNjb3BlLCB0YXJnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vcGVyYXRvcnNbb3BlcmF0b3JdKFtyZXN1bHRMZWZ0LCByZXN1bHRSaWdodF0pO1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQWR2YW5jZWRDb25kaXRpb247XG4iLCJpbXBvcnQgQWR2YW5jZWRDb25kaXRpb24gZnJvbSAnLi9jb25kaXRpb25zL0FkdmFuY2VkQ29uZGl0aW9uJztcbmltcG9ydCBDb25kaXRpb24gZnJvbSAnLi9jb25kaXRpb25zL0NvbmRpdGlvbic7XG5pbXBvcnQge2dldFVzZXJFbWFpbEZyb21VUkwsIGlzRGF0YU9iamVjdFVSTCwgcmVtb3ZlUGF0aEZyb21VUkx9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCBTdWJzY3JpcHRpb25Db25kaXRpb24gZnJvbSAnLi9jb25kaXRpb25zL0FkdmFuY2VkQ29uZGl0aW9uJztcblxuY2xhc3MgUnVsZSB7XG5cbiAgY29uc3RydWN0b3IoZGVjaXNpb24sIGNvbmRpdGlvbiwgc2NvcGUsIHRhcmdldCwgcHJpb3JpdHkpIHtcbiAgICB0aGlzLmRlY2lzaW9uID0gZGVjaXNpb247XG4gICAgdGhpcy5zZXRDb25kaXRpb24oY29uZGl0aW9uKTtcbiAgICB0aGlzLnByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICB9XG5cbiAgc2V0Q29uZGl0aW9uKGNvbmRpdGlvbikge1xuICAgIGlmICghKGNvbmRpdGlvbiBpbnN0YW5jZW9mIENvbmRpdGlvbiB8fCBjb25kaXRpb24gaW5zdGFuY2VvZiBTdWJzY3JpcHRpb25Db25kaXRpb24gfHwgY29uZGl0aW9uIGluc3RhbmNlb2YgQWR2YW5jZWRDb25kaXRpb24pKSB7XG4gICAgICBsZXQgYXR0cmlidXRlID0gY29uZGl0aW9uLmF0dHJpYnV0ZTtcbiAgICAgIHN3aXRjaCAoYXR0cmlidXRlKSB7XG4gICAgICAgIGNhc2UgJ3N1YnNjcmlwdGlvbic6XG4gICAgICAgICAgdGhpcy5jb25kaXRpb24gPSBuZXcgU3Vic2NyaXB0aW9uQ29uZGl0aW9uKGNvbmRpdGlvbi5hdHRyaWJ1dGUsIGNvbmRpdGlvbi5vcGVyYXRvciwgY29uZGl0aW9uLnBhcmFtcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgIHRoaXMuY29uZGl0aW9uID0gbmV3IEFkdmFuY2VkQ29uZGl0aW9uKGNvbmRpdGlvbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy5jb25kaXRpb24gPSBuZXcgQ29uZGl0aW9uKGNvbmRpdGlvbi5hdHRyaWJ1dGUsIGNvbmRpdGlvbi5vcGVyYXRvciwgY29uZGl0aW9uLnBhcmFtcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgIH1cbiAgfVxuXG4gIGV2YWx1YXRlKGNvbnRleHQsIG1lc3NhZ2UsIGlzSW5jb21pbmcpIHtcbiAgICBsZXQgZmllbGQgPSAoaXNJbmNvbWluZykgPyBtZXNzYWdlLnRvIDogbWVzc2FnZS5mcm9tO1xuICAgIGxldCBoeXBlcnR5TmFtZTtcbiAgICBzd2l0Y2ggKHRoaXMuc2NvcGUpIHtcbiAgICAgIGNhc2UgJ2dsb2JhbCc6XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdoeXBlcnR5JzpcbiAgICAgICAgaWYgKGlzRGF0YU9iamVjdFVSTChmaWVsZCkpIHtcbiAgICAgICAgICBsZXQgcmVwb3J0ZXIgPSBjb250ZXh0LnJ1bnRpbWVSZWdpc3RyeS5nZXRSZXBvcnRlclVSTFN5bmNob25vdXMocmVtb3ZlUGF0aEZyb21VUkwoZmllbGQpKTtcbiAgICAgICAgICBpZiAocmVwb3J0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaHlwZXJ0eU5hbWUgPSBjb250ZXh0LnJ1bnRpbWVSZWdpc3RyeS5nZXRIeXBlcnR5TmFtZShyZXBvcnRlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChmaWVsZC5zcGxpdCgnOi8vJylbMF0gPT09ICdoeXBlcnR5Jykge1xuICAgICAgICAgICAgaHlwZXJ0eU5hbWUgPSBjb250ZXh0LnJ1bnRpbWVSZWdpc3RyeS5nZXRIeXBlcnR5TmFtZShyZW1vdmVQYXRoRnJvbVVSTChmaWVsZCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaHlwZXJ0eU5hbWUgPT09IHRoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJ05vdCBBcHBsaWNhYmxlJztcblxuICAgICAgY2FzZSAnaWRlbnRpdHknOlxuICAgICAgICBsZXQgb3duZXI7XG5cbiAgICAgICAgaWYgKGlzRGF0YU9iamVjdFVSTChmaWVsZCkpIHtcbiAgICAgICAgICBsZXQgcmVwb3J0ZXIgPSBjb250ZXh0LnJ1bnRpbWVSZWdpc3RyeS5nZXRSZXBvcnRlclVSTFN5bmNob25vdXMocmVtb3ZlUGF0aEZyb21VUkwoZmllbGQpKTtcbiAgICAgICAgICBvd25lciA9IGNvbnRleHQucnVudGltZVJlZ2lzdHJ5LmdldEh5cGVydHlPd25lcihyZXBvcnRlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGZpZWxkLnNwbGl0KCc6Ly8nKVswXSA9PT0gJ2h5cGVydHknKSB7XG4gICAgICAgICAgICBvd25lciA9IGNvbnRleHQucnVudGltZVJlZ2lzdHJ5LmdldEh5cGVydHlPd25lcihyZW1vdmVQYXRoRnJvbVVSTChmaWVsZCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3duZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG93bmVyID0gZ2V0VXNlckVtYWlsRnJvbVVSTChvd25lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG93bmVyID09PSB0aGlzLnRhcmdldCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICdOb3QgQXBwbGljYWJsZSc7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY29uZGl0aW9uLmlzQXBwbGljYWJsZShjb250ZXh0LCBtZXNzYWdlLCB0aGlzLnNjb3BlLCB0aGlzLnRhcmdldCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlY2lzaW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ05vdCBBcHBsaWNhYmxlJztcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUnVsZTtcbiIsImltcG9ydCBBbGxvd092ZXJyaWRlcyBmcm9tICcuL2NvbWJpbmluZ0FsZ29yaXRobXMvQWxsb3dPdmVycmlkZXMnO1xuaW1wb3J0IEJsb2NrT3ZlcnJpZGVzIGZyb20gJy4vY29tYmluaW5nQWxnb3JpdGhtcy9CbG9ja092ZXJyaWRlcyc7XG5pbXBvcnQgRmlyc3RBcHBsaWNhYmxlIGZyb20gJy4vY29tYmluaW5nQWxnb3JpdGhtcy9GaXJzdEFwcGxpY2FibGUnO1xuaW1wb3J0IFJ1bGUgZnJvbSAnLi9SdWxlJztcblxuY2xhc3MgUG9saWN5IHtcblxuICBjb25zdHJ1Y3RvcihrZXksIHJ1bGVzLCBhY3Rpb25zLCBjb21iaW5pbmdBbGdvcml0aG0pIHtcbiAgICBpZiAoIWtleSkgdGhyb3cgbmV3IEVycm9yKCdrZXkgaXMgbm90IGRlZmluZWQnKTtcbiAgICBpZiAoIWFjdGlvbnMpIHRocm93IG5ldyBFcnJvcignYWN0aW9ucyBhcmUgbm90IGRlZmluZWQnKTtcblxuICAgIHRoaXMuYWN0aW9ucyA9IGFjdGlvbnM7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5fc2V0UnVsZXMocnVsZXMpO1xuICAgIHRoaXMuX3NldENvbWJpbmluZ0FsZ29yaXRobShjb21iaW5pbmdBbGdvcml0aG0pO1xuICB9XG5cbiAgYWRkQWN0aW9uKG1ldGhvZCwgcGFyYW0pIHtcbiAgICB0aGlzLmFjdGlvbnMucHVzaCh7IG1ldGhvZDogbWV0aG9kLCBwYXJhbTogcGFyYW0gfSk7XG4gIH1cblxuICBjcmVhdGVSdWxlKGRlY2lzaW9uLCBjb25kaXRpb24sIHNjb3BlLCB0YXJnZXQsIHByaW9yaXR5KSB7XG4gICAgaWYgKHByaW9yaXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHByaW9yaXR5ID0gdGhpcy5nZXRMYXN0UHJpb3JpdHkoKSArIDE7XG4gICAgfVxuICAgIGxldCBydWxlID0gbmV3IFJ1bGUoZGVjaXNpb24sIGNvbmRpdGlvbiwgc2NvcGUsIHRhcmdldCwgcHJpb3JpdHkpO1xuICAgIHRoaXMucnVsZXMucHVzaChydWxlKTtcbiAgfVxuXG4gIGRlbGV0ZVJ1bGUocnVsZSkge1xuICAgIGxldCBpbmRleFRvUmVtb3ZlID0gdGhpcy5ydWxlcy5pbmRleE9mKHJ1bGUpO1xuICAgIHRoaXMucnVsZXMuc3BsaWNlKGluZGV4VG9SZW1vdmUsIDEpO1xuICB9XG5cbiAgZW5mb3JjZUFjdGlvbnMoY29udGV4dCwgbWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgcmVzdWx0cyA9IFtdO1xuICAgICAgaWYgKHRoaXMuYWN0aW9ucy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSBpbiB0aGlzLmFjdGlvbnMpIHtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gY29udGV4dC5wZXAuYWN0aW9uc1NlcnZpY2VbdGhpcy5hY3Rpb25zW2ldLm1ldGhvZF0obWVzc2FnZSwgdGhpcy5hY3Rpb25zW2ldLnBhcmFtKTtcbiAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBQcm9taXNlLmFsbChyZXN1bHRzKS50aGVuKChtZXNzYWdlcykgPT4ge1xuICAgICAgICAgIHJlc29sdmUobWVzc2FnZXMpO1xuICAgICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKFttZXNzYWdlXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBldmFsdWF0ZVJ1bGVzKGNvbnRleHQsIG1lc3NhZ2UsIGlzSW5jb21pbmcpIHtcbiAgICBsZXQgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgaW4gdGhpcy5ydWxlcykge1xuICAgICAgcmVzdWx0cy5wdXNoKHRoaXMucnVsZXNbaV0uZXZhbHVhdGUoY29udGV4dCwgbWVzc2FnZSwgaXNJbmNvbWluZykpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbWJpbmluZ0FsZ29yaXRobS5jb21iaW5lKHJlc3VsdHMpO1xuICB9XG5cbiAgZ2V0TGFzdFByaW9yaXR5KCkge1xuICAgIGxldCBwcmlvcml0aWVzID0gW107XG5cbiAgICBpZiAodGhpcy5ydWxlcy5sZW5ndGggIT09IDApIHtcbiAgICAgIGZvciAobGV0IGkgaW4gdGhpcy5ydWxlcykge1xuICAgICAgICBwcmlvcml0aWVzLnB1c2godGhpcy5ydWxlc1tpXS5wcmlvcml0eSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkoTWF0aCwgcHJpb3JpdGllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cblxuICBnZXRSdWxlQnlQcmlvcml0eShwcmlvcml0eSkge1xuICAgIGZvciAobGV0IGkgaW4gdGhpcy5ydWxlcykge1xuICAgICAgaWYgKFN0cmluZyh0aGlzLnJ1bGVzW2ldLnByaW9yaXR5KSA9PT0gU3RyaW5nKHByaW9yaXR5KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5ydWxlc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoJ1J1bGUgd2l0aCBwcmlvcml0eSAnICsgcHJpb3JpdHkgKyAnIGRvZXMgbm90IGV4aXN0IScpO1xuICB9XG5cbiAgX3NldENvbWJpbmluZ0FsZ29yaXRobShjb21iaW5pbmdBbGdvcml0aG0pIHtcbiAgICBpZiAoIWNvbWJpbmluZ0FsZ29yaXRobSkge1xuICAgICAgY29tYmluaW5nQWxnb3JpdGhtID0gJ2Jsb2NrT3ZlcnJpZGVzJztcbiAgICB9XG4gICAgc3dpdGNoIChjb21iaW5pbmdBbGdvcml0aG0pIHtcbiAgICAgIGNhc2UgJ2Jsb2NrT3ZlcnJpZGVzJzpcbiAgICAgICAgdGhpcy5jb21iaW5pbmdBbGdvcml0aG0gPSBuZXcgQmxvY2tPdmVycmlkZXMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdhbGxvd092ZXJyaWRlcyc6XG4gICAgICAgIHRoaXMuY29tYmluaW5nQWxnb3JpdGhtID0gbmV3IEFsbG93T3ZlcnJpZGVzKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZmlyc3RBcHBsaWNhYmxlJzpcbiAgICAgICAgdGhpcy5jb21iaW5pbmdBbGdvcml0aG0gPSBuZXcgRmlyc3RBcHBsaWNhYmxlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1Vua25vd24gYWxnb3JpdGhtOiAnICsgY29tYmluaW5nQWxnb3JpdGhtKTtcbiAgICB9XG4gIH1cblxuICBfc2V0UnVsZXMocnVsZXMpIHtcbiAgICB0aGlzLnJ1bGVzID0gW107XG5cbiAgICBmb3IgKGxldCBpIGluIHJ1bGVzKSB7XG4gICAgICBsZXQgcnVsZSA9IHJ1bGVzW2ldO1xuICAgICAgaWYgKHJ1bGUucHJpb3JpdHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBydWxlLnByaW9yaXR5ID0gdGhpcy5nZXRMYXN0UHJpb3JpdHkoKSArIDE7XG4gICAgICB9XG4gICAgICBpZiAoIShydWxlIGluc3RhbmNlb2YgUnVsZSkpIHtcbiAgICAgICAgcnVsZSA9IG5ldyBSdWxlKHJ1bGUuZGVjaXNpb24sIHJ1bGUuY29uZGl0aW9uLCBydWxlLnNjb3BlLCBydWxlLnRhcmdldCwgcnVsZS5wcmlvcml0eSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJ1bGVzLnB1c2gocnVsZSk7XG4gICAgfVxuICB9XG5cbiAgc29ydFJ1bGVzKCkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgbGV0IHggPSBhLnByaW9yaXR5OyBsZXQgeSA9IGIucHJpb3JpdHk7XG4gICAgICByZXR1cm4gKCh4IDwgeSkgPyAtMSA6ICgoeCA+IHkpID8gMSA6IDApKTtcbiAgICB9KTtcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFBvbGljeTtcbiIsIi8vIExvZyBTeXN0ZW1cbmltcG9ydCAqIGFzIGxvZ2dlciBmcm9tICdsb2dsZXZlbCc7XG5sZXQgbG9nID0gbG9nZ2VyLmdldExvZ2dlcignUEVQJyk7XG5cbmltcG9ydCBBY3Rpb25zU2VydmljZSBmcm9tICcuL0FjdGlvbnNTZXJ2aWNlJztcbmltcG9ydCBQRFAgZnJvbSAnLi9QRFAnO1xuaW1wb3J0IFBvbGljeSBmcm9tICcuL1BvbGljeSc7XG5pbXBvcnQge2lzSHlwZXJ0eVVSTH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xuXG5jbGFzcyBQRVAge1xuXG4gIC8qKlxuICAqIENyZWF0ZXMgYSBQb2xpY3kgRW5mb3JjZW1lbnQgUG9pbnQgKFBFUCkgaW5zdGFuY2VcbiAgKiBAcGFyYW0gICAge09iamVjdH0gICAgY29udGV4dFxuICAqL1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIF90aGlzLnBkcCA9IG5ldyBQRFAoY29udGV4dCk7XG4gICAgX3RoaXMuYWN0aW9uc1NlcnZpY2UgPSBuZXcgQWN0aW9uc1NlcnZpY2UoY29udGV4dCk7XG4gICAgX3RoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgY29udGV4dC5wZXAgPSBfdGhpcztcblxuICAgIC8vVE9ETyBzaG91bGQgYmUgYWRkZWQgYSB0cmlnZ2VyIHRvIHZlcmlmeSB3aGVuIHRoZSBsb2FkQ29uZmlndXJhdGlvbnMgaXMgc3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZFxuICAgIGNvbnRleHQubG9hZENvbmZpZ3VyYXRpb25zKCk7XG4gIH1cblxuICAvKipcbiAgKiByZXR1cm4gdGhlIG1lc3NhZ2VCdXMgaW4gdGhpcyBSZWdpc3RyeVxuICAqIEBwYXJhbSB7TWVzc2FnZUJ1c30gICAgICAgICAgIG1lc3NhZ2VCdXNcbiAgKi9cbiAgZ2V0IG1lc3NhZ2VCdXMoKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcbiAgICByZXR1cm4gX3RoaXMuY29udGV4dC5tZXNzYWdlQnVzO1xuICB9XG5cbiAgLyoqXG4gICogU2V0IHRoZSBtZXNzYWdlQnVzIGluIHRoaXMgUmVnaXN0cnlcbiAgKiBAcGFyYW0ge01lc3NhZ2VCdXN9ICAgICAgICAgICBtZXNzYWdlQnVzXG4gICovXG4gIHNldCBtZXNzYWdlQnVzKG1lc3NhZ2VCdXMpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuICAgIF90aGlzLmNvbnRleHQubWVzc2FnZUJ1cyA9IG1lc3NhZ2VCdXM7XG4gICAgX3RoaXMuYWRkR1VJTGlzdGVuZXJzKCk7XG4gIH1cblxuICBhZGRHVUlMaXN0ZW5lcnMoKSB7XG4gICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgIF90aGlzLmNvbnRleHQubWVzc2FnZUJ1cy5hZGRMaXN0ZW5lcihfdGhpcy5jb250ZXh0LnBlcFVSTCwgKG1zZykgPT4ge1xuICAgICAgbGV0IGZ1bmNOYW1lID0gbXNnLmJvZHkubWV0aG9kO1xuXG4gICAgICBsZXQgcmV0dXJuZWRWYWx1ZTtcbiAgICAgIGlmIChmdW5jTmFtZSA9PT0gJ2FkZFRvR3JvdXAnKSB7XG4gICAgICAgIGxldCBncm91cE5hbWUgPSBtc2cuYm9keS5wYXJhbXMuZ3JvdXBOYW1lO1xuICAgICAgICBsZXQgdXNlckVtYWlsID0gbXNnLmJvZHkucGFyYW1zLnVzZXJFbWFpbDtcbiAgICAgICAgcmV0dXJuZWRWYWx1ZSA9IF90aGlzLmNvbnRleHQuYWRkVG9Hcm91cChncm91cE5hbWUsIHVzZXJFbWFpbCk7XG4gICAgICB9IGVsc2UgaWYgKGZ1bmNOYW1lID09PSAnY3JlYXRlR3JvdXAnKSB7XG4gICAgICAgIGxldCBncm91cE5hbWUgPSBtc2cuYm9keS5wYXJhbXMuZ3JvdXBOYW1lO1xuICAgICAgICByZXR1cm5lZFZhbHVlID0gX3RoaXMuY29udGV4dC5jcmVhdGVHcm91cChncm91cE5hbWUpO1xuICAgICAgfSBlbHNlIGlmIChmdW5jTmFtZSA9PT0gJ2FkZFBvbGljeScpIHtcbiAgICAgICAgbGV0IHNvdXJjZSA9IG1zZy5ib2R5LnBhcmFtcy5zb3VyY2U7XG4gICAgICAgIGxldCBrZXkgPSBtc2cuYm9keS5wYXJhbXMua2V5O1xuICAgICAgICBsZXQgcG9saWN5ID0gbXNnLmJvZHkucGFyYW1zLnBvbGljeTtcbiAgICAgICAgbGV0IGNvbWJpbmluZ0FsZ29yaXRobSA9IG1zZy5ib2R5LnBhcmFtcy5jb21iaW5pbmdBbGdvcml0aG07XG4gICAgICAgIHJldHVybmVkVmFsdWUgPSBfdGhpcy5hZGRQb2xpY3koc291cmNlLCBrZXksIHBvbGljeSwgY29tYmluaW5nQWxnb3JpdGhtKTtcbiAgICAgIH0gZWxzZSBpZiAoZnVuY05hbWUgPT09ICdkZWxldGVHcm91cCcpIHtcbiAgICAgICAgbGV0IGdyb3VwTmFtZSA9IG1zZy5ib2R5LnBhcmFtcy5ncm91cE5hbWU7XG4gICAgICAgIHJldHVybmVkVmFsdWUgPSBfdGhpcy5jb250ZXh0LmRlbGV0ZUdyb3VwKGdyb3VwTmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKGZ1bmNOYW1lID09PSAncmVtb3ZlUG9saWN5Jykge1xuICAgICAgICBsZXQgc291cmNlID0gbXNnLmJvZHkucGFyYW1zLnNvdXJjZTtcbiAgICAgICAgbGV0IGtleSA9IG1zZy5ib2R5LnBhcmFtcy5rZXk7XG4gICAgICAgIHJldHVybmVkVmFsdWUgPSBfdGhpcy5yZW1vdmVQb2xpY3koc291cmNlLCBrZXkpO1xuICAgICAgfSBlbHNlIGlmIChmdW5jTmFtZSA9PT0gJ3NhdmVQb2xpY2llcycpIHtcbiAgICAgICAgbGV0IHNvdXJjZSA9IG1zZy5ib2R5LnBhcmFtcy5zb3VyY2U7XG4gICAgICAgIHJldHVybmVkVmFsdWUgPSBfdGhpcy5jb250ZXh0LnNhdmVQb2xpY2llcyhzb3VyY2UpO1xuICAgICAgfSBlbHNlIGlmIChmdW5jTmFtZSA9PT0gJ3VzZXJQb2xpY2llcycpIHtcbiAgICAgICAgcmV0dXJuZWRWYWx1ZSA9IF90aGlzLmNvbnRleHQudXNlclBvbGljaWVzO1xuICAgICAgfSBlbHNlIGlmIChmdW5jTmFtZSA9PT0gJ2FjdGl2ZVVzZXJQb2xpY3knKSB7XG4gICAgICAgIGxldCB1c2VyUG9saWN5ID0gbXNnLmJvZHkucGFyYW1zLnVzZXJQb2xpY3k7XG4gICAgICAgIGlmICh1c2VyUG9saWN5KSB7IF90aGlzLmNvbnRleHQuYWN0aXZlVXNlclBvbGljeSA9IHVzZXJQb2xpY3k7IH1cbiAgICAgICAgcmV0dXJuZWRWYWx1ZSA9IF90aGlzLmNvbnRleHQuYWN0aXZlVXNlclBvbGljeTtcbiAgICAgIH0gZWxzZSBpZiAoZnVuY05hbWUgPT09ICd1c2VyUG9saWN5Jykge1xuICAgICAgICBsZXQga2V5ID0gbXNnLmJvZHkucGFyYW1zLmtleTtcbiAgICAgICAgcmV0dXJuZWRWYWx1ZSA9IF90aGlzLmNvbnRleHQudXNlclBvbGljaWVzW2tleV07XG4gICAgICB9IGVsc2UgaWYgKGZ1bmNOYW1lID09PSAnc2F2ZUFjdGl2ZVBvbGljeScpIHtcbiAgICAgICAgcmV0dXJuZWRWYWx1ZSA9IF90aGlzLmNvbnRleHQuc2F2ZUFjdGl2ZVBvbGljeSgpO1xuICAgICAgfSBlbHNlIGlmIChmdW5jTmFtZSA9PT0gJ2dldE15RW1haWxzJykge1xuICAgICAgICByZXR1cm5lZFZhbHVlID0gX3RoaXMuY29udGV4dC5nZXRNeUVtYWlscygpO1xuICAgICAgfSBlbHNlIGlmIChmdW5jTmFtZSA9PT0gJ2dldE15SHlwZXJ0aWVzJykge1xuICAgICAgICByZXR1cm5lZFZhbHVlID0gX3RoaXMuY29udGV4dC5nZXRNeUh5cGVydGllcygpO1xuICAgICAgfSBlbHNlIGlmIChmdW5jTmFtZSA9PT0gJ2dyb3VwcycpIHtcbiAgICAgICAgcmV0dXJuZWRWYWx1ZSA9IF90aGlzLmNvbnRleHQuZ3JvdXBzO1xuICAgICAgfSBlbHNlIGlmIChmdW5jTmFtZSA9PT0gJ2dldEdyb3Vwc05hbWVzJykge1xuICAgICAgICByZXR1cm5lZFZhbHVlID0gX3RoaXMuY29udGV4dC5nZXRHcm91cHNOYW1lcygpO1xuICAgICAgfSBpZiAoZnVuY05hbWUgPT09ICdyZW1vdmVGcm9tR3JvdXAnKSB7XG4gICAgICAgIGxldCBncm91cE5hbWUgPSBtc2cuYm9keS5wYXJhbXMuZ3JvdXBOYW1lO1xuICAgICAgICBsZXQgdXNlckVtYWlsID0gbXNnLmJvZHkucGFyYW1zLnVzZXJFbWFpbDtcbiAgICAgICAgcmV0dXJuZWRWYWx1ZSA9IF90aGlzLmNvbnRleHQucmVtb3ZlRnJvbUdyb3VwKGdyb3VwTmFtZSwgdXNlckVtYWlsKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHZhbHVlID0ge3R5cGU6ICdleGVjdXRlJywgdmFsdWU6IHJldHVybmVkVmFsdWUsIGNvZGU6IDIwMH07XG4gICAgICBsZXQgcmVwbHlNc2cgPSB7aWQ6IG1zZy5pZCwgdHlwZTogJ3Jlc3BvbnNlJywgdG86IG1zZy5mcm9tLCBmcm9tOiBtc2cudG8sIGJvZHk6IHZhbHVlfTtcbiAgICAgIF90aGlzLmNvbnRleHQubWVzc2FnZUJ1cy5wb3N0TWVzc2FnZShyZXBseU1zZyk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgKiBBZGRzIGEgcG9saWN5IHRvIHRoZSBQb2xpY3kgRW5mb3JjZW1lbnQgUG9pbnQgKFBFUCkuIFRoZSBwb2xpY3kgY2FuIGJlIGNyZWF0ZWQgYnkgdGhlIHNlcnZpY2VcbiAgKiBwcm92aWRlciBvciBieSB0aGUgdXNlci5cbiAgKiBAcGFyYW0gICAge1N0cmluZ30gICAgc291cmNlXG4gICogQHBhcmFtICAgIHtTdHJpbmd9ICAgIGtleVxuICAqIEBwYXJhbSAgICB7T2JqZWN0fSAgICBwb2xpY3lcbiAgKi9cbiAgYWRkUG9saWN5KHNvdXJjZSwga2V5LCBwb2xpY3ksIGNvbWJpbmluZ0FsZ29yaXRobSkge1xuICAgIGlmICghc291cmNlKSB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZSBpcyBub3QgZGVmaW5lZCcpO1xuICAgIGlmICgha2V5KSB0aHJvdyBuZXcgRXJyb3IoJ2tleSBpcyBub3QgZGVmaW5lZCcpO1xuXG4gICAgaWYgKHBvbGljeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwb2xpY3kgPSBuZXcgUG9saWN5KGtleSwgW10sIFtdLCBjb21iaW5pbmdBbGdvcml0aG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIShwb2xpY3kgaW5zdGFuY2VvZiBQb2xpY3kpKSB7XG4gICAgICAgIHBvbGljeSA9IG5ldyBQb2xpY3kocG9saWN5LmtleSwgcG9saWN5LnJ1bGVzLCBwb2xpY3kuYWN0aW9ucywgcG9saWN5LmNvbWJpbmluZ0FsZ29yaXRobSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoIChzb3VyY2UpIHtcbiAgICAgIGNhc2UgJ1NFUlZJQ0VfUFJPVklERVInOlxuICAgICAgICB0aGlzLmNvbnRleHQuc2F2ZVBvbGljaWVzKHNvdXJjZSwgcG9saWN5LCBrZXkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1VTRVInOlxuICAgICAgICB0aGlzLmNvbnRleHQudXNlclBvbGljaWVzW2tleV0gPSBwb2xpY3k7XG4gICAgICAgIHRoaXMuY29udGV4dC5zYXZlUG9saWNpZXMoc291cmNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBFcnJvcignVW5rbm93biBwb2xpY3kgc291cmNlOiAnICsgc291cmNlKTtcbiAgICB9XG4gIH1cblxuICBhdXRob3Jpc2UobWVzc2FnZSwgaXNJbmNvbWluZykge1xuICAgIC8vIGxvZy5sb2coJ1tQb2xpY3kuUEVQIEF1dGhvcmlzZV0gJywgbWVzc2FnZSk7XG4gICAgLy8gbG9nLmxvZyhtZXNzYWdlKTtcbiAgICBpZiAoIW1lc3NhZ2UpIHRocm93IG5ldyBFcnJvcignbWVzc2FnZSBpcyBub3QgZGVmaW5lZCcpO1xuICAgIGlmICghbWVzc2FnZS5mcm9tKSB0aHJvdyBuZXcgRXJyb3IoJ21lc3NhZ2UuZnJvbSBpcyBub3QgZGVmaW5lZCcpO1xuICAgIGlmICghbWVzc2FnZS50bykgdGhyb3cgbmV3IEVycm9yKCdtZXNzYWdlLnRvIGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgaWYgKCFtZXNzYWdlLnR5cGUpIHRocm93IG5ldyBFcnJvcignbWVzc2FnZS50eXBlIGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgbWVzc2FnZS5ib2R5ID0gbWVzc2FnZS5ib2R5IHx8IHt9O1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgbWVzc2FnZS5ib2R5ID0gbWVzc2FnZS5ib2R5IHx8IHt9O1xuICAgICAgbGV0IF90aGlzID0gdGhpcztcblxuICAgICAgbGV0IHJlc3VsdCA9IF90aGlzLnBkcC5ldmFsdWF0ZVBvbGljaWVzKG1lc3NhZ2UsIGlzSW5jb21pbmcpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gJ05vdCBBcHBsaWNhYmxlJykge1xuICAgICAgICByZXN1bHQgPSBfdGhpcy5jb250ZXh0LmRlZmF1bHRCZWhhdmlvdXI7XG4gICAgICAgIG1lc3NhZ2UuYm9keS5hdXRoID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBfdGhpcy5hY3Rpb25zU2VydmljZS5lbmZvcmNlUG9saWNpZXMobWVzc2FnZSwgaXNJbmNvbWluZykudGhlbihtZXNzYWdlcyA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgaW4gbWVzc2FnZXMpIHtcbiAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZXNbaV07XG4gICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgbWVzc2FnZS5ib2R5LmF1dGggPSAobWVzc2FnZS5ib2R5LmF1dGggPT09IHVuZGVmaW5lZCkgPyB0cnVlIDogbWVzc2FnZS5ib2R5LmF1dGg7XG4gICAgICAgICAgICByZXNvbHZlKG1lc3NhZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0geyBib2R5OiB7IGNvZGU6IDQwMywgZGVzY3JpcHRpb246ICdCbG9ja2VkIGJ5IHBvbGljeScgfSwgZnJvbTogbWVzc2FnZS50bywgdG86IG1lc3NhZ2UuZnJvbSwgdHlwZTogJ3Jlc3BvbnNlJyB9O1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH0pO1xuXG4gICAgfSk7XG4gIH1cbiAgYXV0aG9yaXNlU3luYyhtZXNzYWdlKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBtZXNzYWdlLmJvZHkgPSBtZXNzYWdlLmJvZHkgfHwge307XG4gICAgcmVzdWx0ID0gdGhpcy5wZHAuZXZhbHVhdGVQb2xpY2llcyhtZXNzYWdlLCB0cnVlKTtcbiAgICBpZiAocmVzdWx0ID09PSAnTm90IEFwcGxpY2FibGUnKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLmNvbnRleHQuZGVmYXVsdEJlaGF2aW91cjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcblxuICB9XG5cbiAgcmVtb3ZlUG9saWN5KHNvdXJjZSwga2V5KSB7XG4gICAgaWYgKCFzb3VyY2UpIHRocm93IG5ldyBFcnJvcignc291cmNlIGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgaWYgKHNvdXJjZSAhPT0gJyonICYmICFrZXkpIHRocm93IG5ldyBFcnJvcigna2V5IGlzIG5vdCBkZWZpbmVkJyk7XG5cbiAgICBzd2l0Y2ggKHNvdXJjZSkge1xuICAgICAgY2FzZSAnKic6XG4gICAgICAgIHRoaXMuY29udGV4dC5zZXJ2aWNlUHJvdmlkZXJQb2xpY3kgPSB7fTtcbiAgICAgICAgdGhpcy5jb250ZXh0LnVzZXJQb2xpY2llcyA9IHt9O1xuICAgICAgICB0aGlzLmNvbnRleHQuYWN0aXZlVXNlclBvbGljeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jb250ZXh0LnNhdmVQb2xpY2llcygnVVNFUicpO1xuICAgICAgICB0aGlzLmNvbnRleHQuc2F2ZVBvbGljaWVzKCdTRVJWSUNFX1BST1ZJREVSJyk7XG4gICAgICAgIHRoaXMuY29udGV4dC5zYXZlQWN0aXZlUG9saWN5KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnU0VSVklDRV9QUk9WSURFUic6XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNvbnRleHQuc2VydmljZVByb3ZpZGVyUG9saWN5W2tleV07XG4gICAgICAgIHRoaXMuY29udGV4dC5zYXZlUG9saWNpZXMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdVU0VSJzpcbiAgICAgICAgZGVsZXRlIHRoaXMuY29udGV4dC51c2VyUG9saWNpZXNba2V5XTtcbiAgICAgICAgaWYgKGtleSA9PT0gdGhpcy5jb250ZXh0LmFjdGl2ZVVzZXJQb2xpY3kpIHtcbiAgICAgICAgICB0aGlzLmNvbnRleHQuYWN0aXZlVXNlclBvbGljeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB0aGlzLmNvbnRleHQuc2F2ZUFjdGl2ZVBvbGljeSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udGV4dC5zYXZlUG9saWNpZXMoJ1VTRVInKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBFcnJvcignVW5rbm93biBwb2xpY3kgc291cmNlOiAnICsgc291cmNlKTtcbiAgICB9XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBQRVA7XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBOzs7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBTkE7QUFRQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7Ozs7QUFJQTs7Ozs7Ozs7QUNwR0E7Ozs7Ozs7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7QUFJQTs7Ozs7Ozs7QUM3Q0E7QUFFQTs7Ozs7Ozs7QUFPQTs7O0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7QUFFQTs7Ozs7QUFJQTs7O0FBRUE7Ozs7Ozs7QUFPQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQUtBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBO0FBRUE7Ozs7O0FBSUE7Ozs7O0FBRUE7Ozs7Ozs7QUFPQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBRUE7Ozs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBMUJBO0FBQ0E7QUE2QkE7Ozs7Ozs7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7O0FBSUE7Ozs7Ozs7Ozs7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdkNBO0FBQ0E7QUF5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFHQTs7Ozs7Ozs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBWEE7QUFhQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUlBOzs7Ozs7OztBQy9IQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBOzs7O0FBSUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQVRBO0FBV0E7OztBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBdEJBO0FBd0JBOzs7QUF2TEE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7OztBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7QUE4S0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///35\n")}})});