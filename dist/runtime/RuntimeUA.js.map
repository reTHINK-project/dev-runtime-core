{"version":3,"sources":["runtime/RuntimeUA.js"],"names":["require","_Registry","_IdentityModule","_PolicyEngine","_MessageBus","_Loader","_SyncherManager","_RuntimeCoreCtx","RuntimeUA","runtimeFactory","domain","_classCallCheck3","default","this","Error","_this","runtimeCatalogue","createRuntimeCatalogue","loader","_Loader2","runtimeURL","Math","floor","random","identityModule","_IdentityModule2","appSandbox","createAppSandbox","registry","_Registry2","messageBus","_MessageBus2","policyEngine","_PolicyEngine2","_RuntimeCoreCtx2","pipeline","handlers","ctx","authorise","msg","then","changedMgs","next","catch","reason","console","error","fail","addListener","postMessage","syncherManager","_SyncherManager2","descriptor","hypertyInstance","hypertyDescriptorURL","_this2","_promise2","resolve","reject","loadHyperty","result","protostubURL","_this3","loadStub","idpProxyURL","_this4","loadIdpProxy","info","unregisterAllHyperties","url"],"mappings":"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","file":"runtime/RuntimeUA.js","sourcesContent":["/**\n* Copyright 2016 PT Inovação e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n\nimport 'babel-polyfill';\n\n//Main dependecies\nimport Registry from '../registry/Registry';\nimport IdentityModule from '../identity/IdentityModule';\nimport PolicyEngine from '../policy/PolicyEngine';\nimport MessageBus from '../bus/MessageBus';\n\nimport Loader from './Loader';\n\n// import GraphConnector from '../graphconnector/GraphConnector';\n\nimport SyncherManager from '../syncher/SyncherManager';\nimport RuntimeCoreCtx from '../policy/context/RuntimeCoreCtx';\n/**\n * Runtime User Agent Interface will process all the dependecies of the core runtime;\n * @author Vitor Silva [vitor-t-silva@telecom.pt]\n * @version 0.4.0\n *\n * @property {runtimeFactory} runtimeFactory - Specific implementation for all environments;\n * @property {RuntimeCatalogue} runtimeCatalogue - Catalogue of components can be installed;\n * @property {runtimeURL} runtimeURL - This identify the core runtime, should be unique;\n * @property {IdentityModule} identityModule - Identity Module;\n * @property {PolicyEngine} policyEngine - Policy Engine Module;\n * @property {Registry} registry - Registry Module;\n * @property {MessageBus} messageBus - Message Bus is used like a router to redirect the messages from one component to other(s)\n * @property {GraphConnector} graphConnector - Graph Connector handling GUID and contacts\n */\nclass RuntimeUA {\n\n  /**\n   * Create a new instance of Runtime User Agent\n   * @param {runtimeFactory} runtimeFactory - Specific implementation for the environment where the core runtime will run;\n   * @param {domain} domainURL - specify the domain base for the runtime;\n   */\n  constructor(runtimeFactory, domain) {\n\n    if (!runtimeFactory) throw new Error('The sandbox factory is a needed parameter');\n    if (!domain) throw new Error('You need the domain of runtime');\n\n    let _this = this;\n\n    _this.runtimeFactory = runtimeFactory;\n    _this.runtimeCatalogue = runtimeFactory.createRuntimeCatalogue();\n\n    // Prepare the loader to load the hyperties, protostubs and idpproxy;\n    _this.loader = new Loader();\n\n    // TODO: post and return registry/hypertyRuntimeInstance to and from Back-end Service\n    // the response is like: runtime://sp1/123\n\n    let runtimeURL = 'runtime://' + domain + '/' + Math.floor((Math.random() * 10000) + 1);\n    _this.runtimeURL = runtimeURL;\n    _this.domain = domain;\n\n    // TODO: check if runtime catalogue need the runtimeURL;\n    _this.runtimeCatalogue.runtimeURL = runtimeURL;\n\n    // Instantiate the identity Module\n    _this.identityModule = new IdentityModule(runtimeURL);\n\n    // Use the sandbox factory to create an AppSandbox;\n    // In the future can be decided by policyEngine if we need\n    // create a AppSandbox or not;\n    let appSandbox = runtimeFactory.createAppSandbox();\n\n    // Instantiate the Registry Module\n    _this.registry = new Registry(runtimeURL, appSandbox, _this.identityModule, _this.runtimeCatalogue);\n\n    // Set the loader to load Hyperties, Stubs and IdpProxies\n    _this.registry.loader = _this.loader;\n\n    // Instantiate the Message Bus\n    _this.messageBus = new MessageBus(_this.registry);\n\n    // Instantiate the Policy Engine\n    _this.policyEngine = new PolicyEngine(new RuntimeCoreCtx(_this.identityModule, _this.registry));\n\n    _this.messageBus.pipeline.handlers = [\n\n      // Policy message authorise\n      function(ctx) {\n        _this.policyEngine.authorise(ctx.msg).then(function(changedMgs) {\n          ctx.msg = changedMgs;\n          ctx.next();\n        }).catch(function(reason) {\n          console.error(reason);\n          ctx.fail(reason);\n        });\n      }\n    ];\n\n    // Add to App Sandbox the listener;\n    appSandbox.addListener('*', function(msg) {\n      _this.messageBus.postMessage(msg);\n    });\n\n    // Register messageBus on Registry\n    _this.registry.messageBus = _this.messageBus;\n\n    // Register registry on IdentityModule\n    _this.identityModule.registry = _this.registry;\n\n    // Use sandbox factory to use specific methods\n    // and set the message bus to the factory\n    runtimeFactory.messageBus = _this.messageBus;\n\n    // Instanciate the SyncherManager;\n    _this.syncherManager = new SyncherManager(_this.runtimeURL, _this.messageBus, _this.registry, _this.runtimeCatalogue);\n\n    // Set into loader the needed components;\n    _this.loader.registry = _this.registry;\n    _this.loader.runtimeURL = _this.runtimeURL;\n    _this.loader.messageBus = _this.messageBus;\n    _this.loader.runtimeCatalogue = _this.runtimeCatalogue;\n    _this.loader.runtimeFactory = _this.runtimeFactory;\n\n    // Instantiate the Graph Connector\n    // _this.graphConnector = new GraphConnector(_this.runtimeURL, _this.messageBus);\n\n  }\n\n  /**\n  * Accomodate interoperability in H2H and proto on the fly for newly discovered devices in M2M\n  * @param  {CatalogueDataObject.HypertyDescriptor}   descriptor    descriptor\n  */\n  discoverHiperty(descriptor) {\n    // Body...\n  }\n\n  /**\n  * Register Hyperty deployed by the App that is passed as input parameter. To be used when App and Hyperties are from the same domain otherwise the RuntimeUA will raise an exception and the App has to use the loadHyperty(..) function.\n  * @param  {Object} Object                   hypertyInstance\n  * @param  {URL.HypertyCatalogueURL}         descriptor      descriptor\n  */\n  registerHyperty(hypertyInstance, descriptor) {\n    // Body...\n  }\n\n  /**\n  * Deploy Hyperty from Catalogue URL\n  * @param  {URL.HypertyCatalogueURL}    hyperty hypertyDescriptor url;\n  */\n  loadHyperty(hypertyDescriptorURL) {\n\n    if (!hypertyDescriptorURL) throw new Error('Hyperty descriptor url parameter is needed');\n\n    return new Promise((resolve, reject) => {\n\n      this.loader.loadHyperty(hypertyDescriptorURL)\n      .then((result) => {\n        resolve(result);\n      })\n      .catch((reason) => {\n        reject(reason);\n      });\n\n    });\n\n  }\n\n  /**\n  * Deploy Stub from Catalogue URL or domain url\n  * @param  {URL.URL}     domain          domain\n  */\n  loadStub(protostubURL) {\n\n    if (!protostubURL) throw new Error('ProtoStub descriptor url parameter is needed');\n\n    return new Promise((resolve, reject) => {\n\n      this.loader.loadStub(protostubURL)\n      .then((result) => {\n        resolve(result);\n      })\n      .catch((reason) => {\n        reject(reason);\n      });\n\n    });\n\n  }\n\n  /**\n  * Deploy idpProxy from Catalogue URL or domain url\n  * @param  {URL.URL}     domain          domain\n  */\n  loadIdpProxy(idpProxyURL) {\n\n    if (!idpProxyURL) throw new Error('The IDP Proxy URL is a needed parameter, could be a DOMAIN or a URL');\n\n    return new Promise((resolve, reject) => {\n      this.loader.loadIdpProxy(idpProxyURL)\n      .then((result) => {\n        resolve(result);\n      })\n      .catch((reason) => {\n        reject(reason);\n      });\n    });\n\n  }\n\n  /**\n   * Used to close all the runtime; Unregister all hyperties;\n   * @return {Promise<Boolean>} result of the close method, with true or false to the operation success;\n   */\n  close() {\n    let _this = this;\n\n    console.info('Unregister all hyperties');\n    return new Promise(function(resolve, reject) {\n\n      _this.registry.unregisterAllHyperties().then(function(result) {\n        console.info('All the hyperties are unregisted with Success:', result);\n        resolve(true);\n      }).catch(function(reason) {\n        console.error('Failed to unregister the hyperties', reason);\n        reject(false);\n      });\n\n    });\n\n  }\n\n  /**\n  * Used to check for updates about components handled in the Catalogue including protocol stubs and Hyperties. check relationship with lifecycle management provided by Service Workers\n  * @param  {CatalogueURL}       url url\n  */\n  checkForUpdate(url) {\n    // Body...\n  }\n\n}\n\nexport default RuntimeUA;\n"],"sourceRoot":"/source/"}