<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/graphconnector/GraphConnector.js | Service Framework API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">allocation</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/allocation/AddressAllocation.js~AddressAllocation.html">AddressAllocation</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">bus</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/bus/Bus.js~Bus.html">Bus</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/bus/MessageBus.js~MessageBus.html">MessageBus</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/bus/MiniBus.js~MiniBus.html">MiniBus</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/bus/Pipeline.js~Pipeline.html">Pipeline</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">discovery</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/discovery/CoreDiscovery.js~CoreDiscovery.html">CoreDiscovery</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">graphconnector</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/graphconnector/BloomFilter.js~BloomFilter.html">BloomFilter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/graphconnector/GlobalRegistryRecord.js~GlobalRegistryRecord.html">GlobalRegistryRecord</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/graphconnector/GraphConnector.js~GraphConnector.html">GraphConnector</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/graphconnector/GraphConnectorContactData.js~GraphConnectorContactData.html">GraphConnectorContactData</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">identity</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/identity/Crypto.js~Crypto.html">Crypto</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/identity/GuiFake.js~GuiFake.html">GuiFake</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/identity/Identity.js~Identity.html">Identity</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/identity/IdentityModule.js~IdentityModule.html">IdentityModule</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/identity/OpenIdLib.js~OpenIdLib.html">OpenIdLib</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">policy</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/policy/ActionsService.js~ActionsService.html">ActionsService</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/policy/CombiningAlgorithm.js~CombiningAlgorithm.html">CombiningAlgorithm</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/policy/Operators.js~Operators.html">Operators</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/policy/PDP.js~PDP.html">PDP</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/policy/PEP.js~PEP.html">PEP</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/policy/Policy.js~Policy.html">Policy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/policy/ReThinkCtx.js~ReThinkCtx.html">ReThinkCtx</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/policy/Rule.js~Rule.html">Rule</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">policy/combiningAlgorithms</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/policy/combiningAlgorithms/AllowOverrides.js~AllowOverrides.html">AllowOverrides</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/policy/combiningAlgorithms/BlockOverrides.js~BlockOverrides.html">BlockOverrides</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/policy/combiningAlgorithms/FirstApplicable.js~FirstApplicable.html">FirstApplicable</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">policy/conditions</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/policy/conditions/AdvancedCondition.js~AdvancedCondition.html">AdvancedCondition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/policy/conditions/Condition.js~Condition.html">Condition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/policy/conditions/SubscriptionCondition.js~SubscriptionCondition.html">SubscriptionCondition</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">policy/context</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/policy/context/RuntimeCoreCtx.js~RuntimeCoreCtx.html">RuntimeCoreCtx</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">protostub</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/protostub/IdpProxyStub.js~IdpProxyStub.html">IdpProxyStub</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-activate">activate</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">registry</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/registry/HypertyInstance.js~HypertyInstance.html">HypertyInstance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/registry/Registry.js~Registry.html">Registry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/registry/RegistryDataModel.js~RegistryDataModel.html">RegistryDataModel</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">runtime</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/runtime/Descriptors.js~Descriptors.html">Descriptors</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/runtime/Loader.js~Loader.html">Loader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/runtime/RuntimeUA.js~RuntimeUA.html">RuntimeUA</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-runtimeConfiguration">runtimeConfiguration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-runtimeUtils">runtimeUtils</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">sandbox</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/sandbox/Sandbox.js~Sandbox.html">Sandbox</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/sandbox/SandboxRegistry.js~SandboxRegistry.html">SandboxRegistry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-SandboxType">SandboxType</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">store-objects</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/store-objects/DataObjectsStorage.js~DataObjectsStorage.html">DataObjectsStorage</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">syncher</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/syncher/ObserverObject.js~ObserverObject.html">ObserverObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/syncher/ReporterObject.js~ReporterObject.html">ReporterObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/syncher/Subscription.js~Subscription.html">Subscription</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/syncher/SyncherManager.js~SyncherManager.html">SyncherManager</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">utils</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/EventEmitter.js~EventEmitter.html">EventEmitter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-schemaValidation">schemaValidation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-assign">assign</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildURL">buildURL</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-checkAttribute">checkAttribute</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-convertToUserURL">convertToUserURL</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-deepClone">deepClone</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-divideEmail">divideEmail</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-divideURL">divideURL</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-emptyObject">emptyObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-generateGUID">generateGUID</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getConfigurationResources">getConfigurationResources</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getUserEmailFromURL">getUserEmailFromURL</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getUserIdentityDomain">getUserIdentityDomain</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getUserURLFromEmail">getUserURLFromEmail</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isBackendServiceURL">isBackendServiceURL</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isDataObjectURL">isDataObjectURL</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isHypertyURL">isHypertyURL</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isLegacy">isLegacy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isURL">isURL</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isUserURL">isUserURL</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseAttributes">parseAttributes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-removePathFromURL">removePathFromURL</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-splitObjectURL">splitObjectURL</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-tv4">tv4</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-divideURL">divideURL</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/graphconnector/GraphConnector.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 * Copyright 2016 PT Inova&#xE7;&#xE3;o e Sistemas SA
 * Copyright 2016 INESC-ID
 * Copyright 2016 QUOBIS NETWORKS SL
 * Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V
 * Copyright 2016 ORANGE SA
 * Copyright 2016 Deutsche Telekom AG
 * Copyright 2016 Apizee
 * Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/
import GraphConnectorContactData from &apos;./GraphConnectorContactData&apos;;
import BloomFilter from &apos;./BloomFilter&apos;;
import GlobalRegistryRecord from &apos;./GlobalRegistryRecord&apos;;
import bitcoin from &apos;bitcoinjs-lib&apos;;
import bip39 from &apos;bip39&apos;;
import sjcl from &apos;./sjcl&apos;; // 1.0.6
import jsrsasign from &apos;jsrsasign&apos;;
import base64url from &apos;base64-url&apos;;
import hex64 from &apos;hex64&apos;;
import Buffer from &apos;buffer&apos;;

/**
 * The Graph Connector contains the contact list/address book.
 * @author beierle@tu-berlin.de
 */
class GraphConnector {

  // TODO: import / export methods

  /**
   * Constructs a new and empty Graph Connector.
   * @param {string}   hypertyRuntimeURL    The Hyperty Runtime URL.
   * @param {messageBus}    messageBus      The Message Bus.
   * @param {storageManager} storageManager the storage Manager.
   */
  constructor(hypertyRuntimeURL, messageBus, storageManager) {
    this.contacts = [];
    this.lastCalculationBloomFilter1Hop = new Date(0).toISOString();

    this.globalRegistryRecord = new GlobalRegistryRecord();
    this._prvKey;
    this.privateKey;

    this.groups = [];
    this.residenceLocation = &apos;&apos;;
    this.firstName = &apos;&apos;;
    this.lastName = &apos;&apos;;

    this._messageBus = messageBus;
    this._hypertyRuntimeURL = hypertyRuntimeURL;

    if (!storageManager) throw new Error(&apos;storageManager is missing&apos;);
    this.storageManager = storageManager;

    this._loadGraphConnector();
  }

  /**
   * Returns the MessageBus.
   */
  get messageBus() {
    return this._messageBus;
  }

  /**
   * Sets the MessageBus.
   * @param {MessageBus}           messageBus    The Message Bus.
   */
  set messageBus(messageBus) {
    this._messageBus = messageBus;
  }

  /**
   * Sets the first name and last name of the owner.
   * @param  {string}     fname     The owner&apos;s first name.
   * @param  {string}     lname     The owner&apos;s last name.
   * @returns  {boolean} Returns true if the owner name is successfully added.
   */
  setOwnerName(fname, lname) {
    let status = false;
    if (typeof fname !== &apos;undefined&apos;) {
      this.firstName = fname;
      if (typeof lname !== &apos;undefined&apos;) {
        this.lastName = lname;
      }
      status = true;
    }
    this.storageManager.set(&apos;graphConnector:firstName&apos;, 0, this.firstName);
    this.storageManager.set(&apos;graphConnector:lastName&apos;, 0, this.lastName);

    return status;
  }

  /**
   * Generates a GUID and returns a mnemonic from which the GUID can be re-created later.
   * @returns  {string}    mnemonic      A string with 16 words.
   */
  generateGUID() {

    // generate mnemonic and salt
    Buffer.TYPED_ARRAY_SUPPORT = true;
    let mnemonic = bip39.generateMnemonic(160);

    let saltWord = bip39.generateMnemonic(8);
    this._createKeys(mnemonic, saltWord);

    // set lasUpdate date
    this.globalRegistryRecord.lastUpdate = new Date().toISOString();

    // set defualt timeout
    let timeout = new Date();
    timeout.setMonth(timeout.getMonth() + 120);
    this.globalRegistryRecord.timeout = timeout.toISOString();

    // set default values
    this.globalRegistryRecord.active = 1;
    this.globalRegistryRecord.revoked = 0;

    // return mnemonic
    let rtn = mnemonic + &apos; &apos; + saltWord;
    //save to the storage
    this.storageManager.set(&apos;graphConnector:globalRegistryRecord&apos;, 0, this.globalRegistryRecord);
    this.storageManager.set(&apos;graphConnector:privateKey&apos;, 0, this.privateKey);

    return rtn;
  }

  /**
   * Generates a public/private key pair from a given mnemonic (16 words).
   * Expects a string containing 16 words seperated by single spaces.
   * Retrieves data from the Global Registry.
   * @param  {string}     mnemonicAndSalt     A string of 16 words.
   * @returns  {Promise}  Promise          Global Registry Record.
   */
  useGUID(mnemonicAndSalt) {
    // TODO: check if format is correct and if all words are from bip39 english wordlist
    let lastIndex = mnemonicAndSalt.lastIndexOf(&apos; &apos;);
    let mnemonic = mnemonicAndSalt.substring(0, lastIndex);
    let saltWord = mnemonicAndSalt.substring(lastIndex + 1, mnemonicAndSalt.length);
    this._createKeys(mnemonic, saltWord);

    let _this = this;

    // retrieve current info from Global Registry and fill this.globalRegistryRecord
    let msg = {
        type: &apos;READ&apos;,
        from: this._hypertyRuntimeURL + &apos;/graph-connector&apos;,
        to: &apos;global://registry/&apos;,
        body: {guid: this.globalRegistryRecord.guid}
      };

    return new Promise(function(resolve, reject) {

        if (_this.messageBus === undefined) {
          reject(&apos;MessageBus not found on GraphConnector&apos;);
        } else {

          _this.messageBus.postMessage(msg, (reply) =&gt; {

              console.log(reply);

              // reply should be the JSON returned from the Global Registry REST-interface
              let jwt = reply.body.Value;

              if (typeof jwt !== &apos;undefined&apos;) {
                let unwrappedJWT = jsrsasign.KJUR.jws.JWS.parse(reply.body.Value);
                let dataEncoded = unwrappedJWT.payloadObj.data;
                let dataDecoded = base64url.decode(dataEncoded);
                let dataJSON = JSON.parse(dataDecoded);

                // public key should match
                let sameKey = (dataJSON.publicKey == _this.globalRegistryRecord.publicKey);
                if (!sameKey) {
                  reject(&apos;Retrieved key does not match!&apos;);
                } else {
                  let publicKeyObject = jsrsasign.KEYUTIL.getKey(dataJSON.publicKey);
                  let encodedString = jwt.split(&apos;.&apos;).slice(0, 2).join(&apos;.&apos;);
                  let sigValueHex = unwrappedJWT.sigHex;
                  let sig = new jsrsasign.KJUR.crypto.Signature({alg: &apos;SHA256withECDSA&apos;});
                  sig.init(publicKeyObject);
                  sig.updateString(encodedString);
                  let isValid = sig.verify(sigValueHex);

                  if (!isValid) {
                    reject(&apos;Retrieved Record not valid!&apos;);
                  } else {
                    if (typeof dataJSON.userIDs != &apos;undefined&apos; &amp;&amp; dataJSON.userIDs != null) {
                      _this.globalRegistryRecord.userIDs = dataJSON.userIDs;
                    }
                    if (typeof dataJSON.legacyIDs != &apos;undefined&apos; &amp;&amp; dataJSON.legacyIDs != null) {
                      _this.globalRegistryRecord.legacyIDs = dataJSON.legacyIDs;
                    }
                    _this.globalRegistryRecord.lastUpdate = dataJSON.lastUpdate;
                    _this.globalRegistryRecord.timeout = dataJSON.timeout;
                    _this.globalRegistryRecord.salt = dataJSON.salt;
                    _this.globalRegistryRecord.active = dataJSON.active;
                    _this.globalRegistryRecord.revoked = dataJSON.revoked;
                    _this.globalRegistryRecord.defaults = dataJSON.defaults;

                    _this.storageManager.set(&apos;graphConnector:globalRegistryRecord&apos;, 0, _this.globalRegistryRecord);
                    _this.storageManager.set(&apos;graphConnector:privateKey&apos;, 0, _this.privateKey);

                    resolve(_this.globalRegistryRecord);
                  }
                }
              } else {
                resolve(&apos;not found&apos;);
              }
            });
        }
      });
  }

  /**
   * Creates the keys from mnemonic and salt. Also sets public key, guid, and salt for globalRegistryRecord.
   * @param  {string}     mnemonic     A string with 15 words.
   * @param  {string}     salt         A word.
   */
  _createKeys(mnemonic, saltWord) {

    // generate key pair
    let seed = bip39.mnemonicToSeed(mnemonic);
    Buffer.TYPED_ARRAY_SUPPORT = false;
    let hdnode = bitcoin.HDNode.fromSeedBuffer(seed);
    let ecparams = jsrsasign.KJUR.crypto.ECParameterDB.getByName(&apos;secp256k1&apos;);
    let biPrv = hdnode.keyPair.d; // private key big integer
    let epPub = ecparams.G.multiply(biPrv); // d*G
    let biX = epPub.getX().toBigInteger(); // x from Q
    let biY = epPub.getY().toBigInteger(); // y from Q
    let charlen = ecparams.keylen / 4;
    let hPrv = (&apos;0000000000&apos; + biPrv.toString(16)).slice(-charlen);
    let hX = (&apos;0000000000&apos; + biX.toString(16)).slice(-charlen);
    let hY = (&apos;0000000000&apos; + biY.toString(16)).slice(-charlen);
    let hPub = &apos;04&apos; + hX + hY;
    this._prvKey = new jsrsasign.KJUR.crypto.ECDSA({curve: &apos;secp256k1&apos;});
    this._prvKey.setPrivateKeyHex(hPrv);
    this._prvKey.isPrivate = true;
    this._prvKey.isPublic = false;
    let pubKey = new jsrsasign.KJUR.crypto.ECDSA({curve: &apos;secp256k1&apos;});
    this.privateKey = jsrsasign.KEYUTIL.getPEM(this._prvKey, &apos;PKCS8PRV&apos;);
    pubKey.setPublicKeyHex(hPub);
    pubKey.isPrivate = false;
    pubKey.isPublic = true;
    let publicKey = jsrsasign.KEYUTIL.getPEM(pubKey, &apos;PKCS8PUB&apos;);
    publicKey = publicKey.replace(/(\r\n|\n|\r)/gm, &apos;&apos;);
    this.globalRegistryRecord.publicKey = publicKey;

    // generate salt
    let saltHashedBitArray = sjcl.hash.sha256.hash(saltWord);
    let salt = sjcl.codec.base64.fromBits(saltHashedBitArray);
    this.globalRegistryRecord.salt = salt;

    // generate GUID
    let iterations = 10000;
    let guidBitArray = sjcl.misc.pbkdf2(this.globalRegistryRecord.publicKey, salt, iterations);
    let guid = sjcl.codec.base64url.fromBits(guidBitArray);
    this.globalRegistryRecord.guid = guid;
  }

  /**
   * SignGenerates a public/private key pair from a given mnemonic.
   * @returns  {string}     JWT     JSON Web Token ready to commit to Global Registry.
   */
  signGlobalRegistryRecord() {

    let record = this.globalRegistryRecord.getRecord();
    let recordString = JSON.stringify(record);
    let recordStringBase64 = base64url.encode(recordString);
    let jwtTemp = jsrsasign.KJUR.jws.JWS.sign(null, {alg: &apos;ES256&apos;}, {data: recordStringBase64}, this._prvKey);
    let encodedString = jwtTemp.split(&apos;.&apos;).slice(0, 2).join(&apos;.&apos;);

    let sig = new jsrsasign.KJUR.crypto.Signature({alg: &apos;SHA256withECDSA&apos;});
    sig.init(this.privateKey);
    sig.updateString(encodedString);

    let signatureHex = sig.sign();
    let signature = hex64.toBase64(signatureHex);
    let jwt = encodedString + &apos;.&apos; + signature;
    this.storageManager.set(&apos;graphConnector:globalRegistryRecord&apos;, 0, this.globalRegistryRecord);
    this.storageManager.set(&apos;graphConnector:privateKey&apos;, 0, this.privateKey);
    return jwt;
  }

  /**
   * Takes the Global Registry Record as a signed JWT and sends it to the Global Registry via the MessageBus.
   * Returns the response code of the REST-interface of the Global Registry as a Promise.
   * @param  {string}     jwt     The Global Registry Record as a signed JWT.
   * @returns {Propmise}  Promise Response Code from Global Registry.
   */
  sendGlobalRegistryRecord(jwt) {

    let unwrappedJWT = jsrsasign.KJUR.jws.JWS.parse(jwt);
    let dataEncoded = unwrappedJWT.payloadObj.data;
    let dataDecoded = base64url.decode(dataEncoded);
    let dataJSON = JSON.parse(dataDecoded);

    let _this = this;

    let msg = {
        type: &apos;CREATE&apos;,
        from: this._hypertyRuntimeURL + &apos;/graph-connector&apos;,
        to: &apos;global://registry/&apos;,
        body: {guid: dataJSON.guid, jwt: jwt}
      };

    return new Promise(function(resolve, reject) {

        if (_this.messageBus === undefined) {
          reject(&apos;MessageBus not found on GraphConnector&apos;);
        } else {

          _this.messageBus.postMessage(msg, (reply) =&gt; {
              let responseCode = reply.body.Code;
              if (responseCode == 200) {
                resolve(200);
              } else {
                reject(responseCode);
              }

            });
        }
      });
  }

  /**
   * Edit the values for a specific contact.
   * @param  {string}     guidOld          GUID to identify the contact to edit.
   * @param  {string}     firstName          First name of the contact.
   * @param  {string}     lastName          Last name of the contact.
   * @param  {string}     guidNew          New guid of the contact.
   * @param  {boolean}     privStatus          Boolean value to set the private status of the contact.
   * @returns  {array}   Returns the array which contains the contact with new values
   */
  editContact(guidOld, firstName, lastName, guidNew, privStatus) {

    let rtnArray = [];

    for (let i = 0; i &lt; this.contacts.length; i++) {
      if (this.contacts[i]._guid == guidOld) {
        if (guidOld == guidNew) {

          this.contacts[i]._firstName = firstName;
          this.contacts[i]._lastName = lastName;
          this.contacts[i]._guid = guidOld;
          this.contacts[i]._privateContact = privStatus;

          rtnArray.push(this.contacts[i]);

        } else {

          if (!this.guidExist(guidNew)) {

            this.contacts[i]._firstName = firstName;
            this.contacts[i]._lastName = lastName;
            this.contacts[i]._guid = guidNew;
            this.contacts[i]._privateContact = privStatus;

            rtnArray.push(this.contacts[i]);

          }
        }
        if (this.contacts[i]._privateContact) {
          // re-calculate BF1hop
          this.calculateBloomFilter1Hop();
        }
      }
    }
    this.storageManager.set(&apos;graphConnector:contacts&apos;, 0, this.contacts);

    return rtnArray;
  }

  /**
   * To check whether the GUID already exist.
   * @param  {string}     guid        GUID which needs to be checked.
   * @returns  {boolean}   Returns true if the GUID exist
   */
  guidExist(guid) {

    let success = false;

    for (let i = 0; i &lt; this.contacts.length; i++) {
      if (this.contacts[i]._guid == guid || this.globalRegistryRecord.guid == guid) {
        success = true;
      }
    }
    return success;
  }

  /**
   * To return the owner.
   * @returns  {GraphConnectorContactData}   Returns the owner.
   */
  getOwner() {

    let owner = new GraphConnectorContactData(this.globalRegistryRecord.guid, this.firstName, this.lastName);

    owner.groups = this.groups;
    owner.lastCalculationBloomFilter1Hop = this.lastCalculationBloomFilter1Hop;
    owner.residenceLocation = this.residenceLocation;
    owner.contactsBloomFilter1Hop = this.contactsBloomFilter1Hop;
    owner.userIDs = this.globalRegistryRecord.userIDs;
    owner.legacyIDs = this.globalRegistryRecord.legacyIDs;
    owner.defaults = this.globalRegistryRecord.defaults;

    return owner;
  }

  /**
   * Queries the Global Registry for a given GUID.
   * Adds the UserID information from the Global Registry to a contact, if the given GUID matches a user in the contacts.
   * Returns a Graph Connector Contact Data as a Promise.
   * @param  {string}   guid  The GUID to query the Global Registry for
   * @returns   {Promise}   Promise   Graph Connector Contact Data containing UserIDs.
   */
  queryGlobalRegistry(guid) {

    let _this = this;

    let msg = {
        type: &apos;READ&apos;,
        from: this._hypertyRuntimeURL + &apos;/graph-connector&apos;,
        to: &apos;global://registry/&apos;,
        body: {guid: guid}
      };
    return new Promise(function(resolve, reject) {

        if (_this.messageBus === undefined) {
          reject(&apos;MessageBus not found on GraphConnector&apos;);
        } else {

          _this.messageBus.postMessage(msg, (reply) =&gt; {

              console.log(reply);

              // reply should be the JSON returned from the Global Registry REST-interface
              let jwt = reply.body.Value;
              if (typeof jwt !== &apos;undefined&apos;) {

                if (reply.body.Code == 200) {
                  console.log(&apos;verify JWT&apos;);
                  let unwrappedJWT = jsrsasign.KJUR.jws.JWS.parse(reply.body.Value);
                  let dataEncoded = unwrappedJWT.payloadObj.data;
                  let dataDecoded = base64url.decode(dataEncoded);
                  let dataJSON = JSON.parse(dataDecoded);
                  let publicKeyObject = jsrsasign.KEYUTIL.getKey(dataJSON.publicKey);
                  let encodedString = jwt.split(&apos;.&apos;).slice(0, 2).join(&apos;.&apos;);
                  let sigValueHex = unwrappedJWT.sigHex;
                  let sig = new jsrsasign.KJUR.crypto.Signature({alg: &apos;SHA256withECDSA&apos;});
                  sig.init(publicKeyObject);
                  sig.updateString(encodedString);
                  let isValid = sig.verify(sigValueHex);
                  if (!isValid) {
                    console.log(&apos;invalid JWT&apos;);
                    reject(&apos;Retrieved Record not valid!&apos;);
                  } else {
                    console.log(&apos;valid JWT&apos;);
                    let queriedContact = new GraphConnectorContactData(dataJSON.guid, &apos;&apos;, &apos;&apos;);
                    if (typeof dataJSON.userIDs != &apos;undefined&apos; &amp;&amp; dataJSON.userIDs != null) {
                      queriedContact.userIDs = dataJSON.userIDs;

                      for (let i = 0; i &lt; _this.contacts.length; i++) {
                        if (_this.contacts[i]._guid == guid) {
                          _this.contacts[i]._userIDs = dataJSON.userIDs;
                        }
                      }
                    }

                    if (typeof dataJSON.legacyIDs != &apos;undefined&apos; &amp;&amp; dataJSON.legacyIDs != null) {
                      queriedContact.legacyIDs = dataJSON.legacyIDs;

                      for (let i = 0; i &lt; _this.contacts.length; i++) {
                        if (_this.contacts[i]._guid == guid) {
                          _this.contacts[i]._legacyIDs = dataJSON.legacyIDs;
                        }
                      }
                    }

                    resolve(queriedContact);
                  }
                } else {
                  console.log(&apos;Response code is not 200&apos;);
                  resolve(reply.body.Description);
                }
              } else {
                console.log(&apos; undefined Response&apos;);
                resolve(&apos;undefined&apos;);
              }
            });
        }
      });

  }


  /**
   * Adds a UserID for the user.
   * @param {string} uid.
   * @param {string} domain.
   * @returns  {boolean}   returns false if the userID exists and the user ID will not be added, true otherwise.
   */
  addUserID(uid, domain) {
    // check if already inside
    let found = true;
    for (let i = 0; i &lt; this.globalRegistryRecord.userIDs.length; i++) {
      if (this.globalRegistryRecord.userIDs[i].uid == uid &amp;&amp; this.globalRegistryRecord.userIDs[i].domain == domain) {
        found = false;
      }
    }
    if (found) {
      let item = new Object();
      item.uid = uid;
      item.domain = domain;
      this.globalRegistryRecord.userIDs.push(item);
      this.globalRegistryRecord.lastUpdate = new Date().toISOString();

    }

    this.storageManager.set(&apos;graphConnector:globalRegistryRecord&apos;, 0, this.globalRegistryRecord);

    return found;
  }

  /**
   * Removes a UserID for the user.
   * @param {string} uid.
   * @param {string} domain.
   * @returns  {boolean}   true if the userID exists and deleted, false otherwise.
   */
  removeUserID(uid, domain) {
    let found = false;
    for (let i = 0; i &lt; this.globalRegistryRecord.userIDs.length; i++) {
      if (this.globalRegistryRecord.userIDs[i].uid == uid &amp;&amp; this.globalRegistryRecord.userIDs[i].domain == domain) {
        this.globalRegistryRecord.userIDs.splice(i, 1);
        this.globalRegistryRecord.lastUpdate = new Date().toISOString();
        found = true;
      }
    }

    this.storageManager.set(&apos;graphConnector:globalRegistryRecord&apos;, 0, this.globalRegistryRecord);

    return found;
  }

  /**
   * Adds a Legacy ID for the user.
   * @param {string} type.
   * @param {string} category.
   * @param {string} description.
   * @param {string} id.
   * @returns  {boolean}   returns false if the ID exists and the Legacy ID will not be added, true otherwise.
   */
  addLegacyID(type, category, description, id) {
    // check if already inside
    let found = true;
    for (let i = 0; i &lt; this.globalRegistryRecord.legacyIDs.length; i++) {
      if (this.globalRegistryRecord.legacyIDs[i].id == id) {
        found = false;
      }
    }
    if (found) {
      let item = new Object();
      item.type = type;
      item.category = category;
      item.description = description;
      item.id = id;
      this.globalRegistryRecord.legacyIDs.push(item);
      this.globalRegistryRecord.lastUpdate = new Date().toISOString();
    }

    this.storageManager.set(&apos;graphConnector:globalRegistryRecord&apos;, 0, this.globalRegistryRecord);

    return found;
  }

  /**
   * Removes a LegacyID for the user.
   * @param {string} type
   * @param {string} category
   * @param {string} description
   * @param {string} id
   * @returns  {boolean}   true if the LegacyID exists and deleted, false otherwise.
   */
  removeLegacyID(type, category, description, id) {
    let found = false;
    for (let i = 0; i &lt; this.globalRegistryRecord.legacyIDs.length; i++) {
      if (this.globalRegistryRecord.legacyIDs[i].type == type &amp;&amp; this.globalRegistryRecord.legacyIDs[i].category == category
          &amp;&amp; this.globalRegistryRecord.legacyIDs[i].description == description &amp;&amp; this.globalRegistryRecord.legacyIDs[i].id == id) {
        this.globalRegistryRecord.legacyIDs.splice(i, 1);
        this.globalRegistryRecord.lastUpdate = new Date().toISOString();
        found = true;
      }
    }

    this.storageManager.set(&apos;graphConnector:globalRegistryRecord&apos;, 0, this.globalRegistryRecord);

    return found;
  }

  /**
   * set User  Defaults.
   * @param {string} voice
   * @param {string} chat
   * @param {string} video
   * @returns  {boolean}   returns True if the Defaults are successfully added, false otherwise.
   */
  setDefaults(voice, chat, video) {

    this.globalRegistryRecord.defaults.voice = voice;
    this.globalRegistryRecord.defaults.chat = chat;
    this.globalRegistryRecord.defaults.video = video;
    this.globalRegistryRecord.lastUpdate = new Date().toISOString();

    this.storageManager.set(&apos;graphConnector:globalRegistryRecord&apos;, 0, this.globalRegistryRecord);

    return true;
  }

  /**
   * Add a contact to the Graph Connector.
   * @param  {string}   guid          GUID of the new contact.
   * @param  {string}   firstName     First name of the new contact.
   * @param  {string}   lastName      Last name of the new contact.
   * @returns  {boolean}   returns True if the Contact is successfully added, false otherwise.
   */
  addContact(guid, firstName, lastName) {

    //for test accept any guid

    let success = false;
    if (!this.guidExist(guid)) {

      let _this = this;

      let msg = {
          type: &apos;READ&apos;,
          from: this._hypertyRuntimeURL + &apos;/graph-connector&apos;,
          to: &apos;global://registry/&apos;,
          body: {guid: guid}
        };
      return new Promise(function(resolve, reject) {

          if (_this.messageBus === undefined) {
            reject(&apos;MessageBus not found on GraphConnector&apos;);
          } else {

            _this.messageBus.postMessage(msg, (reply) =&gt; {

                console.log(reply);

                // reply should be the JSON returned from the Global Registry REST-interface
                let jwt = reply.body.Value;
                if (typeof jwt !== &apos;undefined&apos;) {

                  if (reply.body.Code == 200) {
                    console.log(&apos;Response code is 200&apos;);
                    console.log(&apos;verify JWT&apos;);
                    let unwrappedJWT = jsrsasign.KJUR.jws.JWS.parse(reply.body.Value);
                    let dataEncoded = unwrappedJWT.payloadObj.data;
                    let dataDecoded = base64url.decode(dataEncoded);
                    let dataJSON = JSON.parse(dataDecoded);
                    let publicKeyObject = jsrsasign.KEYUTIL.getKey(dataJSON.publicKey);
                    let encodedString = jwt.split(&apos;.&apos;).slice(0, 2).join(&apos;.&apos;);
                    let sigValueHex = unwrappedJWT.sigHex;
                    let sig = new jsrsasign.KJUR.crypto.Signature({alg: &apos;SHA256withECDSA&apos;});
                    sig.init(publicKeyObject);
                    sig.updateString(encodedString);
                    let isValid = sig.verify(sigValueHex);
                    if (!isValid) {
                      console.log(&apos;invalid JWT&apos;);
                      resolve(false);
                    } else {
                      console.log(&apos;valid JWT&apos;);
                      let queriedContact = new GraphConnectorContactData(dataJSON.guid, firstName, lastName);
                      if (typeof dataJSON.userIDs != &apos;undefined&apos; &amp;&amp; dataJSON.userIDs != null) {
                        queriedContact.userIDs = dataJSON.userIDs;
                      }
                      if (typeof dataJSON.legacyIDs != &apos;undefined&apos; &amp;&amp; dataJSON.legacyIDs != null) {
                        queriedContact.legacyIDs = dataJSON.legacyIDs;
                      }
                      if (typeof dataJSON.defaults != &apos;undefined&apos; &amp;&amp; dataJSON.defaults != null) {
                        queriedContact.defaults = dataJSON.defaults;
                      }
                      _this.contacts.push(queriedContact);
                      _this.storageManager.set(&apos;graphConnector:contacts&apos;, 0, _this.contacts);
                      resolve(true);
                    }
                  } else {
                    console.log(&apos;Response code is not 200&apos;);
                    let queriedContact = new GraphConnectorContactData(guid, firstName, lastName);
                    _this.contacts.push(queriedContact);
                    _this.storageManager.set(&apos;graphConnector:contacts&apos;, 0, _this.contacts);

                    resolve(true);
                  }
                } else {
                  console.log(&apos; undefined Response&apos;);
                  resolve(false);
                }
              });
          }
        });

    } else {
      return new Promise(function(resolve, reject) {
          resolve(false);
        });
    }
  }

  /**
   * Add a contact to the Graph Connector.
   * @param  {string}   guid          GUID of the new contact.
   * @param  {string}   firstName     First name of the new contact.
   * @param  {string}   lastName      Last name of the new contact.
   * @returns  {boolean}   returns True if the Contact is successfully added, false otherwise.
   */
  updateContactInfo(guid) {

    //for test accept any guid

    let success = false;
    if (this.guidExist(guid)) {

      let _this = this;

      let msg = {
          type: &apos;READ&apos;,
          from: this._hypertyRuntimeURL + &apos;/graph-connector&apos;,
          to: &apos;global://registry/&apos;,
          body: {guid: guid}
        };
      return new Promise(function(resolve, reject) {

          if (_this.messageBus === undefined) {
            reject(&apos;MessageBus not found on GraphConnector&apos;);
          } else {

            _this.messageBus.postMessage(msg, (reply) =&gt; {

                console.log(reply);

                // reply should be the JSON returned from the Global Registry REST-interface
                let jwt = reply.body.Value;
                if (typeof jwt !== &apos;undefined&apos;) {

                  if (reply.body.Code == 200) {
                    console.log(&apos;Response code is 200&apos;);
                    console.log(&apos;verify JWT&apos;);
                    let unwrappedJWT = jsrsasign.KJUR.jws.JWS.parse(reply.body.Value);
                    let dataEncoded = unwrappedJWT.payloadObj.data;
                    let dataDecoded = base64url.decode(dataEncoded);
                    let dataJSON = JSON.parse(dataDecoded);
                    let publicKeyObject = jsrsasign.KEYUTIL.getKey(dataJSON.publicKey);
                    let encodedString = jwt.split(&apos;.&apos;).slice(0, 2).join(&apos;.&apos;);
                    let sigValueHex = unwrappedJWT.sigHex;
                    let sig = new jsrsasign.KJUR.crypto.Signature({alg: &apos;SHA256withECDSA&apos;});
                    sig.init(publicKeyObject);
                    sig.updateString(encodedString);
                    let isValid = sig.verify(sigValueHex);
                    if (!isValid) {
                      console.log(&apos;invalid JWT&apos;);
                      resolve(false);
                    } else {
                      console.log(&apos;valid JWT&apos;);

                      for (let i = 0; i &lt; _this.contacts.length; i++) {

                        if (_this.contacts[i].guid == guid) {

                          if (typeof dataJSON.userIDs != &apos;undefined&apos; &amp;&amp; dataJSON.userIDs != null) {
                              _this.contacts[i]._userIDs = dataJSON.userIDs;
                          }
                          if (typeof dataJSON.legacyIDs != &apos;undefined&apos; &amp;&amp; dataJSON.legacyIDs != null) {
                              _this.contacts[i]._legacyIDs = dataJSON.legacyIDs;
                          }
                          if (typeof dataJSON.defaults != &apos;undefined&apos; &amp;&amp; dataJSON.defaults != null) {
                              _this.contacts[i]._defaults = dataJSON.defaults;
                          }
                        }
                      }
                      _this.storageManager.set(&apos;graphConnector:contacts&apos;, 0, _this.contacts);
                      resolve(true);
                    }
                  }
                } else {
                  console.log(&apos; undefined Response&apos;);
                  resolve(false);
                }
              });
          }
        });

    } else {
      return new Promise(function(resolve, reject) {
          resolve(false);
        });
    }
  }

  /**
   * Removes a location for a user identified by a given GUID.
   * @param  {string}   guid    GUID of the contact.
   * @returns  {boolean}  True if the Location is successfully  removed, false otherwise.
   */
  removeLocation(guid) {
    let success = false;
    if (this.globalRegistryRecord.guid == guid) {
      this.residenceLocation = &apos;&apos;;
      success = true;
    } else {
      for (let i = 0; i &lt; this.contacts.length; i++) {
        if (this.contacts[i]._guid == guid) {
          this.contacts[i].residenceLocation = &apos;&apos;;
          success = true;
        }
      }
    }

    this.storageManager.set(&apos;graphConnector:contacts&apos;, 0, this.contacts);
    this.storageManager.set(&apos;graphConnector:residenceLocation&apos;, 0, this.residenceLocation);

    return success;
  }

  /**
   * Adds a location for a user identified by a given GUID.
   * @param  {string}   guid          GUID of the contact.
   * @param  {string}   locationName    location  of the contact
   * @returns  {boolean}  Success if the Location is successfully added
   */
  setLocation(guid, locationName) {
    let success = false;
    if (typeof locationName !== &apos;undefined&apos;) {
      if (this.globalRegistryRecord.guid == guid) {
        this.residenceLocation = locationName;
        success = true;
      } else {
        for (let i = 0; i &lt; this.contacts.length; i++) {
          if (this.contacts[i]._guid == guid) {
            this.contacts[i].residenceLocation = locationName;
            success = true;
          }
        }
      }

    }

    this.storageManager.set(&apos;graphConnector:contacts&apos;, 0, this.contacts);
    this.storageManager.set(&apos;graphConnector:residenceLocation&apos;, 0, this.residenceLocation);

    return success;
  }

  /**
   * Returns all unique group names.
   * @returns  {array}   Array containing all unique group names.
   */
  getGroupNames() {
    let rtnSet = new Set();
    for (let i = 0; i &lt; this.contacts.length; i++) {
      for (let j = 0; j &lt; this.contacts[i]._groups.length; j++) {
        rtnSet.add(this.contacts[i]._groups[j]);
      }
    }
    for (let k = 0; k &lt; this.groups.length; k++) {
      rtnSet.add(this.groups[k]);
    }

    let rtnArray = Array.from(rtnSet);
    return rtnArray;
  }

  /**
   * Returns all contacts with a given group name, including the owner if applicable.
   * @param  {string}   groupName    Name of the group to return.
   * @returns  {array}   matchingContacts    Contacts matching the given group name. The format is: Contacts&lt;GraphConnectorContactData&gt;.
   */
  getGroup(groupName) {
    let rtnArray = [];
    let ownerTmp;
    if (typeof groupName !== &apos;undefined&apos;) {
      for (let k = 0; k &lt; this.groups.length; k++) {
        if (this.groups[k] == groupName) {
          ownerTmp = new GraphConnectorContactData(this.globalRegistryRecord.guid, this.firstName, this.lastName);
          (typeof this.residenceLocation == &apos;undefined&apos;) ? ownerTmp.residenceLocation = &apos;&apos; : ownerTmp.residenceLocation = this.residenceLocation;
          ownerTmp.userIDs = this.globalRegistryRecord.userIDs;
          ownerTmp.legacyIDs = this.globalRegistryRecord.legacyIDs;
          ownerTmp.defaults = this.globalRegistryRecord.defaults;
          ownerTmp.groups = this.groups;
          ownerTmp.contactsBloomFilter1Hop = this.contactsBloomFilter1Hop;
          ownerTmp._lastSyncBloomFilter1Hop = this.lastCalculationBloomFilter1Hop;
          ownerTmp._lastSyncDomainUserIDs = this.globalRegistryRecord.lastUpdate;
          rtnArray.push(ownerTmp);
        }
      }
      for (let i = 0; i &lt; this.contacts.length; i++) {
        for (let j = 0; j &lt; this.contacts[i]._groups.length; j++) {
          if (this.contacts[i]._groups[j] == groupName) {
            rtnArray.push(this.contacts[i]);
          }
        }
      }
    }
    return rtnArray;
  }

  /**
   * Adds a group to a contact identified by a GUID.
   * @param  {string}   guid          GUID of the contact.
   * @param  {string}   groupName     Group Name to be added to the contact.
   * @returns  {boolean}  Success if the group name is successfully added.
   */
  addGroupName(guid, groupName) {
    let success = false;
    if (typeof groupName !== &apos;undefined&apos;) {
      if (guid == this.globalRegistryRecord.guid) {
        if (!this.groups.includes(groupName)) {
          this.groups.push(groupName);
          success = true;
        }
      } else {
        for (let i = 0; i &lt; this.contacts.length; i++) {
          if (this.contacts[i]._guid == guid) {
            if (!this.contacts[i]._groups.includes(groupName)) {
              this.contacts[i]._groups.push(groupName);
              success = true;
            }
          }
        }
      }
    }

    this.storageManager.set(&apos;graphConnector:contacts&apos;, 0, this.contacts);
    this.storageManager.set(&apos;graphConnector:groups&apos;, 0, this.groups);

    return success;
  }

  /**
   * Removes a group for a contact, identified by a GUID.
   * @param  {string}   guid          GUID of the contact.
   * @param  {string}   groupName     Group name to be removed for the contact.
   * @returns  {boolean}  Success if the group name is successfully removed.
   */
  removeGroupName(guid, groupName) {
    let success = false;
    if (typeof groupName !== &apos;undefined&apos;) {
      if (guid == this.globalRegistryRecord.guid) {
        for (let z = 0; z &lt; this.groups.length; z++) {
          if (this.groups[z] == groupName) {
            this.groups.splice(z, 1);
            success = true;
          }
        }
      } else {
        for (let i = 0; i &lt; this.contacts.length; i++) {
          if (this.contacts[i]._guid == guid) {
            for (let j = 0; j &lt; this.contacts[i]._groups.length; j++) {
              if (this.contacts[i]._groups[j] == groupName) {
                this.contacts[i]._groups.splice(j, 1);
              }
              success = true;
            }
          }
        }
      }
    }
    this.storageManager.set(&apos;graphConnector:contacts&apos;, 0, this.contacts);
    this.storageManager.set(&apos;graphConnector:groups&apos;, 0, this.groups);

    return success;
  }

  /**
   * Returns all the contacts, excluding the owner.
   * @returns  {array}   All the contacts. The format is: Contacts&lt;GraphConnectorContactData&gt;.
   */
  getAllContacts() {
    return this.contacts;
  }

  /**
   * Removes a contact from the Graph Connector.
   * @param  {string}     guid      GUID of the user to be removed.
   * @returns  {boolean}  Success if the Contact is successfully removed.
   */
  removeContact(guid) {
    // remove from contacts
    let status = false;
    for (let i = 0; i &lt; this.contacts.length; i++) {
      if (this.contacts[i]._guid == guid) {
        this.contacts.splice(i, 1);
        status = true;
      }
    }

    // re-calculate BF1hop
    this.calculateBloomFilter1Hop();
    this.storageManager.set(&apos;graphConnector:contacts&apos;, 0, this.contacts);

    return status;
  }

  /**
   * Sets the bloomfilter of a contact.
   * @param  {string}     guid      GUID of the contact to set the bloom filter.
   * @param  {BloomFilter}     bf      BloomFilter object.
   * @returns {boolean} success if the contact guid is found and the bloom filter is set
   */
  setBloomFilter1HopContact(guid, bf) {
    let success = false;
    for (let i = 0; i &lt; this.contacts.length; i++) {
      if (this.contacts[i]._guid == guid) {
        this.contacts[i].contactsBloomFilter1Hop = bf;
        success = true;
      }
    }
    this.storageManager.set(&apos;graphConnector:contacts&apos;, 0, this.contacts);

    return success;
  }

  /**
   * Calculates the Bloom filter containing all non-private contacts.
   */
  calculateBloomFilter1Hop() {
    let bf = new BloomFilter(
        4314,     // number of bits to allocate. With 300 entries, we have a false positive rate of 0.1 %.
        10        // number of hash functions.
    );
    for (let i = 0; i &lt; this.contacts.length; i++) {
      if (!this.contacts[i].privateContact) {
        bf.add(this.contacts[i]._guid);
      }
    }
    this.contactsBloomFilter1Hop = bf;
    this.lastCalculationBloomFilter1Hop = new Date().toISOString();
    this.storageManager.set(&apos;graphConnector:lastCalculationBloomFilter1Hop&apos;, 0, this.lastCalculationBloomFilter1Hop);
  }

  /**
   * Returns the list of contacts which matches the search string &quot;name&quot;. Ex. &quot;Joh&quot; will return users with first or last name &quot;John&quot; or &quot;Aljohanas&quot;.
   * @param  {string}   name    First or last name to look for in the contact list.
   * @returns  {array}   matchingContacts       Contacts matching the given name. The format is: Contacts&lt;GraphConnectorContactData&gt;.
   */
  getContact(name) {
    // TODO: optimize, e.g., find misspelled people
    let rtnArray = [];
    let fname;
    let lname;

    let patt = new RegExp(name, &apos;i&apos;);
    for (let i = 0; i &lt; this.contacts.length; i++) {
      fname = this.contacts[i]._firstName;
      lname = this.contacts[i]._lastName;

      if (patt.test(fname) || patt.test(lname)) {
        rtnArray.push(this.contacts[i]);
      }
    }

    return rtnArray;
  }

  /**
   * Returns success if the userID is successfully added for a contact
   * @param  {string}   guid    guid of the contact whose userID has to be added.
   * @param  {string}   uid   userID which is supposed to be added.
   * @param  {string}   domain   domain which is supposed to be added.
   * @returns  {boolean}   success       returns true if userID is successfully added to the contact.
   */
  setContactUserIDs(guid, uid, domain) {
    let success = false;
    let tmpUserID = [];

    for (let i = 0; i &lt; this.contacts.length; i++) {

      if (this.contacts[i].guid == guid) {

        for (let j = 0; j &lt; this.contacts[i]._userIDs.length; j++) {

          if (this.contacts[i]._userIDs[j].uid == uid &amp;&amp; this.contacts[i]._userIDs[j].domain == domain) {
            return false;
          }
        }
        tmpUserID = this.contacts[i]._userIDs;
        let item = new Object();
        item.uid = uid;
        item.domain = domain;
        tmpUserID.push(item);
        this.contacts[i]._userIDs = tmpUserID;
        success = true;
      }
    }

    this.storageManager.set(&apos;graphConnector:contacts&apos;, 0, this.contacts);

    return success;
  }

  /**
   * Returns ArrayList of userIDs of a contact, if contact not found then it will return a string &apos;Contact Does not exist&apos;
   * @param  {string}   guid    guid of the contact whose userID has to be added.
   * @returns  {array}   success       returns Arraylist of userID of a contact, if contact not found then it will return a string &apos;Contact Does not exist&apos;
   */
  getContactUserIDs(guid) {
    let userIDsArray = [];
    let found = false;
    for (let i = 0; i &lt; this.contacts.length; i++) {

      if (this.contacts[i]._guid == guid) {
        found = true;

        for (let j = 0; j &lt; this.contacts[i]._userIDs.length; j++) {
          userIDsArray.push(this.contacts[i]._userIDs[j]);
        }
      }
    }

    if (!found) {
      return false;
    } else {
      return userIDsArray;
    }
  }

  /**
   * Sets active attribute of the GlobalRegistryRecord.
   * @param  {int}   int    Value to set the active flag of the GlobalRegistryRecord to.
   * @returns {boolean} True if Active is succesfully set, false otherwise.
   */
  setActive(int) {
    if (typeof int === &apos;number&apos;) {
      this.globalRegistryRecord.active = int;
      this.globalRegistryRecord.lastUpdate = new Date().toISOString();
      this.storageManager.set(&apos;graphConnector:globalRegistryRecord&apos;, 0, this.globalRegistryRecord);
      return true;
    }
    return false;
  }

  /**
   * Sets revoked attribute of the GlobalRegistryRecord.
   * @param  {int}   int    Value to set the revoked flag of the GlobalRegistryRecord to.
   * @returns {boolean} True if Revoked is succesfully set, false otherwise.
   */
  setRevoked(int) {
    if (typeof int === &apos;number&apos;) {
      this.globalRegistryRecord.revoked = int;
      this.globalRegistryRecord.lastUpdate = new Date().toISOString();
      this.storageManager.set(&apos;graphConnector:globalRegistryRecord&apos;, 0, this.globalRegistryRecord);

      return true;
    }
    return false;
  }

  /**
   * Sets Timeout attribute of the GlobalRegistryRecord.
   * @param  {Date}   Timeout  Date to set the timeout of the GlobalRegistryRecord to.
   * @returns {boolean} True if Timeout is succesfully set, false otherwise.
   */
  setTimeout(Timeout) {
    let now = new Date();
    if (typeof Timeout == &apos;object&apos; &amp;&amp; Timeout instanceof Date &amp;&amp; Timeout &gt; now) {
      this.globalRegistryRecord.timeout = Timeout.toISOString();
      this.globalRegistryRecord.lastUpdate = new Date().toISOString();
      this.storageManager.set(&apos;graphConnector:globalRegistryRecord&apos;, 0, this.globalRegistryRecord);

      return true;
    }
    return false;
  }

  /**
   Returns the globalRegistryRecord for the owner.
   @returns {object}
   */
  getGlobalRegistryRecord() {
    return this.globalRegistryRecord;
  }

  /**
   * Checks, if the given GUID is known and returns a list of contacs that are direct connections as well as a list of contacts that (most likely) know the given contact.
   * @param  {string}     guid      GUID of the contact to look for.
   * @returns  {array}    relatedContacts     List of related direct contacts and of related friends-of-friends contacts.The format is: RelatedContacts&lt;Direct&lt;GraphConnectorContactData&gt;,FoF&lt;GraphConnectorContactData&gt;&gt;.
   */
  checkGUID(guid) {
    let directContactsArray = [];
    let fofContactsArray = [];
    for (let i = 0; i &lt; this.contacts.length; i++) {
      if (this.contacts[i]._guid === guid) {
        directContactsArray.push(this.contacts[i]);
      }
      let bf1hop = new BloomFilter(
          4314,   // number of bits to allocate. With 300 entries, we have a false positive rate of 0.1 %.
          10        // number of hash functions.
      );
      bf1hop = this.contacts[i].contactsBloomFilter1Hop;

      if (bf1hop !== undefined) {
        bf1hop = this.extend(new BloomFilter(4314, 10), bf1hop);
        if (bf1hop.test(guid)) {
          fofContactsArray.push(this.contacts[i]);
        }
      }
    }
    let rtnArray = [];
    rtnArray.push(directContactsArray, fofContactsArray);
    return rtnArray;
  }

  /**
   * Type cast one object to another equivalent to &quot;$.extend&quot; of jquery
   * @param  {Object}     obj1      Object to which the other object need to be typecasted.
   * @param  {Object}     obj2      Object needs to typecasted.
   * @returns  {Object}   Obj2 with typecasted to obj1.
   */
  extend(obj1, obj2) {
    for (var key in obj2)
        if (obj2.hasOwnProperty(key))
            obj1[key] = obj2[key];
    return obj1;
  }

  /**
   * get the entry from the storage Manager for a given keys: globalRegistryRecord, contacts, groups.
   */
  _loadGraphConnector() {
    let _this = this;
    return new Promise((resolve) =&gt; {

        _this.storageManager.get(&apos;graphConnector:globalRegistryRecord&apos;).then((globalRegistryRecord) =&gt; {
            if (globalRegistryRecord) {
              _this.globalRegistryRecord.timeout = globalRegistryRecord.timeout;
              _this.globalRegistryRecord.active = globalRegistryRecord.active;
              _this.globalRegistryRecord.defaults.chat = globalRegistryRecord.defaults.chat;
              _this.globalRegistryRecord.defaults.video = globalRegistryRecord.defaults.video;
              _this.globalRegistryRecord.defaults.voice = globalRegistryRecord.defaults.voice;
              _this.globalRegistryRecord.guid = globalRegistryRecord.guid;
              _this.globalRegistryRecord.lastUpdate = globalRegistryRecord.lastUpdate;
              _this.globalRegistryRecord.publicKey = globalRegistryRecord.publicKey;
              _this.globalRegistryRecord.revoked = globalRegistryRecord.revoked;
              _this.globalRegistryRecord.salt = globalRegistryRecord.salt;
              _this.globalRegistryRecord.userIDs = globalRegistryRecord.userIDs;
              _this.globalRegistryRecord.legacyIDs = globalRegistryRecord.legacyIDs;
              _this.globalRegistryRecord.schemaVersion = globalRegistryRecord.schemaVersion;
            }
            resolve();
          });

        _this.storageManager.get(&apos;graphConnector:contacts&apos;).then((contacts) =&gt; {
            if (contacts) {
              _this.contacts = contacts;
            }
            resolve();
          });

        _this.storageManager.get(&apos;graphConnector:groups&apos;).then((groups) =&gt; {
            if (groups) {
              _this.groups = groups;
            }
            resolve();
          });

        _this.storageManager.get(&apos;graphConnector:privateKey&apos;).then((privateKey) =&gt; {
            if (privateKey) {
              _this.privateKey = privateKey;
              _this._prvKey = jsrsasign.KEYUTIL.getKey(privateKey, &apos;PKCS8PRV&apos;);
            }
            resolve();
          });

        _this.storageManager.get(&apos;graphConnector:firstName&apos;).then((firstName) =&gt; {
            if (firstName) {
              console.info(&apos;graphConnector:firstName:&apos;, firstName);
              _this.firstName = firstName;
            }
            resolve();
          });

        _this.storageManager.get(&apos;graphConnector:lastName&apos;).then((lastName) =&gt; {
            if (lastName) {
              console.info(&apos;graphConnector:lastName:&apos;, lastName);
              _this.lastName = lastName;
            }
            resolve();
          });

        _this.storageManager.get(&apos;graphConnector:lastCalculationBloomFilter1Hop&apos;).then((lastCalculationBloomFilter1Hop) =&gt; {
            if (lastCalculationBloomFilter1Hop) {
              console.info(&apos;graphConnector:lastName:&apos;, lastCalculationBloomFilter1Hop);
              _this.lastCalculationBloomFilter1Hop = lastCalculationBloomFilter1Hop;
            }
            resolve();
          });

        _this.storageManager.get(&apos;graphConnector:residenceLocation&apos;).then((residenceLocation) =&gt; {
            if (residenceLocation) {
              console.info(&apos;graphConnector:lastName:&apos;, residenceLocation);
              _this.residenceLocation = residenceLocation;
            }
            resolve();
          });
      });

  }

  /**
   * store the entry into the storage Manager for the given keys: globalRegistryRecord, contacts, groups.
   */
  storeGraphConnector() {
    let _this = this;

    _this.storageManager.set(&apos;graphConnector:globalRegistryRecord&apos;, 0, _this.globalRegistryRecord);
    _this.storageManager.set(&apos;graphConnector:contacts&apos;, 0, _this.contacts);
    _this.storageManager.set(&apos;graphConnector:groups&apos;, 0, _this.groups);
    _this.storageManager.set(&apos;graphConnector:privateKey&apos;, 0, _this.privateKey);
    _this.storageManager.set(&apos;graphConnector:firstName&apos;, 0, _this.firstName);
    _this.storageManager.set(&apos;graphConnector:lastName&apos;, 0, _this.lastName);
    _this.storageManager.set(&apos;graphConnector:lastCalculationBloomFilter1Hop&apos;, 0, _this.lastCalculationBloomFilter1Hop);
    _this.storageManager.set(&apos;graphConnector:residenceLocation&apos;, 0, _this.residenceLocation);

  }
}

export default GraphConnector;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
